---
repository:
  name: docenteia-v2-monolith
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-28T06:19:02.088Z
  tool: FlatRepo
statistics:
  totalFiles: 94
  totalLines: 8354
  languages:
    typescript: 59
    json: 10
    javascript: 3
    markdown: 6
    tsx: 11
    css: 1
  fileTypes:
    .ts: 59
    .json: 10
    .js: 3
    .md: 6
    .tsx: 11
    "": 1
    .css: 1
    .jsonl: 3
---

===  vitest.setup.ts
```typescript
import { config } from 'dotenv';
import fs from 'fs';

// Cargar .env.local si existe; si no, .env
if (fs.existsSync('.env.local')) {
  config({ path: '.env.local' });
} else {
  config();
}


```
=== EOF: vitest.setup.ts

===  vitest.config.ts
```typescript
import path from 'path';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    setupFiles: ['vitest.setup.ts'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});


```
=== EOF: vitest.config.ts

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "archive"]
}
```
=== EOF: tsconfig.json

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```
=== EOF: tailwind.config.js

===  REPORTE_ROUTING_MODELOS.md
```markdown
# Reporte: Implementaci√≥n de Routing de Modelos OpenAI

## üéØ **Objetivo**

Implementar un sistema de routing inteligente de modelos OpenAI para optimizar costos y rendimiento seg√∫n el tipo de tarea.

## üìä **Arquitectura Implementada**

### **1. Router de Modelos (`src/lib/ai.ts`)**

```typescript
export function pickModel(
  tier: "cheap" | "thinker" | "embed" = "cheap"
): string {
  if (tier === "thinker") return process.env.THINKER_MODEL || "o3-mini";
  if (tier === "embed")
    return process.env.EMBED_MODEL || "text-embedding-3-small";
  return process.env.CHEAP_MODEL || "gpt-4o-mini";
}
```

**Tiers implementados:**

- **`cheap`**: `gpt-4o-mini` - Para redacci√≥n docente, hints, reformulaciones
- **`thinker`**: `o3-mini` - Para decisiones dif√≠ciles de evaluaci√≥n
- **`embed`**: `text-embedding-3-small` - Para embeddings sem√°nticos

### **2. Escalamiento Inteligente (`src/engine/eval-escalation.ts`)**

```typescript
export async function escalateReasoning(input: {
  student: string;
  objective: string;
  acceptable: string[];
  expected: string[];
  matched: string[];
  missing: string[];
  hintsUsed: number;
}) {
  // Usa o3-mini con reasoning para decisiones complejas
  const res = await ai.responses.create({
    model: pickModel("thinker"),
    reasoning: { effort: "medium" },
    response_format: { type: "json_object" },
  });
}
```

**Caracter√≠sticas:**

- **JSON estricto** para decisiones
- **Reasoning con esfuerzo medio** para an√°lisis profundo
- **Fallback robusto** si falla el escalamiento

### **3. Integraci√≥n en Pipeline H√≠brido**

```typescript
// Escalamiento a thinker para casos borderline/ambiguos
if (cos >= 0.4 && cos < semThresh && (best?.cos || 0) >= 0.35) {
  const escalation = await escalateReasoning({...});

  if (escalation.decision === 'ACCEPT') {
    return { kind: 'ACCEPT', reason: 'THINKER_ESCALATION' };
  } else if (escalation.decision === 'HINT') {
    return { kind: 'HINT', reason: 'THINKER_ESCALATION' };
  }
}
```

**Criterios de escalamiento:**

- **Similitud sem√°ntica borderline** (0.4 ‚â§ cos < umbral)
- **Mejor match aceptable** (‚â• 0.35)
- **Solo cuando es necesario** para evitar costos innecesarios

## üîß **Cambios Implementados**

### **1. Orquestador (`src/ai/orchestrator.ts`)**

```typescript
// Antes
model: "gpt-4o-mini";

// Despu√©s
const model = pickModel("cheap"); // Usar modelo barato para redacci√≥n docente
```

### **2. Embeddings (`src/engine/semvec.ts`)**

```typescript
// Antes
const MODEL = process.env.EMBED_MODEL || "text-embedding-3-small";

// Despu√©s
const MODEL = pickModel("embed");
```

### **3. Evaluaci√≥n H√≠brida (`src/engine/eval.ts`)**

- **Agregado escalamiento** para casos borderline
- **Integraci√≥n con thinker** para decisiones complejas
- **Fallback robusto** en caso de errores

## üìà **Optimizaci√≥n de Costos**

### **Distribuci√≥n de Uso:**

- **80% cheap** (`gpt-4o-mini`) - Redacci√≥n docente, hints
- **15% embed** (`text-embedding-3-small`) - Similitud sem√°ntica
- **5% thinker** (`o3-mini`) - Decisiones complejas

### **Estimaci√≥n de Costos (por 1000 turnos):**

- **Cheap**: ~$0.50 (redacci√≥n docente)
- **Embed**: ~$0.10 (embeddings)
- **Thinker**: ~$0.25 (decisiones complejas)
- **Total**: ~$0.85 (vs $2.00+ con solo gpt-4o)

**Ahorro estimado: 57%**

## üß™ **Casos de Uso**

### **Caso 1: Redacci√≥n Docente**

```
Input: Sin input del estudiante
Model: cheap (gpt-4o-mini)
Output: Pregunta docente breve
Costo: M√≠nimo
```

### **Caso 2: Evaluaci√≥n Clara**

```
Input: "las partes del procedimiento"
Model: cheap + embed
Output: ACCEPT directo
Costo: Bajo
```

### **Caso 3: Evaluaci√≥n Borderline**

```
Input: "los peligros y los riesgos" (cos: 0.535)
Model: cheap + embed + thinker (o3-mini)
Output: Decisi√≥n basada en reasoning
Costo: Medio (solo cuando necesario)
```

## üîß **Configuraci√≥n de Variables de Entorno**

Agregar en `.env.local`:

```bash
CHEAP_MODEL=gpt-4o-mini
THINKER_MODEL=o3-mini
EMBED_MODEL=text-embedding-3-small
```

## üéØ **Beneficios Implementados**

### **1. Optimizaci√≥n de Costos:**

- **57% de ahorro** estimado en costos de API
- **Uso inteligente** de modelos seg√∫n complejidad
- **Escalamiento condicional** solo cuando es necesario

### **2. Mejor Calidad:**

- **o3-mini** para decisiones complejas con reasoning
- **gpt-4o-mini** para redacci√≥n r√°pida y eficiente
- **text-embedding-3-small** para similitud sem√°ntica

### **3. Robustez:**

- **Fallback autom√°tico** si falla el escalamiento
- **Logs de debug** para monitoreo
- **Configuraci√≥n flexible** por variables de entorno

## üìä **M√©tricas a Monitorear**

### **Uso de Modelos:**

- **Porcentaje de uso** de cada tier
- **Tasa de escalamiento** a thinker
- **Costos por turno** promedio

### **Calidad:**

- **Precisi√≥n de decisiones** con thinker
- **Tiempo de respuesta** por modelo
- **Satisfacci√≥n del usuario**

## üéØ **Estado Final**

**‚úÖ SISTEMA DE ROUTING IMPLEMENTADO**

El sistema ahora:

1. **Usa modelos apropiados** seg√∫n la complejidad de la tarea
2. **Optimiza costos** con escalamiento inteligente
3. **Mantiene calidad** con reasoning para decisiones complejas
4. **Es configurable** por variables de entorno

**Pr√≥ximo paso:** Monitorear m√©tricas de uso y costos para validar la optimizaci√≥n.
```
=== EOF: REPORTE_ROUTING_MODELOS.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia-v2-monolith",
  "version": "2.0.0",
  "description": "DocenteIA V2 - Sistema educativo monol√≠tico con Next.js",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "next lint",
    "test": "vitest",
    "chat-demo": "tsx src/index.ts",
    "chat-nose": "tsx scripts/chatNoSe.ts",
    "clean": "rm -rf .next node_modules package-lock.json && npm install",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@next-auth/mongodb-adapter": "^1.1.3",
    "@openai/agents": "^0.0.17",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@types/dompurify": "^3.2.0",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.6",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.536.0",
    "mongodb": "^6.19.0",
    "next": "^15.0.0",
    "next-auth": "^4.24.11",
    "openai": "^5.10.2",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/node": "^20.19.9",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^15.0.0",
    "flatrepo": "^1.2.0",
    "postcss": "^8.4.0",
    "react-test-renderer": "^18.3.1",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.7.0",
    "typescript": "^5.0.0",
    "vitest": "^3.2.4"
  },
  "keywords": [
    "education",
    "ai",
    "chatbot",
    "typescript",
    "nextjs",
    "openai"
  ],
  "author": "KIKE (Backend) + JANKARLO (Frontend)",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```
=== EOF: package.json

===  obejtivodocenteia.md
```markdown
1) Capa de textualizaci√≥n docente (LLM-orchestrator)
Explica y pregunta ‚Äúcomo docente‚Äù a partir de cada step (NARRATION/CONTENT/ASK), con persona, tono y estilo.
El motor determinista decide el paso; el LLM solo redacta con variedad, ejemplos y analog√≠as. ok
2) Persona y estilo por curso
Inyectar course.specialist (rol, tono, gu√≠as de estilo).
Variar frases gu√≠a: ‚ÄúAhora te explico‚Ä¶‚Äù, ‚ÄúBuen intento‚Ä¶‚Äù, ‚ÄúEstamos por buen camino‚Ä¶‚Äù, evitando repeticiones.
3) Pol√≠tica de turnos por tipo de step
NARRATION/CONTENT: 2‚Äì3 frases m√°ximas sin listas ni copiar literal; no pregunta en ese turno.
ASK: formular la pregunta exacta del JSON; validar; si no alcanza, re‚Äëpreguntar con micro-variaci√≥n.
4) Guardarra√≠les de avance
Umbrales claros (evidencia m√≠nima: par√°frasis, ejemplo, justificaci√≥n breve).
No avanzar si faltan preguntas del momento o la evidencia no cumple.
5) Evaluaci√≥n sem√°ntica con r√∫brica ligera
Matching contra acceptable_answers, y respaldo con objective/expected.
Parcialidades (matched/missing), y decisi√≥n ok/hint/refocus/advance.
6) Pistas escalonadas integradas al plan
Pista 1 (‚âà10 palabras), Pista 2 (‚âà20), Pista 3 (casi explicativa), derivadas de acceptable_answers y contentBody, sin spoilers.
7) Manejo de atascos y fuera de foco
Detecci√≥n de DONT_KNOW/IRRELEVANT reiterado; reconduce al objetivo o micro-contenido.
Anti‚Äëbucle y anti‚Äërepetici√≥n de la misma pregunta.
8) Se√±alizaci√≥n y transiciones pedag√≥gicas
Micro‚Äëresumen de cierre + puente al siguiente objetivo/paso.
‚ÄúTe adelanto qu√© veremos ahora‚Ä¶‚Äù sin spoilear respuestas.
9) Memoria de sesi√≥n docente
Intentos por pregunta, pistas usadas, matched/missing.
Referencias a aportes previos del estudiante para personalizar.
10) Biblioteca de preguntas socr√°ticas y reformulaciones
Micro‚Äëpreguntas de descomposici√≥n (‚â§8 palabras), alternativas A/B, enfoques por taxonom√≠a (recuerdo, comprensi√≥n, aplicaci√≥n‚Ä¶).
11) Anti‚Äërepetici√≥n y deduplicaci√≥n
Normalizaci√≥n y filtros para no repetir la misma pregunta o frase en turnos consecutivos.
12) Narrativa con ‚Äúvoz docente‚Äù
Reescritura del body en texto corrido, ejemplos laborales breves, lenguaje sencillo, evitando bullets y copia literal.
13) Cierre de momento y metacognici√≥n
Checklist de objetivos alcanzados y ‚Äúqu√© te llevas‚Äù, mini‚Äëreflexi√≥n o plan de acci√≥n.
14) Adaptaci√≥n de dificultad
Si responde con solvencia, ir a preguntas de mayor nivel; si no, simplificar y ejemplificar.
15) M√©tricas y trazabilidad
contentShown/Total, asksAsked/Total, attempts/hints per ask.
Logs de decisiones (acci√≥n, raz√≥n, paso).
16) Validaci√≥n y saneo del JSON
Asegurar steps completos y ordenados; sin preguntas en NARRATION.
Contenido en CONTENT.body; pregunta solo en ASK.
17) Internacionalizaci√≥n y normas de estilo
Longitudes m√°ximas por bloque, tono consistente, emojis/√©nfasis opcionales seg√∫n curso.
18) UI docente
Marcar visualmente: ‚ÄúExplicaci√≥n‚Äù, ‚ÄúPregunta‚Äù, ‚ÄúPista‚Äù.
Mostrar progreso por momento y paso sin distraer.
19) Pruebas de flujo end‚Äëto‚Äëend
Casos t√≠picos: correcto a la primera, parcial, ‚Äúno lo s√©‚Äù, offtopic, reiteraci√≥n.
Tests de anti‚Äërepetici√≥n y de avance.
20) Fallbacks robustos
Si falta ASK, generar una de verificaci√≥n coherente; si falta CONTENT, sintetizar a partir de KEY_*.
```
=== EOF: obejtivodocenteia.md

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    ignoreBuildErrors: false,
  },
  eslint: {
    ignoreDuringBuilds: false,
  },
}

module.exports = nextConfig
```
=== EOF: next.config.js

===  next-env.d.ts
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference types="next/navigation-types/compat/navigation" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```
=== EOF: next-env.d.ts

===  middleware.ts
```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const requiresAuth = pathname.startsWith('/engine-chat');
  if (!requiresAuth) return NextResponse.next();

  const token = await getToken({ req: request, secret: process.env.AUTH_SECRET || process.env.NEXTAUTH_SECRET });
  if (token) return NextResponse.next();

  const loginUrl = new URL('/login', request.url);
  loginUrl.searchParams.set('callbackUrl', request.nextUrl.pathname + request.nextUrl.search);
  return NextResponse.redirect(loginUrl);
}

export const config = {
  matcher: ['/engine-chat/:path*'],
};



```
=== EOF: middleware.ts

===  test\prompt.spec.ts
```typescript
import { describe, expect, it } from 'vitest';
import { buildUserPrompt } from '../src/ai/prompt';

describe('prompt: hint anti-meta rule', () => {
  it('includes anti-meta guidance in hint prompts', () => {
    const prompt = buildUserPrompt({
      language: 'es',
      action: 'hint',
      stepType: 'ASK',
      questionText: '¬øQu√© esperas aprender sobre procedimientos de seguridad?',
      objective: 'procedimientos de seguridad',
      contentBody: ['partes del procedimiento', 'c√≥mo se aplica', 'importancia de seguirlos'],
      hintWordLimit: 18,
    } as any);
    expect(prompt).toMatch(/Evita frases meta/i);
  });
});


```
=== EOF: test\prompt.spec.ts

===  test\health.lmm.mongo.spec.ts
```typescript
import { describe, it, expect } from 'vitest';
import { getClient, pickModel } from '@/lib/ai';
import { MongoClient } from 'mongodb';

describe('Healthchecks: LLM and MongoDB', () => {
  it('LLM: should create OpenAI client and echo minimal output', async () => {
    // Falla claramente si no hay clave; mostramos mensaje √∫til
    const key = process.env.OPENAI_API_KEY;
    expect(key, 'OPENAI_API_KEY must be set').toBeTruthy();
    const client = getClient();
    const model = pickModel('cheap');
    const r: any = await client.responses.create({
      model,
      input: [
        { role: 'system', content: 'Eres un verificador. Responde solo la palabra OK.' },
        { role: 'user', content: 'Di OK si recibiste este mensaje.' }
      ],
      temperature: 0
    });
    const out = String(r?.output_text || '').trim().toUpperCase();
    expect(out.includes('OK')).toBe(true);
  }, 20000);

  it('MongoDB: should connect and upsert a health document', async () => {
    const uri = process.env.MONGO_URI as string;
    const dbn = (process.env.MONGO_DB as string) || 'docenteia';
    expect(uri, 'MONGO_URI must be set').toBeTruthy();
    const c = new MongoClient(uri);
    await c.connect();
    const db = c.db(dbn);
    const col = db.collection('health');
    await col.updateOne({ _id: 'vitest' }, { $set: { at: Date.now() } }, { upsert: true });
    const doc = await col.findOne({ _id: 'vitest' });
    expect(Boolean(doc)).toBe(true);
    await c.close();
  }, 20000);
});


```
=== EOF: test\health.lmm.mongo.spec.ts

===  test\feedbackSequential.ui.spec.tsx
```tsx
import React from 'react';
import FeedbackSequential from '@/components/FeedbackSequential';
import TestRenderer, { act } from 'react-test-renderer';
import { describe, expect, it, vi } from 'vitest';

function setInput(root: TestRenderer.ReactTestRenderer['root'], value: string) {
  const input = root.findAll((n) => n.type === 'input')[0];
  act(() => input.props.onChange({ target: { value } }));
}

function clickSend(root: TestRenderer.ReactTestRenderer['root']) {
  const btn = root.findAll((n) => n.type === 'button')[0];
  act(() => btn.props.onClick());
}

function getLabels(root: TestRenderer.ReactTestRenderer['root']): string[] {
  const nodes = root.findAll((n) => n.type === 'span' && String(n.props.className || '').includes('font-semibold'));
  return nodes.map((n) => (Array.isArray(n.children) ? n.children.join('') : String(n.children || '')));
}

function getKinds(root: TestRenderer.ReactTestRenderer['root']): string[] {
  const nodes = root.findAll((n) => n.type === 'span' && String(n.props.className || '').includes('uppercase'));
  return nodes.map((n) => (Array.isArray(n.children) ? n.children.join('') : String(n.children || '')));
}

function getLastFeedback(root: TestRenderer.ReactTestRenderer['root']): string {
  const nodes = root.findAll((n) => n.type === 'div' && String(n.props.className || '').includes('whitespace-pre-wrap'));
  const last = nodes[nodes.length - 1];
  if (!last) return '';
  return Array.isArray(last.children) ? last.children.join('') : String(last.children || '');
}

describe('FeedbackSequential UI', () => {
  it('mapea HINT a F0/F1 seg√∫n intento (F0 en intentos 0 y 1, F1 en 2)', () => {
    let renderer: TestRenderer.ReactTestRenderer;
    act(() => {
      renderer = TestRenderer.create(
        <FeedbackSequential
          code="T-Q01"
          prompts={[
            'P0: pregunta',
            'P1: reintento',
            'P2: √∫ltimo'
          ]}
          objective="objetivo"
          acceptable={[]}
          expected={[]}
          answerType="list"
        />
      );
    });
    const root = (renderer as TestRenderer.ReactTestRenderer).root;

    // intento 0: vac√≠o ‚Üí HINT ‚Üí F0
    setInput(root, '');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F0']);
    expect(getKinds(root)[0]).toBe('HINT');

    // intento 1: basura ‚Üí HINT ‚Üí F0
    setInput(root, '???');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F0', 'F0']);

    // intento 2: basura ‚Üí HINT ‚Üí F1
    setInput(root, 'lorem ipsum');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F0', 'F0', 'F1']);
    expect(getKinds(root)[2]).toBe('HINT');
  });

  it('PARTIAL y ACCEPT se etiquetan F2 y completan acorde', () => {
    let onComplete = vi.fn();
    let renderer: TestRenderer.ReactTestRenderer;
    act(() => {
      renderer = TestRenderer.create(
        <FeedbackSequential
          code="T-Q02"
          prompts={[
            'P0', 'P1', 'P2'
          ]}
          objective="definir semilla"
          acceptable={["56"]}
          expected={["semilla"]}
          answerType="definition"
          onComplete={onComplete}
        />
      );
    });
    const root = (renderer as TestRenderer.ReactTestRenderer).root;

    // PARTIAL por expected
    setInput(root, 'La semilla...');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F2']);
    expect(getKinds(root)[0]).toBe('PARTIAL');
    expect(onComplete).not.toHaveBeenCalled();

    // ACCEPT por acceptable
    setInput(root, '56');
    clickSend(root);
    const labels = getLabels(root);
    expect(labels[labels.length - 1]).toBe('F2');
    const kinds = getKinds(root);
    expect(kinds[kinds.length - 1]).toBe('ACCEPT');
    expect(onComplete).toHaveBeenCalledTimes(1);
    const call = onComplete.mock.calls[0][0];
    expect(call.status).toBe('cumplida');
    expect(call.score).toBe(2);
  });

  it('al agotar intentos con finalExplanation agrega F2 final y emite force_advance', () => {
    let onComplete = vi.fn();
    let renderer: TestRenderer.ReactTestRenderer;
    act(() => {
      renderer = TestRenderer.create(
        <FeedbackSequential
          code="T-Q03"
          prompts={[ 'P0', 'P1', 'P2' ]}
          objective="objetivo"
          acceptable={["respuesta-correcta"]}
          expected={[]}
          answerType="list"
          finalExplanation="Explicaci√≥n de cierre"
          onComplete={onComplete}
        />
      );
    });
    const root = (renderer as TestRenderer.ReactTestRenderer).root;

    // Tres intentos fallidos
    setInput(root, 'foo'); clickSend(root);
    setInput(root, 'bar'); clickSend(root);
    setInput(root, 'baz'); clickSend(root);

    const labels = getLabels(root);
    // deber√≠an ser: F0, F0, F1, F2 (cierre)
    expect(labels).toEqual(['F0', 'F0', 'F1', 'F2']);
    const lastText = getLastFeedback(root);
    expect(lastText).toContain('Explicaci√≥n de cierre');

    expect(onComplete).toHaveBeenCalledTimes(1);
    const call = onComplete.mock.calls[0][0];
    expect(call.status).toBe('force_advance');
    expect(call.score === 0 || call.score === 1).toBe(true);
  });
});



```
=== EOF: test\feedbackSequential.ui.spec.tsx

===  test\feedbackSequencer.spec.ts
```typescript
import { describe, expect, it } from 'vitest';
import { buildTraceEntry, computeFeedbackLabel } from '../src/engine/feedbackSequencer';

describe('feedbackSequencer', () => {
  it('computeFeedbackLabel: HINT ‚Üí F0/F1 seg√∫n intento', () => {
    expect(computeFeedbackLabel('HINT', 0)).toBe('F0');
    expect(computeFeedbackLabel('HINT', 1)).toBe('F0');
    expect(computeFeedbackLabel('HINT', 2)).toBe('F1');
  });

  it('computeFeedbackLabel: PARTIAL/ACCEPT ‚Üí F2', () => {
    expect(computeFeedbackLabel('PARTIAL', 0)).toBe('F2');
    expect(computeFeedbackLabel('ACCEPT', 1)).toBe('F2');
  });

  it('buildTraceEntry: estructura P/R/F con metadatos', () => {
    const t = buildTraceEntry({
      question: 'P0',
      response: 'R0',
      feedback: 'F0',
      kind: 'HINT',
      attempt: 1,
      hintsUsed: 2,
      stepCode: 'M1-Q01'
    });
    expect(t.label).toBe('F0');
    expect(t.kind).toBe('HINT');
    expect(t.p).toBe('P0');
    expect(t.r).toBe('R0');
    expect(t.f).toBe('F0');
    expect(t.attempt).toBe(1);
    expect(t.hintsUsed).toBe(2);
    expect(t.stepCode).toBe('M1-Q01');
  });
});



```
=== EOF: test\feedbackSequencer.spec.ts

===  test\eval.classify.spec.ts
```typescript
import { describe, expect, it, vi } from 'vitest';

// Mock semvec and escalation to evitar dependencias de IA en tests
vi.mock('@/engine/semvec', () => ({
  buildAskIndex: async () => ({ centroid: [1], texts: [] }),
  semanticScore: async () => ({ cos: 0, best: null })
}));
vi.mock('@/engine/eval-escalation', () => ({
  escalateReasoning: async () => ({ decision: 'HINT', short: 'stub' })
}));

import { classifyTurn, type AskPolicy } from '../src/engine/eval';

describe('evaluate/classifyTurn basic cases', () => {
  it('capital of France: ACCEPT with "Par√≠s"', () => {
    const policy: AskPolicy = { type: 'conceptual' };
    const acceptable = ['Paris', 'Par√≠s'];
    const expected: string[] = [];
    const r = classifyTurn('Par√≠s', policy, acceptable, expected);
    expect(r.kind).toBe('ACCEPT');
  });

  it('area circle: PARTIAL with mention of "pi"', () => {
    const policy: AskPolicy = { type: 'conceptual' };
    const acceptable: string[] = ['œÄr2', 'œÄr^2', 'pi r2'];
    const expected: string[] = ['pi', 'radio', 'cuadrado'];
    const r = classifyTurn('algo con pi', policy, acceptable, expected);
    expect(r.kind).toBe('PARTIAL');
  });

  it('listado: ACCEPT when k-of-n is met', () => {
    const policy: AskPolicy = { type: 'listado', thresholdK: 2 };
    const acceptable: string[] = ['casco', 'guantes', 'lentes'];
    const expected: string[] = [];
    const r = classifyTurn('casco y guantes obligatorios', policy, acceptable, expected);
    expect(r.kind).toBe('ACCEPT');
  });

  it('listado: PARTIAL when below k', () => {
    const policy: AskPolicy = { type: 'listado', thresholdK: 2 };
    const acceptable: string[] = ['casco', 'guantes', 'lentes'];
    const expected: string[] = [];
    const r = classifyTurn('casco', policy, acceptable, expected);
    expect(r.kind).toBe('PARTIAL');
  });

  it('no s√© -> HINT', () => {
    const policy: AskPolicy = { type: 'conceptual' };
    const acceptable: string[] = ['procedimiento'];
    const expected: string[] = ['partes', 'aplicaci√≥n'];
    const r = classifyTurn('no s√©', policy, acceptable, expected);
    expect(r.kind).toBe('HINT');
  });
});


```
=== EOF: test\eval.classify.spec.ts

===  test\engine.nose.spec.ts
```typescript
import { describe, expect, it, vi } from 'vitest';

// Mocks hoisted para aislar el handler del engine
let __hintCount = 0;
vi.mock('@/ai/orchestrator', () => ({
  runDocenteLLM: async (ctx: any) => {
    const action = ctx?.action;
    if (action === 'ask') {
      return { message: `PREGUNTA: ${ctx.questionText}`, followUp: ctx.questionText };
    }
    if (action === 'ask_options') {
      const items = (ctx?.optionItems || []).slice(0, 2);
      const labeled = items.map((s: string, i: number) => `${String.fromCharCode(65 + i)}) ${s}`);
      return { message: `Elige una opci√≥n: ${labeled.join(' | ')}` } as any;
    }
    if (action === 'hint') {
      __hintCount += 1;
      const fu = __hintCount === 1
        ? '¬øUna micro‚Äëpregunta?'
        : (__hintCount === 2 ? '¬øUna micro‚Äëpregunta m√°s f√°cil?' : '¬øUna micro‚Äëpregunta?');
      return { message: 'Pista breve alineada al objetivo.', followUp: fu };
    }
    if (action === 'feedback') {
      return { message: 'FB: refuerzo/gu√≠a breve.' };
    }
    if (action === 'advance') {
      return { message: 'Puente breve al siguiente foco.' };
    }
    if (action === 'explain') {
      return { message: 'Explicaci√≥n breve del contenido.' };
    }
    return { message: '' };
  }
}));

// Mock semvec para evitar embeddings/OpenAI
vi.mock('@/engine/semvec', () => ({
  buildAskIndex: async () => ({ centroid: [1], texts: [] }),
  semanticScore: async () => ({ cos: 0, best: null })
}));

async function getPOST() {
  const mod = await import('../app/api/engine/turn/route');
  return (mod as any).POST as (req: Request) => Promise<Response>;
}

async function turn(body: any) {
  const req = new Request('http://localhost/api/engine/turn', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const POST = await getPOST();
  const res = await POST(req as any);
  return await (res as any).json();
}

describe('engine: tres "no se" consecutivos', () => {
  it('emite HINT dos veces y luego puente de avance (force_advance)', async () => {
    const sessionKey = 'it-3-no-se';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    // Inicio de sesi√≥n ‚Üí obtener primera pregunta
    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    // 1) no se ‚Üí HINT
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t1.message || '') + (t1.followUp || '')).length).toBeGreaterThan(0);
    // 2) no se ‚Üí HINT
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t2.message || '') + (t2.followUp || '')).length).toBeGreaterThan(0);
    // 3) no se ‚Üí avance forzado: debe incluir el puente de avance del mock
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect((t3.message || '').toLowerCase()).toContain('puente breve al siguiente foco');
    expect((t3.followUp || '').length).toBeGreaterThan(0);
  });

  it('valida feedback y followUp en HINT‚ÜíHINT/ADV‚Üíforce_advance', async () => {
    const sessionKey = 'it-3-no-se-fb';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    // 1) no se ‚Üí HINT con feedback/hint y micro‚Äëpregunta
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg1 = (t1.message || '').toLowerCase();
    const fu1 = (t1.followUp || '').toLowerCase();
    expect(msg1).toMatch(/fb: refuerzo|pista breve alineada|explicaci√≥n breve|puente breve/);
    expect(fu1.length).toBeGreaterThan(0);

    // 2) no se ‚Üí HINT o transici√≥n temprana seg√∫n pol√≠tica
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg2 = (t2.message || '').toLowerCase();
    const fu2 = (t2.followUp || '').toLowerCase();
    expect(msg2).toMatch(/fb: refuerzo|pista breve alineada|explicaci√≥n breve|puente breve|elige una opci√≥n/);
    if (/elige una opci√≥n/.test(msg2)) {
      expect(fu2.length).toBeGreaterThanOrEqual(0);
    } else {
      expect(fu2.length).toBeGreaterThan(0);
    }

    // 3) no se ‚Üí avance con puente y nueva followUp (force_advance)
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg3 = (t3.message || '').toLowerCase();
    const fu3 = (t3.followUp || '').toLowerCase();
    expect(msg3).toContain('puente breve al siguiente foco');
    expect(fu3.length).toBeGreaterThan(0);
  });

  it('no fuerza avance tras dos "no se"; lo hace en el tercero', async () => {
    const sessionKey = 'it-2-no-se-advance';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg1 = (t1.message || '').toLowerCase();
    expect(msg1.length).toBeGreaterThan(0);

    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg2 = (t2.message || '').toLowerCase();
    const fu2 = (t2.followUp || '').toLowerCase();
    // A√∫n NO debe forzar avance en el segundo "no se": debe seguir con hint u opciones
    expect(msg2).not.toContain('puente breve al siguiente foco');
    if (/elige una opci√≥n/.test(msg2)) {
      expect(fu2.length).toBeGreaterThanOrEqual(0);
    } else {
      expect(fu2.length).toBeGreaterThan(0);
    }
    // Tercer "no se" ‚Üí ahora s√≠ puente de avance
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg3 = (t3.message || '').toLowerCase();
    const fu3 = (t3.followUp || '').toLowerCase();
    expect(msg3).toContain('puente breve al siguiente foco');
    expect(fu3.length).toBeGreaterThan(0);
  });

  it('pregunta ‚Üí no se ‚Üí pista f√°cil ‚Üí no se ‚Üí pista m√°s f√°cil ‚Üí no se ‚Üí avance', async () => {
    const sessionKey = 'it-escalada-hints';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    // 1) no se ‚Üí feedback+hint con followUp ‚Äúmicro‚Äëpregunta‚Äù
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t1.message || '').toLowerCase())).toMatch(/pista breve|fb: refuerzo/);
    const fu1s = (t1.followUp || '').toLowerCase();
    expect(fu1s.length).toBeGreaterThan(0);

    // 2) no se ‚Üí feedback+hint con followUp ‚Äúm√°s f√°cil‚Äù
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t2.message || '').toLowerCase())).toMatch(/pista breve|fb: refuerzo|puente breve|elige una opci√≥n/);
    const fu2s = (t2.followUp || '').toLowerCase();
    if (/elige una opci√≥n/.test((t2.message || '').toLowerCase())) {
      expect(fu2s.length).toBeGreaterThanOrEqual(0);
    } else {
      expect(fu2s.length).toBeGreaterThan(0);
    }
    // Si ya hubo avance en el segundo, igual debe haber followUp (siguiente pregunta)

    // 3) no se ‚Üí feedback + mensaje ‚Äúavancemos‚Äù (puente) y nueva pregunta
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect((t3.message || '').toLowerCase()).toContain('puente breve al siguiente foco');
    expect((t3.followUp || '').length).toBeGreaterThan(0);
  });
});


```
=== EOF: test\engine.nose.spec.ts

===  test\engine.integration.lesson02.spec.ts
```typescript
import { describe, expect, it, vi } from 'vitest';

// Mocks HOISTED antes de importar route.ts
vi.mock('@/ai/orchestrator', () => ({
  runDocenteLLM: async (ctx: any) => {
    const action = ctx?.action;
    if (action === 'ask') {
      return { message: `PREGUNTA: ${ctx.questionText}`, followUp: ctx.questionText };
    }
    if (action === 'hint') {
      return { message: 'Pista breve alineada al objetivo.', followUp: '¬øUna micro‚Äëpregunta?' };
    }
    if (action === 'ask_options') {
      const items = (ctx?.optionItems || []).slice(0, 2);
      const labeled = items.map((s: string, i: number) => `${String.fromCharCode(65 + i)}) ${s}`);
      return { message: `Elige una opci√≥n: ${labeled.join(' | ')}` };
    }
    if (action === 'feedback') {
      return { message: 'FB: refuerzo/gu√≠a breve.' };
    }
    if (action === 'advance') {
      return { message: 'Puente breve al siguiente foco.' };
    }
    if (action === 'explain') {
      return { message: 'Explicaci√≥n breve del contenido.' };
    }
    return { message: '' };
  }
}));

// Mock semvec para evitar llamadas a embeddings/OpenAI
vi.mock('@/engine/semvec', () => ({
  buildAskIndex: async () => ({ centroid: [1], texts: [] }),
  semanticScore: async () => ({ cos: 0, best: null })
}));

// Mock evaluaci√≥n sem√°ntica: clasifica por palabra clave en la respuesta (solo la funci√≥n usada)
vi.mock('@/engine/eval', () => ({
  evaluateSemanticOnly: async (user: string) => {
    const u = String(user || '').toLowerCase();
    if (/^correcta/.test(u) || /\bok\b/.test(u)) {
      return { kind: 'ACCEPT', reason: 'STUB', matched: ['ok'], missing: [], sem: { cos: 0.9, best: { text: 'ok', cos: 0.9 } } } as any;
    }
    if (/^parcial/.test(u)) {
      return { kind: 'PARTIAL', reason: 'STUB', matched: ['pi'], missing: ['radio'], sem: { cos: 0.6, best: { text: 'pi', cos: 0.6 } } } as any;
    }
    return { kind: 'HINT', reason: 'STUB', matched: [], missing: ['se√±al'], sem: { cos: 0.1, best: null } } as any;
  }
}));

async function getPOST() {
  const mod = await import('../app/api/engine/turn/route');
  return (mod as any).POST as (req: Request) => Promise<Response>;
}

async function turn(body: any) {
  const req = new Request('http://localhost/api/engine/turn', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const POST = await getPOST();
  const res = await POST(req as any);
  return await (res as any).json();
}

describe('engine integration: lesson02', () => {
  it('Tres "no se" consecutivos ‚Üí ver preguntas y feedback en logs', async () => {
    const sessionKey = 'it-lesson02-3-no-se';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    // Primer turno: iniciar sesi√≥n y obtener la primera pregunta
    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    // Tres "no se"
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });

    // Logs visibles: pregunta y feedback + micro‚Äëpregunta en cada turno
    // eslint-disable-next-line no-console
    console.log('[3_NO_SE]', {
      q0: t0.followUp,
      turn1: { message: t1.message, followUp: t1.followUp },
      turn2: { message: t2.message, followUp: t2.followUp },
      turn3: { message: t3.message, followUp: t3.followUp },
    });

    // Aserciones m√≠nimas para asegurar contenido
    expect((t0.followUp || '').length).toBeGreaterThan(0);
    expect(((t1.message || '') + (t1.followUp || '')).length).toBeGreaterThan(0);
    expect(((t2.message || '') + (t2.followUp || '')).length).toBeGreaterThan(0);
    expect(((t3.message || '') + (t3.followUp || '')).length).toBeGreaterThan(0);
  });
  it('No s√© ‚Üí HINT (pista + micro‚Äëpregunta, sin explicaci√≥n)', async () => {
    const sessionKey = 'it-lesson02-nose';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const r0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    const q0 = r0.followUp || '';
    // Turno con "no se"
    const r1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg = r1.message || '';
    const fu = r1.followUp || '';
    // Debe ser pista, no explicaci√≥n
    expect(msg.toLowerCase()).toMatch(/pista|breve/);
    expect(fu.length).toBeGreaterThan(0);
    // eslint-disable-next-line no-console
    console.log('[NOSE]', { q0, msg, fu });
  });
  it('Caso 1: vac√≠o, vac√≠o, parcial ‚Üí avanza pendiente (2 ayudas, score 1)', async () => {
    const sessionKey = 'it-lesson02-caso1';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const r0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((r0.followUp || '').length).toBeGreaterThan(0);
    const r1 = await turn({ sessionKey, planUrl, userInput: '' });
    expect((r1.followUp || '').length).toBeGreaterThan(0);
    // incluir se√±ales esperadas y tokens suficientes
    const r2 = await turn({ sessionKey, planUrl, userInput: 'parcial radio pi' });
    // Validar que hubo interacci√≥n con pista/feedback y continuidad
    expect(((r2.message || '') + (r2.followUp || '')).length).toBeGreaterThan(0);
    // Log para inspecci√≥n manual
    // eslint-disable-next-line no-console
    console.log('[CASO1]', { m0: r0.message, f0: r0.followUp, m1: r1.message, f1: r1.followUp, m2: r2.message, f2: r2.followUp, assess: r2.assessment });
  });

  it('Caso 2: vac√≠o, vac√≠o, correcta ‚Üí avanza cumplida (2 ayudas, score 2)', async () => {
    const sessionKey = 'it-lesson02-caso2';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const r0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((r0.followUp || '').length).toBeGreaterThan(0);
    const r1 = await turn({ sessionKey, planUrl, userInput: '' });
    expect((r1.followUp || '').length).toBeGreaterThan(0);
    // cumplir minTokens y gatillar ACCEPT del stub
    const r2 = await turn({ sessionKey, planUrl, userInput: 'correcta ok ok' });
    expect(r2.assessment?.level).toBe('R2');
    expect(r2.assessment?.score).toBe(2);
  });

  it('Caso 5: vac√≠o, vac√≠o, vac√≠o ‚Üí force-advance (score 0)', async () => {
    const sessionKey = 'it-lesson02-caso5';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    const r1 = await turn({ sessionKey, planUrl, userInput: '' });
    const r2 = await turn({ sessionKey, planUrl, userInput: '' });
    // No garantizamos assessment en vac√≠o, pero s√≠ un followUp (siguiente paso o re-ask)
    expect((r2.followUp || '').length).toBeGreaterThan(0);
  });
});


```
=== EOF: test\engine.integration.lesson02.spec.ts

===  test\clarify.spec.ts
```typescript
import { describe, expect, it } from 'vitest';
import { isNoSeInput, shouldClarifyQuestion, shouldGateByMinTokens } from '../src/engine/clarify';

describe('clarify helpers', () => {
  it('gates by min tokens', () => {
    expect(shouldGateByMinTokens('', 3)).toBe(true);
    expect(shouldGateByMinTokens('no se', 3)).toBe(true);
    expect(shouldGateByMinTokens('algo breve', 2)).toBe(false);
  });

  it('detects no se patterns', () => {
    expect(isNoSeInput('no se')).toBe(true);
    expect(isNoSeInput('No s√©')).toBe(true);
    expect(isNoSeInput('no estoy seguro')).toBe(true);
    expect(isNoSeInput('s√≠')).toBe(false);
  });

  it('clarify only when not vague/no and not hint', () => {
    expect(shouldClarifyQuestion({ isVague: false, isNo: false, classificationKind: 'PARTIAL', studentAsking: true })).toBe(true);
    expect(shouldClarifyQuestion({ isVague: true, isNo: false, classificationKind: 'PARTIAL', studentAsking: true })).toBe(false);
    expect(shouldClarifyQuestion({ isVague: false, isNo: true, classificationKind: 'PARTIAL', studentAsking: true })).toBe(false);
    expect(shouldClarifyQuestion({ isVague: false, isNo: false, classificationKind: 'HINT', studentAsking: true })).toBe(false);
    expect(shouldClarifyQuestion({ isVague: false, isNo: false, classificationKind: 'PARTIAL', studentAsking: false })).toBe(false);
  });
});


```
=== EOF: test\clarify.spec.ts

===  scripts\chatNoSe.ts
```typescript
// Simple chat runner against the engine turn endpoint (HTTP if available, otherwise direct import)
import 'dotenv/config';
import fs from 'fs';
import path from 'path';

// Ensure .env.local is loaded when available (Next.js style)
try {
  const localPath = path.join(process.cwd(), '.env.local');
  if (fs.existsSync(localPath)) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    require('dotenv').config({ path: localPath });
  }
} catch {}

const planUrl = '/courses/SSO001/lessons/lesson02.json';
const sessionKey = `cli-chat-${Date.now()}`;
const base = process.env.BASE_URL || 'http://localhost:3001';

type TurnRes = { message?: string; followUp?: string; assessment?: any; state?: any };

async function httpTurn(body: any): Promise<TurnRes> {
  const res = await fetch(`${base}/api/engine/turn`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return (await res.json()) as any;
}

async function directTurn(body: any): Promise<TurnRes> {
  const mod = await import('../app/api/engine/turn/route');
  const POST = (mod as any).POST as (req: Request) => Promise<Response>;
  const req = new Request('http://local/api/engine/turn', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const res = await POST(req as any);
  return (await (res as any).json()) as any;
}

async function turn(body: any) {
  try {
    return await httpTurn(body);
  } catch {
    return await directTurn(body);
  }
}

function logStep(tag: string, r: TurnRes) {
  const msg = (r.message || '').trim();
  const fu = (r.followUp || '').trim();
  const compose = (m: string, f: string) => {
    if (m && f) {
      const norm = (s: string) => s.replace(/\s+/g, ' ').trim().toLowerCase();
      if (norm(m).includes(norm(f))) return m; // evitar repetir la pregunta
      const endPunct = /[\.!?]$/.test(m) ? '' : '.';
      return `${m}${endPunct}\n\n${f}`;
    }
    return m || f || '';
  };
  const out = compose(msg, fu);
  console.log(`\n[${tag}]`);
  if (out) console.log(out);
}

async function main() {
  console.log(`Chat clave: ${sessionKey}`);
  // Inicio (reset) ‚Üí obtener pregunta inicial
  const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
  logStep('INICIO', t0);

  // "no se" #1 ‚Üí HINT
  const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
  logStep('NO_SE_1', t1);

  // "no se" #2 ‚Üí HINT (reask m√°s f√°cil)
  const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
  logStep('NO_SE_2', t2);

  // "no se" #3 ‚Üí avance/puente
  const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
  logStep('NO_SE_3', t3);

  // Respuesta tentativa post‚Äëavance
  const t4 = await turn({ sessionKey, planUrl, userInput: 'arnes casco guantes' });
  logStep('POST_AVANCE', t4);
}

main().catch((err) => {
  console.error('[CHAT_ERROR]', err);
  process.exit(1);
});


```
=== EOF: scripts\chatNoSe.ts

===  src\auth.ts
```typescript
// Deprecated in favor of direct route handler config in
// `app/api/auth/[...nextauth]/route.ts` using NextAuth v4 style.
// This file is intentionally left empty to avoid v5 type mismatch.
export {};


```
=== EOF: src\auth.ts

===  docs\AGENTS_PHASE0.md
```markdown
## Fase 0 ‚Äî Preparaci√≥n para OpenAI Agents SDK

Objetivo: establecer m√©tricas, umbrales, flags de despliegue y criterios de aceptaci√≥n para migraci√≥n agentic, manteniendo la calidad pedag√≥gica.

### 1) M√©tricas y umbrales propuestos
- No‚Äës√© encadenados tras S2: objetivo reducir ‚â•30%
  - L√≠nea base: medir % actual de turnos con tercer "no s√©" dentro de una misma `ASK`
  - Umbral de √©xito: ‚â§70% del valor base despu√©s del despliegue
- Pertinencia de MICRO vs `objective`: ‚â•80%
  - M√©todo: muestreo de 50 pistas por m√≥dulo (M2‚ÄìM4) con checklist binaria
- Repetici√≥n textual detectada por guardrails: ~0%
  - Patr√≥n: evitar frases gen√©ricas (p. ej., ‚ÄúLos procedimientos de seguridad incluyen ‚Ä¶‚Äù) y duplicados intra‚Äëmensaje
- Tiempo a completar M2/M3 (turnos): mantener o reducir ‚â§10% sin p√©rdida de acierto
  - Control: comparar medianas pre/post
- Satisfacci√≥n percibida de pista (encuesta 1‚Äë5): +0.5 puntos respecto a base

### 2) Flags de rollout y plan A/B
- Feature flags
  - `agents.enabled`: activa el agente y loop con tools
  - `agents.guardrails.output`: valida formato (MICRO/PISTA/PUENTE, longitudes, anti‚Äërepetici√≥n)
  - `agents.handoffs.enabled`: delegaci√≥n a sub‚Äëagentes (fase 3)
  - `agents.realtime.enabled`: voz (opcional)
- Gradual rollout
  - 10% ‚Üí 30% ‚Üí 60% ‚Üí 100% de sesiones nuevas por `sessionKey` hash
  - Rollback r√°pido desactivando flags
- A/B tests sugeridos
  - S1 con analog√≠as vs sin analog√≠as
  - L√≠mite de palabras de `PISTA` (16/24/32)
  - Threshold de `force_advance` (3 vs 4)

### 3) Alineaci√≥n con objetivos, policies y aptitudes
- Objetivos
  - Cada `ASK` usa `objective` del plan; no derivar desde ‚Äúexpectativas‚Äù cuando exista objetivo espec√≠fico
- Policies del curso
  - `hints.wordLimits`, `allowForcedOn`, `forceNoSeThreshold`, `allowQuestions`
- Aptitudes del docente (0..1)
  - `claridad` (longitud/resumen), `socratismo` (re‚Äëask vs hint), `calidez` (tono), `rigor` (umbrales), `ritmo` (avance)
- Criterios de aceptaci√≥n por acci√≥n
  - hint: exactamente 2 l√≠neas `MICRO:` (‚â§8 palabras) + `PISTA:` (sin ?), ambas alineadas al `objective`
  - feedback: 1‚Äì3 frases, sin preguntas si `allowQuestions=false`, sin re‚Äënarrar
  - advance: `PUENTE:` y no mezclar pasos
  - ask_options (S2): 2 opciones cortas, derivadas de `expected/missing`, alineadas al `objective`

### 4) Riesgos y mitigaciones
- Desalineaci√≥n con el `LessonPlan`
  - Mitigaci√≥n: Guardrail ‚Äúno avanzar‚Äù fuera del paso actual; lectura del plan en caliente en `reset`
- Repetici√≥n del modelo
  - Mitigaci√≥n: anti‚Äëpatrones y deduplicaci√≥n intra‚Äëmensaje + historial reciente
- Latencia por loop agentic
  - Mitigaci√≥n: l√≠mites de turnos; cache en Plan/Policy; streaming opcional
- Sesiones obsoletas tras modificar JSON
  - Mitigaci√≥n: `reset` de sesi√≥n al detectar hash de plan distinto

### 5) Instrumentaci√≥n y trazabilidad
- Tracing por turno: acci√≥n, severidad, uso de tools, guardrails disparados
- Dashboards: tasa de ‚Äúno s√©‚Äù, repetici√≥n, tiempos, satisfacci√≥n, completitud por momento
- Registro de muestras de salida para auditor√≠a pedag√≥gica
```
=== EOF: docs\AGENTS_PHASE0.md

===  docs\AGENTS_IMPLEMENTATION.md
```markdown
## Plan de implementaci√≥n: Migraci√≥n a OpenAI Agents SDK (TypeScript)

### Objetivo
Transitar desde un orquestador manual a un flujo agentic con herramientas (tools), handoffs, guardrails y trazabilidad (tracing) nativos, preservando la pedagog√≠a actual (flujo "no s√©" S1/S2/S3, MICRO/PISTA, PUENTE, anti‚Äërepetici√≥n, objetivos din√°micos por pregunta).

### Beneficios clave
- Agent loop con decisiones iterativas y uso de tools
- Handoffs entre sub‚Äëagentes especializados (Hint/Feedback/Ask/Advance/Options)
- Guardrails de entrada y salida para formato, seguridad y calidad pedag√≥gica
- Tracing integrado para depurar, evaluar y mejorar
- Realtime Agents (opcional) para voz y conversaci√≥n natural con interrupciones

### Arquitectura propuesta (alto nivel)
- Agente principal: "DocenteIA" (instrucciones + aptitudes)
- Sub‚Äëagentes por acci√≥n (handoffs): HintAgent, FeedbackAgent, AdvanceAgent, AskAgent, OptionsAgent
- Tools: PlanTool, SessionTool, PolicyTool, SemvecTool, OptionsTool, HistoryTool
- Guardrails: InputGuardrail (no‚Äës√©, severidad), OutputGuardrail (MICRO/PISTA/PUENTE, longitud, anti‚Äërepetici√≥n)
- Tracing: trazas por turno, evaluaci√≥n de calidad, A/B pedag√≥gico

---

## Fases de implementaci√≥n

### Fase 0 ‚Äî Preparaci√≥n
- Definir m√©tricas de calidad (reducci√≥n de "no s√©" tras S2, precisi√≥n de MICRO/PISTA, cero repeticiones)
- Mapear flags de rollout y riesgos
- Alinear objetivos de curso y pol√≠ticas con aptitudes del docente

### Fase 1 ‚Äî MVP Agentic (agente √∫nico + guardrails de salida)
- Crear agente √∫nico "DocenteIA"
- Implementar OutputGuardrail para acciones clave:
  - hint: exactamente 2 l√≠neas, `MICRO:` (‚â§8 palabras) y `PISTA:` (sin ?), alineadas al objetivo
  - advance: incluir `PUENTE:`
  - feedback: 1‚Äì3 frases (o 2‚Äì3 seg√∫n pol√≠ticas), sin preguntas si `allowQuestions=false`
  - deduplicaci√≥n intra‚Äëmensaje y anti‚Äëpatrones (p. ej. frases gen√©ricas)
- Mantener l√≥gica no‚Äës√© S1/S2/S3 dentro del loop del agente

Entregable: agente "DocenteIA" + validaci√≥n de formato de salida + integraci√≥n con orquestador actual

### Fase 2 ‚Äî Tools y severidad
- A√±adir tools tipadas:
  - PlanTool: lectura del LessonPlan actual, resoluci√≥n de `objective`, `expected`, `moment` y siguiente paso
  - SessionTool: lectura/actualizaci√≥n de `attempts`, `noSeCountByAskCode`, `hintsByAskCode`, `reset`
  - PolicyTool: wordLimits, allowForcedOn, thresholds
  - SemvecTool: soporte de pistas con contenido y similitud sem√°ntica
  - OptionsTool: derivaci√≥n de opciones desde `expected/missing` (S2)
  - HistoryTool: √∫ltimas interacciones para anti‚Äërepetici√≥n contextual
- InputGuardrail: detectar "no s√©" y vac√≠o; ajustar severidad y cortar loops improductivos

Entregable: ejecuci√≥n con tools; severidad din√°mica y pistas m√°s precisas

### Fase 3 ‚Äî Handoffs (sub‚Äëagentes por acci√≥n)
- Separar responsabilidades en sub‚Äëagentes:
  - HintAgent: S1 (analog√≠a si natural), S2 (opciones), S3 (refuerzo y preparaci√≥n de puente)
  - FeedbackAgent: ACCEPT/PARTIAL/HINT/REFOCUS con `allowQuestions` y l√≠mites por pol√≠tica
  - AdvanceAgent: genera `PUENTE` coherente, no re‚Äënarra
  - AskAgent: re‚Äëask guiado por objetivo
  - OptionsAgent: opciones concisas alineadas al objetivo
- Orquestaci√≥n: DocenteIA decide handoff seg√∫n estado y pol√≠ticas

Entregable: coordinaci√≥n por handoffs con control fino de calidad por acci√≥n

### Fase 4 ‚Äî Tracing, evaluaci√≥n y A/B
- Activar tracing integrado y paneles de m√©tricas
- Experimentos A/B: longitud de pista, uso de analog√≠as S1, severidad adaptativa por intentos
- Evaluaciones: tasa de ‚Äúno s√©‚Äù, utilidad percibida de pistas, repeticiones, tiempo a objetivo

Entregable: observabilidad completa y bucle de mejora continua

### Fase 5 ‚Äî Realtime (opcional)
- Integrar Realtime Agents para `VoiceRecorder`
- Interrupciones, barge‚Äëin, handoffs controlados por voz
- Guardrails de transcripci√≥n y moderaci√≥n

Entregable: experiencia de voz con calidad pedag√≥gica preservada

### Fase 6 ‚Äî Consolidaci√≥n y limpieza
- Deprecaci√≥n de l√≥gicas duplicadas en `orchestrator` (uso de sub‚Äëagentes)
- Documentaci√≥n de contratos de Tools y guardrails (ver `docs/AGENTS_CONTRACTS.md`)
- Ajustes finales de pol√≠ticas y aptitudes (perfil docente extendible)

---

## M√©tricas de √©xito sugeridas
- Reducci√≥n >30% de ‚Äúno s√©‚Äù encadenados despu√©s de S2
- ‚â•80% de pistas con MICRO pertinente al `objective`
- Casi cero repeticiones detectadas por guardrails
- Menor tiempo a completar bloques M2/M3 sin p√©rdida de acierto

## Riesgos y mitigaciones
- Desalineaci√≥n con `LessonPlan`: OutputGuardrail ‚Äúno avanzar‚Äù fuera del paso actual
- Repetici√≥n: deduplicaci√≥n + variaci√≥n por historial (HistoryTool)
- Latencia: l√≠mites de turnos, caching en PlanTool/PolicyTool, streaming opcional
```
=== EOF: docs\AGENTS_IMPLEMENTATION.md

===  docs\AGENTS_CONTRACTS.md
```markdown
Contracts: Tools, Guardrails y Sub‚ÄëAgentes

Tools
- PolicyTool.getHintWordLimit(policies, severityIndex): number
- OptionsTool.pickTwoOptions(source, fallback): string[] (max 2)
- InputGuardrail.decideForceAdvanceByNoSe({ noSeCount, forceNoSeThreshold, allowForcedOn, momentKind }): { shouldForceAdvance }

Guardrails
- Output: hint ‚Üí { MICRO ‚â§8 palabras; PISTA sin interrogantes; alineado a objective }
- Output: advance ‚Üí requiere PUENTE breve; sin re‚Äënarraciones
- Output: feedback ‚Üí 1‚Äì3 frases; sin preguntas si allowQuestions=false

Sub‚ÄëAgentes
- runExplainAgent(ctx): explain
- runAskAgent(ctx): ask
- runAskOptionsAgent(ctx): ask_options
- runHintAgent(ctx): hint
- runFeedbackAgent(ctx): feedback
- runAdvanceAgent(ctx): advance
- runEndAgent(ctx): end

Contexto m√≠nimo (DocentePromptContext)
- language: 'es'
- action: 'explain' | 'ask' | 'ask_options' | 'hint' | 'feedback' | 'advance' | 'end'
- stepType: 'ASK' | 'CONTENT' | 'NARRATION' | 'END'
- objective: string
- questionText?: string
- contentBody?: string[]
- matched?/missing?: string[]
- recentHistory?: string[]
- hintWordLimit?: number
- allowQuestions?: boolean
- attempts?/hintsUsed?: number

Reglas de severidad (S1/S2/S3)
- S1: analog√≠a si natural, MICRO directo; hintLimit = wordLimits[0]
- S2: opciones (2) desde expected/missing; hintLimit = wordLimits[1]
- S3: Elemento ‚Üí funci√≥n; hintLimit = wordLimits[2]


```
=== EOF: docs\AGENTS_CONTRACTS.md

===  docs\ADAPTIVE_ENGINE.md
```markdown
# Motor Adaptativo con Control de Presupuesto

## Resumen

Este documento describe la implementaci√≥n del modelo-planificador acotado que permite adaptaci√≥n en tiempo real dentro de l√≠mites estrictos, manteniendo el JSON de la lecci√≥n como fuente de verdad.

## Arquitectura

### Componentes Principales

1. **Planificador Acotado** (`src/engine/planner.ts`)

   - Define comandos de adaptaci√≥n con Zod
   - Opera solo dentro del ciclo actual
   - Detecta desv√≠os de tema
   - Valida comandos antes de ejecutar

2. **Gestor de Presupuesto** (`src/engine/costs.ts`)

   - Controla uso de modelos por tiers
   - Limita escalaciones por sesi√≥n
   - Degrada autom√°ticamente cuando se agota presupuesto

3. **Evaluaci√≥n H√≠brida** (`src/engine/eval-escalation.ts`)

   - Validaci√≥n estricta con Zod
   - Escalaci√≥n inteligente solo cuando es necesaria
   - Fallback seguro en caso de errores

4. **Logger de Telemetr√≠a** (`src/engine/logger.ts`)
   - Registra todas las decisiones del motor
   - Exporta en formato JSONL para auditor√≠a
   - M√©tricas de uso por tier

## Comandos de Adaptaci√≥n

### AdaptCommand Schema

```typescript
{
  op: 'reask' | 'hint' | 'goto' | 'repeat' | 'insert_micro',
  targetAskCode?: string,
  note?: string,
  reason?: 'SEM_LOW' | 'THINKER_ESCALATION' | 'OFF_TOPIC' | 'BUDGET_LIMIT'
}
```

### Operaciones Permitidas

- **reask**: Solicitar reformulaci√≥n de respuesta vaga
- **hint**: Proporcionar pista determinista
- **goto**: Saltar a ASK espec√≠fica del cat√°logo
- **repeat**: Repetir paso actual sin avanzar
- **insert_micro**: Insertar micro-paso temporal (limitado)

## Control de Presupuesto

### Tiers de Modelos

| Tier    | Modelo                 | Costo/1K tokens | Uso                   |
| ------- | ---------------------- | --------------- | --------------------- |
| cheap   | gpt-4o-mini            | $0.005          | Docencia/redacci√≥n    |
| embed   | text-embedding-3-small | $0.001          | Similitud sem√°ntica   |
| thinker | o3-mini                | $0.025          | Razonamiento complejo |

### L√≠mites por Sesi√≥n

- **Presupuesto inicial**: $1.00 (100 centavos)
- **Escalaciones m√°ximas**: 5 por sesi√≥n
- **Umbral de degradaci√≥n**: 10 centavos restantes
- **Modo econ√≥mico**: < 5 centavos restantes

### Pol√≠tica de Uso

- **80% cheap**: Operaciones normales
- **15% embed**: Evaluaci√≥n sem√°ntica
- **5% thinker**: Escalaci√≥n solo cuando es necesaria

## Detecci√≥n de Desv√≠os

### Algoritmo de Clasificaci√≥n

```typescript
function detectTopicDeviation(
  response: string,
  step: any,
  objective: string
): TopicDeviation {
  const objectiveWords = objective
    .toLowerCase()
    .split(/\s+/)
    .filter((w) => w.length > 3);
  const objectiveMatches = objectiveWords.filter((word) =>
    response.includes(word)
  );
  const matchRatio =
    objectiveMatches.length / Math.max(1, objectiveWords.length);

  if (matchRatio >= 0.3) return "ON_TOPIC";
  if (matchRatio >= 0.1) return "VAGUE";
  return "OFF_TOPIC";
}
```

### Respuestas Autom√°ticas

- **ON_TOPIC**: Evaluaci√≥n normal
- **VAGUE**: REASK con solicitud de reformulaci√≥n
- **OFF_TOPIC**: GOTO a siguiente ASK del ciclo

## Integraci√≥n con el Frontend

### Toggle de Modo

```typescript
<select
  value={adaptiveMode ? "adaptive" : "deterministic"}
  onChange={(e) => setAdaptiveMode(e.target.value === "adaptive")}
>
  <option value="deterministic">Determinista</option>
  <option value="adaptive">Adaptativo</option>
</select>
```

### Barra de Presupuesto

```typescript
<div className="w-32 bg-gray-200 rounded-full h-2">
  <div
    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
    style={{ width: `${(budgetMetrics.budgetCentsLeft / 100) * 100}%` }}
  ></div>
</div>
```

## Variables de Entorno

```bash
# Modelos por tier
CHEAP_MODEL=gpt-4o-mini
THINKER_MODEL=o3-mini
EMBED_MODEL=text-embedding-3-small

# Debug
ENGINE_DEBUG=false
NEXT_PUBLIC_ENGINE_DEBUG=false

# Presupuesto
SESSION_BUDGET_CENTS=100
MAX_ESCALATIONS_PER_SESSION=5
ESCALATION_THRESHOLD_CENTS=10
```

## Telemetr√≠a

### Eventos Registrados

- `engine.turn.start`: Inicio de turno
- `evaluation.result`: Resultado de evaluaci√≥n
- `escalation.triggered`: Escalaci√≥n iniciada
- `adaptation.planned`: Adaptaci√≥n planificada
- `budget.usage`: Uso de presupuesto
- `advancement.accept/reject`: Avance del plan

### Formato JSONL

```json
{
  "timestamp": "2024-01-01T12:00:00Z",
  "level": "info",
  "event": "evaluation.result",
  "sessionId": "plan-123",
  "data": { "askCode": "ASK_001", "result": "ACCEPT", "reason": "SEM_LOW" }
}
```

## Riesgos y Mitigaciones

### Deriva del Tema

- **Riesgo**: El planificador inventa pasos persistentes
- **Mitigaci√≥n**: Solo opera dentro del ciclo actual con goto a ASK conocidas

### Costos Desbordados

- **Riesgo**: Presupuesto excedido
- **Mitigaci√≥n**: Hard cap con degradaci√≥n autom√°tica a modo determinista

### JSON Fr√°gil

- **Riesgo**: Respuestas malformadas del LLM
- **Mitigaci√≥n**: Validaci√≥n estricta con Zod antes de actuar

## Pruebas

### Ejecutar Tests

```bash
npm test src/engine/planner.test.ts
```

### Cobertura de Pruebas

- Detecci√≥n de desv√≠os de tema
- Validaci√≥n de comandos de adaptaci√≥n
- Aplicaci√≥n segura de comandos
- Control de presupuesto

## Uso en Producci√≥n

### Activaci√≥n

1. Configurar variables de entorno
2. Activar modo adaptativo en el frontend
3. Monitorear m√©tricas de presupuesto
4. Revisar logs de telemetr√≠a

### Monitoreo

- **M√©tricas clave**: Uso por tier, tasa de escalaci√≥n, costo por sesi√≥n
- **Alertas**: Presupuesto < 20%, escalaciones > 3 por sesi√≥n
- **Logs**: Revisar JSONL para auditor√≠a de decisiones

## Roadmap

### Pr√≥ximas Mejoras

1. **Historial corto**: Implementar contexto de conversaci√≥n reciente
2. **Micro-pasos**: Permitir inserci√≥n temporal de contenido
3. **Pol√≠ticas por curso**: Configuraci√≥n espec√≠fica de adaptaci√≥n
4. **Panel de m√©tricas**: Dashboard para monitoreo en tiempo real

### Optimizaciones

1. **Cache de embeddings**: Reutilizar embeddings calculados
2. **Batch processing**: Procesar m√∫ltiples evaluaciones juntas
3. **Predictive scaling**: Anticipar necesidad de escalaci√≥n
```
=== EOF: docs\ADAPTIVE_ENGINE.md

===  archive\.gitkeep
```


```
=== EOF: archive\.gitkeep

===  app\not-found.tsx
```tsx
export default function NotFound() {
  return (
    <div style={{ padding: 24 }}>
      <h1 style={{ fontWeight: 600, fontSize: 18 }}>P√°gina no encontrada</h1>
      <p style={{ marginTop: 8, color: '#475569' }}>La ruta solicitada no existe.</p>
    </div>
  );
}



```
=== EOF: app\not-found.tsx

===  app\layout.tsx
```tsx
import './globals.css';
export const metadata = { title: 'DocenteIA', description: 'Lecci√≥n guiada por JSON' };

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="es">
      <body className="min-h-screen">{children}</body>
    </html>
  )
}
```
=== EOF: app\layout.tsx

===  app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }
}

@layer base {
  * { @apply border-border; }
  body { @apply bg-background text-foreground; font-feature-settings: "rlig" 1, "calt" 1; }
}


```
=== EOF: app\globals.css

===  .claude\settings.local.json
```json
{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(rm:*)",
      "Bash(npm run dev:*)",
      "Bash(kill:*)"
    ],
    "deny": []
  }
}
```
=== EOF: .claude\settings.local.json

===  src\teacher\resolveProfile.ts
```typescript
import { DEFAULT_TEACHER_PROFILE } from './defaultProfile';

function deepmerge(a: any, b: any): any {
  if (Array.isArray(a) && Array.isArray(b)) return [...a, ...b];
  if (a && typeof a === 'object' && b && typeof b === 'object') {
    const out: any = { ...a };
    for (const k of Object.keys(b)) out[k] = deepmerge(a?.[k], b[k]);
    return out;
  }
  return b === undefined ? a : b;
}

export function resolveTeacherProfile({ reqProfile, planProfile, stateProfile }:{
  reqProfile?: any; planProfile?: any; stateProfile?: any;
}) {
  return deepmerge(DEFAULT_TEACHER_PROFILE, deepmerge(planProfile || {}, deepmerge(stateProfile || {}, reqProfile || {})));
}


```
=== EOF: src\teacher\resolveProfile.ts

===  src\teacher\defaultProfile.ts
```typescript
export const DEFAULT_TEACHER_PROFILE = {
  lang: { stopwords: ["de","la","y","el","en","que","por","para","con","un","una"] },
  feedback: { openers: { hint: ["Gracias por intentarlo.","Vas por buen camino.","Hag√°moslo paso a paso."] } },
  hints: {
    mentionCount: 2,
    wordLimits: [18, 28, 40],
    templates: {
      objective: "Enf√≥cate en: {{keywords}}. {{cueLine}}",
      reask: {
        list: "Menciona en pocas palabras {{base}} (2 elementos).",
        definition: "Define brevemente {{base}}.",
        procedure: "Enumera 2 pasos clave de {{base}}.",
        choice: "Elige la opci√≥n que aplica en {{base}} y di por qu√©."
      },
      open: {
        hint: "Comparte tus ideas (‚â•{{minWords}} palabras). Gu√≠ate por: {{cues}}.",
        reask: "En {{minWords}}‚Äì{{maxWords}} palabras, cu√©ntame tus ideas sobre ‚Äú{{objective}}‚Äù."
      }
    }
  },
  advance: {
    partial: { enabled: true, thresholds: { minMatched: 2, maxMissing: 1, minSem: 0.55 } },
    force:   { enabled: true, afterAttempts: 3 }
  },
  questions: {
    studentAskPhrases: ["te puedo hacer una pregunta","tengo una duda","una consulta","no entiendo","puedes aclarar"],
    resumeAffirmatives: ["s√≠","si","ok","listo","entendido","claro","ya"],
    intentCorpus: [
      "tengo una pregunta","tengo una duda","puedo preguntar","quisiera preguntar",
      "puedes aclarar","me puedes explicar","no entiendo esto","necesito aclaraci√≥n"
    ],
    intentTau: 0.55
  },
  eval: {
    values: { EMPTY: 0, PARTIAL: 1, ACCEPT: 2 },
    suffixHelp: true,
    vagueCenter: {
      corpus: [
        "no se","no s√©","no lo se","no lo s√©","no estoy seguro","no tengo idea",
        "no recuerdo","no me acuerdo","mmm","n/a","no s√© bien","no entend√≠",
        "ninguna idea","no sabr√≠a decir","no sabria decir"
      ],
      tauVagueMin: 0.60,
      delta: 0.05,
      tauObjOpen: 0.28,
      tauObjClosed: 0.44
    }
  }
} as const;

export type TeacherProfile = typeof DEFAULT_TEACHER_PROFILE;


```
=== EOF: src\teacher\defaultProfile.ts

===  src\session\store.ts
```typescript
import type { SessionState } from '@/session/state';
import fs from 'fs/promises';
import path from 'path';

export interface SessionStore {
  get(sessionKey: string): Promise<SessionState | undefined>;
  set(sessionKey: string, state: SessionState): Promise<void>;
  delete(sessionKey: string): Promise<void>;
}

class MemoryStore implements SessionStore {
  private map = new Map<string, SessionState>();
  async get(k: string) { return this.map.get(k); }
  async set(k: string, v: SessionState) { this.map.set(k, v); }
  async delete(k: string) { this.map.delete(k); }
}

type FileShape = { sessions: Record<string, { state: SessionState; lastActivity: number }> };

class JsonFileStore implements SessionStore {
  private filePath: string;
  private data: FileShape = { sessions: {} };
  private writing = Promise.resolve();
  constructor(filePath?: string) {
    this.filePath = filePath || path.join(process.cwd(), '.data', 'sessions.json');
  }
  private async ensureLoaded() {
    if (Object.keys(this.data.sessions).length) return;
    try {
      await fs.mkdir(path.dirname(this.filePath), { recursive: true });
      const raw = await fs.readFile(this.filePath, 'utf-8');
      this.data = JSON.parse(raw) as FileShape;
    } catch {
      this.data = { sessions: {} };
    }
  }
  private async flush() {
    const payload = JSON.stringify(this.data);
    const tmp = this.filePath + '.tmp';
    await fs.writeFile(tmp, payload, 'utf-8');
    await fs.rename(tmp, this.filePath);
  }
  async get(k: string) {
    await this.ensureLoaded();
    return this.data.sessions[k]?.state;
  }
  async set(k: string, v: SessionState) {
    await this.ensureLoaded();
    this.data.sessions[k] = { state: v, lastActivity: Date.now() };
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
  async delete(k: string) {
    await this.ensureLoaded();
    delete this.data.sessions[k];
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
}

let storeInstance: SessionStore | null = null;
export function getSessionStore(): SessionStore {
  if (storeInstance) return storeInstance;
  const useFile = process.env.SESSION_STORE === 'file';
  storeInstance = useFile ? new JsonFileStore() : new MemoryStore();
  return storeInstance;
}


```
=== EOF: src\session\store.ts

===  src\session\state.ts
```typescript
import type { LessonPlan } from '@/plan/types';
import type { RagIndex } from '@/ai/tools/RagTool';

export type SessionState = {
	planUrl: string;
	plan?: LessonPlan;
	momentIdx: number;
	stepIdx: number;
	attemptsByAskCode: Record<string, number>;
	hintsByAskCode?: Record<string, number>;
	lastAnswerByAskCode?: Record<string, string>;
	noSeCountByAskCode?: Record<string, number>;
	lastActionByAskCode?: Record<string, string>;
	teacherProfile?: any;
	justAskedFollowUp?: boolean;
	// Anti-repetici√≥n de narrativa por momento
	narrativesShownByMoment?: Record<number, boolean>;
	lastNarrativeHashByMoment?: Record<number, string>;
	// Blindaje anti-repetici√≥n de historias/contenidos
	shownByStepIndex?: Record<number, boolean>;
	shownByMomentIndex?: Record<number, boolean>;
	askedAskCodes: string[];
	answeredAskCodes: string[];
	partiallyAnsweredAskCodes?: string[];
	pendingRemediation?: Record<string, string[]>;
	done: boolean;
	// Nuevos campos para adaptaci√≥n y presupuesto
	dynamicQueue: Array<{
		op: 'reask' | 'hint' | 'goto' | 'repeat' | 'insert_micro';
		targetAskCode?: string;
		note?: string;
		reason?: 'SEM_LOW' | 'THINKER_ESCALATION' | 'OFF_TOPIC' | 'BUDGET_LIMIT';
	}>;
	budgetCentsLeft: number;
	escalationsUsed: number;
	// Modo de operaci√≥n
	adaptiveMode: boolean;
	// Contexto de consultas para pausar/retomar
	consultCtx?: {
		pausedAt?: { momentIndex: number; stepIndex: number };
		active?: boolean;
		turns?: number;
	};
	// Historial de desv√≠os: consultas fuera del plan para luego retomar
	diversionStack?: Array<{
		fromMomentIndex: number;
		fromStepIndex: number;
		reason: 'GENERAL'|'PERSONAL'|'PLATFORM'|'OTHER';
		query: string;
		answerSummary?: string;
		timestamp: number;
	}>;
	lastFollowUpText?: string;
  // RAG index construido desde la lecci√≥n (gu√≠a)
  ragIndex?: RagIndex;
};

export function initSession(planUrl: string, plan: LessonPlan): SessionState {
	return {
		planUrl,
		plan,
		momentIdx: 0,
		stepIdx: 0,
		attemptsByAskCode: {},
		hintsByAskCode: {},
		lastAnswerByAskCode: {},
		noSeCountByAskCode: {},
		lastActionByAskCode: {},
		justAskedFollowUp: false,
		narrativesShownByMoment: {},
		lastNarrativeHashByMoment: {},
		shownByStepIndex: {},
		shownByMomentIndex: {},
		askedAskCodes: [],
		answeredAskCodes: [],
		done: false,
		// Inicializar nuevos campos
		dynamicQueue: [],
		budgetCentsLeft: 100, // 100 centavos = $1.00 por sesi√≥n
		escalationsUsed: 0,
		adaptiveMode: false, // Por defecto modo determinista
		consultCtx: {}, // Contexto de consultas
		diversionStack: []
	};
}


```
=== EOF: src\session\state.ts

===  src\session\history.ts
```typescript
import fs from 'fs/promises';
import path from 'path';
import { getCollection } from '@/lib/mongo';

function historyPath(sessionKey: string) {
	const dir = path.join(process.cwd(), '.data', 'history');
	const file = path.join(dir, `${sessionKey}.jsonl`);
	return { dir, file };
}

export async function appendHistory(sessionKey: string, record: unknown): Promise<void> {
	const payload = { ts: Date.now(), sessionKey, ...((record as object) || {}) } as any;
	if ((process.env.HISTORY_STORE || '').toLowerCase() === 'mongo') {
		const col = await getCollection('history');
		await col.insertOne(payload as any);
		return;
	}
	const { dir, file } = historyPath(sessionKey);
	try { await fs.mkdir(dir, { recursive: true }); } catch {}
	const line = JSON.stringify(payload) + '\n';
	await fs.appendFile(file, line, 'utf-8');
}

export async function clearHistory(sessionKey: string): Promise<void> {
	if ((process.env.HISTORY_STORE || '').toLowerCase() === 'mongo') {
		const col = await getCollection('history');
		await col.deleteMany({ sessionKey });
		return;
	}
	const { file } = historyPath(sessionKey);
	try { await fs.unlink(file); } catch {}
}

export async function getRecentHistory(sessionKey: string, limit: number = 6): Promise<string[]> {
	if ((process.env.HISTORY_STORE || '').toLowerCase() === 'mongo') {
		const col = await getCollection('history');
		const docs = await col.find({ sessionKey }).sort({ ts: 1 }).project({ message: 1, followUp: 1, content: 1, _id: 0 }).toArray();
		const tail = docs.slice(-limit);
		const out: string[] = [];
		for (const rec of tail) {
			try {
				if (typeof (rec as any)?.content === 'string') { out.push((rec as any).content); continue; }
				const msg = (rec as any).message as string | undefined;
				const fu = (rec as any).followUp as string | undefined;
				const combined = [msg, fu].filter(Boolean).join('\n\n');
				if (combined) out.push(combined);
			} catch {}
		}
		return out;
	}
	const { file } = historyPath(sessionKey);
	try {
		const raw = await fs.readFile(file, 'utf-8');
		const lines = raw.trim().split(/\n+/).filter(Boolean);
		const tail = lines.slice(-limit);
		const out: string[] = [];
		for (const ln of tail) {
			try {
				const rec: any = JSON.parse(ln);
				if (typeof rec?.content === 'string') { out.push(rec.content); continue; }
				if (typeof rec?.message === 'string' || typeof rec?.followUp === 'string') {
					const combined = [rec.message, rec.followUp].filter(Boolean).join('\n\n');
					if (combined) out.push(combined);
					continue;
				}
			} catch {}
		}
		return out;
	} catch {
		return [];
	}
}

export type StoredHistoryItem = {
	ts: number;
	sessionKey: string;
	planUrl?: string;
	stepIdx?: number;
	momentIdx?: number;
	message?: string;
	followUp?: string;
	content?: string;
	sender?: 'ai' | 'student';
	email?: string;
	kind?: string;
	feedbackKind?: string;
	nextAction?: string;
	stepCode?: string;
	matched?: string[];
	missing?: string[];
};

export async function getFullHistory(sessionKey: string): Promise<StoredHistoryItem[]> {
	if ((process.env.HISTORY_STORE || '').toLowerCase() === 'mongo') {
		const col = await getCollection<StoredHistoryItem>('history');
		const docs = await col.find({ sessionKey }).sort({ ts: 1 }).toArray();
		return docs as StoredHistoryItem[];
	}
	const { file } = historyPath(sessionKey);
	try {
		const raw = await fs.readFile(file, 'utf-8');
		const lines = raw.trim().split(/\n+/).filter(Boolean);
		return lines.map((ln) => {
			try { return JSON.parse(ln) as StoredHistoryItem; } catch { return undefined as any; }
		}).filter(Boolean);
	} catch {
		return [];
	}
}

export async function setUserLastSession(email: string, sessionKey: string): Promise<void> {
	if (!email) return;
	if ((process.env.HISTORY_STORE || '').toLowerCase() === 'mongo') {
		const col = await getCollection<{ _id: string; sessionKey: string; updatedAt: number }>('user_last_session');
		await col.updateOne({ _id: email }, { $set: { sessionKey, updatedAt: Date.now() } }, { upsert: true });
	}
}

export async function getUserLastSession(email: string): Promise<string | null> {
	if (!email) return null;
	if ((process.env.HISTORY_STORE || '').toLowerCase() === 'mongo') {
		const col = await getCollection<{ _id: string; sessionKey: string }>('user_last_session');
		const doc = await col.findOne({ _id: email });
		return doc?.sessionKey || null;
	}
	return null;
}


```
=== EOF: src\session\history.ts

===  src\schema\timeline.ts
```typescript
import { z } from 'zod';

export const TimelineStepSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	type: z.string(),
	// ASK
	question: z.string().optional(),
	objective: z.string().optional(),
	expected: z.array(z.string()).optional(),
	acceptable_answers: z.array(z.string()).optional(),
	question_type: z.string().optional(),
	answer_type: z.enum(['open', 'list', 'definition', 'procedure', 'choice']).optional(),
	// Hints/ayudas
	micro_concepts: z.array(z.string()).optional(),
	// CONTENT / CASE / NARRATION / KEY_* / TOPICS / REFLECTION_AREAS
	title: z.string().optional(),
	body: z.array(z.string()).optional(),
	text: z.string().optional(),
	description: z.string().optional(),
	items: z.array(z.string()).optional(),
	variables: z.array(z.string()).optional()
});

export const TimelineMomentSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	title: z.string(),
	steps: z.array(TimelineStepSchema)
});

export const TimelineFileSchema = z.object({
	meta: z.object({
		lesson_id: z.string().optional(),
		lesson_name: z.string().optional(),
		version: z.string().optional(),
		language: z.string().optional(),
		ordered: z.boolean().optional(),
		generated_at: z.string().optional()
	}),
	moments: z.array(TimelineMomentSchema)
});

export type TimelineStep = z.infer<typeof TimelineStepSchema>;
export type TimelineMoment = z.infer<typeof TimelineMomentSchema>;
export type TimelineFile = z.infer<typeof TimelineFileSchema>;

export function assertTimeline(obj: unknown): TimelineFile {
	return TimelineFileSchema.parse(obj);
}


```
=== EOF: src\schema\timeline.ts

===  src\plan\types.ts
```typescript
import type { TimelineFile, TimelineStep } from '@/schema/timeline';

export type StepType = 'NARRATION'|'CONTENT'|'ASK'|'CASE'|'KEY_CONTENT'|'KEY_POINTS'|'KEY_ELEMENTS'|'TOPICS'|'EXPECTED_LEARNING'|'REFLECTION_AREAS';

export type PlanStep = {
	momentIndex: number;
	stepIndex: number;
	code?: string;
	order?: number;
	type: StepType;
	data: TimelineStep;
};

export type LessonPlan = {
	meta: TimelineFile['meta'];
	moments: Array<{ title: string; code?: string; order?: number; steps: PlanStep[] }>;
	allSteps: PlanStep[];
	contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }>;
	askCatalog: Array<{ globalIndex: number; momentIndex: number; stepIndex: number; code?: string; question: string; acceptable: string[] }>;
};



```
=== EOF: src\plan\types.ts

===  src\plan\compilePlan.ts
```typescript
import { assertTimeline, TimelineFile } from '@/schema/timeline';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { LessonPlan, PlanStep, StepType } from './types';

function toStepType(t?: string): StepType {
	const u = String(t || '').toUpperCase();
	return (['NARRATION','CONTENT','ASK','CASE','KEY_CONTENT','KEY_POINTS','KEY_ELEMENTS','TOPICS','EXPECTED_LEARNING','REFLECTION_AREAS'] as StepType[])
		.find(x => x === u) || 'CONTENT';
}

export function compilePlan(tl: TimelineFile): LessonPlan {
	const moments = (tl.moments || []).map((m, mi) => {
		const steps: PlanStep[] = (m.steps || [])
			.sort((a, b) => (a.order || 0) - (b.order || 0))
			.map((s, si) => ({ momentIndex: mi, stepIndex: si, code: s.code, order: s.order, type: toStepType(s.type), data: s }));
		return { title: m.title, code: m.code, order: m.order, steps };
	});
	const allSteps = moments.flatMap(m => m.steps);
	// Construir ciclos CONTENT->ASK por proximidad
	const contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }> = [];
	let current: { contentStepIndex: number; askStepIndices: number[] } | null = null;
	for (let i = 0; i < allSteps.length; i++) {
		const s = allSteps[i];
		if (s.type === 'CONTENT') {
			if (current) contentCycles.push(current);
			current = { contentStepIndex: i, askStepIndices: [] };
		} else if (s.type === 'ASK') {
			if (!current) current = { contentStepIndex: -1, askStepIndices: [] };
			current.askStepIndices.push(i);
		}
	}
	if (current) contentCycles.push(current);
	// Cat√°logo de preguntas
	const askCatalog = allSteps
		.map((s, idx) => ({
			globalIndex: idx,
			momentIndex: s.momentIndex,
			stepIndex: s.stepIndex,
			code: s.code,
			question: s.data.question || '',
			acceptable: s.data.acceptable_answers || []
		}))
		.filter(x => !!x.question);
	return { meta: tl.meta, moments, allSteps, contentCycles, askCatalog };
}

export async function loadAndCompile(url: string): Promise<LessonPlan> {
	let obj: any;
	// Soporte server-side: si es ruta absoluta del sitio (/courses/..), leer desde /public
	if (/^https?:/i.test(url)) {
		const res = await fetch(url);
		obj = await res.json();
	} else if (url.startsWith('/')) {
		const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	} else {
		const filePath = path.isAbsolute(url) ? url : path.join(process.cwd(), url);
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	}
	const tl = assertTimeline(obj);
	return compilePlan(tl);
}


```
=== EOF: src\plan\compilePlan.ts

===  src\lib\mongo.ts
```typescript
import { MongoClient, type Db, type Collection, type Document } from 'mongodb';

let client: MongoClient | null = null;
let clientPromise: Promise<MongoClient> | null = null;

export async function getMongoClient(): Promise<MongoClient> {
  if (client) return client;
  if (!clientPromise) {
    const uri = process.env.MONGO_URI || '';
    if (!uri) throw new Error('MONGO_URI is required');
    clientPromise = new MongoClient(uri, { maxPoolSize: 5 }).connect().then((c) => {
      client = c; return c;
    });
  }
  return clientPromise;
}

export async function getDb(): Promise<Db> {
  const c = await getMongoClient();
  const dbName = process.env.MONGO_DB || 'docenteia';
  return c.db(dbName);
}

export async function getCollection<T extends Document = Document>(name: string): Promise<Collection<T>> {
  const db = await getDb();
  return db.collection<T>(name);
}


```
=== EOF: src\lib\mongo.ts

===  src\lib\authOptions.ts
```typescript
import type { NextAuthOptions } from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import Credentials from 'next-auth/providers/credentials';

export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID || process.env.AUTH_GOOGLE_ID || '',
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || process.env.AUTH_GOOGLE_SECRET || ''
    }),
    Credentials({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'text' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        const email = String(credentials?.email || '').trim();
        const password = String(credentials?.password || '').trim();
        if (!email || !password) return null;
        return { id: 'user-1', name: email.split('@')[0], email } as any;
      }
    })
  ],
  session: { strategy: 'jwt' },
  pages: { signIn: '/login' },
  // Permite NEXTAUTH_SECRET o AUTH_SECRET
  secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET,
  callbacks: {
    async jwt({ token, account }) {
      if (account?.provider === 'google') token.provider = 'google';
      return token;
    },
    async session({ session, token }) {
      (session as any).provider = (token as any).provider;
      return session;
    }
  }
};


```
=== EOF: src\lib\authOptions.ts

===  src\lib\ai.ts
```typescript
import OpenAI from 'openai';

let client: OpenAI | null = null;

export function pickModel(tier: 'cheap'|'thinker'|'embed'='cheap'): string {
  if (tier === 'thinker') return process.env.THINKER_MODEL || 'o3-mini';
  if (tier === 'embed')  return process.env.EMBED_MODEL  || 'text-embedding-3-small';
  return process.env.CHEAP_MODEL || 'gpt-4o-mini';
}

export function getClient() {
  if (client) return client;
  const key = process.env.OPENAI_API_KEY;
  if (!key) {
    throw new Error('OPENAI_API_KEY is required to initialize OpenAI client');
  }
  client = new OpenAI({ apiKey: key });
  return client;
}
```
=== EOF: src\lib\ai.ts

===  src\hooks\usePlanChat.ts
```typescript
import { useEffect, useRef, useState } from 'react';

export type PlanChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

function generateSessionKey(): string {
	return `plan-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
}

export function usePlanChat(planUrl: string = '') {
	const [messages, setMessages] = useState<PlanChatMessage[]>([]);
	const [isTyping, setIsTyping] = useState<boolean>(false);
	const [done, setDone] = useState<boolean>(false);
	const [engineState, setEngineState] = useState<{ stepIdx: number; momentIdx: number; done: boolean; stepCode?: string } | null>(null);
	const [adaptiveMode, setAdaptiveMode] = useState<boolean>(false);
	const [budgetMetrics, setBudgetMetrics] = useState<any>(null);
	const sessionKeyRef = useRef<string>('');
	const idSeq = useRef<number>(1);
  const bootedRef = useRef<boolean>(false);

	useEffect(() => {
		if (!sessionKeyRef.current) {
			// Persistir la sesi√≥n para recargas superficiales
			try {
				const stored = typeof window !== 'undefined' ? window.sessionStorage.getItem('planSessionKey') : '';
				if (stored) sessionKeyRef.current = stored;
				else {
					sessionKeyRef.current = generateSessionKey();
					if (typeof window !== 'undefined') window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
				}
			} catch {
				sessionKeyRef.current = generateSessionKey();
			}
		}
		// Primer turno para obtener el primer paso del plan (evitar doble invocaci√≥n en StrictMode)
		if (!bootedRef.current && planUrl) {
			bootedRef.current = true;
			void turn('');
		}
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [planUrl]);

  async function turn(userInput: string) {
		if (done) return;
		// Mostrar inmediatamente el mensaje del estudiante
		if (userInput && userInput.trim()) {
			setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'student', content: userInput, timestamp: new Date() }]);
		}
		setIsTyping(true);
		try {
			const res = await fetch('/api/engine/turn', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ 
					sessionKey: sessionKeyRef.current, 
					userInput, 
					planUrl, 
					reset: !messages.length,
					adaptiveMode 
				})
			});
			if (!res.ok) throw new Error('engine turn failed');
			const { message, followUp, state, budgetMetrics: newBudgetMetrics, stepCode, momentIdx } = await res.json();
			
			// Crear UNA sola burbuja del asistente (message + followUp)
			if (message || followUp) {
				const norm = (s: string) => s.replace(/\s+/g, ' ').trim().toLowerCase();
				const hasQ = followUp && norm(message || '').includes(norm(followUp));
				const combined = [message, (!hasQ && followUp) ? followUp : '']
					.map(s => (s || '').trim())
					.filter(Boolean)
					.join('\n\n');
				
				// Evitar repetir exactamente el mismo texto que la √∫ltima burbuja del assistant
				setMessages(prev => {
					const last = prev.slice().reverse().find(m => m.sender === 'ai');
					if (last && norm(last.content) === norm(combined)) return prev;
					return [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: combined, timestamp: new Date() }];
				});
			}
			setDone(Boolean(state?.done));
			setEngineState(state ? { ...state, stepCode: (stepCode || (state as any)?.stepCode), momentIdx: (typeof momentIdx === 'number' ? momentIdx : (state as any)?.momentIdx) } : null);
			if (newBudgetMetrics) {
				setBudgetMetrics(newBudgetMetrics);
			}
		} catch (_err) {
			// Emitir mensaje de error simple
			setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: 'Ocurri√≥ un error al avanzar el plan.', timestamp: new Date() }]);
		} finally {
			setIsTyping(false);
		}
	}

	function sendMessage(content: string) {
		if (!content || !content.trim()) return;
		void turn(content);
	}

	function clearMessages() {
		setMessages([]);
	}

	function resetSession() {
		// Limpiar sessionStorage y regenerar sessionKey
		if (typeof window !== 'undefined') {
			window.sessionStorage.removeItem('planSessionKey');
		}
		sessionKeyRef.current = generateSessionKey();
		if (typeof window !== 'undefined') {
			window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
		}
		// Resetear estado
		setMessages([]);
		setDone(false);
		setIsTyping(false);
		setBudgetMetrics(null);
		setEngineState(null);
		bootedRef.current = false;
		// Reiniciar con nuevo plan
		void turn('');
	}

	return { messages, isTyping, done, sendMessage, clearMessages, resetSession, adaptiveMode, setAdaptiveMode, budgetMetrics, state: engineState };
}


```
=== EOF: src\hooks\usePlanChat.ts

===  src\engine\sequencer.ts
```typescript

export function computeForceAdvanceTargets(state: any, nextAskIdx: number): { narrationIdx?: number; askIdx: number } {
  const steps: any[] = state?.plan?.allSteps || [];
  const ask = steps[nextAskIdx];
  if (!ask) return { askIdx: nextAskIdx };
  const targetMoment = ask.momentIndex;
  // Buscar el primer paso "mostrable" en el mismo momento antes del ASK
  let narrationIdx: number | undefined = undefined;
  for (let i = 0; i < steps.length; i++) {
    const s = steps[i];
    if (s?.momentIndex !== targetMoment) continue;
    // Solo considerar pasos anteriores al ASK y de tipo narrativo/contenido
    if (s.stepIndex < ask.stepIndex && (s.type === 'NARRATION' || s.type === 'CONTENT')) {
      narrationIdx = i;
      break;
    }
    // Si ya pasamos el ASK, detener
    if (s.stepIndex >= ask.stepIndex) break;
  }
  return { narrationIdx, askIdx: nextAskIdx };
}



```
=== EOF: src\engine\sequencer.ts

===  src\engine\semvec.ts
```typescript
import { getClient } from '@/lib/ai';
import { getBudgetManager, pickModelWithBudget } from './costs';

export type AskVectorIndex = {
	acceptables: string[];
	expected: string[];
	centroid: number[];
	byItem: { text: string; vec: number[] }[];
};

function cosine(a: number[], b: number[]): number {
	let dot = 0;
	let na = 0;
	let nb = 0;
	const len = Math.min(a.length, b.length);
	for (let i = 0; i < len; i++) { dot += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
	if (!na || !nb) return 0;
	return dot / (Math.sqrt(na) * Math.sqrt(nb));
}

export async function embedTexts(texts: string[]): Promise<number[][]> {
	if (!texts || texts.length === 0) return [];
	const model = pickModelWithBudget('embed');
	const client = getClient();
	const res = await client.embeddings.create({ model: model as any, input: texts });
	
	// Registrar uso de embeddings para costeo
	const budgetManager = getBudgetManager();
	const approxTokens = texts.reduce((total, text) => total + Math.ceil(text.length / 4), 0);
	budgetManager.recordUsage('embed', approxTokens);
	
	return res.data.map(x => (x as any).embedding as number[]);
}

export async function buildAskIndex(acceptables: string[] = [], expected: string[] = []): Promise<AskVectorIndex> {
	const items = Array.from(new Set([...(acceptables || []), ...(expected || [])].map(s => String(s || '').trim()).filter(Boolean)));
	if (items.length === 0) return { acceptables, expected, centroid: [], byItem: [] };
	const vecs = await embedTexts(items);
	const dim = vecs[0]?.length || 0;
	const centroid = dim ? Array.from({ length: dim }, (_, j) => vecs.reduce((acc, v) => acc + (v[j] || 0), 0) / vecs.length) : [];
	return {
		acceptables,
		expected,
		centroid,
		byItem: items.map((t, i) => ({ text: t, vec: vecs[i] || [] }))
	};
}

export async function semanticScore(answer: string, index: AskVectorIndex): Promise<{ cos: number; best?: { text: string; cos: number } }> {
	const text = String(answer || '').trim();
	if (!text || !index || !index.centroid || index.centroid.length === 0) return { cos: 0 };
	const [u] = await embedTexts([text]);
	const cosC = cosine(u || [], index.centroid || []);
	let best = { text: '', cos: 0 };
	for (const it of index.byItem || []) {
		const c = cosine(u || [], it.vec || []);
		if (c > best.cos) best = { text: it.text, cos: c };
	}
	return { cos: cosC, best };
}


```
=== EOF: src\engine\semvec.ts

===  src\engine\runner.ts
```typescript
import type { PlanStep } from '@/plan/types';
import type { SessionState } from '@/session/state';
import { getBudgetManager } from './costs';
import { log } from './logger';
import { applyAdaptCommand, planAdaptation, type PlanningContext } from './planner';

export type SkipAction = { kind: 'skip'; step?: PlanStep };
export type ExplainAction = { kind: 'explain'; step: PlanStep };
export type AskAction = { kind: 'ask'; step: PlanStep };
export type EndAction = { kind: 'end' };
export type EngineAction = SkipAction | ExplainAction | AskAction | EndAction;

export function currentStep(state?: SessionState): PlanStep | undefined {
	const steps = state?.plan?.allSteps || [];
	if (typeof state?.stepIdx !== 'number') return undefined;
	if (state.stepIdx < 0 || state.stepIdx >= steps.length) return undefined;
	return steps[state.stepIdx];
}

export function decideAction(step?: PlanStep, state?: SessionState): EngineAction {
	if (!step) return { kind: 'end' };
	
			// Si el modo adaptativo est√° activado y es un paso ASK, consultar al planificador
		if (state?.adaptiveMode && step.type === 'ASK') {
			const budgetManager = getBudgetManager();
			const metrics = budgetManager.getUsageMetrics();
			
			// Obtener historial corto para el contexto
			const shortHistory: Array<{
				stepIdx: number;
				action: string;
				response?: string;
			}> = []; // TODO: Implementar historial real cuando se necesite
			
			const context: PlanningContext = {
				state: state,
				shortHistory,
				budgetCentsLeft: metrics.budgetCentsLeft,
				escalationsUsed: state.escalationsUsed || 0
			};
			
			const adaptation = planAdaptation(context);
			if (adaptation) {
				// Aplicar la adaptaci√≥n al estado
				const adaptedState = applyAdaptCommand(adaptation, state);
				// Actualizar el estado global con la adaptaci√≥n
				Object.assign(state, adaptedState);
				// Log de adaptaci√≥n aplicada
				log.adaptation('session-' + Date.now(), adaptation);
			}
		}
	
	switch (step.type) {
		case 'ASK':
			return { kind: 'ask', step };
		case 'CONTENT':
		case 'NARRATION':
		case 'CASE':
		case 'REFLECTION_AREAS':
			return { kind: 'explain', step };
		case 'KEY_CONTENT':
		case 'KEY_POINTS':
		case 'KEY_ELEMENTS':
		case 'TOPICS':
		case 'EXPECTED_LEARNING':
		default:
			return { kind: 'skip', step } as SkipAction;
	}
}

export function next(state?: SessionState): SessionState {
	if (!state) {
		throw new Error('Session state not initialized');
	}
	const steps = state.plan?.allSteps || [];
	const nextIdx = (state.stepIdx ?? 0) + 1;
	if (nextIdx >= steps.length) {
		const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
		return { ...state, stepIdx: steps.length, momentIdx: lastMomentIdx, done: true };
	}
	const newStep = steps[nextIdx];
	const newMomentIdx = typeof newStep?.momentIndex === 'number' ? newStep.momentIndex : state.momentIdx;
	return { ...state, stepIdx: nextIdx, momentIdx: newMomentIdx, done: false };
}

export function advanceTo(state: SessionState, targetStepIndex?: number): SessionState {
  if (targetStepIndex === undefined || targetStepIndex === null) {
    const steps = state.plan?.allSteps || [];
    const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
    return { ...state, done: true, stepIdx: steps.length, momentIdx: lastMomentIdx };
  }
  const steps = state.plan?.allSteps || [];
  const boundedIndex = Math.max(0, Math.min(targetStepIndex, Math.max(0, steps.length)));
  const step = steps[boundedIndex];
  const newMomentIdx = typeof step?.momentIndex === 'number' ? step.momentIndex : state.momentIdx;
  return { ...state, stepIdx: boundedIndex, momentIdx: newMomentIdx, done: false };
}

export function getCycleIndexForStep(state: SessionState, stepIdx: number): number | undefined {
  const cycles = state.plan?.contentCycles || [];
  for (let i = 0; i < cycles.length; i++) {
    const c = cycles[i];
    if (c.contentStepIndex === stepIdx) return i;
    if (c.askStepIndices.includes(stepIdx)) return i;
  }
  return undefined;
}

export function getNextAskInSameCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const cycleIdx = getCycleIndexForStep(state, stepIdx);
  if (cycleIdx === undefined) return undefined;
  const cycle = cycles[cycleIdx];
  const askList = cycle.askStepIndices || [];
  const pos = askList.indexOf(stepIdx);
  if (pos === -1) return askList.length ? askList[0] : undefined; // si estamos en CONTENT, volver a la primera ASK
  return askList[pos + 1];
}

export function getFirstAskOfNextCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const currentCycleIdx = getCycleIndexForStep(state, stepIdx);
  const startIdx = currentCycleIdx === undefined ? 0 : currentCycleIdx + 1;
  for (let i = startIdx; i < cycles.length; i++) {
    const askList = cycles[i].askStepIndices || [];
    if (askList.length > 0) return askList[0];
  }
  return undefined;
}

export function decideNextAction(context: {
  lastAction: string;
  noSeCount: number;
  attempts: number;
  momentKind?: string;
}): 'reask' | 'hint' | 'explain' | 'options' | 'force_advance' {
  const { lastAction, noSeCount, attempts, momentKind } = context;
  
  // Solo permitir avance forzado en CONEXI√ìN (no SALUDO)
  const policyAllowsForce = ['CONEXION'].includes(momentKind || '');
  
  // Si no permite forzar y hay muchos intentos, usar transici√≥n pedag√≥gica
  if (!policyAllowsForce && attempts >= 2) {
    if (lastAction === 'hint') return 'explain';
    if (lastAction === 'explain') return 'options';
    if (lastAction === 'options') return 'reask';
    return 'hint';
  }
  
  // Si permite forzar, solo despu√©s de agotar opciones (umbral m√°s alto)
  if (policyAllowsForce && attempts >= 4) {
    return 'force_advance';
  }
  
  // L√≥gica normal de transici√≥n
  if (noSeCount > 0) return 'hint';
  if (lastAction === 'hint') return 'explain';
  if (lastAction === 'explain') return 'options';
  
  return 'reask';
}



```
=== EOF: src\engine\runner.ts

===  src\engine\questions.ts
```typescript
export function isStudentAskingQuestion(input: string, teacherProfile?: any): boolean {
  const normalized = (input || '').toLowerCase().trim();

  // signos de pregunta
  if (/\?\s*$/.test(input || '')) return true;

  // intenci√≥n de "pedir permiso para preguntar"
  const askIntent = Array.isArray(teacherProfile?.questions?.studentAskPhrases)
    ? teacherProfile.questions.studentAskPhrases
    : [
      'te puedo hacer una pregunta', 'puedo hacer una pregunta', 'tengo una pregunta',
      'tengo una duda', 'una consulta', 'puedo consultar', 'quiero preguntar'
    ];
  if (askIntent.some((p: string) => normalized.includes(p))) return true;

  // aclaraciones expl√≠citas
  const clarification = [
    'no entiendo', 'no comprendo', 'puedes aclarar', '¬øpuedes aclarar',
    'puedes explicar', 'qu√© significa', 'c√≥mo es que', 'por qu√©', 'cu√°l es',
    'd√≥nde est√°', 'cu√°ndo', 'qui√©n', 'qu√© es'
  ];
  return clarification.some((p: string) => normalized.includes(p));
}

export function isAffirmativeToResume(input: string, teacherProfile?: any): boolean {
  const n = (input || '').toLowerCase().trim();
  const ok = Array.isArray(teacherProfile?.questions?.resumeAffirmatives)
    ? teacherProfile.questions.resumeAffirmatives
    : ['s√≠','si','ok','listo','entendido','claro','ya'];
  if (ok.includes(n) || /^si[,\.!?\s]?/i.test(input||'')) return true;
  const synonyms = ['continuar','seguir','sigamos','seguimos','retomar','reanudar','proseguir','volver'];
  return synonyms.some(s => n.includes(s));
}

export function isGreetingInput(input: string): boolean {
  const n = (input || '').toLowerCase().trim();
  if (!n) return false;
  const greetings = ['hola','buenas','buen d√≠a','buen dia','buenas tardes','buenas noches','hey','qu√© tal','que tal','saludos'];
  return greetings.some(g => n === g || n.startsWith(g));
}

export function isPersonalInfoQuery(input: string): boolean {
  const n = (input || '').toLowerCase();
  if (!n) return false;
  const patterns = [
    /tu\s+nombre/,
    /c[o√≥]mo\s+te\s+llamas?/,
    /qui[e√©]n\s+eres/,
    /eres\s+humano/,
    /qu[e√©]\s+modelo/,
    /qui[e√©]n\s+te\s+(cre[o√≥]|program[o√≥])/,
  ];
  return patterns.some(rx => rx.test(n));
}

// Ayuda de plataforma: problemas de uso de la app/curso
export function isPlatformHelpQuery(input: string): boolean {
  const n = (input || '').toLowerCase();
  if (!n) return false;
  const pats = [
    /no\s+(me\s+)?funciona/, /no\s+abre/, /no\s+carga/, /se\s+traba/, /error/,
    /video|audio|sonido|micr[o√≥]fono|c[a√°]mara/, /pantalla\s+completa/,
    /plataforma|aplicaci[o√≥]n|app|curso|lecci[o√≥]n/, /login|contrase[n√±]a|acceso/,
    /bot[o√≥]n|siguiente|atr[a√°]s|continuar/
  ];
  return pats.some(rx => rx.test(n));
}

// Preguntas tipo conocimiento general (estilo enciclop√©dico)
export function isGeneralKnowledgeStyleQuestion(input: string): boolean {
  const n = (input || '').toLowerCase().trim();
  if (!n) return false;
  const pats = [
    /qu[e√©]\s+es\s+/, /qui[e√©]n\s+es\s+/, /c[o√≥]mo\s+funciona\s+/, /d[o√≥]nde\s+/, /cu[a√°]ndo\s+/, /por\s+qu[e√©]\s+/, /definici[o√≥]n\s+de\s+/
  ];
  return pats.some(rx => rx.test(n)) || /\?\s*$/.test(n);
}

// Detecci√≥n por embeddings (centro de intenci√≥n de pregunta). Mantiene la versi√≥n s√≠ncrona como atajo.
import { buildAskIndex, semanticScore } from '@/engine/semvec';

export async function isStudentAskingQuestionSem(input: string, teacherProfile?: any): Promise<boolean> {
  const text = String(input || '').trim();
  if (!text) return false;
  // Si trae signo de pregunta, ya es una pregunta
  if (/\?\s*$/.test(text)) return true;
  const corpus: string[] = Array.isArray(teacherProfile?.questions?.intentCorpus) && teacherProfile.questions.intentCorpus.length
    ? teacherProfile.questions.intentCorpus
    : [
        'tengo una pregunta','tengo una duda','puedo preguntar','quisiera preguntar',
        'puedes aclarar','me puedes explicar','no entiendo esto','necesito aclaraci√≥n'
      ];
  const tau: number = typeof teacherProfile?.questions?.intentTau === 'number' ? teacherProfile.questions.intentTau : 0.55;
  try {
    const idx = await buildAskIndex(corpus, []);
    const { cos } = await semanticScore(text, idx);
    return cos >= tau;
  } catch {
    return false;
  }
}
```
=== EOF: src\engine\questions.ts

===  src\engine\planner.ts
```typescript
import type { SessionState } from '@/session/state';
import { z } from 'zod';
import { getCycleIndexForStep, getNextAskInSameCycle } from './runner';

// Esquema Zod para comandos de adaptaci√≥n acotados
export const AdaptCommandSchema = z.object({
  op: z.enum(['reask', 'hint', 'goto', 'repeat', 'insert_micro']),
  targetAskCode: z.string().optional(),
  note: z.string().optional(),
  reason: z.enum(['SEM_LOW', 'THINKER_ESCALATION', 'OFF_TOPIC', 'BUDGET_LIMIT']).optional()
});

export type AdaptCommand = z.infer<typeof AdaptCommandSchema>;

// Tipos para el contexto de planificaci√≥n
export type PlanningContext = {
  state: SessionState;
  currentCycleIndex?: number;
  shortHistory: Array<{
    stepIdx: number;
    action: string;
    response?: string;
  }>;
  budgetCentsLeft: number;
  escalationsUsed: number;
};

// Evaluaci√≥n de desv√≠o de tema
export type TopicDeviation = 'ON_TOPIC' | 'VAGUE' | 'OFF_TOPIC';

export function detectTopicDeviation(
  studentResponse: string,
  currentStep: any,
  objective: string
): TopicDeviation {
  const response = studentResponse.toLowerCase().trim();
  const objectiveWords = objective.toLowerCase().split(/\s+/).filter(w => w.length > 3);
  
  // Palabras clave del objetivo presentes
  const objectiveMatches = objectiveWords.filter(word => response.includes(word));
  const matchRatio = objectiveMatches.length / Math.max(1, objectiveWords.length);
  
  if (matchRatio >= 0.3) return 'ON_TOPIC';
  if (matchRatio >= 0.1) return 'VAGUE';
  return 'OFF_TOPIC';
}

// Planificador principal acotado
export function planAdaptation(context: PlanningContext): AdaptCommand | null {
  const { state, budgetCentsLeft, escalationsUsed } = context;
  const currentStep = state.plan?.allSteps?.[state.stepIdx];
  
  if (!currentStep || currentStep.type !== 'ASK') {
    return null; // Solo adaptamos en pasos ASK
  }

  // Verificar presupuesto antes de escalar
  const canEscalate = budgetCentsLeft > 10 && escalationsUsed < 5;
  
  // Si no hay presupuesto, forzar HINT determinista
  if (!canEscalate) {
    return {
      op: 'hint',
      reason: 'BUDGET_LIMIT',
      note: 'Presupuesto agotado, usando hint determinista'
    };
  }

  // Detectar desv√≠o de tema
  const deviation = detectTopicDeviation(
    context.shortHistory[context.shortHistory.length - 1]?.response || '',
    currentStep,
    currentStep.data?.objective ?? ''
  );

  if (deviation === 'OFF_TOPIC') {
    // Proponer bridge corto y volver al ciclo actual
    const nextAskInCycle = getNextAskInSameCycle(state, state.stepIdx);
    if (nextAskInCycle !== undefined) {
      return {
        op: 'goto',
        targetAskCode: state.plan?.allSteps?.[nextAskInCycle]?.code,
        reason: 'OFF_TOPIC',
        note: 'Desv√≠o detectado, redirigiendo a siguiente pregunta del ciclo'
      };
    }
  }

  if (deviation === 'VAGUE') {
    return {
      op: 'reask',
      reason: 'SEM_LOW',
      note: 'Respuesta vaga, solicitando reformulaci√≥n'
    };
  }

  // Si est√° on-topic pero necesita escalaci√≥n, el evaluador decidir√°
  return null;
}

// Validar comando antes de ejecutar
export function validateAdaptCommand(command: AdaptCommand, state: SessionState): boolean {
  try {
    AdaptCommandSchema.parse(command);
    
    // Validaciones adicionales de contexto
    if (command.op === 'goto' && command.targetAskCode) {
      const targetStep = state.plan?.allSteps?.find(s => s.code === command.targetAskCode);
      if (!targetStep) return false;
    }
    
    return true;
  } catch {
    return false;
  }
}

// Aplicar comando al estado (sin modificar el plan)
export function applyAdaptCommand(command: AdaptCommand, state: SessionState): SessionState {
  if (!validateAdaptCommand(command, state)) {
    return state; // No aplicar si no es v√°lido
  }

  switch (command.op) {
    case 'repeat':
      // Repetir el paso actual sin avanzar
      return { ...state };
      
    case 'goto':
      if (command.targetAskCode) {
        const targetIdx = state.plan?.allSteps?.findIndex(s => s.code === command.targetAskCode);
        if (targetIdx !== undefined && targetIdx >= 0) {
          return { ...state, stepIdx: targetIdx };
        }
      }
      return state;
      
    case 'reask':
    case 'hint':
      // No avanzar, mantener en el paso actual
      return { ...state };
      
    case 'insert_micro':
      // Solo permitir micro-pasos dentro del ciclo actual
      const currentCycle = getCycleIndexForStep(state, state.stepIdx);
      if (currentCycle !== undefined) {
        // Aqu√≠ se podr√≠a insertar un paso temporal, pero por ahora solo mantenemos posici√≥n
        return { ...state };
      }
      return state;
      
    default:
      return state;
  }
}
```
=== EOF: src\engine\planner.ts

===  src\engine\logger.ts
```typescript
import type { SessionState } from '@/session/state';
import type { EscalationResponse } from './eval-escalation';
import type { AdaptCommand } from './planner';
import { getCollection } from '@/lib/mongo';

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export type LogEvent = {
  timestamp: string;
  level: LogLevel;
  event: string;
  sessionId?: string;
  data: Record<string, any>;
};

class EngineLogger {
  private logs: LogEvent[] = [];
  private debugMode: boolean;
  private logToMongo: boolean;
  private collectionName: string;

  constructor() {
    this.debugMode = process.env.ENGINE_DEBUG === 'true' || 
                    process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true';
    this.logToMongo = (process.env.LOG_STORE || '').toLowerCase() === 'mongo';
    this.collectionName = process.env.LOG_COLLECTION || 'engine_logs';
  }

  private log(level: LogLevel, event: string, data: Record<string, any> = {}, sessionId?: string) {
    const logEvent: LogEvent = {
      timestamp: new Date().toISOString(),
      level,
      event,
      sessionId,
      data
    };

    this.logs.push(logEvent);

    // Log a consola si est√° en modo debug
    if (this.debugMode) {
      console.log(`[${level.toUpperCase()}] ${event}:`, data);
    }

    // Persistir en Mongo si est√° habilitado
    if (this.logToMongo) {
      (async () => {
        try {
          const col = await getCollection(this.collectionName);
          const ts = Date.parse(logEvent.timestamp) || Date.now();
          const doc: any = {
            ts,
            level: logEvent.level,
            event: logEvent.event,
            sessionKey: logEvent.sessionId,
            // Campos destacados para consultas r√°pidas
            stepIdx: typeof logEvent.data?.stepIdx === 'number' ? logEvent.data.stepIdx : undefined,
            momentIdx: typeof logEvent.data?.momentIdx === 'number' ? logEvent.data.momentIdx : undefined,
            stepCode: logEvent.data?.stepCode,
            classification: logEvent.data?.classification || logEvent.data?.result,
            feedbackKind: logEvent.data?.feedbackKind,
            nextAction: logEvent.data?.nextAction,
            messageChars: logEvent.data?.messageChars,
            followUpChars: logEvent.data?.followUpChars,
            inputLen: logEvent.data?.userInputLen,
            budget: logEvent.data?.budgetMetrics,
            data: logEvent.data || {}
          };
          await col.insertOne(doc);
        } catch {}
      })();
    }
  }

  // API gen√©rica para emitir eventos arbitrarios
  emit(event: string, data: Record<string, any> = {}, level: LogLevel = 'info', sessionId?: string) {
    this.log(level, event, data, sessionId);
  }

  // Eventos del motor
  engineTurnStart(sessionId: string, stepIdx: number, stepType: string) {
    this.log('info', 'engine.turn.start', { stepIdx, stepType }, sessionId);
  }

  engineTurnEnd(sessionId: string, stepIdx: number, action: string) {
    this.log('info', 'engine.turn.end', { stepIdx, action }, sessionId);
  }

  // Eventos de evaluaci√≥n
  evaluationStart(sessionId: string, askCode: string, studentResponse: string) {
    this.log('info', 'evaluation.start', { askCode, responseLength: studentResponse.length }, sessionId);
  }

  evaluationResult(sessionId: string, askCode: string, result: 'ACCEPT' | 'HINT' | 'REASK', reason?: string) {
    this.log('info', 'evaluation.result', { askCode, result, reason }, sessionId);
  }

  escalationTriggered(sessionId: string, askCode: string, reason: string) {
    this.log('info', 'escalation.triggered', { askCode, reason }, sessionId);
  }

  escalationResult(sessionId: string, askCode: string, result: EscalationResponse) {
    this.log('info', 'escalation.result', { askCode, decision: result.decision, reason: result.reason }, sessionId);
  }

  // Eventos de planificaci√≥n adaptativa
  adaptationPlanned(sessionId: string, command: AdaptCommand) {
    this.log('info', 'adaptation.planned', { 
      op: command.op, 
      targetAskCode: command.targetAskCode,
      reason: command.reason 
    }, sessionId);
  }

  adaptationApplied(sessionId: string, command: AdaptCommand, success: boolean) {
    this.log('info', 'adaptation.applied', { 
      op: command.op, 
      success,
      reason: command.reason 
    }, sessionId);
  }

  // Eventos de presupuesto
  budgetCheck(sessionId: string, tier: string, allowed: boolean, budgetLeft: number) {
    this.log('info', 'budget.check', { tier, allowed, budgetLeft }, sessionId);
  }

  budgetUsage(sessionId: string, tier: string, cost: number, tokens: number) {
    this.log('info', 'budget.usage', { tier, cost, tokens }, sessionId);
  }

  budgetLimit(sessionId: string, tier: string) {
    this.log('warn', 'budget.limit', { tier }, sessionId);
  }

  // Eventos de avance
  advancementAccept(sessionId: string, stepIdx: number, askCode: string) {
    this.log('info', 'advancement.accept', { stepIdx, askCode }, sessionId);
  }

  advancementReject(sessionId: string, stepIdx: number, askCode: string, reason: string) {
    this.log('info', 'advancement.reject', { stepIdx, askCode, reason }, sessionId);
  }

  // Eventos de error
  error(sessionId: string, error: string, context?: Record<string, any>) {
    this.log('error', 'engine.error', { error, context }, sessionId);
  }

  // M√©tricas de sesi√≥n
  sessionMetrics(sessionId: string, state: SessionState, budgetMetrics: any) {
    this.log('info', 'session.metrics', {
      stepIdx: state.stepIdx,
      momentIdx: state.momentIdx,
      attemptsByAskCode: state.attemptsByAskCode,
      escalationsUsed: state.escalationsUsed,
      budgetCentsLeft: state.budgetCentsLeft,
      adaptiveMode: state.adaptiveMode,
      budgetMetrics
    }, sessionId);
  }

  // Obtener logs para auditor√≠a
  getLogs(): LogEvent[] {
    return [...this.logs];
  }

  // Exportar logs en formato JSONL
  exportJSONL(): string {
    return this.logs.map(log => JSON.stringify(log)).join('\n');
  }

  // Limpiar logs (√∫til para sesiones largas)
  clear() {
    this.logs = [];
  }
}

// Instancia global del logger
export const engineLogger = new EngineLogger();

// Funciones de conveniencia para uso directo
export const log = {
  turnStart: (sessionId: string, stepIdx: number, stepType: string) => 
    engineLogger.engineTurnStart(sessionId, stepIdx, stepType),
  
  turnEnd: (sessionId: string, stepIdx: number, action: string) => 
    engineLogger.engineTurnEnd(sessionId, stepIdx, action),
  
  evalStart: (sessionId: string, askCode: string, response: string) => 
    engineLogger.evaluationStart(sessionId, askCode, response),
  
  evalResult: (sessionId: string, askCode: string, result: 'ACCEPT' | 'HINT' | 'REASK', reason?: string) => 
    engineLogger.evaluationResult(sessionId, askCode, result, reason),
  
  escalation: (sessionId: string, askCode: string, result: EscalationResponse) => 
    engineLogger.escalationResult(sessionId, askCode, result),
  
  adaptation: (sessionId: string, command: AdaptCommand) => 
    engineLogger.adaptationPlanned(sessionId, command),
  
  budget: (sessionId: string, tier: string, cost: number, tokens: number) => 
    engineLogger.budgetUsage(sessionId, tier, cost, tokens),
  
  error: (sessionId: string, error: string, context?: Record<string, any>) => 
    engineLogger.error(sessionId, error, context),
  
  metrics: (sessionId: string, state: SessionState, budgetMetrics: any) => 
    engineLogger.sessionMetrics(sessionId, state, budgetMetrics)
};
```
=== EOF: src\engine\logger.ts

===  src\engine\hints.ts
```typescript
type HintPolicies = {
  mentionCount?: number;
  wordLimits?: number[]; // [S1, S2, S3]
  variants?: string[];
  templates?: {
    objective?: string;
    reask?: Record<'list'|'definition'|'procedure'|'choice', string>;
    open?: { hint: string; reask: string };
  };
};

type LangPolicies = { stopwords?: string[] };

export function makeTokenizer(stop: string[] = []) {
  const STOP = new Set(stop);
  return (s: string) =>
    (s || '')
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/["'()\[\]{}]/g, '')
      .split(/[^a-z√°√©√≠√≥√∫√±0-9]+/)
      .filter(Boolean)
      .filter(w => w.length > 2 && !STOP.has(w));
}

export function extractKeywords(from: string[], stop: string[] = []): string[] {
  const tok = makeTokenizer(stop);
  const uniq: string[] = [];
  for (const item of from) for (const w of tok(item)) if (!uniq.includes(w)) uniq.push(w);
  return uniq.slice(0, 40);
}

export function buildStudentFacingBase(questionText: string, objective: string, expected: string[]): string {
  return (questionText && questionText.toLowerCase().includes('sobre '))
    ? `lo que esperas aprender sobre ${questionText.split('sobre ')[1].replace(/[?¬ø.]/g,'').trim()}`
    : (expected?.[0] || objective || 'el tema actual');
}

// Nivel de severidad seg√∫n intentos/pistas
function severity(attempts: number, hintsUsed: number): 0|1|2 {
  if (attempts <= 1 && hintsUsed === 0) return 0; // S1
  if (hintsUsed <= 1) return 1;                    // S2
  return 2;                                        // S3
}

export function makeHintMessage(opts: {
  questionText: string;
  objective: string;
  expected: string[];
  missing: string[];
  answerType?: 'open'|'list'|'definition'|'procedure'|'choice';
  hintsUsed: number;
  attempts: number;
  coursePolicies?: { hints?: HintPolicies; language?: LangPolicies; feedback?: any };
  teacherProfile?: any;
}) {
  const { questionText, objective, expected, missing, answerType = 'list', hintsUsed, attempts } = opts as any;
  const policy = (opts as any).teacherProfile || (opts as any).coursePolicies || {};
  const hp = policy?.hints || {};
  const lp = policy?.language || policy?.lang || {};
  const wordLimits = hp.wordLimits || [16, 22, 28];
  const mentionCount = hp.mentionCount ?? 2;
  const sev = severity(attempts, hintsUsed);
  const maxMsgChars = wordLimits[Math.min(sev, wordLimits.length-1)] * 5;

  const stop = lp.stopwords || [];
  const kws = extractKeywords([objective, ...(expected||[])], stop).slice(0, 6);

  // cues: prioriza missing; si no hay, usa expected
  const cuesArr = (missing?.length ? missing : expected || []).slice(0, mentionCount);
  const cueLine = cuesArr.length ? `Menciona ${cuesArr.join(', ')}.` : '';

  const variants = hp.variants || [];
  const opener = variants.length ? variants[hintsUsed % variants.length] : '';
  const openerClean = opener ? (/[.!?]$/.test(opener.trim()) ? opener.trim() : `${opener.trim()}.`) : '';

  const replaceTokens = (tmpl: string, tokens: Record<string, string>): string => {
    let out = String(tmpl || '');
    for (const [k, v] of Object.entries(tokens)) {
      const re2 = new RegExp(`\\{\\{\s*${k}\s*\\}\\}`, 'g');
      const re1 = new RegExp(`\\{\s*${k}\s*\\}`, 'g');
      out = out.replace(re2, v).replace(re1, v);
    }
    return out;
  };

  if (answerType === 'open') {
    const fallbackAspects: string[] = (hp.templates as any)?.open?.fallbackAspects || [];
    const aspects = cuesArr.length ? cuesArr : fallbackAspects;
    const cuesLine = aspects.length ? `Por ejemplo, considera ${aspects.join(', ')}.` : '';
    const msg = [`Comparte tus ideas en al menos ${wordLimits[0]} palabras.`, cuesLine]
      .map(s => s.trim())
      .filter(Boolean)
      .join(' ')
      .replace(/gu[i√≠]ate\s+por\s*:\s*/i, '');
    return msg.trim();
  }

  // Construcci√≥n m√°s natural: oraciones separadas y sin duplicados
  const focus = kws.length ? `Enf√≥cate en ${kws.join(', ')}.` : '';
  const parts = [openerClean, focus, cueLine].map(s => (s || '').trim()).filter(Boolean);
  const msg = parts.join(' ');
  return msg.slice(0, maxMsgChars);
}

export function makeReaskMessage(opts: {
  questionText: string;
  objective: string;
  expected: string[];
  answerType?: 'open'|'list'|'definition'|'procedure'|'choice';
  coursePolicies?: { hints?: HintPolicies };
  teacherProfile?: any;
}) {
  const { questionText, objective, expected, answerType = 'list' } = opts as any;
  const policy = (opts as any).teacherProfile || (opts as any).coursePolicies || {};
  const hp = policy?.hints || {};
  const baseStr = buildStudentFacingBase(questionText, objective, expected);
  if (answerType === 'open') {
    const tmpl = hp.templates?.open?.reask || 'En {minWords}-{maxWords} palabras, cu√©ntame {aspects} sobre "{objective}".';
    const minw = (hp.wordLimits || [16])[0];
    const base = buildStudentFacingBase(questionText, objective, expected);
    const aspectsLabel = (hp.templates as any)?.open?.aspectsLabel || 'tus ideas principales';
    const replaceTokens = (s: string, tokens: Record<string, string>) => {
      let out = s;
      for (const [k, v] of Object.entries(tokens)) {
        const re2 = new RegExp(`\\{\\{\s*${k}\s*\\}\\}`, 'g');
        const re1 = new RegExp(`\\{\s*${k}\s*\\}`, 'g');
        out = out.replace(re2, v).replace(re1, v);
      }
      return out;
    };
    return replaceTokens(tmpl, {
      minWords: String(minw),
      maxWords: String(minw + 8),
      aspects: aspectsLabel,
      objective: base
    });
  }
  const reaskTmpls = (hp.templates?.reask || {}) as Record<'list'|'definition'|'procedure'|'choice', string>;
  const maxWords = (hp.wordLimits || [16])[0];
  const map: Record<string, string> = {
    list: reaskTmpls.list || '',
    definition: reaskTmpls.definition || '',
    procedure: reaskTmpls.procedure || '',
    choice: reaskTmpls.choice || ''
  };
  const fallback = `Menciona en ${maxWords} palabras 2 elementos de ${baseStr}.`;
  const replaceTokens = (s: string, tokens: Record<string, string>) => {
    let out = s;
    for (const [k, v] of Object.entries(tokens)) {
      const re2 = new RegExp(`\\{\\{\s*${k}\s*\\}\\}`, 'g');
      const re1 = new RegExp(`\\{\s*${k}\s*\\}`, 'g');
      out = out.replace(re2, v).replace(re1, v);
    }
    return out;
  };
  const raw = map[answerType] || '';
  const rendered = replaceTokens(raw, { maxWords: String(maxWords), base: baseStr });
  return rendered || fallback;
}

// Funciones legacy para compatibilidad - eliminar despu√©s de migraci√≥n
// (legacy wrappers eliminados tras migraci√≥n)








```
=== EOF: src\engine\hints.ts

===  src\engine\feedbackSequencer.ts
```typescript
export type FeedbackKind = 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS' | string;

export function computeFeedbackLabel(kind: FeedbackKind, attempt: number): 'F0'|'F1'|'F2' {
  const a = Math.max(0, Number(attempt || 0));
  if (String(kind).toUpperCase() === 'HINT') {
    return a <= 1 ? 'F0' : 'F1';
  }
  return 'F2';
}

export function buildTraceEntry(args: {
  question: string;
  response: string;
  feedback: string;
  kind: FeedbackKind;
  attempt: number;
  hintsUsed?: number;
  stepCode?: string;
}) {
  const { question, response, feedback, kind, attempt, hintsUsed = 0, stepCode = '' } = args;
  const label = computeFeedbackLabel(kind, attempt);
  return {
    label, // F0/F1/F2
    kind,
    p: String(question || ''),
    r: String(response || ''),
    f: String(feedback || ''),
    attempt: Number(attempt || 0),
    hintsUsed: Number(hintsUsed || 0),
    stepCode: String(stepCode || '')
  };
}


```
=== EOF: src\engine\feedbackSequencer.ts

===  src\engine\feedback.ts
```typescript
export type FeedbackClass = {
  kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS';
  matched?: string[];
  missing?: string[];
};

export function buildDeterministicFeedback(
  cls: FeedbackClass,
  opts: {
    attempts: number;            // intentos de respuesta del alumno
    hintsUsed: number;           // pistas ya usadas en ESTA pregunta
    coursePolicies?: any;        // policies.json ya cargadas
  }
): string {
  const has = (arr?: string[]) => Array.isArray(arr) && arr.length > 0;

  // 1) Mensajes cortos por estado (evita muletillas)
  if (cls.kind === 'ACCEPT' && has(cls.matched)) {
    return `Bien: mencionaste ${cls.matched!.join(', ')}.`;
  }
  if (cls.kind === 'PARTIAL') {
    const a = has(cls.matched) ? `acertaste ${cls.matched!.join(', ')}` : 'ya est√°s cerca';
    const missTop = has(cls.missing) ? `Te falta incluir ${cls.missing!.slice(0,2).join(', ')}.` : '';
    return `Vas bien: ${a}. ${missTop}`.trim();
  }

  // 2) Abridores configurables (rotar por n√∫mero de pistas, no por attempts)
  const openers: string[] = (opts.coursePolicies?.feedback?.openers?.hint || []) as string[];
  const idx = (opts.hintsUsed % Math.max(1, openers.length || 1)); // <‚Äî ROTA DE VERDAD
  const opener = openers[idx] || 'Intenta precisar un poco m√°s.';

  // 3) Reducir "Menciona‚Ä¶" a DOS elementos para no sonar rob√≥tico
  if (has(cls.missing)) {
    const top = cls.missing!.slice(0, 2);
    return `${opener} Menciona: ${top.join(', ')}.`;
  }
  return `${opener} Da un ejemplo o una idea concreta.`;
}
```
=== EOF: src\engine\feedback.ts

===  src\engine\eval.ts
```typescript
import { engineLogger } from './logger';

export function normalize(input: string): string {
	return (input || '')
		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		// Colapsa repeticiones largas de caracteres: accidenteee -> accidentee
		.replace(/([a-z√±])\1{2,}/g, '$1$1')
		.replace(/[^\w\s]/g, ' ')
		.replace(/\s+/g, ' ')
		.trim();
}

export function matchesAcceptable(user: string, acceptable: string[]): boolean {
	const u = normalize(user);
	return acceptable.some(a => {
		const n = normalize(a);
		return n.length > 0 && (u === n || u.includes(n) || n.includes(u));
	});
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
}

function tokenSet(s: string): Set<string> {
  return new Set(normalize(s).split(' ').filter(Boolean));
}

function jaccard(a: string, b: string): number {
  const A = tokenSet(a), B = tokenSet(b);
  const interArr: string[] = [];
  A.forEach(v => { if (B.has(v)) interArr.push(v); });
  const inter = interArr.length;
  const unionSet = new Set<string>();
  A.forEach(v => unionSet.add(v));
  B.forEach(v => unionSet.add(v));
  const union = unionSet.size || 1;
  return inter / union;
}

export function computeMatchedMissing(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const u = normalize(user);
	const essentials = acceptable;
	const matched: string[] = [];
	const uTokens = u.split(' ').filter(Boolean);
	for (const a of essentials) {
		const n = normalize(a);
		if (!n) continue;
		// Coincidencia estricta por frase completa
		if (u === n || u.includes(n) || n.includes(u)) { matched.push(a); continue; }
		if (fuzzy) {
			const dist = levenshtein(u, n);
			const sim = jaccard(u, n);
			if ((fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin)) { matched.push(a); continue; }
			// Fuzzy a nivel de tokens: si alg√∫n token del usuario se parece a un token del aceptable
			const nTokens = n.split(/\s+/).filter(t => t.length >= 4);
			const uStrong = uTokens.filter(t => t.length >= 4);
			const tokenHit = uStrong.some(ut => nTokens.some(nt => {
				if (!ut || !nt) return false;
				if (ut === nt || ut.includes(nt) || nt.includes(ut)) return true;
				const d = levenshtein(ut, nt);
				return typeof fuzzy.maxEditDistance === 'number' ? d <= fuzzy.maxEditDistance : d <= 1;
			}));
			if (tokenHit) { matched.push(a); continue; }
			// Soft token match conservador por inclusi√≥n directa
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) { matched.push(a); }
			continue;
		}
		// Sin fuzzy: aplicar soft token match m√≠nimo
		const tokens = n.split(/\s+/).filter(t => t.length >= 4);
		if (tokens.some(t => u.includes(t))) { matched.push(a); continue; }
	}
	if (matched.length === 0 && expected?.length) {
		const extras = expected.filter(e => {
			const n = normalize(e);
			if (!n) return false;
			if (u.includes(n)) return true;
			if (fuzzy) {
				const dist = levenshtein(u, n);
				const sim = jaccard(u, n);
				return (fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin);
			}
			// Soft token para expected
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) return true;
			return false;
		}).slice(0, 2);
		matched.push(...extras);
	}
	const missing = essentials.filter(a => !matched.includes(a)).slice(0, 3);
	return { matched, missing };
}

export function evaluateAnswer(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const { matched, missing } = computeMatchedMissing(user, acceptable, expected, fuzzy);
	return { ok: matched.length > 0, matched, missing };
}

export type AskPolicy = {
	type: 'conceptual'|'listado'|'aplicacion'|'identificacion'|'experiencial'|'metacognitiva'|'reflexiva'|string;
	thresholdK?: number; // para listado
	requiresJustification?: boolean; // para aplicacion
};

export function classifyTurn(
	user: string,
	policy: AskPolicy,
	acceptable: string[] = [],
	expected: string[] = [],
	fuzzy?: { maxEditDistance?: number; similarityMin?: number }
): { kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; matched: string[]; missing: string[]; reason: string } {
	const u = normalize(user);
	if (!u) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	// Gate duro: si el alumno dice "no s√©" o equivalente, no intentamos ACCEPT/PARTIAL
	if (isNoSe(user)) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	const { matched, missing } = computeMatchedMissing(u, acceptable, expected, fuzzy);
	const hasAny = matched.length > 0;
	// Aceptaci√≥n estricta solo por se√±ales "acceptable" (no por extras de expected)
	const hasAcceptable = matchesAcceptable(user, acceptable);
	if (policy.type === 'listado') {
		const k = Math.max(1, policy.thresholdK || 2);
		if (matched.length >= k) return { kind: 'ACCEPT', matched, missing, reason: 'K_OF_N' };
		if (matched.length > 0 || expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'PARTIAL_LISTADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	if (policy.type === 'aplicacion') {
		if (hasAny && (!policy.requiresJustification || /porque|para|ya que/i.test(user))) return { kind: 'ACCEPT', matched, missing, reason: 'APLICACION_OK' };
		if (hasAny) return { kind: 'PARTIAL', matched, missing, reason: 'FALTA_JUSTIFICACION' };
		if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	// conceptual, identificacion, etc.
	if (hasAcceptable) return { kind: 'ACCEPT', matched, missing, reason: 'MATCH_ACCEPTABLE' };
	if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
	return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
}

export function isVagueAnswer(
	user: string,
	question?: string,
	opts?: { stopwords?: string[]; minUsefulTokens?: number; maxStopwordRatio?: number; echoOverlap?: number; repeatSimilarity?: number; lastAnswer?: string }
): boolean {
	const u = normalize(user);
	if (!u) return true;
	const tokens = u.split(' ').filter(Boolean);
	const stop = new Set((opts?.stopwords || []).map(s => normalize(s)));
	const useful = tokens.filter(t => !stop.has(t));
	const stopRatio = tokens.length ? (tokens.length - useful.length) / tokens.length : 1;
	if (useful.length < (opts?.minUsefulTokens ?? 3)) return true;
	if (stopRatio > (opts?.maxStopwordRatio ?? 0.6)) return true;
	const q = question ? normalize(question) : '';
	if (q) {
		const overlap = jaccard(u, q);
		if (overlap >= (opts?.echoOverlap ?? 0.7)) return true;
	}
	const last = normalize(opts?.lastAnswer || '');
	if (last) {
		const sim = jaccard(u, last);
		if (sim >= (opts?.repeatSimilarity ?? 0.8)) return true;
	}
	return false;
}

export function isNoSe(answer?: string): boolean {
	const a = (answer || '').trim().toLowerCase();
	if (!a) return true;
	const patterns = [
		/^no\s*se$/, /^no\s*lo\s*se$/, /^no\s*s√©$/, /^no\s*lo\s*s√©$/,
		/^ns$/, /^n\/a$/, /^no\s*sab[o√≥]$/, /^no\s*est[o√≥]\s*seguro$/,
		/^no$/, /^mmm$/, /^mm$/,
		/^[\.\!\?‚Ä¶]+$/
	];
	if (patterns.some(rx => rx.test(a))) return true;
	const words = a.split(/\s+/).filter(Boolean);
	return false; // deja solo patrones expl√≠citos (no, no s√©, n/a, mmm‚Ä¶)
}

export function detectTopicDeviation(
	studentResponse: string,
	currentStep: any,
	objective: string
): 'ON_TOPIC' | 'VAGUE' | 'OFF_TOPIC' {
	const response = studentResponse.toLowerCase().trim();
	const objectiveWords = objective.toLowerCase().split(/\s+/).filter(w => w.length > 3);
	
	// Palabras clave del objetivo presentes
	const objectiveMatches = objectiveWords.filter(word => response.includes(word));
	const matchRatio = objectiveMatches.length / Math.max(1, objectiveWords.length);
	
	if (matchRatio >= 0.3) return 'ON_TOPIC';
	if (matchRatio >= 0.1) return 'VAGUE';
	return 'OFF_TOPIC';
}



// Evaluaci√≥n h√≠brida (vaguedad ‚Üí r√°pido ‚Üí sem√°ntico)
// Importes din√°micos para evitar dependencias de IA (OpenAI) durante carga en tests

export type HybridOpts = {
  fuzzy?: { maxEditDistance?: number; similarityMin?: number };
  semThresh?: number;
  semBestThresh?: number;
  maxHints?: number;
};

export async function evaluateHybrid(
  user: string,
  acceptable: string[] = [],
  expected: string[] = [],
  policy: AskPolicy = { type: 'conceptual' },
  opts: HybridOpts = { fuzzy: { maxEditDistance: 1, similarityMin: 0.35 }, semThresh: 0.78, semBestThresh: 0.65, maxHints: 2 },
  context?: { lastAnswer?: string; hintsUsed?: number; sessionKey?: string; stepCode?: string }
): Promise<{ kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; reason: string; matched: string[]; missing: string[]; sem?: { cos: number; best?: { text: string; cos: number } } }> {
  // Umbrales de embeddings por tipo de pregunta (MUY PERMISIVOS)
  const getThresholdsByType = (type: string) => {
    switch (type) {
      case 'diagn√≥stica':
        return { semThresh: 0.45, semBestThresh: 0.35 };
      case 'conceptual':
        return { semThresh: 0.50, semBestThresh: 0.40 };
      case 'aplicaci√≥n':
        return { semThresh: 0.48, semBestThresh: 0.38 };
      case 'listado':
        return { semThresh: 0.46, semBestThresh: 0.36 };
      default:
        	return { semThresh: opts.semThresh ?? 0.48, semBestThresh: opts.semBestThresh ?? 0.40 };
    }
  };
  
  const thresholds = getThresholdsByType(policy.type);
  const semThresh = thresholds.semThresh;
  const semBestThresh = thresholds.semBestThresh;
  const u = normalize(user);
  if (!u) return { kind: 'HINT', reason: 'EMPTY', matched: [], missing: acceptable.slice(0,3) };
  if (isNoSe(user)) return { kind: 'HINT', reason: 'DONT_KNOW', matched: [], missing: acceptable.slice(0,3) };

  // 1) Gate de vaguedad (barato) - M√ÅS PERMISIVO
  const vague = isVagueAnswer(u, undefined, { minUsefulTokens: 2, echoOverlap: 0.8, lastAnswer: context?.lastAnswer });
  if (vague) return { kind: 'HINT', reason: 'VAGUE', matched: [], missing: acceptable.slice(0,3) };
  
  // 2) Detecci√≥n de "eco" (repetici√≥n de pregunta/respuesta anterior) - M√ÅS PERMISIVO
  if (context?.lastAnswer) {
    const overlap = jaccard(u, normalize(context.lastAnswer));
    if (overlap >= 0.8) return { kind: 'HINT', reason: 'ECHO', matched: [], missing: acceptable.slice(0,3) };
  }

  // 2) Match r√°pido (barato)
  const fast = classifyTurn(u, policy, acceptable, expected, opts.fuzzy);
  if (fast.kind === 'ACCEPT' || fast.kind === 'PARTIAL') return { ...fast, reason: fast.reason, sem: undefined } as any;

  // 3) Sem√°ntico (costoso): embeddings (carga diferida)
  let idx: any = null;
  let cos = 0; let best: any = null;
  try {
    const sem = await import('@/engine/semvec');
    idx = await sem.buildAskIndex(acceptable, expected);
    if (!idx || !idx.centroid?.length) return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
    const res = await sem.semanticScore(u, idx);
    cos = res.cos; best = res.best;
  } catch {
    return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
  }
  
  // Debug: embeddings activos
  if (process.env.ENGINE_DEBUG === 'true') {
    console.log('[EMBEDDINGS]', { 
      user: u.slice(0, 50), 
      cos, 
      best: best?.text?.slice(0, 30), 
      semThresh: opts.semThresh,
      semBestThresh: opts.semBestThresh 
    });
  }
  // Usar umbrales calculados por tipo de pregunta
  if (cos >= semThresh) {
    if (policy.type === 'aplicacion') {
      const justifica = /porque|para|ya que/i.test(user);
      return { kind: (justifica ? 'ACCEPT' : 'PARTIAL'), reason: (justifica ? 'SEM_APLICACION_OK' : 'SEM_FALTA_JUSTIFICACION'), matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } } as any;
    }
    return { kind: 'PARTIAL', reason: 'SEM_SIMILAR', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((best?.cos || 0) >= semBestThresh) {
    return { kind: 'PARTIAL', reason: 'SEM_BEST', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((context?.hintsUsed || 0) >= (opts.maxHints ?? 2)) {
    return { kind: 'REFOCUS', reason: 'MAX_HINTS', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
  }
  
  // Escalamiento a thinker para casos borderline/ambiguos
  if (cos >= 0.4 && cos < semThresh && (best?.cos || 0) >= 0.35) {
    try {
      // Log de escalaci√≥n iniciada
      try {
        engineLogger.escalationTriggered(context?.sessionKey || 'unknown', context?.stepCode || 'unknown', 'SEM_LOW');
      } catch {}
      
      const { escalateReasoning } = await import('./eval-escalation');
      const escalation = await escalateReasoning({
        student: user,
        objective: policy.type,
        acceptable,
        expected,
        matched: best?.text ? [best.text] : [],
        missing: acceptable.filter(a => a !== best?.text).slice(0,2),
        hintsUsed: context?.hintsUsed || 0
      });
      
      // Log de resultado de escalaci√≥n
      try {
        engineLogger.escalationResult(context?.sessionKey || 'unknown', context?.stepCode || 'unknown', escalation);
      } catch {}
      
      if (escalation.decision === 'ACCEPT') {
        return { kind: 'ACCEPT', reason: 'THINKER_ESCALATION', matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } };
      } else if (escalation.decision === 'HINT') {
        return { kind: 'HINT', reason: 'THINKER_ESCALATION', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
      }
    } catch (error) {
      // Si falla el escalamiento, continuar con la l√≥gica normal
      console.warn('[ESCALATION_ERROR]', error);
    }
  }
  
  return { kind: 'HINT', reason: 'SEM_LOW', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
}

// Evaluaci√≥n SOLO sem√°ntica (sin gates r√°pidos ni heur√≠sticas de vaguedad)
export type SemanticOpts = { semThresh?: number; semBestThresh?: number; maxHints?: number; vagueCenter?: { corpus?: string[]; tauVagueMin?: number; delta?: number; tauObj?: number } };

export async function evaluateSemanticOnly(
  user: string,
  acceptable: string[] = [],
  expected: string[] = [],
  policy: AskPolicy = { type: 'conceptual' },
  opts: SemanticOpts = { semThresh: 0.50, semBestThresh: 0.40, maxHints: 2 },
  context?: { hintsUsed?: number; sessionKey?: string; stepCode?: string }
): Promise<{ kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; reason: string; matched: string[]; missing: string[]; sem?: { cos: number; best?: { text: string; cos: number } } }> {
  const u = normalize(user);
  if (!u) return { kind: 'HINT', reason: 'EMPTY', matched: [], missing: acceptable.slice(0,3) };

  // Umbrales por tipo (solo sem√°nticos)
  const t = normalize(String(policy.type || ''));
  const getThresholds = () => {
    switch (t) {
      case 'diagnostica': return { semThresh: opts.semThresh ?? 0.40, semBestThresh: opts.semBestThresh ?? 0.30 };
      case 'conceptual':  return { semThresh: opts.semThresh ?? 0.44, semBestThresh: opts.semBestThresh ?? 0.34 };
      case 'aplicacion':  return { semThresh: opts.semThresh ?? 0.42, semBestThresh: opts.semBestThresh ?? 0.32 };
      case 'listado':     return { semThresh: opts.semThresh ?? 0.42, semBestThresh: opts.semBestThresh ?? 0.32 };
      default:            return { semThresh: opts.semThresh ?? 0.44, semBestThresh: opts.semBestThresh ?? 0.34 };
    }
  };
  const { semThresh, semBestThresh } = getThresholds();

  // √çndice + score sem√°ntico (objetivo)
  let idx: any = null;
  let cos = 0; let best: any = null;
  try {
    const sem = await import('@/engine/semvec');
    idx = await sem.buildAskIndex(acceptable, expected);
    if (!idx || !idx.centroid?.length) return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
    const res = await sem.semanticScore(u, idx);
    cos = res.cos; best = res.best;
  } catch {
    return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) } as any;
  }

  // Centro vago por embeddings (opcional y configurable)
  if (opts?.vagueCenter?.corpus && Array.isArray(opts.vagueCenter.corpus) && opts.vagueCenter.corpus.length > 0) {
    try {
      const sem = await import('@/engine/semvec');
      const idxV = await sem.buildAskIndex(opts.vagueCenter.corpus as any, []);
      const { cos: cosVague } = await sem.semanticScore(u, idxV);
      const tauV = typeof opts.vagueCenter.tauVagueMin === 'number' ? opts.vagueCenter.tauVagueMin : 0.60;
      const delta = typeof opts.vagueCenter.delta === 'number' ? opts.vagueCenter.delta : 0.05;
      const tauObj = typeof opts.vagueCenter.tauObj === 'number' ? opts.vagueCenter.tauObj : semThresh;
      const emptyByCenter = (cosVague >= (cos + delta)) || ((cos < tauObj) && (cosVague >= tauV));
      if (emptyByCenter) {
        return { kind: 'HINT', reason: 'EMPTY_CENTER', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } } as any;
      }
    } catch {}
  }

  // Decisi√≥n SOLO por embeddings
  if (cos >= semThresh) {
    if (t === 'aplicacion') {
      const justifica = /porque|para|ya que/i.test(user);
      return {
        kind: (justifica ? 'ACCEPT' : 'PARTIAL'),
        reason: (justifica ? 'SEM_APLICACION_OK' : 'SEM_FALTA_JUSTIFICACION'),
        matched: best?.text ? [best.text] : [],
        missing: [],
        sem: { cos, best }
      } as any;
    }
    return {
      kind: 'PARTIAL',
      reason: 'SEM_SIMILAR',
      matched: best?.text ? [best.text] : [],
      missing: acceptable.filter(a => a !== best?.text).slice(0,2),
      sem: { cos, best }
    };
  }

  if ((best?.cos || 0) >= semBestThresh) {
    return {
      kind: 'PARTIAL',
      reason: 'SEM_BEST',
      matched: best?.text ? [best.text] : [],
      missing: acceptable.filter(a => a !== best?.text).slice(0,2),
      sem: { cos, best }
    };
  }

  // Sin suficiente similitud ‚Üí pista o refocus determinista
  const hintsUsed = context?.hintsUsed || 0;
  if (hintsUsed >= (opts.maxHints ?? 2)) {
    return { kind: 'REFOCUS', reason: 'MAX_HINTS', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } } as any;
  }

  return { kind: 'HINT', reason: 'SEM_LOW', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } } as any;
}
```
=== EOF: src\engine\eval.ts

===  src\engine\eval-escalation.ts
```typescript
import { getClient } from '@/lib/ai';
import { z } from 'zod';
import { getBudgetManager, pickModelWithBudget } from './costs';

// Esquema Zod para validaci√≥n estricta del JSON
const EscalationResponseSchema = z.object({
  decision: z.enum(['ACCEPT', 'HINT', 'REASK']),
  short: z.string().min(1).max(200),
  reason: z.enum(['SEM_LOW', 'THINKER_ESCALATION', 'OFF_TOPIC', 'BUDGET_LIMIT']).optional()
});

export type EscalationResponse = z.infer<typeof EscalationResponseSchema>;

export async function escalateReasoning(input: {
  student: string;
  objective: string;
  acceptable: string[];
  expected: string[];
  matched: string[];
  missing: string[];
  hintsUsed: number;
}): Promise<EscalationResponse> {
  const budgetManager = getBudgetManager();
  
  // Verificar presupuesto antes de escalar
  if (!budgetManager.canEscalate()) {
    return {
      decision: 'HINT',
      short: 'Considera revisar los conceptos clave mencionados.',
      reason: 'BUDGET_LIMIT'
    };
  }

  const ai = getClient();
  const model = pickModelWithBudget('thinker');
  
  const sys = [
    'Eres un evaluador estricto.',
    'Devuelve SOLO JSON con: { "decision": "ACCEPT|HINT|REASK", "short": "texto breve", "reason": "SEM_LOW|THINKER_ESCALATION|OFF_TOPIC" }. Sin comentarios.'
  ].join('\n');

  const user = `
Objetivo: ${input.objective}
Respuesta del alumno: ${input.student}
Acceptable: ${input.acceptable.join(', ')}
Expected: ${input.expected.join(', ')}
Matched: ${input.matched.join(', ')}
Missing: ${input.missing.join(', ')}
Hints usadas: ${input.hintsUsed}
Regla: si faltan conceptos cr√≠ticos -> HINT con pista breve; si es off-topic/vago -> REASK; si cumple -> ACCEPT.
`;

  try {
    const res = await ai.responses.create({
      model,
      reasoning: { effort: 'medium' },
      input: [
        { role: 'system', content: sys },
        { role: 'user',   content: user }
      ],
      max_output_tokens: 120
    });

    const raw = res.output_text || '{}';
    
    // Validar con Zod antes de usar
    const parsed = JSON.parse(raw);
    const validated = EscalationResponseSchema.parse(parsed);
    
    // Registrar uso en el presupuesto
    budgetManager.recordUsage('thinker', 200);
    
    return validated;
  } catch (error) {
    // Fallback seguro si falla la validaci√≥n o la llamada
    return {
      decision: 'REASK',
      short: 'Reformula tu respuesta con m√°s precisi√≥n.',
      reason: 'THINKER_ESCALATION'
    };
  }
}
```
=== EOF: src\engine\eval-escalation.ts

===  src\engine\costs.ts
```typescript
// Configuraci√≥n de costos por modelo (en centavos por 1K tokens)
const COST_CONFIG = {
  cheap: 0.5,    // gpt-4o-mini
  embed: 0.1,    // text-embedding-3-small  
  thinker: 2.5   // o3-mini
};

// Estimaci√≥n de tokens por tipo de operaci√≥n
const TOKEN_ESTIMATES = {
  response: 150,    // Respuesta t√≠pica
  embedding: 50,    // Embedding de texto
  escalation: 200   // Escalaci√≥n con razonamiento
};

export type CostTier = 'cheap' | 'embed' | 'thinker';

export class BudgetManager {
  private budgetCentsLeft: number;
  private usageByTier: Record<CostTier, number> = {
    cheap: 0,
    embed: 0,
    thinker: 0
  };

  constructor(initialBudgetCents: number = 100) {
    this.budgetCentsLeft = initialBudgetCents;
  }

  // Verificar si se puede usar un tier espec√≠fico
  canUseTier(tier: CostTier): boolean {
    const estimatedCost = this.estimateCost(tier);
    return this.budgetCentsLeft >= estimatedCost;
  }

  // Registrar uso y actualizar presupuesto
  recordUsage(tier: CostTier, actualTokens?: number): number {
    const tokens = actualTokens || TOKEN_ESTIMATES[tier === 'embed' ? 'embedding' : 'response'];
    const cost = (tokens / 1000) * COST_CONFIG[tier];
    
    this.usageByTier[tier] += tokens;
    this.budgetCentsLeft = Math.max(0, this.budgetCentsLeft - cost);
    
    return cost;
  }

  // Estimaci√≥n de costo para una operaci√≥n
  private estimateCost(tier: CostTier): number {
    const tokens = TOKEN_ESTIMATES[tier === 'embed' ? 'embedding' : 'response'];
    return (tokens / 1000) * COST_CONFIG[tier];
  }

  // Obtener m√©tricas de uso
  getUsageMetrics() {
    return {
      budgetCentsLeft: this.budgetCentsLeft,
      usageByTier: { ...this.usageByTier },
      totalCost: 100 - this.budgetCentsLeft,
      canEscalate: this.canUseTier('thinker')
    };
  }

  // Verificar si se puede escalar (thinker)
  canEscalate(): boolean {
    return this.canUseTier('thinker') && this.budgetCentsLeft > 10;
  }

  // Forzar modo econ√≥mico (solo cheap)
  forceCheapMode(): boolean {
    return this.budgetCentsLeft < 5;
  }
}

// Instancia global del gestor de presupuesto
let globalBudgetManager: BudgetManager | null = null;

export function getBudgetManager(): BudgetManager {
  if (!globalBudgetManager) {
    globalBudgetManager = new BudgetManager();
  }
  return globalBudgetManager;
}

export function resetBudgetManager(budgetCents: number = 100): BudgetManager {
  globalBudgetManager = new BudgetManager(budgetCents);
  return globalBudgetManager;
}

// Wrapper para pickModel que respeta el presupuesto
export function pickModelWithBudget(tier: CostTier): string {
  const budgetManager = getBudgetManager();
  
  // Si no hay presupuesto para el tier solicitado, degradar
  if (!budgetManager.canUseTier(tier)) {
    if (tier === 'thinker') return process.env.CHEAP_MODEL || 'gpt-4o-mini';
    if (tier === 'embed') return process.env.CHEAP_MODEL || 'gpt-4o-mini';
    return process.env.CHEAP_MODEL || 'gpt-4o-mini';
  }
  
  // Usar el modelo original
  if (tier === 'thinker') return process.env.THINKER_MODEL || 'o3-mini';
  if (tier === 'embed') return process.env.EMBED_MODEL || 'text-embedding-3-small';
  return process.env.CHEAP_MODEL || 'gpt-4o-mini';
}
```
=== EOF: src\engine\costs.ts

===  src\engine\clarify.ts
```typescript
export type ClassificationKind = 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS' | string;

export function shouldClarifyQuestion(opts: {
  isVague: boolean;
  isNo: boolean;
  classificationKind: ClassificationKind;
  studentAsking: boolean;
}): boolean {
  const { isVague, isNo, classificationKind, studentAsking } = opts;
  return !isVague && !isNo && classificationKind !== 'HINT' && Boolean(studentAsking);
}

export function shouldGateByMinTokens(text: string, minTokens: number = 3): boolean {
  const raw = String(text || '').trim();
  if (!raw) return true;
  const tokens = raw.split(/\s+/).filter(Boolean);
  return tokens.length < Math.max(1, Math.floor(minTokens));
}

export function isNoSeInput(text?: string): boolean {
  const t = String(text || '').trim();
  if (!t) return true;
  return /^(no\s*(lo\s*)?s[e√©]|no\s*est[o√≥]y?\s*seguro|no\s*s[e√©]\s*bien)$/i.test(t);
}


```
=== EOF: src\engine\clarify.ts

===  src\engine\advance.ts
```typescript
export function shouldAdvanceOnPartial({ cls, teacherProfile, stepData }: any) {
  const tp = teacherProfile || {};
  const thr = (stepData && (stepData as any).partial_thresholds) || tp?.advance?.partial?.thresholds || {};
  const minMatched = Number((thr as any).minMatched ?? 2);
  const maxMissing = Number((thr as any).maxMissing ?? 1);
  const minSem = Number((thr as any).minSem ?? 0.55);
  const matched = Array.isArray(cls?.matched) ? cls.matched.length : Number(cls?.matched || 0);
  const missing = Array.isArray(cls?.missing) ? cls.missing.length : Number(cls?.missing || 0);
  // Permitir que cls.sem sea un n√∫mero o un objeto { cos }
  const sem = typeof cls?.sem === 'number' ? Number(cls.sem) : Number(cls?.sem?.cos || 0);
  return tp?.advance?.partial?.enabled === true &&
    ((matched >= minMatched && missing <= maxMissing) || (sem >= minSem));
}

export function shouldForceAdvance({ attempts, teacherProfile }: any) {
  const tp = teacherProfile || {};
  const enabled = tp?.advance?.force?.enabled === true;
  const after = Number(tp?.advance?.force?.afterAttempts ?? 3);
  return Boolean(enabled && attempts >= after);
}


```
=== EOF: src\engine\advance.ts

===  src\components\VoiceRecorder.tsx
```tsx
'use client';
import { Mic } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

export default function VoiceRecorder({ onResult, language = 'es' }: { onResult: (text: string) => void; language?: string }) {
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const [recording, setRecording] = useState(false);
  const [supported, setSupported] = useState(true);

  useEffect(() => {
    if (!navigator.mediaDevices || typeof window === 'undefined' || !(window as any).MediaRecorder) {
      setSupported(false);
    }
  }, []);

  const start = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mr = new MediaRecorder(stream);
      mediaRecorderRef.current = mr;
      chunksRef.current = [];
      mr.ondataavailable = e => { if (e.data && e.data.size > 0) chunksRef.current.push(e.data); };
      mr.onstop = async () => {
        try {
          const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
          const form = new FormData();
          form.append('audio', blob, 'audio.webm');
          form.append('language', language);
          const res = await fetch('/api/audio/transcribe', { method: 'POST', body: form });
          const data = await res.json();
          if (data?.text) onResult(data.text);
        } catch {}
      };
      mr.start();
      setRecording(true);
    } catch {
      setSupported(false);
    }
  };

  const stop = () => {
    const mr = mediaRecorderRef.current;
    if (mr && mr.state !== 'inactive') {
      mr.stop();
      setRecording(false);
    }
  };

  if (!supported) return null;

  return (
    <button
      onClick={() => (recording ? stop() : start())}
      className={`rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg ${
        recording ? 'bg-gradient-to-r from-rose-600 to-red-600 text-white p-3' : 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white p-3'
      }`}
      title={recording ? 'Detener dictado' : 'Dictar con voz'}
      aria-label={recording ? 'Detener dictado' : 'Dictar con voz'}
      type="button"
    >
      <Mic className="w-5 h-5" />
    </button>
  );
}


```
=== EOF: src\components\VoiceRecorder.tsx

===  src\components\LoginButton.tsx
```tsx
"use client";
import { signIn } from "next-auth/react";

export default function LoginButton() {
  return (
    <button
      onClick={() => signIn("google", { callbackUrl: "/engine-chat" })}
      className="flex w-full items-center justify-center gap-3 rounded-md border bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm transition hover:bg-gray-50 active:scale-[0.99]"
    >
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 533.5 544.3" className="h-5 w-5" aria-hidden>
        <path fill="#4285F4" d="M533.5 278.4c0-18.5-1.6-37-5-54.9H272.1v103.9h146.9c-6.3 34.8-25.6 64.3-54.6 84v69.7h88.3c51.7-47.6 80.8-117.8 80.8-202.7z"/>
        <path fill="#34A853" d="M272.1 544.3c73.1 0 134.6-24.2 179.5-66l-88.3-69.7c-24.5 16.5-56 26-91.2 26-70 0-129.4-47.2-150.7-110.7H31.7v69.9C76.9 487.3 168.8 544.3 272.1 544.3z"/>
        <path fill="#FBBC05" d="M121.4 323.9c-10.1-30.1-10.1-62.5 0-92.6V161.4H31.7c-41.9 83.7-41.9 183.8 0 267.5l89.7-69.9z"/>
        <path fill="#EA4335" d="M272.1 107.7c39.7-.6 78.1 14.5 107.2 42.3l79.8-79.8C407.1 24.9 340.1-.8 272.1 0 168.8 0 76.9 57 31.7 161.4l89.7 69.9C142.7 167.8 202.2 107.7 272.1 107.7z"/>
      </svg>
      Ingresar con Google
    </button>
  );
}


```
=== EOF: src\components\LoginButton.tsx

===  src\components\FeedbackSequential.tsx
```tsx
"use client";
import React from 'react';
import { classifyTurn, isNoSe } from "@/engine/eval";
import { buildTraceEntry, computeFeedbackLabel } from "@/engine/feedbackSequencer";
import { makeHintMessage, makeReaskMessage } from "@/engine/hints";
import { DEFAULT_TEACHER_PROFILE } from "@/teacher/defaultProfile";
import FeedbackSequentialInjected, { type FeedbackSequentialInjectedProps } from "./FeedbackSequential.deps-injected";

export type AttemptOutcome = {
  label: "F0" | "F1" | "F2";
  kind: "HINT" | "PARTIAL" | "ACCEPT" | "REFOCUS";
  feedback: string;
  scoreDelta: 0 | 1 | 2;
};

export type FeedbackSequentialProps = Omit<FeedbackSequentialInjectedProps, "overrides"> & {
  teacherProfile?: any;
};

export default function FeedbackSequential(props: FeedbackSequentialProps) {
  const teacher = props.teacherProfile || DEFAULT_TEACHER_PROFILE;

  const overrides: NonNullable<FeedbackSequentialInjectedProps["overrides"]> = {
    maxAttempts: 3,
    isEmpty: (answer: string) => !String(answer || "").trim() || isNoSe(answer),
    evaluate: (answer, ctx) => {
      const res = classifyTurn(
        answer,
        { type: ctx.policyType as any },
        ctx.acceptable,
        ctx.expected,
        { maxEditDistance: 1, similarityMin: 0.35 }
      );
      return { kind: res.kind as any, matched: res.matched || [], missing: res.missing || [], reason: res.reason };
    },
    label: (kind, attempt) => computeFeedbackLabel(kind, attempt),
    makeHint: (opts) => makeHintMessage({
      questionText: opts.questionText,
      objective: opts.objective,
      expected: opts.expected,
      missing: opts.missing,
      answerType: props.answerType as any,
      hintsUsed: opts.hintsUsed,
      attempts: opts.attempts,
      coursePolicies: undefined,
      teacherProfile: teacher,
    }),
    makeReask: (opts) => makeReaskMessage({
      questionText: opts.questionText,
      objective: opts.objective,
      expected: opts.expected,
      answerType: props.answerType as any,
      coursePolicies: undefined,
      teacherProfile: teacher,
    }),
    buildTrace: (args) => buildTraceEntry(args as any),
    scorePolicy: ({ attempts, lastKind, hintsUsed, acceptedAt, exhausted, hadPartial }) => {
      if (lastKind === "ACCEPT") return { status: "cumplida", score: 2 } as const;
      if (exhausted) {
        if (hadPartial) return { status: props.finalExplanation ? "force_advance" : "pendiente", score: 1 } as const;
        return { status: props.finalExplanation ? "force_advance" : "pendiente", score: 0 } as const;
      }
      return { status: "pendiente", score: 0 } as const;
    },
  };

  return <FeedbackSequentialInjected {...props} overrides={overrides} teacherProfile={teacher} />;
}


```
=== EOF: src\components\FeedbackSequential.tsx

===  src\components\FeedbackSequential.deps-injected.tsx
```tsx
"use client";
import React, { useCallback, useMemo, useState } from "react";

// Tipos compartidos entre versiones
export type AttemptOutcome = {
  label: "F0" | "F1" | "F2";
  kind: "HINT" | "PARTIAL" | "ACCEPT" | "REFOCUS";
  feedback: string;
  scoreDelta: 0 | 1 | 2;
};

export type FeedbackSequentialInjectedProps = {
  code?: string;
  prompts: [string, string, string];
  objective: string;
  acceptable: string[];
  expected?: string[];
  answerType?: "open" | "list" | "definition" | "procedure" | "choice";
  finalExplanation?: string;
  teacherProfile?: any;
  onComplete?: (result: {
    status: "cumplida" | "pendiente" | "force_advance";
    score: 0 | 1 | 2;
    hints: number;
    attempts: number;
    trace: Array<any>;
  }) => void;
  uiText?: {
    inputPlaceholder?: string;
    sendLabel?: string;
  };
  overrides?: {
    maxAttempts?: number;
    isEmpty?: (answer: string) => boolean;
    evaluate?: (
      answer: string,
      ctx: {
        policyType: string;
        acceptable: string[];
        expected: string[];
        answerType: FeedbackSequentialInjectedProps["answerType"];
        hintsUsed: number;
        attempt: number;
      }
    ) => { kind: "HINT" | "PARTIAL" | "ACCEPT" | "REFOCUS"; matched: string[]; missing: string[]; reason?: string };
    label?: (kind: AttemptOutcome["kind"], attempt: number) => AttemptOutcome["label"];
    makeHint?: (opts: {
      questionText: string;
      objective: string;
      expected: string[];
      missing: string[];
      answerType?: FeedbackSequentialInjectedProps["answerType"];
      hintsUsed: number;
      attempts: number;
      teacherProfile?: any;
    }) => string;
    makeReask?: (opts: {
      questionText: string;
      objective: string;
      expected: string[];
      answerType?: FeedbackSequentialInjectedProps["answerType"];
      teacherProfile?: any;
    }) => string;
    buildTrace?: (args: {
      question: string;
      response: string;
      feedback: string;
      kind: AttemptOutcome["kind"];
      attempt: number;
      hintsUsed?: number;
      stepCode?: string;
    }) => any;
    scorePolicy?: (args: {
      attempts: number;
      lastKind: AttemptOutcome["kind"];
      hintsUsed: number;
      acceptedAt?: number | null;
      exhausted: boolean;
      hadPartial?: boolean;
    }) => { status: "cumplida" | "pendiente" | "force_advance"; score: 0 | 1 | 2 };
  };
};

function usePolicyType(answerType?: FeedbackSequentialInjectedProps["answerType"]) {
  // Map flexible, se puede sobreescribir desde overrides.evaluate
  return useMemo(() => {
    switch (answerType) {
      case "list":
        return "listado";
      case "procedure":
        return "aplicacion";
      case "choice":
        return "identificacion";
      case "definition":
      case "open":
      default:
        return "conceptual";
    }
  }, [answerType]);
}

export default function FeedbackSequentialInjected(props: FeedbackSequentialInjectedProps) {
  const {
    code = "",
    prompts,
    objective,
    acceptable,
    expected = [],
    answerType = "list",
    finalExplanation,
    teacherProfile,
    onComplete,
    uiText,
    overrides,
  } = props;

  const policyType = usePolicyType(answerType);
  const maxAttempts = overrides?.maxAttempts ?? 3;
  const [attempt, setAttempt] = useState<number>(0);
  const [input, setInput] = useState<string>("");
  const [hintsUsed, setHintsUsed] = useState<number>(0);
  const [trace, setTrace] = useState<any[]>([]);
  const [done, setDone] = useState<boolean>(false);
  const [outcomes, setOutcomes] = useState<AttemptOutcome[]>([]);

  const currentQuestion = prompts[Math.min(attempt, prompts.length - 1)] || "";

  const buildFeedbackText = useCallback((kind: AttemptOutcome["kind"], ctx: { missing: string[]; matched: string[] }) => {
    // HINT/REFOCUS ‚Üí usar generadores; PARTIAL ‚Üí gu√≠a + reask; ACCEPT ‚Üí reforzar con matched (si hay)
    if (kind === "HINT" || kind === "REFOCUS") {
      const hintMsg = overrides?.makeHint?.({
        questionText: currentQuestion,
        objective,
        expected,
        missing: ctx.missing,
        answerType,
        hintsUsed,
        attempts: attempt,
        teacherProfile,
      }) || "";
      const reask = overrides?.makeReask?.({
        questionText: currentQuestion,
        objective,
        expected,
        answerType,
        teacherProfile,
      }) || "";
      return [hintMsg, reask].filter(Boolean).join(" ").trim();
    }
    if (kind === "PARTIAL") {
      const reask = overrides?.makeReask?.({
        questionText: currentQuestion,
        objective,
        expected,
        answerType,
        teacherProfile,
      }) || "";
      // Mensaje centrado en completar elementos faltantes, evitando cadenas est√°ticas
      const dynamicSuffix = ctx.missing.length ? ctx.missing.join(", ") : "";
      return [reask, dynamicSuffix].filter(Boolean).join(" ¬∑ ").trim();
    }
    // ACCEPT ‚Üí sin reask; devolver se√±ales/matched como refuerzo m√≠nimo
    return (ctx.matched || []).join(", ");
  }, [answerType, attempt, currentQuestion, expected, objective, overrides, teacherProfile, hintsUsed]);

  const handleSend = useCallback(() => {
    if (done) return;
    const value = String(input || "").trim();
    if (!value) {
      // vac√≠o expl√≠cito ‚Üí HINT
      const kind: AttemptOutcome["kind"] = "HINT";
      const label = overrides?.label ? overrides.label(kind, attempt) : ("F0" as AttemptOutcome["label"]);
      const feedback = buildFeedbackText(kind, { matched: [], missing: acceptable.slice(0, 3) });
      const outcome: AttemptOutcome = { label, kind, feedback, scoreDelta: 0 };
      setOutcomes(prev => [...prev, outcome]);
      setHintsUsed(h => h + 1);
      const t = overrides?.buildTrace?.({
        question: currentQuestion,
        response: value,
        feedback,
        kind,
        attempt,
        hintsUsed,
        stepCode: code,
      });
      if (t) setTrace(prev => [...prev, t]);
      setAttempt(a => a + 1);
      setInput("");
      return;
    }

    const res = overrides?.evaluate?.(value, {
      policyType,
      acceptable,
      expected,
      answerType,
      hintsUsed,
      attempt,
    }) || { kind: "HINT" as const, matched: [], missing: acceptable.slice(0, 3) };

    const label = overrides?.label ? overrides.label(res.kind, attempt) : ("F2" as AttemptOutcome["label"]);
    const feedback = buildFeedbackText(res.kind, { matched: res.matched || [], missing: res.missing || [] });
    const outcome: AttemptOutcome = {
      label,
      kind: res.kind,
      feedback,
      scoreDelta: res.kind === "ACCEPT" ? 2 : res.kind === "PARTIAL" ? 1 : 0,
    };
    setOutcomes(prev => [...prev, outcome]);
    if (res.kind === "HINT" || res.kind === "REFOCUS") setHintsUsed(h => h + 1);

    const t = overrides?.buildTrace?.({
      question: currentQuestion,
      response: value,
      feedback,
      kind: res.kind,
      attempt,
      hintsUsed,
      stepCode: code,
    });
    if (t) setTrace(prev => [...prev, t]);

    const nextAttempt = attempt + 1;
    const exhausted = nextAttempt >= maxAttempts;
    const accepted = res.kind === "ACCEPT";

    if (accepted || exhausted) {
      const hadPartial = (!accepted && outcomes.some(o => o.kind === "PARTIAL")) || res.kind === "PARTIAL";
      const decision = overrides?.scorePolicy?.({
        attempts: nextAttempt,
        lastKind: res.kind,
        hintsUsed: hintsUsed + (res.kind === "HINT" || res.kind === "REFOCUS" ? 1 : 0),
        acceptedAt: accepted ? nextAttempt : null,
        exhausted,
        hadPartial,
      }) || { status: accepted ? "cumplida" : (finalExplanation ? "force_advance" : "pendiente"), score: accepted ? 2 : (hadPartial ? 1 : 0) };

      // En caso de fuerza de avance con explicaci√≥n final, registrar una √∫ltima entrada F2 sin respuesta
      let extraTrace: any | null = null;
      if (!accepted && exhausted && finalExplanation) {
        const fk: AttemptOutcome["kind"] = "REFOCUS";
        const flabel = overrides?.label ? overrides.label(fk, nextAttempt) : ("F2" as AttemptOutcome["label"]);
        const extraOutcome: AttemptOutcome = { label: flabel, kind: fk, feedback: finalExplanation, scoreDelta: 0 };
        setOutcomes(prev => [...prev, extraOutcome]);
        const te = overrides?.buildTrace?.({
          question: currentQuestion,
          response: "",
          feedback: finalExplanation,
          kind: fk,
          attempt: nextAttempt,
          hintsUsed: hintsUsed,
          stepCode: code,
        });
        if (te) { setTrace(prev => [...prev, te]); extraTrace = te; }
      }

      setDone(true);
      // Ensamblar traza final localmente para no depender del setState as√≠ncrono
      const finalTrace = [
        ...trace,
        ...(t ? [t] : []),
        ...(extraTrace ? [extraTrace] : []),
      ];
      onComplete?.({
        status: decision.status,
        score: decision.score as 0 | 1 | 2,
        hints: hintsUsed + (res.kind === "HINT" || res.kind === "REFOCUS" ? 1 : 0),
        attempts: nextAttempt,
        trace: finalTrace,
      });
    } else {
      setAttempt(nextAttempt);
    }
    setInput("");
  }, [acceptable, expected, answerType, attempt, buildFeedbackText, code, currentQuestion, done, finalExplanation, hintsUsed, maxAttempts, objective, onComplete, overrides, policyType, input, trace, outcomes]);

  // UI m√≠nima (tailwind), sin textos fijos: usa uiText cuando aplique
  return (
    <div className="w-full">
      <div className="space-y-3">
        <div className="text-sm text-slate-700">
          <span className="font-medium">{code ? `${code} ¬∑ ` : ""}</span>
          <span>{currentQuestion}</span>
        </div>

        <div className="space-y-2">
          {outcomes.map((o, idx) => (
            <div key={idx} className="border rounded-lg p-2 text-sm">
              <div className="flex items-center justify-between">
                <span className="font-semibold">{o.label}</span>
                <span className="text-xs uppercase tracking-wide text-slate-500">{o.kind}</span>
              </div>
              {o.feedback ? (
                <div className="mt-1 text-slate-800 whitespace-pre-wrap">{o.feedback}</div>
              ) : null}
            </div>
          ))}
        </div>

        <div className="flex gap-2 items-center">
          <input
            className="flex-1 border rounded-lg px-3 py-2 text-sm"
            placeholder={uiText?.inputPlaceholder || ""}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            disabled={done}
          />
          <button
            className="px-3 py-2 text-sm rounded-lg bg-blue-600 text-white disabled:opacity-50"
            onClick={handleSend}
            disabled={done}
          >
            {uiText?.sendLabel || "‚Üí"}
          </button>
        </div>
      </div>
    </div>
  );
}


```
=== EOF: src\components\FeedbackSequential.deps-injected.tsx

===  src\components\EngineChatLayout.tsx
```tsx
'use client';
// Legacy layout: remove tight coupling with legacy core types
type LessonVM = any;
type EngineState = any;
import { Clock, Menu, Send, User, X } from 'lucide-react';
import Image from 'next/image';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import VoiceRecorder from './VoiceRecorder';

export type EngineChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

export default function EngineChatLayout({
  messages,
  isTyping,
  onSend,
  vm,
  state
}: {
  messages: EngineChatMessage[];
  isTyping: boolean;
  onSend: (text: string) => void;
  vm: LessonVM | null;
  state: EngineState | null;
}) {
  const [inputValue, setInputValue] = useState('');
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesScrollRef = useRef<HTMLDivElement>(null);
  const [previewSrc, setPreviewSrc] = useState<string | null>(null);
  const stickRef = useRef<boolean>(true);
  const [mediaIdx, setMediaIdx] = useState<number>(0);

  const mediaImages: string[] = useMemo(() => {
    try {
      // 1) Priorizar im√°genes del momento actual
      const momentIdx: number = Number((state as any)?.momentIdx || (state as any)?.state?.momentIdx || 0);
      const momentImages: any[] = (vm as any)?.moments?.[momentIdx]?.images || [];
      const normalizedMoment = momentImages.map((it: any) => (typeof it === 'string' ? it : (it?.url || it?.src || it?.image))).filter(Boolean);
      if (normalizedMoment.length) return normalizedMoment;

      // 2) Si no hay en momento, intentar por paso desde vm.media
      const stepCode: string | undefined = (state as any)?.stepCode || (state as any)?.state?.stepCode;
      const entry = (vm as any)?.media?.[stepCode || ''] || {};
      const images = entry?.images;
      const byStep = Array.isArray(images) ? images.filter(Boolean) : [];
      return byStep;
    } catch { return []; }
  }, [vm, state]);

  type MediaItem = { url: string; name?: string; description?: string; caption?: string };
  const deriveNameFromUrl = (u?: string): string => {
    try {
      if (!u) return '';
      const last = u.split('?')[0].split('#')[0].split('/').pop() || '';
      const base = last.replace(/\.[a-zA-Z0-9]+$/, '');
      return base.replace(/[\-_]+/g, ' ');
    } catch { return ''; }
  };
  const currentMultimedia: MediaItem[] = useMemo(() => {
    try {
      // 1) Priorizar im√°genes del momento para todo el curso/JSON
      const momentIdx: number = Number((state as any)?.momentIdx || (state as any)?.state?.momentIdx || 0);
      const momentImages: any[] = (vm as any)?.moments?.[momentIdx]?.images || [];
      if (Array.isArray(momentImages) && momentImages.length) {
        return momentImages
          .map((it: any) => (typeof it === 'string' ? { url: it } : { url: it?.url || it?.src || it?.image, name: it?.name || it?.title, description: it?.description || it?.desc, caption: it?.caption || it?.label }))
          .filter((it: any) => !!it.url)
          .map((it: any) => ({ url: it.url, name: it.name || deriveNameFromUrl(it.url), description: it.description || '', caption: it.caption || it.description || deriveNameFromUrl(it.url) }));
      }

      // 2) Si no hay im√°genes por momento, usar mapping por paso (plan/media del curso)
      const stepCode: string | undefined = (state as any)?.stepCode || (state as any)?.state?.stepCode;
      const entry = (vm as any)?.media?.[stepCode || ''] || {};
      const baseRaw = Array.isArray(entry?.items) ? entry.items : [];
      const hintRaw = Array.isArray(entry?.hintItems) ? entry.hintItems : [];
      if (baseRaw.length || hintRaw.length) {
        const mapIt = (it: any) => ({
          url: it?.url || it?.src || it?.image || '',
          name: it?.name || it?.title || deriveNameFromUrl(it?.url || it?.src || it?.image),
          description: it?.description || it?.desc || '',
          caption: it?.caption || it?.label || ''
        });
        return [...baseRaw.map(mapIt), ...hintRaw.map(mapIt)].filter((it: MediaItem) => !!it.url);
      }

      // 3) √öltimo recurso: lista simple de URLs detectadas
      const imgs = mediaImages;
      return imgs.map((url) => ({ url, name: deriveNameFromUrl(url), caption: deriveNameFromUrl(url) }));
    } catch { return mediaImages.map((url) => ({ url, name: deriveNameFromUrl(url), caption: deriveNameFromUrl(url) })); }
  }, [vm, state, mediaImages]);

  // Limitar elementos visibles seg√∫n progreso de hints (si viene del engine)
  const visibleMultimedia: MediaItem[] = useMemo(() => {
    try {
      // 0) Si hay im√°genes definidas a nivel de momento, usarlas siempre (sin esquema base/hints)
      const momentIdx: number = Number((state as any)?.momentIdx || (state as any)?.state?.momentIdx || 0);
      const momentImages: any[] = (vm as any)?.moments?.[momentIdx]?.images || [];
      if (Array.isArray(momentImages) && momentImages.length) {
        return currentMultimedia; // ya normalizadas en currentMultimedia
      }

      const stepCode: string | undefined = (state as any)?.stepCode || (state as any)?.state?.stepCode;
      const entry = (vm as any)?.media?.[stepCode || ''] || {};
      const baseRaw = Array.isArray(entry?.items) ? entry.items : [];
      const hintRaw = Array.isArray(entry?.hintItems) ? entry.hintItems : [];
      const hintsUsedLocal = Number((state as any)?.hintsUsed || 0);
      if (baseRaw.length || hintRaw.length) {
        const mapIt = (it: any) => ({
          url: it?.url || it?.src || it?.image || '',
          name: it?.name || it?.title || deriveNameFromUrl(it?.url || it?.src || it?.image),
          description: it?.description || it?.desc || '',
          caption: it?.caption || it?.label || ''
        });
        const base = baseRaw.map(mapIt).filter((it: MediaItem) => !!it.url);
        const hintAll = hintRaw.map(mapIt).filter((it: MediaItem) => !!it.url);
        const unlocked = hintAll.slice(0, Math.max(0, Math.min(hintsUsedLocal, hintAll.length)));
        return [...base, ...unlocked];
      }
      // Sin esquema base/hints -> fallback progresivo simple
      const hintsUsedBasic = Number((state as any)?.hintsUsed || 0);
      const cap = Math.min(currentMultimedia.length, Math.max(1, hintsUsedBasic + 1));
      return currentMultimedia.slice(0, cap);
    } catch { return currentMultimedia; }
  }, [vm, state, currentMultimedia]);

  useEffect(() => { setMediaIdx(0); }, [mediaImages?.length]);

  useEffect(() => {
    if (!stickRef.current) return;
    const sc = messagesScrollRef.current;
    if (sc) {
      try {
        sc.scrollTo({ top: sc.scrollHeight, behavior: 'smooth' });
      } catch {
        // fallback
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }
  }, [messages, isTyping]);

  const onMessagesScroll = (e: React.UIEvent<HTMLDivElement>) => {
    try {
      const el = e.currentTarget;
      const distanceFromBottom = el.scrollHeight - el.scrollTop - el.clientHeight;
      stickRef.current = distanceFromBottom < 120; // pegarse al fondo salvo que el usuario suba
    } catch { stickRef.current = true; }
  };

  const handleSend = () => {
    if (!inputValue.trim()) return;
    onSend(inputValue);
    setInputValue('');
  };

  const handleKey = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }
  };

  return (
    <div className="h-screen bg-slate-100 overflow-hidden flex flex-col">
      {/* Header */}
      <header className="bg-white border-b border-slate-200 px-4 md:px-6 py-3 md:py-4 sticky top-0 z-40">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="bg-gradient-to-br from-blue-600 to-indigo-600 p-2.5 rounded-xl shadow-lg" />
                         <div>
               <h1 className="text-base md:text-lg font-bold text-slate-900">{vm?.title || 'DocenteIA'}</h1>
               <p className="text-[10px] md:text-xs text-slate-600">Versi√≥n {vm?.version} ¬∑ {vm?.locale}</p>
             </div>
          </div>
        </div>
      </header>

      <div className="flex-1 flex w-full overflow-hidden min-h-0">
        {/* Left side: Panel informativo (Aprendizaje esperado, Puntos clave y Progreso) */}
                 <div className={`hidden lg:block transition-all duration-300 pl-2 ${sidebarOpen ? 'lg:basis-[20%] xl:basis-[20%] opacity-100' : 'lg:basis-[90px] opacity-100'} ${sidebarOpen ? 'min-w-[220px]' : 'min-w-[90px]'}`}>
           <div className={`h-full mx-3 my-0 rounded-2xl shadow-sm border border-slate-200 flex flex-col bg-white transition-all duration-300 relative ${sidebarOpen ? 'scale-100' : 'scale-95'}`}>
             
                           {/* Bot√≥n de toggle siempre visible */}
              <button 
                onClick={() => setSidebarOpen(!sidebarOpen)} 
                className={`absolute top-4 z-10 p-2 rounded-lg bg-slate-100 hover:bg-slate-200 transition-colors ${sidebarOpen ? 'right-4' : 'left-1/2 transform -translate-x-1/2'}`}
                style={{ top: '16px' }}
              >
                {sidebarOpen ? <Menu className="w-4 h-4 rotate-180" /> : <Menu className="w-4 h-4" />}
              </button>
             
             <div className={`px-6 py-4 border-b border-slate-200 ${!sidebarOpen ? 'opacity-0' : 'opacity-100'}`}>
               <h3 className="text-sm font-semibold text-slate-900 flex items-center gap-2">
                 <span className="inline-block w-2 h-2 rounded-full bg-blue-600" />
                 Resumen de la sesi√≥n
               </h3>
             </div>
            <div className={`p-6 space-y-4 overflow-y-auto ${!sidebarOpen ? 'opacity-0' : 'opacity-100'}`}>
              {vm && state && (
                <>
                  {Array.isArray(vm.expectedLearning) && vm.expectedLearning.length > 0 && (
                    <div>
                                             <h4 className="text-[10px] font-medium text-slate-700 mb-2 flex items-center gap-2">
                         <span className="inline-block w-1.5 h-1.5 rounded-full bg-blue-500" />
                         Aprendizaje esperado
                       </h4>
                      <div className="space-y-2">
                        {vm.expectedLearning.map((it: string, i: number) => (
                                                     <div key={`el-${i}`} className="text-[10px] text-slate-800 bg-gradient-to-br from-blue-50 to-indigo-50 border border-blue-100 rounded-lg px-3 py-2">
                             {it}
                           </div>
                        ))}
                      </div>
                    </div>
                  )}
                  <div>
                    {vm.keyPoints && vm.keyPoints.length > 0 && (
                      <div>
                                                 <h4 className="text-[10px] font-medium text-slate-700 mb-2 flex items-center gap-2">
                           <span className="inline-block w-1.5 h-1.5 rounded-full bg-blue-500" />
                           Puntos clave
                         </h4>
                        <div className="space-y-2">
                          {vm.keyPoints.map((kp: any) => (
                                                         <div key={kp.id} className={`p-3 rounded-lg border ${kp.completed ? 'bg-gradient-to-br from-green-50 to-green-100 border-green-200' : 'bg-gradient-to-br from-blue-50 to-indigo-50 border-blue-100'}`}>
                               <div className="text-[10px] font-medium text-slate-800">{kp.title}</div>
                               {kp.description && <div className="text-[9px] text-slate-600 mt-1">{kp.description}</div>}
                             </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                  <div className="pt-2 border-t border-slate-200">
                                         <div className="flex justify-between text-xs mb-1">
                       <span className="text-slate-600">Momento</span>
                       <span className="font-medium text-slate-900">{vm.moments.length > 0 ? Math.min(state.momentIdx + 1, vm.moments.length) : 0}/{vm.moments.length}</span>
                     </div>
                    <div className="w-full bg-slate-100 rounded-full h-2">
                      <div className="bg-gradient-to-r from-blue-600 to-indigo-600 h-2 rounded-full transition-all" style={{ width: `${Math.round(((vm.moments.length > 0 ? Math.min(state.momentIdx + 1, vm.moments.length) : 0) / Math.max(1, vm.moments.length)) * 100)}%` }} />
                    </div>
                                         <div className="mt-3">
                       <h4 className="text-[10px] font-medium text-slate-700 mb-2">Momentos</h4>
                      <div className="space-y-2">
                        {vm.moments.map((m: any, i: number) => (
                                                     <div
                             key={`${m.title}-${i}`}
                             className={`flex items-center gap-3 text-[10px] p-3 rounded-xl border transition-all duration-200 ${
                              i === state.momentIdx
                                ? 'bg-blue-50 border-blue-300 shadow-sm ring-2 ring-blue-200 text-blue-700'
                                : i < state.momentIdx
                                  ? 'bg-gradient-to-br from-green-50 to-green-100 border-green-200 text-green-700'
                                  : 'bg-white border-slate-200 hover:bg-slate-50 hover:border-slate-300 text-slate-600'
                            }`}
                          >
                            <span
                              className={`w-2.5 h-2.5 rounded-full ${
                                i < state.momentIdx ? 'bg-green-600' : (i === state.momentIdx ? 'bg-blue-600' : 'bg-slate-300')
                              }`}
                            />
                            <span className="truncate">{m.title}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </>
              )}
            </div>
          </div>
        </div>

        {/* Main chat (centro, m√°s ancho que multimedia) */}
        <div className={`transition-all duration-300 w-full flex-1 min-w-[420px] min-h-0`}>
          <div className="h-full bg-white mx-3 my-0 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            {/* Messages */}
            <div ref={messagesScrollRef} className="flex-1 overflow-y-auto p-6 space-y-6 min-h-0 pb-20 overscroll-contain" onScroll={onMessagesScroll}>
              {messages.map((m) => (
                <div key={m.id} className={`flex items-start space-x-4 ${m.sender === 'student' ? 'flex-row-reverse space-x-reverse' : ''}`}>
                  {m.sender === 'ai' ? (
                    <button
                      type="button"
                      className="w-10 h-10 rounded-full overflow-hidden ring-2 ring-blue-500 shadow-md bg-white flex items-center justify-center cursor-pointer"
                      onClick={() => vm?.avatarUrl && setPreviewSrc(vm.avatarUrl)}
                      aria-label="Ver foto de la instructora"
                    >
                      {vm?.avatarUrl ? (
                        <Image src={vm.avatarUrl} alt="Instructora" width={40} height={40} className="object-cover w-10 h-10" />
                      ) : (
                        <div className="w-10 h-10 flex items-center justify-center text-sm font-semibold bg-gradient-to-br from-blue-600 to-indigo-600 text-white">AI</div>
                      )}
                    </button>
                  ) : (
                    <div className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold shadow-md bg-gradient-to-br from-slate-600 to-slate-700 text-white">
                      <User className="w-5 h-5" />
                    </div>
                  )}
                  <div className={`flex-1 ${m.sender === 'student' ? 'text-right' : ''}`}>
                    <div className={`inline-block px-5 py-3 rounded-2xl shadow-sm max-w-[70ch] ${m.sender === 'student' ? 'bg-gradient-to-r from-blue-600 to-blue-700 text-white' : 'bg-white border border-slate-200 text-slate-900'}`}>
                      <p className="text-xs leading-relaxed whitespace-pre-wrap">{m.content}</p>
                    </div>
                    <div className={`mt-2 flex items-center space-x-2 ${m.sender === 'student' ? 'justify-end' : 'justify-start'}`}>
                      <Clock className="w-3 h-3 text-slate-400" />
                      <span className="text-[10px] text-slate-500">{m.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    </div>
                  </div>
                </div>
              ))}
              {isTyping && (
                <div className="flex items-start space-x-4">
                  <button
                    type="button"
                    className="w-10 h-10 rounded-full overflow-hidden ring-2 ring-blue-500 shadow-md bg-white flex items-center justify-center cursor-pointer"
                    onClick={() => vm?.avatarUrl && setPreviewSrc(vm.avatarUrl)}
                    aria-label="Ver foto de la instructora"
                  >
                    {vm?.avatarUrl ? (
                      <Image src={vm.avatarUrl} alt="Instructora" width={40} height={40} className="object-cover w-10 h-10" />
                    ) : (
                      <div className="w-10 h-10 flex items-center justify-center text-sm font-semibold bg-gradient-to-br from-blue-600 to-indigo-600 text-white">AI</div>
                    )}
                  </button>
                  <div className="inline-flex items-center gap-1 bg-white border border-slate-200 text-slate-500 px-3 py-2 rounded-2xl">
                    <span className="sr-only">Escribiendo‚Ä¶</span>
                    <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.2s]"></span>
                    <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.1s]"></span>
                    <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce"></span>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <div className="px-6 py-3 border-t border-slate-200 bg-slate-50 rounded-b-2xl">
              <div className="flex items-end space-x-2">
                <textarea
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKey}
                  placeholder="Escribe tu respuesta..."
                  rows={1}
                  className="flex-1 w-full px-4 py-3 bg-white border border-slate-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  style={{ minHeight: '48px', maxHeight: '120px' }}
                />
                <VoiceRecorder onResult={(t)=>setInputValue((v)=> (v ? (v+ ' ' + t) : t))} />
                <button onClick={handleSend} disabled={!inputValue.trim()} className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-slate-300 disabled:to-slate-400 text-white p-3 rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg disabled:shadow-none">
                  <Send className="w-5 h-5" />
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Right side: Contenido Multimedia */}
        <div className={`hidden lg:block transition-all duration-300 ${sidebarOpen ? 'lg:basis-[30%] xl:basis-[32%]' : 'lg:basis-[30%] xl:basis-[32%]'} min-w-[320px]`}>
          <div className="h-full bg-white mx-3 my-0 rounded-2xl shadow-sm border border-slate-200 flex flex-col min-h-0">
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="text-sm font-semibold text-slate-900">Contenido Multimedia</h3>
            </div>
            <div className="flex-1 p-6 min-h-0 overflow-y-auto overscroll-contain">
              {isTyping || !currentMultimedia?.length ? (
                <div className="bg-gradient-to-br from-slate-100 to-slate-200 rounded-xl text-slate-400 border border-slate-200 flex items-center justify-center aspect-video min-h-[360px]">
                  <span className="text-xs">{isTyping ? 'Pensando‚Ä¶' : 'Sin contenido para este paso'}</span>
                </div>
              ) : (
                <>
                  <div className="relative rounded-xl overflow-hidden border border-slate-200 aspect-video bg-black/5">
                    <img
                      src={visibleMultimedia[Math.min(mediaIdx, Math.max(0, visibleMultimedia.length - 1))]?.url}
                      alt="Paso"
                      className="absolute inset-0 w-full h-full object-cover"
                      loading="eager"
                      fetchPriority="high"
                    />
                  </div>
                  <div className="mt-3 text-xs text-slate-700 text-center">
                    {(visibleMultimedia[Math.min(mediaIdx, Math.max(0, visibleMultimedia.length - 1))]?.caption
                      || visibleMultimedia[Math.min(mediaIdx, Math.max(0, visibleMultimedia.length - 1))]?.description
                      || visibleMultimedia[Math.min(mediaIdx, Math.max(0, visibleMultimedia.length - 1))]?.name
                      || '')}
                  </div>
                  {visibleMultimedia.length > 0 && (
                    <div className="flex flex-col space-y-2 mt-3">
                      {visibleMultimedia.map((image, index) => (
                        <label
                          key={`mopt-${index}`}
                          className={`flex items-center space-x-3 cursor-pointer p-3 rounded-xl border transition-all duration-200 ${
                            mediaIdx === index
                              ? 'bg-blue-50 border-blue-300 shadow-sm ring-2 ring-blue-200'
                              : 'bg-white border-slate-200 hover:bg-slate-50 hover:border-slate-300'
                          }`}
                        >
                          <input
                            type="radio"
                            name="imageSelector"
                            checked={mediaIdx === index}
                            onChange={() => setMediaIdx(index)}
                            className={`w-4 h-4 focus:ring-2 focus:ring-blue-500 ${
                              mediaIdx === index
                                ? 'text-blue-600 bg-blue-600 border-blue-600'
                                : 'text-blue-600 bg-white border-slate-300'
                            }`}
                          />
                          <span className={`text-xs font-medium ${mediaIdx === index ? 'text-blue-700' : 'text-slate-700'}`}>
                            {image?.caption || image?.name || `Imagen ${index + 1}`}
                          </span>
                        </label>
                      ))}
                    </div>
                  )}
                </>
              )}
                             <div className="mt-4 text-[10px] text-slate-600">Contenido multimedia de la sesi√≥n</div>
            </div>
          </div>
        </div>
      </div>
      {previewSrc && (
        <div
          className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4"
          onClick={() => setPreviewSrc(null)}
        >
          <div className="relative bg-white rounded-xl shadow-xl p-2" onClick={(e) => e.stopPropagation()}>
            <button
              type="button"
              className="absolute -top-3 -right-3 bg-white rounded-full shadow p-1 border"
              onClick={() => setPreviewSrc(null)}
              aria-label="Cerrar"
            >
              <X className="w-4 h-4" />
            </button>
            <Image
              src={previewSrc}
              alt="Sophia Fuentes"
              width={640}
              height={640}
              className="max-h-[80vh] h-auto w-auto rounded-lg"
              priority
            />
          </div>
        </div>
      )}
    </div>
  );
}


```
=== EOF: src\components\EngineChatLayout.tsx

===  public\media\SSO001.json
```json
{
    "M1-Q01": {
      "items": [
        { "url": "https://thewowstyle.com/wp-content/uploads/2015/01/nature-images..jpg", "caption": "Base 1" },
        { "url": "https://thewowstyle.com/wp-content/uploads/2015/01/nature-images..jpg", "caption": "Base 2" }

      ]
    },
    "M2-Q01": {
      "items": [
        { "url": "https://tse3.mm.bing.net/th/id/OIP.lEIXIAuERshElh8uJBp-JwHaE7?rs=1&pid=ImgDetMain&o=7&rm=3", "caption": "Base 4" },
        { "url": "https://tse2.mm.bing.net/th/id/OIP.8iergpw7gn3VQhfCf2X2XAHaJ4?w=1280&h=1707&rs=1&pid=ImgDetMain&o=7&rm=3", "caption": "Base 5" }

      ],
      "hintItems": [
        { "url": "https://tse4.mm.bing.net/th/id/OIP.ZZ5lu48NgI11nCT4q-gJEQHaEo?pid=ImgDet&w=474&h=296&rs=1&o=7&rm=3", "caption": "Pista 1" },
        { "url": "https://tse2.mm.bing.net/th/id/OIP.KJRiBJJ4iAzfb9ZzgP4R-wHaEo?w=2880&h=1800&rs=1&pid=ImgDetMain&o=7&rm=3", "caption": "Pista 2" },
        { "url": "https://tse1.mm.bing.net/th/id/OIP.NEURNN7JDV6LrTsRWh_jXgHaEK?w=1920&h=1080&rs=1&pid=ImgDetMain&o=7&rm=3", "caption": "Pista 3" }
      ]
    }
  }
```
=== EOF: public\media\SSO001.json

===  src\ai\tracing.ts
```typescript
export type TraceEvent = {
	name: string;
	timestamp: number;
	props?: Record<string, unknown>;
};

export function trace(event: TraceEvent) {
	try {
		if (process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true') {
			// eslint-disable-next-line no-console
			console.debug(JSON.stringify({ tag: 'trace', ...event }));
		}
	} catch {
		// noop
	}
}


```
=== EOF: src\ai\tracing.ts

===  src\ai\realtime.ts
```typescript
export type RealtimeSessionConfig = {
	transport?: 'websocket' | 'webrtc';
	url?: string;
};

export class RealtimeClientStub {
	private readonly config: RealtimeSessionConfig;

	constructor(config: RealtimeSessionConfig = {}) {
		this.config = config;
	}

	async connect(): Promise<void> {
		// Stub only: integration planned with @openai/agents Realtime
		return;
	}

	async sendAudioChunk(_pcm16: ArrayBuffer): Promise<void> {
		// Stub
		return;
	}

	async close(): Promise<void> {
		// Stub
		return;
	}
}


```
=== EOF: src\ai\realtime.ts

===  src\ai\prompt.ts
```typescript
import type { DocenteAction, DocentePromptContext } from './prompt_parts/types';
import { buildSystemPrompt as buildSystemPromptParts } from './prompt_parts/system';
import { renderAsk, renderExplain, renderFeedback, renderHint } from './prompt_parts/user';

export function buildSystemPrompt(ctx: DocentePromptContext): string { return buildSystemPromptParts(ctx); }

export function buildUserPrompt(ctx: DocentePromptContext): string {
  const lines: string[] = [];

  // Helpers
  const pushIf = (cond: any, s: string) => { if (cond) lines.push(s.trim()); };
  const hasAny = (...vals: Array<string | string[] | undefined | null>) =>
    vals.some(v => Array.isArray(v) ? v.filter(Boolean).length > 0 : !!v);

  // Header
  pushIf(true, `Momento: ${ctx.momentTitle || ''}`); // permite vac√≠o pero mantiene etiqueta
  pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);

  // Normalizaciones
  const contentItems = Array.from(new Set((ctx.contentBody || [])
    .filter(Boolean)
    .map(s => String(s).trim())))
    .slice(0, 20);
  const safeAnswer = String(ctx.userAnswer || '').trim().slice(0, 300);
  const matched = Array.from(new Set(ctx.matched || [])).filter(Boolean).slice(0, 8);
  const missing = Array.from(new Set(ctx.missing || [])).filter(Boolean).slice(0, 8);
  const recent = (ctx.recentHistory || []).slice(-3).join(' | ');
  pushIf(recent, `Historial reciente: ${recent}`);
  pushIf(ctx.closureCriteria, `Criterio de cierre: ${ctx.closureCriteria}`);

  switch (ctx.action) {
    case 'explain': { renderExplain(ctx, lines, contentItems); break; }

    case 'ask': { renderAsk(ctx, lines); break; }

    case 'hint': { renderHint(ctx, lines, contentItems, matched, missing); break; }

    case 'ask_simple': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const opts = Array.from(new Set(ctx.simpleOptions || [])).filter(Boolean).slice(0, 5);
      if (opts.length) {
        lines.push(`Opciones (elige una): ${opts.join(' / ')}`);
      }
      lines.push('Tarea: formula la elecci√≥n de forma clara y breve. No re‚Äënarrar el caso.');
      break;
    }

    case 'ask_options': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      const items = Array.from(new Set(ctx.optionItems || [])).filter(Boolean).slice(0, 5);
      if (items.length) {
        const labeled = items.map((s, i) => `${String.fromCharCode(65 + i)}) ${s}`);
        lines.push(`Opciones (alineadas al Objetivo): ${labeled.join(' | ')}`);
      }
      lines.push('Tarea: pide que elija una opci√≥n (A, B, C, ‚Ä¶) y espera su selecci√≥n. No re‚Äënarrar el caso. Si procede, recuerda en 1 frase c√≥mo la elecci√≥n ayuda a cumplir el Objetivo.');
      break;
    }

    case 'ok': {
      if (!ctx.questionText) lines.push('Falta la pregunta que se est√° validando.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      lines.push('Tarea: en 1‚Äì2 frases, reconoce lo correcto citando los aciertos y, si aplica, orienta brevemente lo que falta, sin preguntas. No introduzcas contenido nuevo.');
      break;
    }

    case 'advance': {
      lines.push('Tarea: puente corto al siguiente foco en ‚â§14 palabras.');
      lines.push('Formato de salida: EXACTAMENTE 1 l√≠nea:');
      lines.push('PUENTE: <tu puente breve>');
      break;
    }

    case 'end': {
      lines.push('Tarea: cierre final breve.');
      break;
    }

    case 'feedback': { renderFeedback(ctx, lines, contentItems, matched, missing); break; }

    default: {
      lines.push(`Acci√≥n desconocida: ${String((ctx as any).action)}`);
      break;
    }
  }

  // Limpieza final: sin l√≠neas vac√≠as y con espacios normalizados
  return lines
    .map(s => s.trim())
    .filter(Boolean)
    .join('\n');
}


```
=== EOF: src\ai\prompt.ts

===  src\ai\outputGuardrails.ts
```typescript
import type { DocentePromptContext } from './prompt_parts/types';

function normalizeWhitespace(text: string): string {
  return String(text || '').replace(/\s+/g, ' ').trim();
}

function splitIntoSentences(text: string): string[] {
  const raw = normalizeWhitespace(text);
  if (!raw) return [];
  return raw.split(/(?<=[\.!?])\s+/).map(s => s.trim()).filter(Boolean);
}

function joinFirstSentences(text: string, maxSentences: number): string {
  const sentences = splitIntoSentences(text);
  return sentences.slice(0, Math.max(1, maxSentences)).join(' ').trim();
}

function removeInterrogativeSentences(text: string): string {
  const sentences = splitIntoSentences(text);
  const kept = sentences.filter(s => !/[?¬ø]\s*$/.test(s));
  return kept.join(' ').trim();
}

function wordCount(text: string): number {
  const t = normalizeWhitespace(text);
  if (!t) return 0;
  return t.split(' ').length;
}

function truncateToWords(text: string, maxWords: number): string {
  const t = normalizeWhitespace(text);
  if (!t) return '';
  const parts = t.split(' ');
  if (parts.length <= maxWords) return t;
  return parts.slice(0, Math.max(1, maxWords)).join(' ').trim();
}

export function guardHintOutput(
  ctx: DocentePromptContext,
  out: { message: string; followUp?: string }
): { message: string; followUp: string } {
  const limit = Number(ctx.hintWordLimit || 18);

  // Limpiar followUp (MICRO)
  let fu = String(out.followUp || '').replace(/^\s*MICRO\s*:\s*/i, '').trim();
  if (!fu) {
    fu = String(ctx.questionText || '').trim();
  }
  // ‚â§ 8 palabras
  fu = truncateToWords(fu, 8);

  // Limpiar message (PISTA)
  let msg = String(out.message || '')
    .replace(/^\s*PISTA\s*:\s*/i, '')
    .replace(/^\s*te\s+doy\s+una\s+pista\s*:\s*/i, '')
    .trim();
  // Sin preguntas en pista
  msg = removeInterrogativeSentences(msg);
  // L√≠mite de palabras
  msg = truncateToWords(msg, limit);

  return { message: msg, followUp: fu };
}

export function guardAdvanceOutput(
  _ctx: DocentePromptContext,
  message: string
): string {
  if (!message) return 'Puente breve al siguiente foco.';
  // Breve y sin preguntas
  let out = removeInterrogativeSentences(message);
  out = joinFirstSentences(out, 2);
  return out || 'Puente breve al siguiente foco.';
}

export function guardFeedbackOutput(
  ctx: DocentePromptContext,
  message: string,
  maxSentences: number = 3
): string {
  let out = String(message || '').trim();
  if (ctx.allowQuestions === false) {
    out = removeInterrogativeSentences(out);
  }
  out = joinFirstSentences(out, Math.max(1, maxSentences));
  return out;
}
```
=== EOF: src\ai\outputGuardrails.ts

===  src\ai\orchestrator.ts
```typescript
import { getClient, pickModel } from '@/lib/ai';
import type { DocentePromptContext } from './prompt_parts/types';
import { buildSystemPrompt, buildUserPrompt } from './prompt';
import { guardAdvanceOutput, guardFeedbackOutput, guardHintOutput } from './outputGuardrails';
import { trace } from './tracing';

function stripQuestions(text?: string): string {
  const raw = (text || '').trim();
  if (!raw) return '';
  const sentences = raw.split(/(?<=[\.!?¬ø])\s+/).filter(Boolean);
  return sentences.filter(s => !/[?¬ø]\s*$/.test(s.trim())).join(' ');
}

function lastQuestion(text?: string): string {
  const lines = (text || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
  const qs = lines.filter(l => /[?¬ø]\s*$/.test(l));
  return qs[qs.length - 1] || '';
}

function normalizeForMatch(s: string): string {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

// Anti re‚Äënarraci√≥n: elimina p√°rrafos exactos presentes en el historial reciente
function stripRepeatedFromHistory(text: string, ctx: DocentePromptContext): string {
  const raw = (text || '').trim();
  if (!raw || !Array.isArray(ctx.recentHistory) || ctx.recentHistory.length === 0) return raw;
  const historyBlob = normalizeForMatch(ctx.recentHistory.join(' \n '));
  const paras = raw.split(/\n\n+/).map(s => s.trim()).filter(Boolean);
  const kept: string[] = [];
  for (const p of paras) {
    const pNorm = normalizeForMatch(p);
    const isRepeated = pNorm.length >= 60 && historyBlob.includes(pNorm);
    if (!isRepeated) kept.push(p);
  }
  return kept.join('\n\n').trim();
}

// Antiduplicaci√≥n interna
function stripSelfDuplicates(text: string): string {
  const raw = (text || '').trim();
  if (!raw) return '';
  const bannedStart = /^los\s+procedimientos\s+de\s+seguridad\s+incluyen/i;
  const normMap = new Set<string>();
  const bannedSeen = new Set<string>();

  const paragraphs = raw.split(/\n\n+/).map(s => s.trim()).filter(Boolean);
  const keptParas: string[] = [];
  for (const p of paragraphs) {
    const sentences = p.split(/(?<=[\.!?])\s+/).map(s => s.trim()).filter(Boolean);
    const keptSentences: string[] = [];
    for (const s of sentences) {
      if (!s) continue;
      const n = normalizeForMatch(s);
      if (!n) continue;
      if (bannedStart.test(s)) {
        const key = 'banned:los_procedimientos_de_seguridad_incluyen';
        if (bannedSeen.has(key)) continue;
        bannedSeen.add(key);
      }
      if (normMap.has(n)) continue;
      normMap.add(n);
      keptSentences.push(s);
    }
    const joined = keptSentences.join(' ')
      .replace(/\s+\n/g, '\n')
      .trim();
    if (joined) keptParas.push(joined);
  }
  return keptParas.join('\n\n').trim();
}

export async function runDocenteLLM(ctx: DocentePromptContext): Promise<{ message: string; followUp?: string }> {
  const system = buildSystemPrompt(ctx);
  const user = buildUserPrompt(ctx);
  const model = pickModel('cheap');
  const temp = ctx.conversationMode ? 0.4 : 0.3;
  let offline = false;
  let out = '';
  try {
    trace({ name: 'llm.call', timestamp: Date.now(), props: { action: ctx.action, model, temp } });
    const client = getClient();
    const r = await client.responses.create({
      model,
      input: [
        { role: 'system', content: system },
        { role: 'user', content: user },
      ],
      temperature: temp,
    });
    out = ((r as any).output_text || '').trim();
    trace({ name: 'llm.ok', timestamp: Date.now(), props: { action: ctx.action, chars: out.length } });
  } catch (err: any) {
    offline = true;
    try { console.error('[LLM_ERROR]', String(err?.message || err)); } catch {}
    trace({ name: 'llm.error', timestamp: Date.now(), props: { action: ctx.action, error: String(err?.message || err) } });
  }

  if (!offline) {
    if (ctx.action === 'explain') {
      return { message: stripQuestions(out) };
    }
    if (ctx.action === 'ask') {
      const q = (ctx.questionText || '').trim();
      let msg = (ctx.conversationMode ? out : stripQuestions(out)).replace(/^\s*Docente\s*:\s*/i, '').trim();
      msg = stripRepeatedFromHistory(msg, ctx);
      msg = stripSelfDuplicates(msg);
      const norm = (s: string) => s.replace(/\s+/g, ' ').toLowerCase();
      const already = norm(msg).includes(norm(q));
      const merged = already ? msg : [msg, q].filter(Boolean).join('\n\n');
      return { message: merged };
    }
    if (ctx.action === 'ok' || ctx.action === 'advance') {
      let raw = out.replace(/^\s*Docente\s*:\s*/i, '').trim();
      if (ctx.action === 'advance') {
        const m = raw.match(/PUENTE\s*:\s*(.+)$/im);
        if (m) {
          const bridge = stripSelfDuplicates(stripQuestions(m[1] || '').trim());
          const guarded = guardAdvanceOutput(ctx, bridge);
          trace({ name: 'llm.out.advance', timestamp: Date.now(), props: { chars: guarded.length } });
          return { message: guarded };
        }
      }
      let msg = stripQuestions(raw);
      msg = stripRepeatedFromHistory(msg, ctx);
      msg = stripSelfDuplicates(msg);
      const guarded = guardAdvanceOutput(ctx, msg);
      trace({ name: 'llm.out.advance', timestamp: Date.now(), props: { chars: guarded.length } });
      return { message: guarded };
    }
    if (ctx.action === 'hint') {
      let raw = out.replace(/^\s*Docente\s*:\s*/i, '').trim();
      const microMatch = raw.match(/^\s*MICRO\s*:\s*(.+)$/im);
      const pistaMatch = raw.match(/^\s*PISTA\s*:\s*(.+)$/im);
      if (microMatch || pistaMatch) {
        const fuLines = (microMatch?.[1] || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
        const fu = (fuLines[0] || '').trim();
        let hint = (pistaMatch?.[1] || '').trim();
        hint = hint.replace(/^te\s+doy\s+una\s+pista\s*:\s*/i, '').trim();
        const cleaned = stripSelfDuplicates(stripRepeatedFromHistory(stripQuestions(hint), ctx));
        const guarded = guardHintOutput(ctx, { message: cleaned, followUp: fu });
        trace({ name: 'llm.out.hint', timestamp: Date.now(), props: { fuChars: (fu || '').length, msgChars: (guarded.message || '').length } });
        return guarded;
      }
      let msg = stripQuestions(raw).trim();
      msg = stripRepeatedFromHistory(msg, ctx);
      msg = stripSelfDuplicates(msg);
      const follow = lastQuestion(raw);
      const guarded = guardHintOutput(ctx, { message: msg, followUp: follow });
      trace({ name: 'llm.out.hint', timestamp: Date.now(), props: { fuChars: (follow || '').length, msgChars: (guarded.message || '').length } });
      return guarded;
    }
    if (ctx.action === 'ask_simple' || ctx.action === 'ask_options') {
      const msg = stripSelfDuplicates(stripRepeatedFromHistory(out.replace(/^\s*Docente\s*:\s*/i, '').trim(), ctx));
      trace({ name: 'llm.out.ask', timestamp: Date.now(), props: { chars: msg.length, kind: ctx.action } });
      return { message: msg };
    }
    if (ctx.action === 'feedback') {
      let raw = out.replace(/^\s*Docente\s*:\s*/i, '').trim();
      let msg = ctx.conversationMode ? raw : stripQuestions(raw);
      msg = stripSelfDuplicates(stripRepeatedFromHistory(msg, ctx));
      const guarded = guardFeedbackOutput({ ...ctx, allowQuestions: ctx.allowQuestions }, msg);
      trace({ name: 'llm.out.feedback', timestamp: Date.now(), props: { chars: guarded.length, kind: (ctx as any).kind } });
      return { message: guarded };
    }
    trace({ name: 'llm.out.raw', timestamp: Date.now(), props: { chars: out.length } });
    return { message: out };
  }

  const q = (ctx.questionText || '').trim();
  if (ctx.action === 'explain') {
    const parts = [
      ctx.narrationText,
      ...(Array.isArray(ctx.contentBody) ? ctx.contentBody : []),
      ctx.caseText,
      ctx.objective,
    ].filter(Boolean).join(' ');
    return { message: stripQuestions(parts).slice(0, 400) };
  }
  if (ctx.action === 'ask') {
    return { message: q };
  }
  if (ctx.action === 'advance') {
    return { message: 'Puente breve al siguiente foco.' };
  }
  if (ctx.action === 'hint') {
    return { message: 'Te doy una pista: menciona 1‚Äì2 elementos clave del objetivo.', followUp: q ? q : '¬øUna micro‚Äëpregunta?' };
  }
  if (ctx.action === 'ask_simple' || ctx.action === 'ask_options') {
    return { message: q };
  }
  if (ctx.action === 'feedback') {
    return { message: 'FB: refuerzo/gu√≠a breve.' };
  }
  return { message: q };
}


```
=== EOF: src\ai\orchestrator.ts

===  src\ai\ab.ts
```typescript
export type ABVariant = 'A' | 'B';

export function pickVariant(sessionKey?: string): ABVariant {
	const key = String(sessionKey || 'default');
	let hash = 0;
	for (let i = 0; i < key.length; i++) hash = (hash * 31 + key.charCodeAt(i)) | 0;
	return (Math.abs(hash) % 2) === 0 ? 'A' : 'B';
}

export function varyHintLimit(base: number, variant: ABVariant): number {
	// B empuja un 20% m√°s largo (tope 60)
	if (variant === 'B') return Math.min(Math.round(base * 1.2), 60);
	return base;
}


```
=== EOF: src\ai\ab.ts

===  public\courses\registry.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "SSO001",
      "lessons": [
        {
          "id": "lesson02",
          "name": "Lecci√≥n 02",
          "planUrl": "/courses/SSO001/lessons/lesson02.json"
        },
        {
          "id": "lesson01",
          "name": "IPERC Continuo - Identificaci√≥n y Control de Riesgos",
          "planUrl": "/courses/SSO001/lessons/lesson01.json"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\registry.json

===  app\login\page.tsx
```tsx
import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/authOptions";
import LoginButton from "@/components/LoginButton";

export default async function LoginPage() {
  const session = await getServerSession(authOptions);
  if (session) {
    redirect("/engine-chat");
  }

  return (
    <main className="min-h-screen flex items-center justify-center bg-gray-50 p-6">
      <div className="w-full max-w-sm rounded-xl border bg-white p-8 shadow-sm">
        <div className="mb-6 text-center">
          <h1 className="text-2xl font-semibold">Bienvenido</h1>
          <p className="mt-1 text-sm text-gray-500">Inicia sesi√≥n para continuar</p>
        </div>
        <LoginButton />
      </div>
    </main>
  );
}



```
=== EOF: app\login\page.tsx

===  app\engine-chat\page.tsx
```tsx
"use client";
import EngineChatLayout from '@/components/EngineChatLayout';
import { usePlanChat } from '@/hooks/usePlanChat';
import { useEffect, useMemo, useState } from 'react';
import { useSearchParams } from 'next/navigation';

type LessonRef = { id: string; name?: string; planUrl: string };
type CourseRef = { id: string; name?: string; lessons: LessonRef[] };
type Registry = { courses: CourseRef[] };

export default function EngineChatPage() {
  const [registry, setRegistry] = useState<Registry | null>(null);
  const [selectedCourseId, setSelectedCourseId] = useState<string>('');
  const [selectedLessonId, setSelectedLessonId] = useState<string>('');
  const [lessonVM, setLessonVM] = useState<any>(null);
  const searchParams = useSearchParams();

  // derive current planUrl from selection
  const planUrl: string | null = useMemo(() => {
    if (!registry || !selectedCourseId || !selectedLessonId) return null;
    const course = registry.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return lesson?.planUrl || null;
  }, [registry, selectedCourseId, selectedLessonId]);

  const { messages, isTyping, done, sendMessage, clearMessages, adaptiveMode, setAdaptiveMode, budgetMetrics, state } = usePlanChat(planUrl || '');
  const showControls = false;

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        const res = await fetch('/courses/registry.json');
        if (!res.ok) return;
        const json = (await res.json()) as Registry;
        if (!alive) return;
        setRegistry(json);
        // selecci√≥n por querystring o por defecto (primer curso/lecci√≥n)
        const qCourse = searchParams?.get('course');
        const qLesson = searchParams?.get('lesson');
        const fallbackCourse = json.courses?.[0];
        const course = (qCourse && json.courses.find(c => c.id === qCourse)) || fallbackCourse;
        if (course) {
          setSelectedCourseId(prev => prev || course.id);
          const fallbackLesson = course.lessons?.[0];
          const lesson = (qLesson && course.lessons.find(l => l.id === qLesson)) || fallbackLesson;
          if (lesson) setSelectedLessonId(prev => prev || lesson.id);
        }
      } catch {}
    })();
    return () => { alive = false; };
  }, [searchParams]);

  // Cargar el plan y construir VM (aprendizaje esperado, puntos clave y momentos) al cambiar planUrl
  useEffect(() => {
    let alive = true;
    if (!planUrl) return;
    (async () => {
      try {
        // Evitar caching del navegador durante edici√≥n
        const res = await fetch(`${planUrl}${planUrl.includes('?') ? '&' : '?'}ts=${Date.now()}`, { cache: 'no-store' } as any);
        if (!res.ok) return;
        const plan = await res.json();
        if (!alive) return;
        // Fusionar media del plan con documento externo en /public/media/{course}.json
        // Si el plan ya trae im√°genes por momento, priorizamos esas y evitamos arrastrar media global que pueda colisionar entre lecciones
        let mergedMedia: any = plan?.media || {};
        const hasMomentImages = Array.isArray(plan?.moments) && (plan.moments as any[]).some((m: any) => Array.isArray(m?.images) && m.images.length > 0);
        if (!hasMomentImages) {
          try {
            const docUrl = selectedCourseId ? `/media/${selectedCourseId}.json` : '/media/SSO001.json';
            const mRes = await fetch(`/api/media?planUrl=${encodeURIComponent(planUrl)}&docUrl=${encodeURIComponent(docUrl)}`);
            if (mRes.ok) {
              const mJson = await mRes.json();
              mergedMedia = mJson?.media || mergedMedia;
            }
          } catch {}
        }
        const moments = (plan.moments || []).map((m: any) => ({ title: m.title, images: m.images }));
        const keyPoints: Array<{ id: string; title: string; description?: string; completed?: boolean }> = [];
        const expectedLearning: string[] = [];
        (plan.moments || []).forEach((m: any, mi: number) => {
          (m.steps || []).forEach((s: any) => {
            if (String(s.type || '').toUpperCase() === 'EXPECTED_LEARNING') {
              (s.items || []).forEach((it: string) => expectedLearning.push(it));
            }
            if (String(s.type || '').toUpperCase() === 'KEY_POINTS') {
              (s.items || []).forEach((title: string, idx: number) => {
                keyPoints.push({ id: `${s.code || `M${mi + 1}-KP`}-${idx}` , title, completed: false });
              });
            }
          });
        });
        setLessonVM({
          version: plan?.meta?.version || 'plan',
          locale: plan?.meta?.language || 'es',
          moments,
          keyPoints,
          expectedLearning,
          avatarUrl: '/image/sophia_fuentes.png',
          media: mergedMedia
        });
      } catch {}
    })();
    return () => { alive = false; };
  }, [planUrl]);

  // Simple VM/state placeholders for EngineChatLayout
  const vm = useMemo(() => {
    const course = registry?.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return {
      title: [course?.name || course?.id, lesson?.name || lesson?.id].filter(Boolean).join(' ¬∑ ') || 'DocenteIA',
      version: lessonVM?.version || 'plan',
      locale: lessonVM?.locale || 'es-CL',
      moments: lessonVM?.moments || [],
      keyPoints: lessonVM?.keyPoints || [],
      expectedLearning: lessonVM?.expectedLearning || [],
      avatarUrl: lessonVM?.avatarUrl || '/image/sophia_fuentes.png',
      media: lessonVM?.media || {}
    } as any;
  }, [registry, selectedCourseId, selectedLessonId, lessonVM]);

  const layoutState = useMemo(() => ({
    momentIdx: state?.momentIdx || 0,
    stepCode: (state as any)?.stepCode,
    hintsUsed: (state as any)?.hintsUsed,
    maxHints: (state as any)?.maxHints
  }), [state?.momentIdx, (state as any)?.stepCode, (state as any)?.hintsUsed, (state as any)?.maxHints]);

  return (
    <div className="fixed inset-0 bg-slate-100 overflow-hidden">
      <div className="w-full h-full min-h-0 px-0 pt-2 pb-0 flex flex-col overflow-hidden">
        {showControls && (
          <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4 mb-4 flex flex-col md:flex-row gap-3">
            <div className="flex-1 grid grid-cols-1 md:grid-cols-3 gap-3">
              <select
                className="border rounded-lg px-3 py-2"
                value={selectedCourseId}
                onChange={(e) => { setSelectedCourseId(e.target.value); setSelectedLessonId(''); clearMessages(); }}
              >
                <option value="">Selecciona curso‚Ä¶</option>
                {registry?.courses.map(c => (
                  <option key={c.id} value={c.id}>{c.name || c.id}</option>
                ))}
              </select>
              <select
                className="border rounded-lg px-3 py-2"
                value={selectedLessonId}
                onChange={(e) => { setSelectedLessonId(e.target.value); clearMessages(); }}
                disabled={!selectedCourseId}
              >
                <option value="">Selecciona lecci√≥n‚Ä¶</option>
                {registry?.courses.find(c => c.id === selectedCourseId)?.lessons.map(l => (
                  <option key={l.id} value={l.id}>{l.name || l.id}</option>
                ))}
              </select>
              <div className="flex items-center gap-2">
                <button onClick={() => clearMessages()} className="border rounded-lg px-3 py-2">Nueva sesi√≥n</button>
                {done && <span className="text-green-600 text-sm">Fin de la lecci√≥n</span>}
              </div>
            </div>
            
            {/* Controles de modo adaptativo y presupuesto */}
            <div className="flex items-center gap-4 border-t pt-4 mt-4">
              <div className="flex items-center gap-2">
                <label className="text-sm font-medium">Modo:</label>
                <select 
                  value={adaptiveMode ? 'adaptive' : 'deterministic'} 
                  onChange={(e) => setAdaptiveMode(e.target.value === 'adaptive')}
                  className="border rounded-lg px-2 py-1 text-sm"
                >
                  <option value="deterministic">Determinista</option>
                  <option value="adaptive">Adaptativo</option>
                </select>
              </div>
              
              {budgetMetrics && (
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium">Presupuesto:</span>
                  <div className="w-32 bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${(budgetMetrics.budgetCentsLeft / 100) * 100}%` }}
                    ></div>
                  </div>
                  <span className="text-xs text-gray-600">
                    ${(budgetMetrics.budgetCentsLeft / 100).toFixed(2)}
                  </span>
                </div>
              )}
            </div>
          </div>
        )}

        <div className="flex-1 overflow-hidden">
          <EngineChatLayout
            messages={messages as any}
            isTyping={isTyping}
            onSend={(t) => sendMessage(t)}
            vm={vm}
            state={layoutState as any}
          />
        </div>
      </div>
    </div>
  );
}



```
=== EOF: app\engine-chat\page.tsx

===  .data\history\plan-1756359356199-mc7wv1v0.jsonl
```
{"ts":1756359358312,"sessionKey":"plan-1756359356199-mc7wv1v0","planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Bienvenida y objetivo de la sesi√≥n. Exploraremos qu√© son los procedimientos de seguridad y su relevancia en el trabajo. Procedimientos de Seguridad","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?","sender":"ai"}
```
=== EOF: .data\history\plan-1756359356199-mc7wv1v0.jsonl

===  .data\history\plan-1756350253620-lthn8nab.jsonl
```
{"ts":1756359172792,"sessionKey":"plan-1756350253620-lthn8nab","planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Bienvenida y objetivo de la sesi√≥n. Exploraremos qu√© son los procedimientos de seguridad y su relevancia en el trabajo. Procedimientos de Seguridad","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?","sender":"ai"}
```
=== EOF: .data\history\plan-1756350253620-lthn8nab.jsonl

===  .data\history\plan-1756316452419-1fye0jmx.jsonl
```
{"ts":1756350214297,"planUrl":"/courses/SSO001/lessons/lesson01.json","stepIdx":3,"momentIdx":0,"message":"Bienvenido. Hoy nos enfocaremos en el IPERC Continuo, que nos ayuda a identificar los peligros en un entorno, evaluar los riesgos asociados y determinar las medidas de control necesarias. Tambi√©n aprenderemos a estimar el riesgo residual, es decir, el riesgo que queda despu√©s de aplicar las medidas de control.","followUp":"¬øQu√© crees que sea un peligro y por qu√© es importante identificarlos?"}
```
=== EOF: .data\history\plan-1756316452419-1fye0jmx.jsonl

===  src\engine\flow\transition.ts
```typescript
export type TransitionAction = 'ask' | 'hint' | 'ask_simple' | 'ask_options' | 'explain' | 'ok';

export type EscalationConfig = {
  noSeToHint?: number;
  hintToAskSimple?: number;
  askSimpleToOptions?: number;
  hardStopToExplain?: number;
};

export function decideNextAction(params: {
  lastAction?: TransitionAction;
  classKind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  attempts: number;
  noSeCount: number;
  cfg?: EscalationConfig;
}): { nextAction: TransitionAction; resetNoSe?: boolean } {
  const { lastAction, classKind, attempts, noSeCount, cfg } = params;

  // Acierto expl√≠cito del clasificador
  if (classKind === 'ACCEPT') {
    return { nextAction: 'ok', resetNoSe: true };
  }

  // Si hay configuraci√≥n expl√≠cita, resp√©tala
  if (cfg) {
    const toHint = cfg.noSeToHint ?? Number.POSITIVE_INFINITY;
    const toSimple = cfg.hintToAskSimple ?? Number.POSITIVE_INFINITY;
    const toOptions = cfg.askSimpleToOptions ?? Number.POSITIVE_INFINITY;
    const toExplain = cfg.hardStopToExplain ?? Number.POSITIVE_INFINITY;

    if (lastAction === 'ask') {
      if (noSeCount >= toHint) return { nextAction: 'hint' };
      return { nextAction: 'ask' };
    }
    if (lastAction === 'hint') {
      if (noSeCount >= toSimple) return { nextAction: 'ask_simple' };
      return { nextAction: 'hint' };
    }
    if (lastAction === 'ask_simple') {
      if (noSeCount >= toOptions) return { nextAction: 'ask_options' };
      return { nextAction: 'ask_simple' };
    }
    if (lastAction === 'ask_options') {
      if (noSeCount >= toExplain) return { nextAction: 'explain' };
      return { nextAction: 'ask_options' };
    }
    // Fallback config-driven: empezar por ask
    return { nextAction: 'ask' };
  }

  // Sin configuraci√≥n: preferir feedback primero cuando hay se√±ales parciales
  if (classKind === 'PARTIAL') {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  } else {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  }
  return { nextAction: 'ask' };
}


```
=== EOF: src\engine\flow\transition.ts

===  src\app\login\page.tsx
```tsx
"use client";
import { signIn } from "next-auth/react";
import { useState } from "react";

export default function LoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    await signIn("credentials", { email, password, callbackUrl: "/engine-chat" });
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-6">
      <form onSubmit={onSubmit} className="w-full max-w-sm space-y-4 rounded-md border bg-white p-6 shadow-sm">
        <h1 className="text-lg font-semibold">Iniciar sesi√≥n</h1>
        <button
          type="button"
          onClick={() => signIn('google', { callbackUrl: '/engine-chat' })}
          className="w-full rounded border bg-white px-4 py-2 text-sm shadow-sm"
        >
          Continuar con Google
        </button>
        <div className="space-y-1">
          <label className="text-sm">Email</label>
          <input className="w-full rounded border px-3 py-2" value={email} onChange={e => setEmail(e.target.value)} />
        </div>
        <div className="space-y-1">
          <label className="text-sm">Password</label>
          <input type="password" className="w-full rounded border px-3 py-2" value={password} onChange={e => setPassword(e.target.value)} />
        </div>
        <button type="submit" className="w-full rounded bg-blue-600 px-4 py-2 text-white">Entrar</button>
      </form>
    </div>
  );
}
```
=== EOF: src\app\login\page.tsx

===  src\ai\tools\RagTool.ts
```typescript
import type { LessonPlan } from '@/plan/types';
import { embedTexts } from '@/engine/semvec';

export type RagItem = { text: string; vec: number[] };
export type RagIndex = { byItem: RagItem[] };

function chunkText(text: string, maxLen: number = 280): string[] {
	const t = String(text || '').trim();
	if (!t) return [];
	if (t.length <= maxLen) return [t];
	const sentences = t.split(/(?<=[\.\!\?])\s+/).map(s => s.trim()).filter(Boolean);
	const chunks: string[] = [];
	let cur = '';
	for (const s of sentences) {
		if ((cur + ' ' + s).trim().length > maxLen) {
			if (cur) chunks.push(cur.trim());
			cur = s;
		} else {
			cur = (cur ? cur + ' ' : '') + s;
		}
	}
	if (cur) chunks.push(cur.trim());
	return chunks;
}

export async function buildLessonRagIndex(plan?: LessonPlan): Promise<RagIndex | undefined> {
	try {
		if (!plan) return undefined;
		const texts: string[] = [];
		for (const step of plan.allSteps || []) {
			const t = String(step?.data?.text || '').trim();
			const body = Array.isArray(step?.data?.body) ? (step.data.body as string[]) : [];
			const q = String(step?.data?.question || '').trim();
			const objective = String(step?.data?.objective || '').trim();
			const acceptable = Array.isArray(step?.data?.acceptable_answers) ? (step.data.acceptable_answers as string[]) : [];
			if (t) texts.push(...chunkText(t));
			for (const b of body) texts.push(...chunkText(b));
			if (q) texts.push(q);
			if (objective) texts.push(objective);
			for (const a of acceptable) texts.push(...chunkText(a));
		}
		const items = Array.from(new Set(texts.map(s => s.trim()).filter(Boolean)));
		const vecs = await embedTexts(items);
		const byItem: RagItem[] = items.map((text, i) => ({ text, vec: vecs[i] || [] }));
		return { byItem };
	} catch {
		return undefined;
	}
}

function cosine(a: number[], b: number[]): number {
	let dot = 0;
	let na = 0;
	let nb = 0;
	const len = Math.min(a.length, b.length);
	for (let i = 0; i < len; i++) { dot += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
	if (!na || !nb) return 0;
	return dot / (Math.sqrt(na) * Math.sqrt(nb));
}

export async function retrieveTopK(query: string, index?: RagIndex, k: number = 3): Promise<string[]> {
	const q = String(query || '').trim();
	if (!q || !index || !Array.isArray(index.byItem) || index.byItem.length === 0) return [];
	const [qv] = await embedTexts([q]);
	if (!qv || qv.length === 0) return [];
	const scored = index.byItem.map(it => ({ text: it.text, score: cosine(qv, it.vec || []) }));
	scored.sort((a, b) => b.score - a.score);
	return scored.slice(0, Math.max(0, k)).map(s => s.text);
}

export async function retrieveTopKWithScores(query: string, index?: RagIndex, k: number = 3): Promise<Array<{ text: string; score: number }>> {
	const q = String(query || '').trim();
	if (!q || !index || !Array.isArray(index.byItem) || index.byItem.length === 0) return [];
	const [qv] = await embedTexts([q]);
	if (!qv || qv.length === 0) return [];
	const scored = index.byItem.map(it => ({ text: it.text, score: cosine(qv, it.vec || []) }));
	scored.sort((a, b) => b.score - a.score);
	return scored.slice(0, Math.max(0, k));
}

export async function maxSimilarity(query: string, index?: RagIndex): Promise<number> {
	const arr = await retrieveTopKWithScores(query, index, 1);
	return arr.length ? Math.max(0, arr[0].score || 0) : 0;
}


```
=== EOF: src\ai\tools\RagTool.ts

===  src\ai\tools\PolicyTool.ts
```typescript
export function getHintWordLimit(policies: any, hintsUsedOrSeverityIndex: number, fallbackLimits: number[] = [16, 28, 40]): number {
	try {
		const wl: number[] = Array.isArray(policies?.hints?.wordLimits)
			? (policies.hints.wordLimits as number[])
			: fallbackLimits;
		const idx = Math.min(Math.max(Number(hintsUsedOrSeverityIndex) || 0, 0), Math.max(0, wl.length - 1));
		const val = Number(wl[idx]);
		return Number.isFinite(val) ? val : fallbackLimits[0];
	} catch {
		return fallbackLimits[0];
	}
}


```
=== EOF: src\ai\tools\PolicyTool.ts

===  src\ai\tools\OptionsTool.ts
```typescript
export function pickTwoOptions(source: string[], fallback: string[] = []): string[] {
	const pool = Array.from(new Set([...(source || []), ...(fallback || [])].filter(Boolean)));
	if (pool.length <= 2) return pool;
	// prefer first relevant 2, but ensure deterministic order
	return pool.slice(0, 2);
}


```
=== EOF: src\ai\tools\OptionsTool.ts

===  src\ai\tools\InputGuardrail.ts
```typescript
export type NoSeDecision = {
	shouldForceAdvance: boolean;
	reason?: 'NOSE_THRESHOLD' | 'ATTEMPTS_MAX' | 'NONE';
};

export function decideForceAdvanceByNoSe(params: {
	noSeCount: number;
	forceNoSeThreshold: number; // e.g., 3
	allowForcedOn: string[]; // e.g., ['CONEXION']
	momentKind: string;
}): NoSeDecision {
	const { noSeCount, forceNoSeThreshold, allowForcedOn, momentKind } = params;
	if (
		forceNoSeThreshold > 0 &&
		noSeCount >= forceNoSeThreshold &&
		Array.isArray(allowForcedOn) && allowForcedOn.includes(String(momentKind))
	) {
		return { shouldForceAdvance: true, reason: 'NOSE_THRESHOLD' };
	}
	return { shouldForceAdvance: false, reason: 'NONE' };
}


```
=== EOF: src\ai\tools\InputGuardrail.ts

===  src\ai\prompt_parts\user.ts
```typescript
import type { DocentePromptContext } from './types';

const pushIf = (arr: string[], cond: any, s: string) => { if (cond) arr.push(s.trim()); };
const hasAny = (...vals: Array<string | string[] | undefined | null>) =>
  vals.some(v => Array.isArray(v) ? v.filter(Boolean).length > 0 : !!v);

export function renderExplain(ctx: DocentePromptContext, lines: string[], contentItems: string[]) {
  if (!hasAny(ctx.narrationText, contentItems, ctx.caseText)) {
    lines.push('Faltan insumos para explicar (narraci√≥n, contenido o caso).');
  }
  const payload = [
    ctx.narrationText ? `Narraci√≥n: ${ctx.narrationText}` : '',
    contentItems.length ? `Contenido: ${contentItems.join(' | ')}` : '',
    ctx.caseText ? `Caso: ${ctx.caseText}` : ''
  ].filter(Boolean).join('\n');
  pushIf(lines, payload, payload);
  lines.push('Tarea: explica con TUS PALABRAS el contenido en 2‚Äì3 frases, sin listas ni preguntas.');
  lines.push('Reglas: si ya se us√≥ este ejemplo, var√≠alo o ad√°ptalo; no avances si el criterio de cierre no se cumple.');
}

export function renderAsk(ctx: DocentePromptContext, lines: string[]) {
  if (!ctx.questionText) lines.push('Falta la pregunta.');
  pushIf(lines, ctx.questionText, `Pregunta: ${ctx.questionText}`);
  lines.push('Tarea: enmarca brevemente y cierra con la PREGUNTA EXACTA tal cual. No a√±adas contenido nuevo.');
  lines.push('Reglas: si el estudiante ya respondi√≥ esta pregunta en el turno previo, no la repitas; produce una transici√≥n breve y contin√∫a dentro del paso sin avanzar al siguiente hasta cumplir el criterio de cierre. No re-narres el caso ni repitas la historia.');
}

export function renderHint(ctx: DocentePromptContext, lines: string[], contentItems: string[], matched: string[], missing: string[]) {
  if (!ctx.questionText) lines.push('Falta la pregunta para la pista.');
  pushIf(lines, ctx.questionText, `Pregunta: ${ctx.questionText}`);
  pushIf(lines, ctx.objective, `Objetivo: ${ctx.objective}`);
  pushIf(lines, contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
  pushIf(lines, String(ctx.userAnswer || '').trim(), `Respuesta del estudiante: ${String(ctx.userAnswer || '').trim().slice(0, 300)}`);
  pushIf(lines, matched.length, `Aciertos: ${matched.join(', ')}`);
  pushIf(lines, missing.length, `Faltantes: ${missing.join(', ')}`);
  const limit = ctx.hintWordLimit || 18;
  const hu = Number(ctx.hintsUsed || 0);
  const sev = hu <= 0 ? 'S1' : (hu === 1 ? 'S2' : 'S3');
  lines.push(
    `Tarea: primero escribe UNA sola micro‚Äëpregunta (‚â§8 palabras) que ayude al estudiante a responder seg√∫n el OBJETIVO espec√≠fico, y en una l√≠nea aparte. ` +
    `Luego, escribe UNA pista (${limit} palabras aprox., sin signos de interrogaci√≥n) orientada al OBJETIVO (concreta, sin definiciones generales). Nunca devuelvas solo preguntas.`
  );
  lines.push('Formato de salida: EXACTAMENTE 2 l√≠neas; usa etiquetas (solo UNA micro‚Äëpregunta total):');
  lines.push('MICRO: <tu micro‚Äëpregunta (‚â§8 palabras, solo 1) que ayude al estudiante a responder seg√∫n el OBJETIVO>');
  lines.push('PISTA: <con√©ctala expl√≠citamente con el OBJETIVO (sin listas ni definiciones) >');
  lines.push('IMPORTANTE: La micro‚Äëpregunta debe estar DIRECTAMENTE relacionada con el OBJETIVO');
  lines.push('Alinea ambas l√≠neas con los principios: gradualidad cognitiva, andamiaje progresivo, conexi√≥n experiencial, diagn√≥stico continuo, construcci√≥n sem√°ntica, econom√≠a pedag√≥gica y preservaci√≥n del desaf√≠o.');
  lines.push('Evita frases meta o didasc√°licas (p. ej., "voy a darte una pista" o "esta es una micro‚Äëpregunta"): produce directamente el contenido solicitado.');
  lines.push('MICRO debe apuntar exclusivamente al OBJETIVO (diagn√≥stico), referenciar si procede algo del Historial reciente o del contexto del estudiante (conexi√≥n experiencial) y mantener el desaf√≠o (‚â§8 palabras, sin dar contenido nuevo).');
  lines.push(`PISTA debe ofrecer el apoyo m√≠nimo necesario (andamiaje) conectado al OBJETIVO (econom√≠a), sin revelar la respuesta (preservar desaf√≠o) y pudiendo introducir gradualmente 1 t√©rmino clave de la disciplina si aporta (construcci√≥n sem√°ntica). L√≠mite ‚âà ${limit} palabras.`);
  lines.push('No incluyas prefijos como "PISTA:" o "Te doy una pista:" dentro del contenido; usa solo la etiqueta en la l√≠nea.');
  if (sev === 'S1') {
    lines.push('Severidad S1: mant√©n la ayuda breve y concreta, orientada expl√≠citamente al Objetivo. Prefiere micro‚Äëpregunta directa (‚â§8 palabras). No ofrecer opciones todav√≠a.');
  } else if (sev === 'S2') {
    lines.push('Severidad S2: facilita con opciones; si la acci√≥n fuera ask_options se mostrar√°n 2 alternativas enfocadas al Objetivo. Mant√©n la micro‚Äëpregunta ‚â§8 palabras cuando aplique.');
  } else {
    lines.push('Severidad S3: solicita formato "Elemento ‚Üí funci√≥n" en UNA frase. Despu√©s, prepara transici√≥n breve si persiste la duda.');
  }
  lines.push('Reglas: mant√©n tono cercano; evita definiciones generales y no re‚Äënarrar el caso. No repitas literalmente frases del contenido (por ejemplo, evita repetir "Los procedimientos de seguridad incluyen ‚Ä¶"). Evita repetir la misma micro‚Äëpregunta usada en el turno previo (usa Historial reciente). No dupliques frases dentro del mismo mensaje. No a√±adas l√≠neas extra ni encabezados.');
}

export function renderFeedback(ctx: DocentePromptContext, lines: string[], contentItems: string[], matched: string[], missing: string[]) {
  const limit = ctx.hintWordLimit || 3;
  const allowQ = ctx.allowQuestions !== false;

  // Conversaci√≥n libre: responder cualquier consulta de forma natural
  if (ctx.conversationMode) {
    lines.push('Modo conversaci√≥n: responde de forma natural y breve (1‚Äì3 frases).');
    lines.push('Si la consulta es personal (tu nombre o identidad), responde: "Puedes llamarme Sophia Fuentes." Si te preguntan por tu sexo (hombre o mujer), responde que no tienes porque eres una IA.');
    lines.push('Si la consulta est√° fuera de tema, contesta en 1 frase y pivota con una pregunta hacia el objetivo. Replanteado la pregunta si es necesario. ya no vuelva a repetir la pregunta anterior');
    lines.push('Evita re‚Äënarrar casos; no repitas ideas; puedes hacer 1 pregunta breve si ayuda.');
  }

  lines.push(`Momento: ${ctx.momentTitle || ''}`);
  pushIf(lines, ctx.objective, `Objetivo: ${ctx.objective}`);
  pushIf(lines, ctx.questionText, `Pregunta: ${ctx.questionText}`);
  pushIf(lines, String(ctx.userAnswer || '').trim(), `Respuesta del estudiante: ${String(ctx.userAnswer || '').trim().slice(0, 300)}`);
  pushIf(lines, matched.length, `Aciertos: ${matched.join(', ')}`);
  pushIf(lines, missing.length, `Faltantes: ${missing.join(', ')}`);
  pushIf(lines, contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
  const kind = (ctx.kind || 'HINT').toUpperCase();
  if (kind === 'ACCEPT') {
    lines.push(
      `Tarea (feedback: ACCEPT): escribe hasta ${limit} frases: ` +
      `1) empieza con una frase de refuerzo espec√≠fica citando 1‚Äì2 aciertos (usa Aciertos); ` +
      `2) si procede, orienta brevemente el siguiente foco` + (allowQ ? '' : `, sin preguntas`) + `, sin revelar respuestas. No re‚Äënarrar el caso.`
    );
  } else if (kind === 'PARTIAL') {
    lines.push(
      `Tarea (feedback: PARTIAL): escribe ${limit} frases: ` +
      `1) valida el esfuerzo y nombra lo correcto (usa Aciertos) sin repetir f√≥rmulas de √°nimo ya usadas; ` +
      `2) si el t√©rmino del estudiante es extremo/coloquial (p. ej., "se muere"), infiere su categor√≠a sem√°ntica pr√≥xima (p. ej., lesi√≥n grave por ca√≠da) y reencuadra con lenguaje profesional; ` +
      `orienta 1 faltante con una pista concreta alineada al objetivo/contenido (usa Faltantes y Pistas de contenido). ` +
      (allowQ ? '' : `No incluyas preguntas. `) + `Evita definiciones generales y no reveles soluciones completas.`
    );
  } else if (kind === 'REFOCUS') {
    lines.push(
      `Tarea (feedback: REFOCUS): escribe hasta ${limit} frases: ` +
      `1) ofrece √°nimo (sin repetirlo si ya fue expresado) y se√±ala con amabilidad el desv√≠o; ` +
      `2) redirige al criterio/objetivo central en forma concreta` + (allowQ ? '' : `, sin preguntas`) + `. No re‚Äënarrar el caso.`
    );
  } else {
    lines.push(
      `Tarea (feedback: HINT): escribe ${limit} frases: ` +
      `1) empieza con ‚ÄúVamos a ‚Ä¶‚Äù (tono cercano) y normaliza la duda sin repetir empat√≠a del turno previo; ` +
      `2) da una pista concreta alineada al objetivo (usa Pistas de contenido o el primer Faltante); si el t√©rmino es extremo/coloquial, reencuadra con lenguaje profesional. No re‚Äënarrar el caso ni repetir frases literales. No dupliques frases.` + (allowQ ? '' : ` No incluyas preguntas.`)
    );
  }
}


```
=== EOF: src\ai\prompt_parts\user.ts

===  src\ai\prompt_parts\types.ts
```typescript
export type DocenteAction = 'explain' | 'ask' | 'hint' | 'ok' | 'advance' | 'end' | 'ask_simple' | 'ask_options' | 'feedback';

export type TeacherAptitudes = {
  claridad?: number;    // 0..1 afecta longitudes m√°ximas, concisi√≥n
  socratismo?: number;  // 0..1 probabilidad de re-ask vs hint
  calidez?: number;     // 0..1 tono de feedback/apertura
  rigor?: number;       // 0..1 umbrales de ACCEPT/PARTIAL
  ritmo?: number;       // 0..1 afterAttempts para force_advance
};

export type DocentePromptContext = {
  language?: string;
  course?: { role?: string; tone?: string; style_guidelines?: string };
  action: DocenteAction;
  stepType: string;
  momentTitle?: string;
  objective?: string;
  contentBody?: string[];
  narrationText?: string;
  caseText?: string;
  questionText?: string;
  acceptable?: string[];
  userAnswer?: string;
  matched?: string[];
  missing?: string[];
  recentHistory?: string[];
  hintWordLimit?: number;
  simpleOptions?: string[];
  optionItems?: string[];
  kind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  closureCriteria?: string;
  allowQuestions?: boolean;
  attempts?: number;
  hintsUsed?: number;
  aptitudes?: TeacherAptitudes;
  teacherAptitudes?: string[];
  conversationMode?: boolean;
};


```
=== EOF: src\ai\prompt_parts\types.ts

===  src\ai\prompt_parts\system.ts
```typescript
import type { DocentePromptContext } from './types';

export function buildSystemPrompt(ctx: DocentePromptContext): string {
  const lang = ctx.language || 'es';
  const role = ctx.course?.role ? `Act√∫a como ${ctx.course.role}.` : '';
  const tone = ctx.course?.tone ? `Tono: ${ctx.course.tone}.` : '';
  const style = ctx.course?.style_guidelines ? `Gu√≠a de estilo: ${ctx.course.style_guidelines}.` : '';
  const isHint = String(ctx.action || '').toLowerCase() === 'hint';
  const firstAid = Number(ctx.hintsUsed || 0) <= 0;
  const obj = String(ctx.objective || '').toLowerCase();
  const isConversation = Boolean((ctx as any).conversationMode);
  const rules = [
    `Eres un Docente IA uno-a-uno, tu nombre es Sophia Fuentes. Responde en ${lang}.`,
    role,
    tone,
    style,
    isConversation ? '' : 'Sigue estrictamente el paso actual del plan. No avances ni mezcles pasos.',
    isConversation ? 'Usa el plan como gu√≠a flexible: prioriza la intenci√≥n del estudiante y su ritmo.' : '',
    'Nunca copies literal el JSON; reescribe con tus palabras. Evita vi√±etas/listas y par√°grafos largos.',
    'Preferentemente 2‚Äì3 frases por bloque; usar hasta 4‚Äì5 cuando el objetivo requiera retroalimentaci√≥n concreta. Lenguaje claro. No spoilers.',
    'Regla de orden: primero analiza la frase del estudiante, lo aportado/intenci√≥n y la brecha; luego gu√≠a el micro‚Äëpaso m√≠nimo (pregunta u orientaci√≥n) en 1‚Äì2 frases.',
    'Si el estudiante responde "no s√©" repetidamente, reduce dificultad seg√∫n la acci√≥n solicitada.',
    'Normaliza el error y la duda: valida el esfuerzo y anima a continuar antes de orientar.',
    'Al interpretar la respuesta del estudiante, considera equivalencias sem√°nticas razonables (t√©rminos extremos/coloquiales ‚âà categor√≠as profesionales) y reencuadra con lenguaje t√©cnico sin a√±adir conceptos fuera del objetivo/contenido.',
    'Mant√©n continuidad con el √∫ltimo turno: si ya respondi√≥, no repitas la misma pregunta; contin√∫a dentro del paso seg√∫n el plan.',
    'Evita repetir el mismo ejemplo en turnos consecutivos; var√≠alo o ad√°ptalo al contexto de la respuesta.',
    isConversation ? '' : 'si la respuesta del estudiante tiene sentido de acuerdo a objetivo de la pregunta consid√©ralo como partial. Si cumple con dos o mas criterios como correcta',
    isConversation ? '' : 'Solo avanza cuando se cumpla el criterio de cierre del paso actual (si aplica).',
    'En acciones ask, hint,partial ,partial_feedback, feedback, ask_simple y ask_options no re-narres el caso ni describas la situaci√≥n inicial; si fuera imprescindible, referencia en UNA sola frase sin repetir detalles. Reserva la narraci√≥n extensa solo para explain.',
    // Principios pedag√≥gicos
    'Principios para la intervenci√≥n pedag√≥gica (especialmente en la primera clase):',
    '‚Ä¢ Criterio de gradualidad cognitiva: cada repregunta baja UN nivel de complejidad respecto a la anterior; construye una escalera descendente hasta que el estudiante conecta.',
    '‚Ä¢ Criterio de andamiaje progresivo: cada pista aporta la m√≠nima ayuda necesaria para habilitar el siguiente paso; evita resolver el problema por completo.',
    '‚Ä¢ Criterio de preservaci√≥n del desaf√≠o: mant√©n activo el esfuerzo cognitivo; evita pistas tan directas que eliminen la necesidad de pensar.',
    '‚Ä¢ Criterio de diagn√≥stico continuo: usa cada repregunta para revelar qu√© elemento espec√≠fico no comprende, y adapta la siguiente intervenci√≥n.',
    '‚Ä¢ Criterio de construcci√≥n sem√°ntica: introduce gradualmente vocabulario y conceptos de la disciplina sobre bases comprensibles.',
    '‚Ä¢ Criterio de econom√≠a pedag√≥gica: usa la menor cantidad de informaci√≥n adicional posible en cada pista, maximizando el aprendizaje autogenerado.',
    // Reglas de conversaci√≥n libre (agent-first)
    isConversation ? 'Modo conversaci√≥n: responde cualquier consulta de forma natural (1‚Äì3 frases). Mant√©n el orden an√°lisis‚Üímicro‚Äëpaso; redirigir al objetivo es opcional.' : '',
    // Reglas globales suaves para pistas S1
    isHint && firstAid ? 'Sugerencia S1 (primer intento de ayuda): prefiere analog√≠as breves con el patr√≥n "como ‚Ä¶" alineadas al Objetivo, solo si suenan naturales; evita generalidades vac√≠as.' : '',
    isHint ? `La micro‚Äëpregunta debe estar alineada al Objetivo: "${ctx.objective}". Ayuda al estudiante a responder seg√∫n este objetivo espec√≠fico.` : '',
    // Analog√≠as orientadas a resolver la micro‚Äëpregunta
    isHint ? 'Cuando incluyas una analog√≠a, ori√©ntala a resolver la micro‚Äëpregunta: mapea el elemento preguntado a un objeto cotidiano ("como ‚Ä¶") y sugiere expl√≠citamente c√≥mo responder aplicando esa equivalencia, manteniendo el foco del Objetivo.' : ''
  ].filter(Boolean).join(' ');
  return rules;
}


```
=== EOF: src\ai\prompt_parts\system.ts

===  src\ai\agents\index.ts
```typescript
import type { DocentePromptContext } from '@/ai/prompt_parts/types';
import { runDocenteLLM } from '@/ai/orchestrator';

export async function runExplainAgent(ctx: DocentePromptContext) {
	return runDocenteLLM({ ...ctx, action: 'explain' });
}

export async function runAskAgent(ctx: DocentePromptContext) {
	return runDocenteLLM({ ...ctx, action: 'ask' });
}

export async function runAskOptionsAgent(ctx: DocentePromptContext & { optionItems?: string[] }) {
	return runDocenteLLM({ ...ctx, action: 'ask_options' as any });
}

export async function runHintAgent(ctx: DocentePromptContext) {
	return runDocenteLLM({ ...ctx, action: 'hint' });
}

export async function runFeedbackAgent(ctx: DocentePromptContext) {
	return runDocenteLLM({ ...ctx, action: 'feedback' });
}

export async function runAdvanceAgent(ctx: DocentePromptContext) {
	return runDocenteLLM({ ...ctx, action: 'advance' });
}

export async function runEndAgent(ctx: DocentePromptContext) {
	return runDocenteLLM({ ...ctx, action: 'end' as any });
}


```
=== EOF: src\ai\agents\index.ts

===  public\courses\SSO001\policies.json
```json
{
  "language": {
    "stopwords": ["el","la","los","las","un","una","unos","unas","de","en","y","o","a","para","con","sobre","que","es","son","del","al","por","se","como","mas","m√°s","menos","no","si","s√≠","qu√©","cuales","cu√°les"]
  },
  "evaluation": {
    "attemptsMax": 3,
    "levels": {
      "R0": { "description": "vac√≠o/vago/fuera de tema" },
      "R1": { "description": "parcial" },
      "R2": { "description": "correcta" }
    },
    "thresholds": {
      "similarityMin": 0.50,
      "similarityBest": 0.62,
      "keywordMin": 1,
      "minTokens": 3
    },
    "scoring": { "R2": 2, "R1": 1, "R0": 0 },
    "semantic": {
      "open":   { "semThresh": 0.35, "semBestThresh": 0.30 },
      "closed": { "semThresh": 0.46, "semBestThresh": 0.40 }
    }
  },
  "thresholds": {
    "conceptual": { "min": 1 },
    "identificacion": { "min": 1 },
    "listado": { "kDefault": 2 },
    "aplicacion": { "requiresJustification": true },
    "metacognitiva": { "min": 1 },
    "experiencial": { "min": 1 },
    "reflexiva": { "min": 1 }
  },
  "hints": {
    "wordLimits": [16, 28, 40],
    "maxHints": 2,
    "escalateAfterAttempts": [1, 2, 3],
    "variants": [
      "Piensa en los criterios del EPP",
      "Recuerda los riesgos antes de actuar"
    ],
    "rotateVariants": true,
    "templates": {
      "objective": "{opener} Enf√≥cate en {keywords}. {cueLine}",
      "reask": {
        "list": "Menciona en {maxWords} palabras 2 elementos de {base}.",
        "definition": "Define brevemente {base} (‚â§{maxWords} palabras).",
        "procedure": "En {maxWords} palabras, describe 2 pasos clave de {base}.",
        "choice": "Elige 1 aspecto de {base} y justifica en {maxWords} palabras."
      },
      "open": {
        "hint": "Comparte tus ideas en al menos {minWords} palabras. {cuesLine}",
        "reask": "En {minWords}-{maxWords} palabras, cu√©ntame tus ideas principales sobre \"{objective}\".",
        "fallbackAspects": ["prop√≥sito", "criterios", "ejemplo"]
      }
    }
  },

  "feedback": {
    "openers": {
      "hint": [
        "Considera revisar",
        "Piensa en",
        "Recuerda que",
        "Ten en cuenta"
      ]
    },
    "showDeterministic": false,
    "maxSentences": 3,
    "allowQuestions": true
  },
  "conversation": {
    "enabled": true,
    "maxTurns": 3,
    "consultPrompt": "¬øCu√°l es tu consulta?",
    "resumeSynonyms": ["continuar","seguir","sigamos","retomar","reanudar","est√° claro","ahora entiendo","gracias"]
  },
  "advance": {
    "allowForcedOn": ["SALUDO", "CONEXION", "ADQUISICION", "APLICACION", "DISCUSION", "REFLEXION", "OTRO"],
    "maxAttemptsBeforeForce": 3
  },
  "vague": {
    "minUsefulTokens": 3,
    "maxStopwordRatio": 0.6,
    "echoOverlap": 0.7,
    "repeatSimilarity": 0.8,
    "vagueAttemptsBeforeAB": 2,
    "vagueAttemptsBeforeExplain": 3,
    "simplifiedAskMaxWords": 10
  },
  "typeMap": {
    "abierta": "metacognitiva",
    "diagnostica": "identificacion",
    "diagn√≥stica": "identificacion",
    "aplicacion_practica": "aplicacion",
    "aplicacion": "aplicacion",
    "analisis": "conceptual",
    "analisis_comparativo": "conceptual",
    "analisis_critico": "conceptual",
    "seleccion_justificada": "aplicacion",
    "planificacion_aplicacion": "aplicacion",
    "autoevaluacion": "reflexiva",
    "identificacion": "identificacion",
    "conceptual": "conceptual",
    "listado": "listado",
    "reflexiva": "reflexiva",
    "experiencial": "experiencial"
  },
  "debug": { "logs": true }
}


```
=== EOF: public\courses\SSO001\policies.json

===  public\courses\SSO001\overrides.json
```json
{
  "steps": {
    "M3-Q02": { "type": "listado", "k": 4 },
    "M4-Q01": { "type": "aplicacion", "requiresJustification": true }
  }
}



```
=== EOF: public\courses\SSO001\overrides.json

===  public\courses\SSO001\course.json
```json
{
  "id": "SSO001",
  "name": "Seguridad y Salud Ocupacional",
  "version": "1.0.0",
  "language": "es",
  "objectives": [
    "Identificar riesgos",
    "Aplicar procedimientos"
  ],
  "specialist": {},
  "lessons": [
    {
      "id": "lesson02",
      "title": "Procedimientos de Seguridad",
      "order": 2,
      "path": "/courses/SSO001/lessons/lesson02.json"
    },
    {
      "id": "lesson01",
      "title": "IPERC Continuo - Identificaci√≥n y Control de Riesgos",
      "order": 1,
      "path": "/courses/SSO001/lessons/lesson01.json"
    }
  ]
}


```
=== EOF: public\courses\SSO001\course.json

===  app\api\media\route.ts
```typescript
import type { NextRequest } from 'next/server';

type MediaMap = Record<string, { images?: string[]; items?: Array<{ url?: string; src?: string; image?: string; name?: string; title?: string; description?: string; desc?: string; caption?: string; label?: string }> } >;

async function loadPlanJson(absPlanUrl: string): Promise<any> {
  const res = await fetch(absPlanUrl, { cache: 'no-store' });
  if (!res.ok) throw new Error(`Failed to load plan: ${res.status}`);
  return await res.json();
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const planUrl = searchParams.get('planUrl') || '/courses/SSO001/lessons/lesson02.json';
    const step = searchParams.get('step');
    const docUrl = searchParams.get('docUrl'); // documento externo opcional con mapping de media

    // Construir URL absoluta contra el mismo host
    const absPlanUrl = new URL(planUrl, req.url).toString();
    const plan = await loadPlanJson(absPlanUrl);
    const mediaPlan: MediaMap = (plan?.media || {}) as MediaMap;
    let mediaDoc: MediaMap = {};
    if (docUrl) {
      const absDocUrl = new URL(docUrl, req.url).toString();
      try {
        mediaDoc = (await loadPlanJson(absDocUrl)) as MediaMap;
      } catch {}
    }
    const media: MediaMap = { ...mediaPlan, ...mediaDoc };

    if (step) {
      const entry = media[String(step)] || { images: [] };
      const images = Array.isArray(entry?.images) ? entry.images : [];
      const items = Array.isArray(entry?.items) ? entry.items : [];
      return new Response(
        JSON.stringify({ step, images, items }),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      );
    }

    return new Response(JSON.stringify({ media }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (err: any) {
    return new Response(JSON.stringify({ error: err?.message || 'media endpoint error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}


```
=== EOF: app\api\media\route.ts

===  app\api\history\route.ts
```typescript
import { NextResponse } from 'next/server';
import { getFullHistory, getUserLastSession } from '@/session/history';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/authOptions';
import { getSessionStore } from '@/session/store';

export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const sessionKey = url.searchParams.get('sessionKey');
    const by = url.searchParams.get('by') || 'session';

    if (by === 'user') {
      const session: any = await getServerSession(authOptions as any);
      const email: string | undefined = session?.user?.email || undefined;
      if (!email) return NextResponse.json({ items: [], sessionKey: null, state: null });
      const last = await getUserLastSession(email);
      if (!last) return NextResponse.json({ items: [], sessionKey: null, state: null });
      const items = await getFullHistory(last);
      const state = await getSessionStore().get(last);
      const stateMin = state ? { stepIdx: state.stepIdx, momentIdx: state.momentIdx, done: state.done, stepCode: (state as any)?.stepCode } : null;
      return NextResponse.json({ items, sessionKey: last, state: stateMin });
    }

    if (!sessionKey) return NextResponse.json({ error: 'missing_sessionKey' }, { status: 400 });
    const items = await getFullHistory(sessionKey);
    const state = await getSessionStore().get(sessionKey);
    const stateMin = state ? { stepIdx: state.stepIdx, momentIdx: state.momentIdx, done: state.done, stepCode: (state as any)?.stepCode } : null;
    return NextResponse.json({ items, sessionKey, state: stateMin });
  } catch (e) {
    return NextResponse.json({ error: 'history_failed' }, { status: 500 });
  }
}


```
=== EOF: app\api\history\route.ts

===  public\courses\SSO001\lessons\lesson02.json
```json
{
  "meta": {
    "lesson_id": "SSO001_lesson02",
    "lesson_name": "Procedimientos de Seguridad",
    "version": "1.0.0",
    "language": "es",
    "ordered": true,
    "generated_at": "2025-08-14T00:00:00Z"
  },
  "moments": [
    {
      "code": "M1",
      "order": 1,
      "title": "Saludo",
      "steps": [
        { "code": "M1-EL01", "order": 1, "type": "EXPECTED_LEARNING", "items": [
          "Explicar los componentes del procedimiento de seguridad en situaciones de trabajo, de acuerdo con los est√°ndares y normativas vigentes."
        ]},
        { "code": "M1-KP01", "order": 2, "type": "KEY_POINTS", "items": [
          "Qu√© es un procedimiento", "Por qu√© es importante", "C√≥mo se aplica"
        ]},
        { "code": "M1-N01", "order": 3, "type": "NARRATION", "text": "Bienvenida y objetivo de la sesi√≥n. Exploraremos qu√© son los procedimientos de seguridad y su relevancia en el trabajo." },
        { "code": "M1-Q01", "order": 4, "type": "ASK",
          "question": "¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?",
          "objective": "Elicitar expectativas del estudiante sobre la importancia de los procedimientos de seguridad",
          "answer_type": "open",
          "acceptable_answers": ["partes del procedimiento", "c√≥mo se aplica", "importancia de seguirlos", "selecci√≥n de EPP"],
          "question_type": "metacognitiva"
        }
      ]
    },
    {
      "code": "M2",
      "order": 2,
      "title": "Conexi√≥n",
      "steps": [
        { "code": "M2-N01", "order": 1, "type": "NARRATION",
          "text": "Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arn√©s, pero no ha trabajado en altura antes." },
        { "code": "M2-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© elementos de seguridad identificas en los trabajos de altura?",
          "objective": "Activar conocimientos previos sobre los elementos de seguridad en trabajos de altura",
          "acceptable_answers": ["arn√©s", "arn√©s de seguridad", "l√≠nea", "l√≠nea de vida", "casco", "guantes", "inspecci√≥n previa", "supervisi√≥n"],
          "question_type": "diagn√≥stica"
          
        },


        { "code": "M2-Q02", "order": 3, "type": "ASK",
          "question": "¬øQu√© podr√≠a pasar si no se siguen los procedimientos correctos?",
          "objective": "Conciencia de riesgos",
          "acceptable_answers": ["ca√≠das", "lesiones", "accidentes", "sanciones", "multas", "muerte", "fatalidad", "accidente mortal", "da√±o grave"],
          "question_type": "reflexiva"
        }
      ]
    },
    {
      "code": "M3",
      "order": 3,
      "title": "Adquisici√≥n",
      "steps": [
        { "code": "M3-C01", "order": 1, "type": "CONTENT",
          "title": "Definici√≥n de procedimiento de seguridad",
          "body": [
            "PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos espec√≠ficos para realizar una tarea de forma segura, minimizando riesgos laborales"
          ]
        },
        { "code": "M3-Q01", "order": 2, "type": "ASK",
          "question": "¬øC√≥mo definir√≠as un procedimiento de seguridad con tus palabras?",
          "objective": "Comprender la definici√≥n",
          "answer_type": "definition",
          "acceptable_answers": ["secuencia documentada de pasos", "realizar una tarea de forma segura", "minimizar riesgos laborales"],
          "question_type": "conceptual"
        },
        { "code": "M3-C02", "order": 3, "type": "CONTENT",
          "title": "Partes de un procedimiento",
          "body": [
            "Objetivo", "Alcance", "Responsabilidades", "Pasos espec√≠ficos", "EPP requerido", "Medidas de emergencia", "Registros"
          ]
        },
        { "code": "M3-Q02", "order": 4, "type": "ASK",
          "question": "¬øQu√© partes debe incluir un procedimiento de seguridad completo?",
          "objective": "Identificar componentes",
          "acceptable_answers": ["objetivo", "alcance", "responsabilidades", "pasos espec√≠ficos", "epp requerido", "medidas de emergencia", "registros"],
          "question_type": "listado"
        },
        { "code": "M3-C03", "order": 5, "type": "CONTENT",
          "title": "Criterios para seleccionar EPP",
          "body": [
            "Evaluar tipo de riesgo y nivel de exposici√≥n",
            "Compatibilidad, ajuste y comodidad",
            "Cumplimiento normativo y certificaciones"
          ]
        },
        { "code": "M3-Q03", "order": 6, "type": "ASK",
          "question": "Menciona dos criterios para seleccionar EPP adecuadamente.",
          "objective": "Dominar criterios de selecci√≥n de EPP",
          "answer_type": "list",
          "acceptable_answers": ["tipo de riesgo", "nivel de exposici√≥n", "compatibilidad", "ajuste", "normativa", "certificaciones"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M4",
      "order": 4,
      "title": "Aplicaci√≥n",
      "steps": [
        { "code": "M4-CASE01", "order": 1, "type": "CASE",
          "title": "Trabajo en altura en fachada",
          "description": "Instalaci√≥n de ventanas en tercer piso con uso de arn√©s y l√≠nea de vida.",
          "variables": ["altura > 2 m", "arn√©s", "l√≠nea de vida", "supervisi√≥n", "verificaci√≥n de anclajes"]
        },
        { "code": "M4-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© EPP m√≠nimo usar√≠as y por qu√©?",
          "objective": "Justificar selecci√≥n de EPP",
          "answer_type": "procedure",
          "acceptable_answers": ["arn√©s con l√≠nea de vida", "casco", "guantes", "calzado antideslizante"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M5",
      "order": 5,
      "title": "Discusi√≥n",
      "steps": [
        { "code": "M5-TOP01", "order": 1, "type": "TOPICS",
          "items": ["Protocolizar vs. improvisar", "Cultura de seguridad"]
        },
        { "code": "M5-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© ventajas tiene documentar procedimientos frente a improvisar?",
          "objective": "Comparar enfoques",
          "acceptable_answers": ["estandariza", "reduce errores", "trazabilidad", "cumplimiento"],
          "question_type": "argumentativa"
        }
      ]
    },
    {
      "code": "M6",
      "order": 6,
      "title": "Reflexi√≥n",
      "steps": [
        { "code": "M6-REF01", "order": 1, "type": "REFLECTION_AREAS",
          "items": ["H√°bitos personales de seguridad", "Compromisos inmediatos"]
        },
        { "code": "M6-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© cambio aplicar√°s esta semana para mejorar tu seguridad?",
          "objective": "Plan de mejora personal",
          "answer_type": "open",
          "acceptable_answers": ["ejemplo personal", "compromiso concreto"],
          "question_type": "reflexiva"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\SSO001\lessons\lesson02.json

===  public\courses\SSO001\lessons\lesson01.json
```json
{
  "meta": {
    "lesson_id": "SSO001_lesson_01",
    "lesson_name": "IPERC Continuo - Identificaci√≥n de peligros, evaluacion de riesgos y  Control",
    "version": "1.0.0",
    "language": "es",
    "ordered": true,
    "generated_at": "2025-08-27T00:00:00Z"
  },
  "moments": [
    {
      "code": "M1",
      "order": 1,
      "title": "Saludo",
      "images": [
        {
          "url": "https://www.levelset.com/wp-content/uploads/2019/02/bigstock-201485356-600x400.jpg",
          "description": "Trabajadores en obra de construcci√≥n con equipos de seguridad"
        }
      ],
      "steps": [
        { "code": "M1-EL01", "order": 1, "type": "EXPECTED_LEARNING", "items": [
          "Reconocer la importancia de identificar peligros y evaluar riesgos"
        ]},
        { "code": "M1-KP01", "order": 2, "type": "KEY_POINTS", "items": [
          "Reconocer los peligros", "Evaluar los riesgos", "Diferenciar los niveles de los controles"
        ]},
        { "code": "M1-N01", "order": 3, "type": "NARRATION", "text": "Bienvenido. Hoy trabajaremos con IPERC Continuo para identificar peligros, riesgos, consecuencias y controles, y estimar el riesgo residual." },
        { "code": "M1-Q01", "order": 4, "type": "ASK",
          "question": "¬øQu√© crees que sea un peligro y por qu√© es importante identificarlos?",
          "objective": "Renocer la omportancia de identificar peligros y evaluar riesgos",
          "answer_type": "open",
          "acceptable_answers": ["algo que puede lastimar", "cosas peligrosas", "lo que causa accidentes", "algo que hace da√±o", "situaciones riesgosas", "para evitar accidentes", "para no lastimarse", "para trabajar seguro"], "question_type": "diagn√≥stica"
        }
      ]
    },
    {
      "code": "M2",
      "order": 2,
      "title": "Conexi√≥n",
      "images": [
        {
          "url": "https://s7d2.scene7.com/is/image/TWCNews/welder_2_02152022",
          "description": "Soldador realizando trabajo de soldadura con chispas y luz brillante"
        }
      ],
      "steps": [
        { 
          "code": "M2-N01", 
          "order": 1, 
          "type": "NARRATION",
          "text": "Observa esta imagen de trabajo de soldadura y activa tus saberes previos sobre peligros y riesgos." 
        },
        { 
          "code": "M2-Q01", 
          "order": 2, 
          "type": "ASK",
          "question": "¬øQu√© peligros observas en la imagen de soldadura?",
          "objective": "Activar conocimientos previos sobre identificaci√≥n de peligros en soldadura",
          "answer_type": "open",
          "acceptable_answers": ["chispas", "fuego", "humo", "luz brillante", "calor", "metal caliente", "gases", "quemaduras", "radiaci√≥n"],
          "question_type": "diagn√≥stica"
        },
        { 
          "code": "M2-Q02", 
          "order": 3, 
          "type": "ASK",
          "question": "¬øQu√© riesgos podr√≠an derivarse de estos peligros?",
          "objective": "Diferenciar entre peligros identificados y posibles riesgos",
          "answer_type": "open",
          "acceptable_answers": ["quemarse", "lastimarse los ojos", "respirar humo malo", "incendio", "accidente", "intoxicaci√≥n"],
          "question_type": "reflexiva"
        }
      ]
    },
    {
      "code": "M3",
      "order": 3,
      "title": "Adquisici√≥n",
      "images": [
        {
          "url": "https://udocz-images.b-cdn.net/documents_html/721461-6a3fd26b751d57b061e680c7d9282596/bg3.jpg?width=2688",
          "description": "Diagrama conceptual de peligro, riesgo y control"
        },
        {
          "url": "https://alertaprevencion.cl/wp-content/uploads/2021/07/heirarchycontrols_spanish.png",
          "description": "Pir√°mide de jerarqu√≠a de controles en espa√±ol"
        },
        {
          "url": "https://www.altrasan.com/fotos/1647363464_wlmv.jpg",
          "description": "Izaje con excavadora levantando bloques; trabajador a pie cercano en zona de obra"
        }
      ],
      "steps": [
        { "code": "M3-C01", "order": 1, "type": "CONTENT",
          "title": "Definiciones seg√∫n Norma Peruana",
          "body": [
            "Peligro: Caracter√≠stica intr√≠nseca con potencial de causar da√±o a la salud, integridad f√≠sica o vida de las personas",
            "Riesgo: Combinaci√≥n de la probabilidad de que ocurra un evento peligroso y la severidad de las consecuencias",
            "Consecuencia: Da√±o, lesi√≥n o p√©rdida que puede resultar si el riesgo se materializa"
          ]
        },
        { "code": "M3-Q01", "order": 2, "type": "ASK",
          "question": "Define con tus palabras: peligro, riesgo y consecuencia.",
          "objective": "Comprender definiciones b√°sicas de peligro, riesgo y consecuencia",
          "answer_type": "definition",
          "acceptable_answers": ["potencial de da√±o", "probabilidad y severidad", "da√±o resultante"],
          "question_type": "conceptual"
        },
        { "code": "M3-C02", "order": 3, "type": "CONTENT",
          "title": "Jerarqu√≠a de controles",
          "body": [
            "En la jerarqu√≠a de controles es importante diferenciar los niveles porque:",
            "Prioriza medidas m√°s eficaces (eliminar/sustituir) antes que EPP.",
            "Disminuye probabilidad y severidad al actuar en la fuente del peligro.",
            "Reduce la dependencia del comportamiento humano y el error.",
            "Optimiza recursos enfocando esfuerzos en controles de mayor impacto.",
            "Permite estimar y justificar el riesgo residual y las decisiones tomadas.",
            "",
            "Los siguientes niveles son:",
            "Eliminar el peligro",
            "Sustituir por alternativa m√°s segura",
            "Controles de ingenier√≠a",
            "Controles administrativos",
            "EPP"
          ]
        },
        { "code": "M3-Q02", "order": 4, "type": "ASK",
          "question": "En una situaci√≥n donde un trabajador debe cruzar una v√≠a donde circulan equipos pesados, ¬øqu√© dos opciones de la jerarqu√≠a de controles usar√≠as para reducir el riesgo?",
          "objective": "Aplicar jerarqu√≠a de controles a situaci√≥n real",
          "answer_type": "list",
          "acceptable_answers": ["eliminaci√≥n", "sustituci√≥n", "ingenier√≠a", "administrativos", "epp", "pasarelas", "barreras", "se√±alizaci√≥n", "reubicar trabajo", "evitar cruzar", "cambiar ruta", "usar puente", "poner se√±ales", "hacer horarios", "usar casco", "chaleco reflectante", "supervisi√≥n", "procedimientos", "capacitaci√≥n"],
          "question_type": "aplicaci√≥n"
        },
        { "code": "M3-Q03", "order": 5, "type": "ASK",
          "question": "Observa la imagen de izaje con excavadora. ¬øQu√© peligros y riesgos identificas y qu√© dos controles aplicar√≠as seg√∫n la jerarqu√≠a para reducir el riesgo?",
          "objective": "Aplicar IPERC y jerarqu√≠a de controles a una maniobra de izaje con excavadora",
          "answer_type": "list",
          "acceptable_answers": [
            "carga suspendida", "radio de giro", "golpeado por la carga", "atrapamiento",
            "pinzamiento", "falta de se√±alero", "delimitar zona", "barricadas",
            "cinta de seguridad", "plan de izaje", "capacidad del equipo", "inspecci√≥n de cadenas",
            "accesorio certificado", "taglines", "comunicaci√≥n por se√±ales", "distancia segura",
            "prohibido bajo la carga", "superficie firme", "estabilizar/asegurar el equipo",
            "EPP casco botas chaleco", "se√±alizaci√≥n", "aislar peatones", "capacitaci√≥n del rigger",
            "permiso de trabajo"
          ],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M4",
      "order": 4,
      "title": "Aplicaci√≥n",
      "images": [
        {
          "url": "https://www.hydrauliccylindersinc.com/wp-content/uploads/2022/05/cleaning-scaled.jpeg",
          "description": "Trabajador realizando mantenimiento en sistema hidr√°ulico de excavadora"
        }
      ],
      "steps": [
        { "code": "M4-CASE01", "order": 1, "type": "CASE",
          "title": "Mantenimiento de sistema hidr√°ulico",
          "description": "Observa la imagen: Un trabajador realiza mantenimiento en el sistema hidr√°ulico de una excavadora de orugas. Est√° manipulando un cilindro hidr√°ulico con un recipiente rojo para recoger fluidos. Identifica los peligros, riesgos y controles aplicando IPERC.",
          "variables": ["sistema hidr√°ulico presurizado", "equipo pesado en mantenimiento", "superficie irregular", "falta de calzos", "derrames de fluidos", "movimiento inesperado"]
        },
        { "code": "M4-Q01", "order": 2, "type": "ASK",
          "question": "Identifica dos peligros en la imagen, un riesgo por cada peligro y dos controles por cada riesgo.",
          "objective": "Aplicar IPERC identificando peligros, riesgos y controles espec√≠ficos",
          "answer_type": "procedure",
          "acceptable_answers": ["sistema hidr√°ulico presurizado", "equipo pesado en mantenimiento", "superficie irregular", "falta de calzos", "derrames de fluidos", "movimiento inesperado", "quemaduras por fluidos", "atrapamiento", "ca√≠das", "golpes", "bloqueo y etiquetado", "se√±alizaci√≥n", "uso de EPP", "revisi√≥n previa", "zapatos de seguridad", "supervisi√≥n", "procedimientos", "contenci√≥n de derrames"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M5",
      "order": 5,
      "title": "Discusi√≥n",
      "steps": [
        { "code": "M5-Q01", "order": 1, "type": "ASK",
          "question": "¬øPor qu√© elegiste ese orden de jerarqu√≠a? ¬øQu√© nivel representa cada control?",
          "objective": "Argumentar elecci√≥n de controles y orden de jerarqu√≠a",
          "answer_type": "open",
          "acceptable_answers": ["m√°s efectivo", "m√°s seguro", "previene el riesgo", "reduce probabilidad", "protege al trabajador", "cumple normativa", "es obligatorio", "es la mejor opci√≥n", "eliminaci√≥n", "sustituci√≥n", "ingenier√≠a", "administrativos", "epp", "nivel 1", "nivel 2", "nivel 3", "nivel 4", "nivel 5", "primero eliminar", "despu√©s sustituir", "luego ingenier√≠a", "despu√©s administrativos", "√∫ltimo epp"],
          "question_type": "argumentativa"
        }
      ]
    },
    {
      "code": "M6",
      "order": 6,
      "title": "Reflexi√≥n",
      "steps": [
        { "code": "M6-Q01", "order": 1, "type": "ASK",
          "question": "¬øQu√© aprendiste hoy que aplicar√°s en tus tareas diarias de trabajo?",
          "objective": "Reflexionar y transferir aprendizaje a tareas espec√≠ficas",
          "answer_type": "open",
          "acceptable_answers": ["identificar peligros", "evaluar riesgos", "aplicar controles", "usar jerarqu√≠a", "seguir procedimientos", "usar EPP", "documentar", "supervisar", "capacitar", "prevenir accidentes", "trabajar seguro", "cumplir normativa", "mejorar seguridad", "aplicar IPERC", "transferir conocimiento", "compromiso personal", "cambio de h√°bitos", "mejora continua", "en mi trabajo", "en mis tareas", "en mi √°rea", "en mi equipo", "en mi turno", "antes de empezar", "durante la tarea", "al finalizar", "revisar mi √°rea", "verificar equipos", "comunicar riesgos", "reportar peligros"],
          "question_type": "reflexiva"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\SSO001\lessons\lesson01.json

===  app\api\engine\turn\route.ts
```typescript
import { runDocenteLLM } from '@/ai/orchestrator';
import { runAdvanceAgent, runAskAgent, runAskOptionsAgent, runEndAgent, runExplainAgent, runFeedbackAgent, runHintAgent } from '@/ai/agents';
import { isNoSeInput, shouldGateByMinTokens } from '@/engine/clarify';
import { evaluateSemanticOnly, type AskPolicy } from '@/engine/eval';
// import { extractKeywords } from '@/engine/hints';
import { isAffirmativeToResume, isStudentAskingQuestion, isStudentAskingQuestionSem } from '@/engine/questions';
import { isGreetingInput } from '@/engine/questions';
import { isPersonalInfoQuery, isPlatformHelpQuery, isGeneralKnowledgeStyleQuestion } from '@/engine/questions';
import { advanceTo, currentStep, decideAction, decideNextAction, getNextAskInSameCycle, next } from '@/engine/runner';
import { loadAndCompile } from '@/plan/compilePlan';
import { appendHistory, clearHistory, getRecentHistory, setUserLastSession } from '@/session/history';
import { SessionState, initSession } from '@/session/state';
import { getSessionStore } from '@/session/store';
import { resolveTeacherProfile } from '@/teacher/resolveProfile';
import fs from 'fs/promises';
import { NextResponse } from 'next/server';
import path from 'path';
import { getHintWordLimit } from '@/ai/tools/PolicyTool';
import { pickTwoOptions } from '@/ai/tools/OptionsTool';
import { decideForceAdvanceByNoSe } from '@/ai/tools/InputGuardrail';
import { pickVariant, varyHintLimit } from '@/ai/ab';
import { buildLessonRagIndex, retrieveTopKWithScores, maxSimilarity } from '@/ai/tools/RagTool';
import { engineLogger } from '@/engine/logger';
import { normalize } from '@/engine/eval';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/authOptions';


// Evita repetir frases casi id√©nticas al componer mensajes
function composeUniqueText(...parts: Array<string | undefined>): string {
	const norm = (s: string) => s
		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		.replace(/\s+/g, ' ')
		.trim();
	const seen = new Set<string>();
	const out: string[] = [];
	for (const p of parts) {
		const text = String(p || '').trim();
		if (!text) continue;
		const lines = text.split(/\n+/).map(s => s.trim()).filter(Boolean);
		for (const line of lines) {
			const key = norm(line);
			if (key && !seen.has(key)) {
				seen.add(key);
				out.push(line);
			}
		}
	}
	return out.join('\n\n');
}


type ClientState = {
  momentIdx?: number;
  stepIdx?: number;
  attemptsByAskCode?: Record<string, number>;
  noSeCountByAskCode?: Record<string, number>;
  lastActionByAskCode?: Record<string, string>;
  lastAnswerByAskCode?: Record<string, string>;
  done?: boolean;
};

type Body = { sessionKey: string; userInput?: string; planUrl?: string; reset?: boolean; clientState?: ClientState; adaptiveMode?: boolean };

const SESSIONS = new Map<string, SessionState>();
const COURSE_POLICIES_CACHE = new Map<string, any>();

function mapMomentKind(title?: string): 'SALUDO'|'CONEXION'|'ADQUISICION'|'APLICACION'|'DISCUSION'|'REFLEXION'|'OTRO' {
  const t = (title || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  if (t.includes('saludo')) return 'SALUDO';
  if (t.includes('conexion')) return 'CONEXION';
  if (t.includes('adquisicion')) return 'ADQUISICION';
  if (t.includes('aplicacion')) return 'APLICACION';
  if (t.includes('discusion')) return 'DISCUSION';
  if (t.includes('reflexion')) return 'REFLEXION';
  return 'OTRO';
}

function deriveCourseId(planUrl: string): string | undefined {
  const m = planUrl.match(/\/courses\/(.*?)\//);
  return m?.[1];
}

async function loadCoursePolicies(courseId?: string) {
  if (!courseId) return undefined;
  if (COURSE_POLICIES_CACHE.has(courseId)) return COURSE_POLICIES_CACHE.get(courseId);

  try {
    const url = `/courses/${courseId}/policies.json`;
    let json: any;
    if (/^https?:/i.test(url)) {                       // remoto
      const res = await fetch(url);
      if (!res.ok) return undefined;
      json = await res.json();
    } else {                                           // relativo -> public/
      const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
      const raw = await fs.readFile(filePath, 'utf-8');
      json = JSON.parse(raw);
    }
    COURSE_POLICIES_CACHE.set(courseId, json);
    return json;
  } catch {
    return undefined;
  }
}

// buildStudentFacingBase eliminado: reutilizar el de src/engine/hints

export async function POST(req: Request) {
	try {
		const body = (await req.json()) as Body;
		const { sessionKey, userInput = '', planUrl = '/courses/SSO001/lessons/lesson02.json', reset = false, clientState, adaptiveMode = false } = body;
		let pendingInput = (userInput || '').toString();
    // Email del usuario autenticado (si existe) para anotar ownership del historial
    let email: string | undefined;
    try { const sess: any = await getServerSession(authOptions as any); email = sess?.user?.email || undefined; } catch {}
		if (reset) {
			SESSIONS.delete(sessionKey);
			try { await getSessionStore().delete(sessionKey); } catch {}
			try { await clearHistory(sessionKey); } catch {}
		}
		let state = (await getSessionStore().get(sessionKey)) || SESSIONS.get(sessionKey);
    		if (!state) {
			const plan = await loadAndCompile(planUrl);
			state = initSession(planUrl, plan);
			// Aplicar modo adaptativo si se solicita
			if (adaptiveMode) {
				state.adaptiveMode = true;
			}
      try { (state as any).ragIndex = await buildLessonRagIndex((state as any).plan); } catch {}
			SESSIONS.set(sessionKey, state);
			try { await getSessionStore().set(sessionKey, state); } catch {}
		}
    if (!state) {
      throw new Error('No se pudo inicializar la sesi√≥n');
    }
    // Rehidratar desde clientState si viene en el request (persistencia sin servidor)
    if (clientState) {
      // No sobrescribir con √≠ndices m√°s antiguos del cliente
      if (typeof clientState.momentIdx === 'number') {
        const m = Number(clientState.momentIdx);
        if (typeof state.momentIdx !== 'number' || m > (state.momentIdx as number)) {
          state.momentIdx = m;
        }
      }
      if (typeof clientState.stepIdx === 'number') {
        const sIdx = Number(clientState.stepIdx);
        if (typeof state.stepIdx !== 'number' || sIdx > (state.stepIdx as number)) {
          state.stepIdx = sIdx;
        }
      }
      state.attemptsByAskCode = { ...(state.attemptsByAskCode || {}), ...(clientState.attemptsByAskCode || {}) };
      state.noSeCountByAskCode = { ...(state.noSeCountByAskCode || {}), ...(clientState.noSeCountByAskCode || {}) };
      state.lastActionByAskCode = { ...(state.lastActionByAskCode || {}), ...(clientState.lastActionByAskCode || {}) };
      state.lastAnswerByAskCode = { ...(state.lastAnswerByAskCode || {}), ...(clientState.lastAnswerByAskCode || {}) };
      // Flag opcional
      if (typeof (clientState as any).justAskedFollowUp === 'boolean') {
        state.justAskedFollowUp = Boolean((clientState as any).justAskedFollowUp);
      }
		}
    const coursePolicies = await loadCoursePolicies(deriveCourseId(state.planUrl));
    const teacherProfile = resolveTeacherProfile({
      reqProfile: (body as any)?.teacherProfile,
      planProfile: (state as any)?.plan?.meta?.teacherProfile,
      stateProfile: (state as any)?.teacherProfile
    });
    (state as any).teacherProfile = teacherProfile;
		// Registrar inmediatamente el mensaje del estudiante (en cualquier flujo)
		if (pendingInput && pendingInput.trim()) {
			try {
				await appendHistory(sessionKey, {
					planUrl: state.planUrl,
					stepIdx: state.stepIdx,
					momentIdx: state.momentIdx,
					content: pendingInput,
					sender: 'student',
					email
				});
				if (email) { try { await setUserLastSession(email, sessionKey); } catch {} }
			} catch {}
		}

		const step = currentStep(state);
		// Emit inicio de turno y log de arranque
		try { engineLogger.engineTurnStart(sessionKey, state.stepIdx, String(step?.type || '')); } catch {}
		// Debug inicio de turno
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st0 = currentStep(state);
				const payload0 = {
					tag: 'engine.turn.start',
					sessionKey,
					momentTitle: state.plan?.moments?.[st0?.momentIndex || 0]?.title,
					stepType: st0?.type,
					stepIdx: state.stepIdx,
					userInputLen: (pendingInput || '').length
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload0));
			}
		} catch {}
		
		// Interceptor universal de consultas (antes de evaluar el ASK)
		state.consultCtx = state.consultCtx || {};
		
		// Variables de salida
		let message = '';
		let followUp = '';
		let displayValue: string | undefined;
		// Variables para r√∫brica/evaluaci√≥n
		let assessment: any = null;
		let lastClsKind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'|null = null;
		let lastMatched: string[] = [];
		let lastMissing: string[] = [];
		let lastAttempts = 0;
		let lastHints = 0;
		let lastStepCodeForAssess = '';
		
		// --- REEMITIR REPREGUNTA SI A√öN NO RESPONDE (continuidad) ---
		if (!pendingInput.trim() && state.justAskedFollowUp && state.lastFollowUpText) {
			return NextResponse.json({
				message: '',
				followUp: state.lastFollowUpText,
				state
			});
		}

		// Saludos: responder c√°lido y retomar la pregunta vigente
		if (pendingInput.trim() && isGreetingInput(pendingInput)) {
			const st = currentStep(state);
			const q = st?.type === 'ASK' ? (st as any).data?.question || '' : '';
			try {
				const recent = await getRecentHistory(sessionKey, 6);
				const greet = await runFeedbackAgent({
					language: 'es',
					action: 'feedback',
					stepType: 'ASK',
					questionText: pendingInput,
					objective: String((st as any)?.data?.objective || state.plan?.meta?.lesson_name || ''),
					recentHistory: recent,
					allowQuestions: true,
					conversationMode: true
				} as any);
				message = (greet.message || '').trim();
			} catch { message = ''; }
			followUp = q;
			state.justAskedFollowUp = Boolean(followUp);
			return NextResponse.json({ message, followUp, state });
		}

		// Consulta personal: responder con alias y redirigir al objetivo (v√≠a LLM)
		if (pendingInput.trim() && isPersonalInfoQuery(pendingInput)) {
			const st = currentStep(state);
			const q = st?.type === 'ASK' ? (st as any).data?.question || '' : '';
			try {
				const recent = await getRecentHistory(sessionKey, 6);
				const resp = await runFeedbackAgent({
					language: 'es',
					action: 'feedback',
					stepType: 'ASK',
					questionText: pendingInput,
					objective: String((st as any)?.data?.objective || state.plan?.meta?.lesson_name || ''),
					recentHistory: recent,
					allowQuestions: true,
					conversationMode: true
				} as any);
				message = (resp.message || '').trim();
			} catch { message = ''; }
			followUp = q;
			state.justAskedFollowUp = Boolean(followUp);
			return NextResponse.json({ message, followUp, state });
		}

		// Consulta general/plataforma: responder breve y retomar el plan
		if (!state.consultCtx.active && pendingInput.trim() && (isPlatformHelpQuery(pendingInput) || isGeneralKnowledgeStyleQuestion(pendingInput))) {
			const st = currentStep(state);
			const q = st?.type === 'ASK' ? (st as any).data?.question || '' : '';
			try {
				// Registrar punto de pausa y el desv√≠o
				(state as any).diversionStack = Array.isArray((state as any).diversionStack) ? (state as any).diversionStack : [];
				(state.consultCtx ||= {}).pausedAt = { momentIndex: state.momentIdx, stepIndex: state.stepIdx } as any;
				(state as any).diversionStack.push({ fromMomentIndex: state.momentIdx, fromStepIndex: state.stepIdx, reason: isPlatformHelpQuery(pendingInput) ? 'PLATFORM' : 'GENERAL', query: pendingInput, timestamp: Date.now() });
			} catch {}
			try {
				const recent = await getRecentHistory(sessionKey, 6);
				const rel = await retrieveTopKWithScores(pendingInput, (state as any).ragIndex, 3);
				const items = rel.map(r => r.text);
				const resp = await runFeedbackAgent({
					language: 'es',
					action: 'feedback',
					stepType: 'ASK',
					questionText: pendingInput,
					objective: String(state.plan?.meta?.lesson_name || ''),
					contentBody: items,
					recentHistory: recent,
					allowQuestions: false,
					conversationMode: true
				} as any);
				message = (resp.message || '').trim();
			} catch { message = ''; }
			// Retomar con la pregunta actual si existe
			followUp = q;
			state.justAskedFollowUp = Boolean(followUp);
			return NextResponse.json({ message, followUp, state });
		}
		
		// --- CONSULTA ACTIVA: si ya estamos en modo consulta, responder cualquier entrada como consulta ---
		if (state.consultCtx.active && pendingInput.trim()) {
			const recent = await getRecentHistory(sessionKey, 6);
			const qa = await runFeedbackAgent({
				language: 'es',
				action: 'feedback',
				stepType: 'ASK',
				questionText: pendingInput,
				objective: String(state.plan?.meta?.lesson_name || ''),
				recentHistory: recent,
				allowQuestions: true,
				conversationMode: true
			} as any);
			message = (qa.message || '').trim();
			state.consultCtx.turns = Number(state.consultCtx.turns || 0) + 1;
			const consultMax2 = Number((coursePolicies as any)?.conversation?.maxTurns ?? 3);
			if (state.consultCtx.turns >= consultMax2) {
				state.consultCtx.active = false;
				state.consultCtx.turns = 0;
				// Restaurar el punto pausado si existe
				try {
					const paused = (state.consultCtx as any).pausedAt;
					if (paused && typeof paused.stepIndex === 'number') {
						state = advanceTo(state, paused.stepIndex);
						state.momentIdx = paused.momentIndex ?? state.momentIdx;
						SESSIONS.set(sessionKey, state);
						try { await getSessionStore().set(sessionKey, state); } catch {}
						(state.consultCtx as any).pausedAt = undefined;
					}
				} catch {}
				const st = currentStep(state);
				if (st?.type === 'ASK') {
					followUp = st.data?.question || '';
					message = composeUniqueText(message, 'Retomando‚Ä¶');
					state.justAskedFollowUp = Boolean(followUp);
				}
			}
			return NextResponse.json({ message, followUp: followUp || '', state });
		}
		
		// 1) Si el alumno pide "permiso" para preguntar (detecci√≥n sem√°ntica de intenci√≥n)
		const isNoSeRegex = /^\s*(no\s*(lo\s*)?s[e√©]|no\s*est[o√≥]y?\s*seguro|no\s*s[e√©]\s*bien)\s*$/i;
		const consultMax = Number((coursePolicies as any)?.conversation?.maxTurns ?? 3);
		state.consultCtx = state.consultCtx || { active: false, turns: 0 };
		if (!isNoSeRegex.test(pendingInput) && (await isStudentAskingQuestionSem(pendingInput, (state as any).teacherProfile)) && !/\?\s*$/.test(pendingInput)) {
			// Intenci√≥n sin pregunta expl√≠cita ‚Üí pedir la consulta (v√≠a LLM)
			state.consultCtx.active = true;
			state.consultCtx.turns = 0;
			try { (state.consultCtx as any).pausedAt = { momentIndex: state.momentIdx, stepIndex: state.stepIdx }; } catch {}
			try { (state as any).diversionStack?.push({ fromMomentIndex: state.momentIdx, fromStepIndex: state.stepIdx, reason: 'GENERAL', query: pendingInput, timestamp: Date.now() }); } catch {}
			try {
				const recent = await getRecentHistory(sessionKey, 6);
				const askC = await runFeedbackAgent({
					language: 'es',
					action: 'feedback',
					stepType: 'ASK',
					questionText: pendingInput,
					objective: String(state.plan?.meta?.lesson_name || ''),
					recentHistory: recent,
					allowQuestions: true,
					conversationMode: true
				} as any);
				message = (askC.message || '').trim();
			} catch { message = ''; }
			return NextResponse.json({ message, followUp: '', state });
		}
		
		// 2) Si trae una pregunta concreta (termina en ?)
		if (!isNoSeRegex.test(pendingInput) && /\?\s*$/.test(pendingInput)) {
			state.consultCtx.active = true;
			state.consultCtx.turns = Number(state.consultCtx.turns || 0) + 1;
			try { (state.consultCtx as any).pausedAt = (state.consultCtx as any).pausedAt || { momentIndex: state.momentIdx, stepIndex: state.stepIdx }; } catch {}
			try { (state as any).diversionStack?.push({ fromMomentIndex: state.momentIdx, fromStepIndex: state.stepIdx, reason: 'GENERAL', query: pendingInput, timestamp: Date.now() }); } catch {}
			const recent = await getRecentHistory(sessionKey, 6);
			const qa = await runFeedbackAgent({
				language: 'es',
				action: 'feedback',
				stepType: 'ASK',
				questionText: pendingInput,
				objective: String(state.plan?.meta?.lesson_name || ''),
				recentHistory: recent,
				allowQuestions: true,
				conversationMode: true
			} as any);
			message = (qa.message || '').trim();
			if (state.consultCtx.turns >= consultMax) {
				state.consultCtx.active = false;
				state.consultCtx.turns = 0;
				const st = currentStep(state);
				if (st?.type === 'ASK') {
					followUp = st.data?.question || '';
					message = composeUniqueText(message, 'Retomando‚Ä¶');
					state.justAskedFollowUp = Boolean(followUp);
				}
			}
			return NextResponse.json({ message, followUp: followUp || '', state });
		}

		// 3) Si el alumno confirma que ya entendi√≥, retomas donde qued√≥, incluyendo se√±ales conversacionales
		if (state.consultCtx.active && isAffirmativeToResume(pendingInput, (state as any).teacherProfile)) {
			state.consultCtx.active = false;
			state.consultCtx.turns = 0;
			// Restaurar el punto pausado si existe
			try {
				const paused = (state.consultCtx as any).pausedAt;
				if (paused && typeof paused.stepIndex === 'number') {
					state = advanceTo(state, paused.stepIndex);
					state.momentIdx = paused.momentIndex ?? state.momentIdx;
					SESSIONS.set(sessionKey, state);
					try { await getSessionStore().set(sessionKey, state); } catch {}
					(state.consultCtx as any).pausedAt = undefined;
				}
			} catch {}
			const st = currentStep(state);
			if (st?.type === 'ASK') {
				const q = st.data?.question || '';
				message = '';
				followUp = q;
				state.justAskedFollowUp = Boolean(followUp);
				return NextResponse.json({ message, followUp, state });
			}
		}
		
		// Bucle: saltar SKIP consecutivos y construir salida adecuada
		// Debug vars
		let dbg: any = null;
		let safety = 0;
    let skipGuarantee = false;
		while (safety++ < 20) {
			const act = decideAction(currentStep(state));
			if (act.kind === 'skip') {
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				continue;
			}
			if (act.kind === 'explain') {
				const data = act.step.data;
				const parts = [data.title, ...(data.body || []), data.text, ...(data.items || [])].filter(Boolean) as string[];
				const bodyArr: string[] = parts as string[];
				try {
					// Anti-repetici√≥n por paso: explicar cada CONTENT/NARRATION solo una vez
					const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
					const stepKey = `${act.step.momentIndex}-${act.step.stepIndex}`;
					const already = Boolean((shownMap as any)[stepKey]);
					if (!already) {
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({
						language: 'es',
						action: 'explain',
						stepType: act.step.type,
						momentTitle: state.plan?.moments[act.step.momentIndex]?.title,
						objective: state.plan?.meta?.lesson_name || '',
						contentBody: bodyArr,
						recentHistory: recent
					});
						message = llm.message || bodyArr.join(' ‚Äî ') || 'Continuemos con el contenido.';
						(shownMap as any)[stepKey] = true;
					} else {
						message = '';
					}
				} catch {
					message = bodyArr.join(' ‚Äî ') || 'Continuemos con el contenido.';
				}
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				// Buscar la siguiente ASK saltando pasos de metadatos y avanzar el puntero a ella
				const steps = state.plan?.allSteps || [];
				let targetIdx: number | undefined;
				for (let i = state.stepIdx; i < steps.length; i++) {
					const s = steps[i];
					const t = s.type;
					if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'EXPECTED_LEARNING') continue;
					if (t === 'ASK') { followUp = s.data.question || ''; targetIdx = i; }
					break;
				}
				// marcar flag para evitar eco y adelantar estado a la ASK
				state.justAskedFollowUp = Boolean(followUp);
				state.lastFollowUpText = followUp;
				// marca narrativa mostrada por paso: ya marcada en shownByStepIndex
				if (typeof targetIdx === 'number') { state = advanceTo(state, targetIdx); }
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				break;
			}
        if (act.kind === 'ask') {
            // Registrar mensaje del estudiante si hay entrada
            if (pendingInput && pendingInput.trim()) {
              try {
                await appendHistory(sessionKey, {
                  planUrl: state.planUrl,
                  stepIdx: state.stepIdx,
                  momentIdx: state.momentIdx,
                  content: pendingInput,
                  sender: 'student',
                  email
                });
                if (email) { try { await setUserLastSession(email, sessionKey); } catch {} }
              } catch {}
            }
				const q = act.step.data.question || '';
				const acceptable = act.step.data.acceptable_answers || [];
				// Pol√≠tica por tipo con K din√°mico para LISTADO
				const qtype = String(act.step.data.question_type || '').toLowerCase();
				// Identificador del paso para contar intentos/acciones previas
				const stepCodeDyn = act.step.code || `Q:${q.substring(0,50)}`;
				const attemptsSoFar = Number(state.attemptsByAskCode?.[stepCodeDyn] || 0);
				const lastActionForStep = String(state.lastActionByAskCode?.[stepCodeDyn] || 'ask');
				const firstAttempt = attemptsSoFar === 0;
				const afterHint = lastActionForStep === 'hint';
				// Escala por intento: S1 exige 2; S2/S3 exige 1
				const dynamicK = qtype.includes('lista') ? (firstAttempt ? 2 : 1) : undefined;
				const policy: AskPolicy = qtype.includes('lista') ? { type: 'listado', thresholdK: dynamicK }
					: qtype.includes('aplica') ? { type: 'aplicacion', requiresJustification: true }
					: (qtype.includes('abierta') ? { type: 'metacognitiva' } : { type: (qtype as any) || 'conceptual' });
				// Usar solo el objective para generar preguntas y pistas
				let expected: string[] = [];
				try {
					const objective = String(act.step.data?.objective || '');
					// Extraer palabras clave del objective para usar como expected
					const objectiveWords = objective.split(/\s+/).filter(word => word.length > 3).slice(0, 5);
					expected = objectiveWords;
				} catch {}
          const momentKind = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
          const maxAttempts = Number(coursePolicies?.advance?.maxAttemptsBeforeForce ?? 3);
          const allowForcedOn: string[] = Array.isArray(coursePolicies?.advance?.allowForcedOn) ? coursePolicies.advance.allowForcedOn : ['CONEXION'];
          const forceNoSeThreshold = Number((coursePolicies as any)?.advance?.forceOnNoSeThreshold ?? 3);
          const stepCode = act.step.code || `Q:${q.substring(0,50)}`;
          if (!pendingInput.trim()) {
            // evitar eco si acabamos de adjuntar followUp
            if (state.justAskedFollowUp) {
              message = '';
              followUp = '';
              state.justAskedFollowUp = false;
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
              skipGuarantee = true;
              break;
            }
            // F0/F1: emitir pista motivadora + micro-pregunta y contabilizar intento/ayuda
            try {
              const askData: any = (act as any)?.step?.data || {};
              const recent = await getRecentHistory(sessionKey, 4);
              const sevIdx0 = Number(state.hintsByAskCode?.[stepCode] || 0);
              let hintLimit0 = getHintWordLimit(coursePolicies, sevIdx0);
              try { hintLimit0 = varyHintLimit(hintLimit0, pickVariant(sessionKey)); } catch {}
              const llmHint = await runHintAgent({
                language: 'es',
                action: 'hint',
                stepType: 'ASK',
                questionText: q,
                objective: String(askData.objective || ''),
                contentBody: [String(act.step.data?.objective || '')],
                hintWordLimit: hintLimit0,
                allowQuestions: true,
                recentHistory: recent,
                attempts: Number(state.attemptsByAskCode?.[stepCode] || 0),
                hintsUsed: Number(state.hintsByAskCode?.[stepCode] || 0)
              } as any);
              const fu0 = (llmHint.followUp || q).trim();
              message = composeUniqueText(fu0, llmHint.message || '');
              followUp = fu0;
            } catch {
              message = '';
              followUp = q;
            }
            // Contadores y estado de hint
            const attemptsMap: any = state.attemptsByAskCode || (state.attemptsByAskCode = {} as any);
            const hintsMap0: any = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
            const lastActionMap0: any = state.lastActionByAskCode || (state.lastActionByAskCode = {} as any);
            attemptsMap[stepCode] = (attemptsMap[stepCode] || 0) + 1;
            hintsMap0[stepCode] = (hintsMap0[stepCode] || 0) + 1;
            lastActionMap0[stepCode] = 'hint';
            state.justAskedFollowUp = Boolean(followUp);
            state.lastFollowUpText = followUp;
            // Force advance si aplica tras intentos
            if ((state.attemptsByAskCode[stepCode] || 0) >= maxAttempts && allowForcedOn.includes(momentKind)) {
              const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
              if (typeof nextAskIdx === 'number') {
                state = advanceTo(state, nextAskIdx);
                followUp = (currentStep(state) as any)?.data?.question || '';
                state.justAskedFollowUp = Boolean(followUp);
              }
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                message = [message, bridge.message].filter(Boolean).join('\n\n');
              } catch {}
            }
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            break;
          }
          // Evaluaci√≥n para preguntas abiertas (answer_type: "open")
          const answerType = (act.step.data as any)?.answer_type || '';
          const rubric = (act.step.data as any)?.rubric || {};
          const objText = String(act.step.data?.objective || '');
          const isOpen = (answerType === 'open') || String((act.step.data as any)?.question_type || '').toLowerCase().includes('abierta');
          
          // Log de inicio de evaluaci√≥n
          try {
            engineLogger.evaluationStart(sessionKey, stepCode, pendingInput);
          } catch {}
          
          let cls: any;
          let vague: boolean = false;
          const hintsUsed = Number(state.hintsByAskCode?.[stepCode] || 0);
          const attempts = state.attemptsByAskCode?.[stepCode] || 0;
          
          {
            // Gate previo por tokens √∫tiles (evitar PARTIAL fantasma)
            const minTokens = Number(((coursePolicies as any)?.evaluation?.thresholds?.minTokens) ?? 3);
            if (shouldGateByMinTokens(pendingInput, minTokens)) {
              cls = { kind: 'HINT', reason: 'MIN_TOKENS', matched: [], missing: (Array.isArray(acceptable) && acceptable.length ? acceptable : (expected||[])).slice(0,3) } as any;
              vague = true;
            }
            // Evaluaci√≥n SOLO con embeddings (incluye abiertas), con umbral de parcial m√°s cercano configurable
            const evalCfg = (coursePolicies as any)?.evaluation?.semantic || {};
            const semOpen = evalCfg.open || { semThresh: 0.28, semBestThresh: 0.24 };
            const semClosed = evalCfg.closed || { semThresh: 0.44, semBestThresh: 0.34 };
            const th = isOpen ? semOpen : semClosed;
                          const acceptablesEff = isOpen ? [String(act.step.data?.objective || '')] : acceptable;
            if (!vague) {
              const sem = await evaluateSemanticOnly(
                pendingInput,
                acceptablesEff,
                expected,
                policy,
                { semThresh: Number(th.semThresh ?? (isOpen ? 0.28 : 0.44)), semBestThresh: Number(th.semBestThresh ?? (isOpen ? 0.22 : 0.34)), maxHints: Number(coursePolicies?.hints?.maxHints ?? 2), vagueCenter: {
                  corpus: (state as any)?.teacherProfile?.eval?.vagueCenter?.corpus,
                  tauVagueMin: (state as any)?.teacherProfile?.eval?.vagueCenter?.tauVagueMin,
                  delta: (state as any)?.teacherProfile?.eval?.vagueCenter?.delta,
                  tauObj: isOpen ? (Number((state as any)?.teacherProfile?.eval?.vagueCenter?.tauObjOpen ?? th.semThresh)) : (Number((state as any)?.teacherProfile?.eval?.vagueCenter?.tauObjClosed ?? th.semThresh))
                } },
                { hintsUsed, sessionKey, stepCode }
              );
              cls = { kind: sem.kind, matched: sem.matched, missing: sem.missing, reason: sem.reason, sem: sem.sem };
              vague = false;
            }
            // Evaluaci√≥n basada en objective (no keywords espec√≠ficos)
            if (!vague && cls?.kind !== 'ACCEPT') {
              try {
                const objective = String(act.step.data?.objective || '');
                const textN = normalize(String(pendingInput || ''));
                // Evaluar si la respuesta est√° alineada con el objective
                const objectiveWords = normalize(objective).split(/\s+/).filter(word => word.length > 3);
                const kwHits = objectiveWords.filter(k => textN.includes(k)).length;
                const kwMin = Number(((coursePolicies as any)?.evaluation?.thresholds?.keywordMin) ?? 1);
                // Suavizar: si hay se√±al sem√°ntica previa (cls.kind === 'PARTIAL'), no degradar a HINT solo por keywords
                if (kwHits < kwMin && cls?.kind !== 'PARTIAL') { (cls as any).kind = 'HINT'; }
              } catch {}
            }
            // Capturar evaluaci√≥n para r√∫brica
            lastClsKind = cls.kind as any;
            lastMatched = Array.isArray(cls.matched) ? cls.matched : [];
            lastMissing = Array.isArray(cls.missing) ? cls.missing : [];
            lastAttempts = attempts;
            lastHints = hintsUsed;
            lastStepCodeForAssess = stepCode;
            
            // Log de clasificaci√≥n de evaluaci√≥n
            try {
              engineLogger.evaluationResult(sessionKey, stepCode, cls.kind as any, cls.reason);
            } catch {}
            // Log expl√≠cito en consola (si debug activo por pol√≠ticas o env)
            try {
              const debugOnNow = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
              if (debugOnNow) {
                // eslint-disable-next-line no-console
                console.debug(JSON.stringify({
                  tag: 'evaluation.result',
                  sessionKey,
                  stepCode,
                  classification: cls.kind,
                  reason: cls.reason,
                  matched: (Array.isArray(cls.matched) ? cls.matched.slice(0,5) : []),
                  missing: (Array.isArray(cls.missing) ? cls.missing.slice(0,5) : [])
                }));
              }
            } catch {}
          }
          
          // Endurecer aceptaci√≥n en SALUDO/CONEXI√ìN (evitar falsos ACCEPT)
          const isMeta = String(qtype).includes('abierta');
          
          // Aceptaci√≥n en metacognitivas: permitir avance con 1 se√±al v√°lida
          if (isMeta && cls.kind === 'ACCEPT') {
            const matchedCount = (cls.matched || []).length;
            const strongEnough = matchedCount >= 1;
            if (!strongEnough) {
              (cls as any).kind = 'HINT';
            }
          }
          
          // Regla del cuadro: PARTIAL -> Avanza y registra pendientes (sin reask)
          if (!vague && cls.kind === 'PARTIAL') {
            try {
              // Registrar pendientes y marcar como parcialmente respondida
              const faltos = Array.isArray(cls.missing) ? cls.missing.slice(0, 3) : [];
              (state as any).partiallyAnsweredAskCodes = Array.from(new Set([
                (((state as any).partiallyAnsweredAskCodes || []) as string[]), stepCode
              ]));
              (state as any).pendingRemediation = (state as any).pendingRemediation || {};
              if (faltos.length) (state as any).pendingRemediation[stepCode] = faltos;

              // Feedback breve de tipo PARCIAL
              let fb = '';
              try {
                const fbCfg: any = (coursePolicies as any)?.feedback || {};
                const recent = await getRecentHistory(sessionKey, 4);
                const llm = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: [String(act.step.data?.objective || '')], hintWordLimit: Number(fbCfg.maxSentences ?? 2), allowQuestions: fbCfg.allowQuestions !== false, kind: 'PARTIAL' as any, recentHistory: recent });
                fb = llm.message || '';
              } catch {}

              // Avanzar y preparar siguiente paso
              state = next(state);
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}

              let nextMsg = '';
              const nextStep = currentStep(state);
              if (nextStep?.type === 'NARRATION' || nextStep?.type === 'CONTENT') {
                const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                const stepKey = `${nextStep.momentIndex}-${nextStep.stepIndex}`;
                if (!(shownMap as any)[stepKey]) {
                  try {
                    const recent = await getRecentHistory(sessionKey, 4);
                    const explain = await runDocenteLLM({ language: 'es', action: 'explain', stepType: nextStep.type, narrationText: nextStep.data?.text || '', contentBody: nextStep.data?.body || [], caseText: (nextStep.data as any)?.case || '', objective: String(nextStep.data?.objective || state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                    if ((explain.message || '').trim()) { nextMsg = explain.message!; (shownMap as any)[stepKey] = true; }
                  } catch { nextMsg = ''; }
                }
                state = next(state);
                SESSIONS.set(sessionKey, state);
                try { await getSessionStore().set(sessionKey, state); } catch {}
              }

              const nextAskStep = currentStep(state);
              if (nextAskStep?.type === 'ASK') {
                followUp = nextAskStep.data?.question || '';
                state.justAskedFollowUp = Boolean(followUp);
              }
              message = [fb, nextMsg].filter(Boolean).join('\n\n');
              dbg = { ...(dbg || {}), kind: 'PARTIAL', feedbackKind: 'PARTIAL', matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], stepCode };
              pendingInput = '';
              break;
            } catch {}
          }
          
          // En metacognitiva (Saludo) NO aceptar respuestas DONT_KNOW/VAGUE ni por longitud.
          // La aceptaci√≥n debe basarse en se√±ales reales del objetivo/expected o acceptable.
          // Feedback determinista usando util reutilizable
          if (!vague && cls.kind === 'ACCEPT') {
            let fb = '';
            try {
              const fbCfg: any = (coursePolicies as any)?.feedback || {};
              const recent = await getRecentHistory(sessionKey, 4);
              // En ACCEPT, evitar re-preguntar dentro del feedback por defecto
              const allowQ = fbCfg && typeof fbCfg.allowQuestions === 'boolean' ? Boolean(fbCfg.allowQuestions) : false;
              const llm = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: [String(act.step.data?.objective || '')], hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: allowQ, kind: 'ACCEPT' as any, recentHistory: recent });
              fb = llm.message || '';
            } catch {}
            
            // ‚úÖ Marcar cumplimiento de la ASK actual
            state.answeredAskCodes = Array.isArray(state.answeredAskCodes) ? state.answeredAskCodes : [];
            const code = act.step.data?.code || stepCode;
            if (!state.answeredAskCodes.includes(code)) {
              state.answeredAskCodes.push(code);
            }
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            
            // Protecci√≥n de cumplimiento: verificar que la ASK actual est√© respondida antes de avanzar
            const currentStepCode = act.step.code || stepCode;
            const isAnswered = Array.isArray(state.answeredAskCodes) && state.answeredAskCodes.includes(currentStepCode);

            if (!isAnswered && act.step.type === 'ASK') {
              // No avanzar si la ASK actual no est√° respondida, salvo si la pol√≠tica lo permite
              const mk = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
              const allowForcedArr = Array.isArray((coursePolicies as any)?.advance?.allowForcedOn) ? (coursePolicies as any).advance.allowForcedOn as string[] : ['CONEXION'];
              const policyAllowsForce = allowForcedArr.includes(mk);

              if (!policyAllowsForce) {
                // Re-preguntar la ASK actual
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'reask', stepCode };
                pendingInput = '';
                break;
              }
            }
            
            // Avanzar al siguiente paso en orden secuencial (no saltar ASKs)
            state = next(state);
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            
            // Componer salida seg√∫n el tipo de paso siguiente
            let nextMsg = '';
            
            // Consumir pasos narrativos consecutivos (NARRATION, CONTENT, CASE)
            while (true) {
              const ns = currentStep(state);
            
            // Debug: verificar qu√© paso es el siguiente
            if (process.env.ENGINE_DEBUG === 'true') {
              console.log('[AVANCE_ACCEPT]', { 
                  nextStepType: ns?.type, 
                  nextStepCode: ns?.code,
                  nextStepText: ns?.data?.text?.slice(0, 50),
                  momentIndex: ns?.momentIndex,
                  stepIndex: ns?.stepIndex
                });
              }

              if (!ns) break;
              if (ns.type === 'NARRATION' || ns.type === 'CONTENT' || ns.type === 'CASE') {
              // Blindaje anti-repetici√≥n: verificar si ya se mostr√≥ este contenido
              const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                const stepKey = `${ns.momentIndex}-${ns.stepIndex}`;
              if (!(shownMap as any)[stepKey]) {
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const explain = await runDocenteLLM({ 
                    language: 'es', 
                    action: 'explain', 
                      stepType: ns.type, 
                      narrationText: ns.data?.text || '',
                      contentBody: ns.data?.body || [],
                      caseText: (ns.data as any)?.case || '',
                      objective: String(ns.data?.objective || state.plan?.meta?.lesson_name || ''),
                    recentHistory: recent 
                  });
                    // Acumular narrativa √∫nicamente si hay contenido real
                  if ((explain.message || '').trim()) {
                      nextMsg = composeUniqueText(nextMsg, explain.message!);
                      (shownMap as any)[stepKey] = true;
                    }
                  } catch {}
                }
                // Avanzar al siguiente paso tras la narrativa (se haya mostrado o no)
              state = next(state);
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
                continue;
              }
              break;
            }
            
            // Si hay una pregunta siguiente, ponerla como followUp (evitar repetir la misma ASK)
            const nextAskStep = currentStep(state);
            if (nextAskStep?.type === 'ASK') {
              const justAnswered = act.step.code || stepCode;
              const candidateCode = nextAskStep.code || nextAskStep.data?.code;
              if (candidateCode && candidateCode !== justAnswered) {
              followUp = nextAskStep.data?.question || '';
              state.justAskedFollowUp = Boolean(followUp);
              dbg = { ...(dbg || {}), messageType: 'ask', nextAction: 'ask' };
              }
            }
            
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            message = composeUniqueText(fb, nextMsg);
            
            // Debug: verificar la composici√≥n final del mensaje
            if (process.env.ENGINE_DEBUG === 'true') {
              console.log('[MENSAJE_FINAL]', { 
                fbLength: fb.length,
                nextMsgLength: nextMsg.length,
                messageLength: message.length,
                messagePreview: message.slice(0, 200),
                hasNarrativa: nextMsg.length > 0
              });
            }
            dbg = { ...(dbg || {}), kind: 'ACCEPT', feedbackKind: 'ACCEPT', matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], stepCode };
					pendingInput = '';
            break;
				}
          // Contabilizar respuesta previa y contadores separados para 'no s√©'
          state.lastAnswerByAskCode![stepCode] = pendingInput;
          const noSeMap = state.noSeCountByAskCode || (state.noSeCountByAskCode = {});
          // Detecci√≥n real de "no s√©" / evasivas - M√ÅS PERMISIVO
          const isNo = isNoSeInput(pendingInput);
          if (isNo) {
            noSeMap[stepCode] = (noSeMap[stepCode] || 0) + 1;
            // Si es "no s√©", adem√°s de noSeCount, cuenta intento pedag√≥gico
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          } else {
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          }
          const vagueCfg = coursePolicies?.vague || {};
          if (vague || cls.kind === 'HINT' || isNo || cls.reason === 'MAX_HINTS' || cls.reason === 'SEM_LOW') {
            // Pol√≠tica de reintentos por pregunta (loop control)
            const lastActionMap = state.lastActionByAskCode || (state.lastActionByAskCode = {});
            const hintsMap = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
            const attempts = state.attemptsByAskCode[stepCode] || 0;
            const currentHints = hintsMap[stepCode] || 0;
            const lastAction = (lastActionMap[stepCode] as any) || 'ask';
            // Avance forzado temprano: tras 2 "no se" consecutivos en momentos permitidos
            try {
              const momentKindNow = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
              const noSeCountNow = state.noSeCountByAskCode?.[stepCode] || 0;
              const allowForcedArr = Array.isArray((coursePolicies as any)?.advance?.allowForcedOn) ? (coursePolicies as any).advance.allowForcedOn as string[] : allowForcedOn;
              const forceDecision = decideForceAdvanceByNoSe({ noSeCount: noSeCountNow, forceNoSeThreshold, allowForcedOn: allowForcedArr, momentKind: momentKindNow });
              if (isNo && forceDecision.shouldForceAdvance) {
                // Mover a la siguiente ASK del mismo ciclo, respetando narrativa previa
                const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
                if (typeof nextAskIdx === 'number') {
                  try {
                    const steps: any[] = state?.plan?.allSteps || [];
                    const ask = steps[nextAskIdx];
                    const targetMoment = ask?.momentIndex;
                    let narrationIdx: number | undefined = undefined;
                    for (let i = 0; i < steps.length; i++) {
                      const s = steps[i];
                      if (s?.momentIndex !== targetMoment) continue;
                      if (s.stepIndex < ask.stepIndex && (s.type === 'NARRATION' || s.type === 'CONTENT')) { narrationIdx = i; break; }
                      if (s.stepIndex >= ask.stepIndex) break;
                    }
                    if (typeof narrationIdx === 'number') {
                      const stKey = `${steps[narrationIdx].momentIndex}-${steps[narrationIdx].stepIndex}`;
                      const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                      if (!(shownMap as any)[stKey]) {
                        try {
                          const recent = await getRecentHistory(sessionKey, 4);
                          const explain = await runDocenteLLM({ language: 'es', action: 'explain', stepType: steps[narrationIdx].type, narrationText: steps[narrationIdx].data?.text || '', contentBody: steps[narrationIdx].data?.body || [], objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                          message = composeUniqueText(message, explain.message || '');
                          (shownMap as any)[stKey] = true;
                        } catch {}
                      }
                    }
                  } catch {}
                  state = advanceTo(state, nextAskIdx);
                  SESSIONS.set(sessionKey, state);
                  try { await getSessionStore().set(sessionKey, state); } catch {}
                  followUp = (currentStep(state) as any)?.data?.question || '';
                  state.justAskedFollowUp = Boolean(followUp);
                  state.lastFollowUpText = followUp;
                }
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = composeUniqueText(message, bridge.message);
                } catch {}
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'force_advance', stepCode };
                pendingInput = '';
                break;
              }
            } catch {}
            
            // Actualizar contadores: diferir incremento de hints
            if (cls.kind === 'HINT' || vague || isNo) {
              // El incremento real de hints se realiza solo cuando emitimos una pista m√°s abajo
              lastActionMap[stepCode] = 'hint';
            }
            
            // Detectar si el estudiante est√° haciendo una pregunta (solo si NO es no‚Äës√©/vago/HINT)
            const shouldClarify = !vague && !isNo && cls.kind !== 'HINT' && isStudentAskingQuestion(pendingInput, (state as any).teacherProfile);
            if (shouldClarify) {
              // Ruta clarify: insertar micro-explicaci√≥n del objetivo actual
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const clarify = await runDocenteLLM({ 
                  language: 'es', 
                  action: 'explain', 
                  stepType: 'ASK', 
                  objective: String(act.step.data.objective || ''),
                  contentBody: [String(act.step.data.objective || '')],
                  recentHistory: recent 
                });
                message = clarify.message || '';
                // Re-preguntar la ASK actual con reformulaci√≥n
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                dbg = { kind: 'CLARIFY', matched: [], missing: [], nextAction: 'clarify', stepCode };
              } catch {
                message = '';
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
              }
              pendingInput = '';
              break;
            }
            
            // Pol√≠tica de reintentos: 0‚ÜíHINT_1, 1‚ÜíHINT_2, ‚â•2‚Üíopciones o transici√≥n pedag√≥gica
            let fb = '';
            if (attempts < maxAttempts && (cls.kind === 'HINT' || vague || isNo)) {
              // Caso especial: segundo "no s√©" ‚Üí ofrecer DOS opciones (ask_options)
              try {
                const noSeCountNow = Number(state.noSeCountByAskCode?.[stepCode] || 0);
                if (isNo && noSeCountNow === 2) {
                  const itemsSrc = (Array.isArray(cls.missing) && (cls.missing as any[]).length > 0) ? (cls.missing as string[]) : [String(act.step.data?.objective || '')];
                  const items = pickTwoOptions(itemsSrc, [String(act.step.data?.objective || '')]);
                  if (items.length >= 2) {
                const recent = await getRecentHistory(sessionKey, 4);
                    const llm = await runDocenteLLM({
                      language: 'es',
                      action: 'ask_options',
                      stepType: 'ASK',
                      questionText: q,
                      objective: String(act.step.data.objective || state.plan?.meta?.lesson_name || ''),
                      optionItems: items,
                      recentHistory: recent
                    } as any);
                    message = llm.message || '';
                    followUp = '';
                    state.justAskedFollowUp = false;
                    const lastActionMap2 = state.lastActionByAskCode || (state.lastActionByAskCode = {});
                    lastActionMap2[stepCode] = 'options';
                    dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'options', stepCode };
                    pendingInput = '';
                    break;
                  }
                }
              } catch {}
              // Mensaje alentador exclusivamente desde LLM
              try {
                const fbCfg: any = (coursePolicies as any)?.feedback || {};
                const recent = await getRecentHistory(sessionKey, 4);
                const llmFb = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: [String(act.step.data?.objective || '')], hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: false, kind: cls.kind as any, recentHistory: recent });
                fb = llmFb.message || '';
              } catch {}
              // Pista y micro‚Äëpregunta exclusivamente desde LLM
              {
                const objText = String(act.step.data.objective || state.plan?.meta?.lesson_name || '');
                const expectedArr = Array.isArray(expected) ? expected : [];
                const missingArr = Array.isArray(cls.missing) ? cls.missing : [];
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const sevIdx = Number(state.hintsByAskCode?.[stepCode] || 0);
                  let hintLimit = getHintWordLimit(coursePolicies, sevIdx);
                  try { hintLimit = varyHintLimit(hintLimit, pickVariant(sessionKey)); } catch {}
                  const llmHint = await runHintAgent({
                    language: 'es',
                    action: 'hint',
                    stepType: 'ASK',
                    questionText: q,
                    userAnswer: pendingInput,
                    matched: cls.matched,
                    missing: missingArr,
                    objective: objText,
                    contentBody: expectedArr,
                    hintWordLimit: hintLimit,
                    allowQuestions: true,
                    recentHistory: recent,
                    attempts,
                    hintsUsed
                  } as any);
                  const hintMsg = llmHint.message || '';
                  // Micro‚Äëpregunta primero y luego la pista (y mantener followUp)
                  let fu = (llmHint.followUp || '').trim();
                  if (!fu) {
                    try {
                      const recent2 = await getRecentHistory(sessionKey, 4);
                      const reask2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: objText, recentHistory: recent2 });
                      fu = (reask2.followUp || reask2.message || q || '').trim();
                    } catch {
                      fu = q;
                    }
                  }
                  message = composeUniqueText(fb, fu, hintMsg);
                  followUp = fu || q;
                } catch {
                  message = fb || '';
                  followUp = q;
                }

                // Anti‚Äërepetici√≥n de follow‚Äëup con LLM
                if (state.lastFollowUpText && state.lastFollowUpText === followUp) {
                  try {
                    const recent2 = await getRecentHistory(sessionKey, 4);
                    const reask2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: objText, recentHistory: recent2 });
                    followUp = reask2.followUp || reask2.message || q;
                  } catch { followUp = q; }
                }
                state.justAskedFollowUp = Boolean(followUp);
                state.lastFollowUpText = followUp;
                // Incrementar UNA sola pista por turno y por paso
                (state as any).__hintBumpedForStep = (state as any).__hintBumpedForStep || {};
                const bumped = Boolean((state as any).__hintBumpedForStep[stepCode]);
                if (!bumped) {
                  hintsMap[stepCode] = (hintsMap[stepCode] || 0) + 1;
                  (state as any).__hintBumpedForStep[stepCode] = true;
                }
              }
              dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              pendingInput = '';
              break;
            }
            // Transici√≥n pedag√≥gica: usar decideNextAction en lugar de DEFAULT_ACCEPT agresivo
            {
              const momentKind = state.plan?.moments?.[act.step.momentIndex]?.code || '';
              const lastAction = state.lastActionByAskCode?.[stepCode] || '';
              const noSeCount = state.noSeCountByAskCode?.[stepCode] || 0;
              
              const forceDecision = decideForceAdvanceByNoSe({ noSeCount, forceNoSeThreshold, allowForcedOn, momentKind });
              const earlyForce = (cls.kind === 'HINT') && forceDecision.shouldForceAdvance;
              const nextAction = (earlyForce || (attempts >= maxAttempts && cls.kind === 'HINT')) ? 'force_advance' : decideNextAction({
                lastAction,
                noSeCount,
                attempts,
                momentKind
              });
              
              if (nextAction === 'force_advance') {
                // En avance forzado: omitir feedback determinista; el puente vendr√° del LLM
                // Avance forzado respetando orden del JSON: NARRATION/CONTENT -> ASK
                const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
                if (typeof nextAskIdx === 'number') {
                  try {
                    // Intentar emitir narrativa previa del mismo momento si existe
                    const steps: any[] = state?.plan?.allSteps || [];
                    const ask = steps[nextAskIdx];
                    const targetMoment = ask?.momentIndex;
                    let narrationIdx: number | undefined = undefined;
                    for (let i = 0; i < steps.length; i++) {
                      const s = steps[i];
                      if (s?.momentIndex !== targetMoment) continue;
                      if (s.stepIndex < ask.stepIndex && (s.type === 'NARRATION' || s.type === 'CONTENT')) { narrationIdx = i; break; }
                      if (s.stepIndex >= ask.stepIndex) break;
                    }
                    if (typeof narrationIdx === 'number') {
                      // Emitir narrativa si no se mostr√≥
                      const stKey = `${steps[narrationIdx].momentIndex}-${steps[narrationIdx].stepIndex}`;
                      const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                      if (!(shownMap as any)[stKey]) {
                        try {
                          const recent = await getRecentHistory(sessionKey, 4);
                          const explain = await runDocenteLLM({ language: 'es', action: 'explain', stepType: steps[narrationIdx].type, narrationText: steps[narrationIdx].data?.text || '', contentBody: steps[narrationIdx].data?.body || [], objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                          message = composeUniqueText(message, explain.message || '');
                          (shownMap as any)[stKey] = true;
                        } catch {}
                      }
                    }
                  } catch {}
                  // Posicionar en la ASK objetivo y setear followUp
                  state = advanceTo(state, nextAskIdx);
                  SESSIONS.set(sessionKey, state);
                  try { await getSessionStore().set(sessionKey, state); } catch {}
                  followUp = (currentStep(state) as any)?.data?.question || '';
                  state.justAskedFollowUp = Boolean(followUp);
                  state.lastFollowUpText = followUp;
                }
                // Puente breve (si procede)
                try {
                  // Feedback breve del LLM antes del puente
                  try {
                    const fbCfg: any = (coursePolicies as any)?.feedback || {};
                    const recent = await getRecentHistory(sessionKey, 4);
                    const llmFb = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 2), allowQuestions: false, kind: cls.kind as any, recentHistory: recent });
                    message = composeUniqueText(message, llmFb.message || '');
                  } catch {}
                  const recent = await getRecentHistory(sessionKey, 4);
                  const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = composeUniqueText(message, bridge.message);
                } catch {}
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'force_advance', stepCode };
              } else if (nextAction === 'options') {
                // Presentar opciones basadas en expected
                const items = pickTwoOptions([String(act.step.data?.objective || '')]);
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const llm = await runDocenteLLM({
                    language: 'es',
                    action: 'ask_options',
                    stepType: 'ASK',
                    questionText: q,
                    optionItems: items,
                    recentHistory: recent
                  } as any);
                  message = llm.message || '';
                  followUp = '';
                  state.justAskedFollowUp = false;
                } catch {
                  message = q;
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'options';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'options', stepCode };
              } else if (nextAction === 'reask') {
                // Reformular pregunta breve con LLM
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const reask = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = '';
                  followUp = reask.followUp || reask.message || q;
                  state.justAskedFollowUp = Boolean(followUp);
                } catch {
                  message = '';
                  followUp = q;
                  state.justAskedFollowUp = Boolean(followUp);
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'reask';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'reask', stepCode };
              } else if (nextAction === 'hint') {
                // Emitir una pista adicional breve exclusivamente desde LLM
                try {
                const objText = String(act.step.data.objective || state.plan?.meta?.lesson_name || '');
                const expectedArr = [String(act.step.data?.objective || '')];
                const missingArr = Array.isArray(cls.missing) ? cls.missing : [];
                  const recent = await getRecentHistory(sessionKey, 4);
                  const sevIdx3 = Number(state.hintsByAskCode?.[stepCode] || 0);
                  let hintLimit3 = getHintWordLimit(coursePolicies, sevIdx3);
                  try { hintLimit3 = varyHintLimit(hintLimit3, pickVariant(sessionKey)); } catch {}
                  const llmHint2 = await runHintAgent({
                    language: 'es',
                    action: 'hint',
                    stepType: 'ASK',
                  questionText: q,
                    userAnswer: pendingInput,
                    matched: cls.matched,
                  missing: missingArr,
                    objective: objText,
                    contentBody: expectedArr,
                    hintWordLimit: hintLimit3,
                    allowQuestions: true,
                    recentHistory: recent
                  } as any);
                  message = llmHint2.message || '';
                  followUp = llmHint2.followUp || '';
                  state.justAskedFollowUp = Boolean(followUp);
                } catch {
                  message = '';
                followUp = '';
                state.justAskedFollowUp = false;
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'hint';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              } else {
                // Transici√≥n pedag√≥gica por defecto
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction, stepCode };
              }
              pendingInput = '';
              break;
            }
          }
			}
			if (act.kind === 'end') {
				try {
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({ language: 'es', action: 'end', stepType: 'END', objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm.message || '';
				} catch {
					message = '';
				}
				break;
			}
		}
		// Componer assessment (r√∫brica) si hubo una evaluaci√≥n reciente
		try {
			if (lastClsKind) {
				const ev: any = (coursePolicies as any)?.evaluation || {};
				const scoring: Record<string, number> = ev.scoring || { R2: 2, R1: 1, R0: 0 };
				const level = lastClsKind === 'ACCEPT' ? 'R2' : (lastClsKind === 'PARTIAL' ? 'R1' : 'R0');
				const levelNum = level === 'R2' ? 2 : (level === 'R1' ? 1 : 0);
				const aids = Math.max(0, lastHints);
				const aidTag = aids > 0 ? `${levelNum}${'A'.repeat(Math.min(aids, 2))}` : undefined;
				assessment = {
					level,
					score: typeof scoring[level] === 'number' ? scoring[level] : levelNum,
					tags: aidTag ? [aidTag] : [],
					matched: lastMatched,
					missing: lastMissing,
					attempt: lastAttempts,
					hintsUsed: lastHints,
					stepCode: lastStepCodeForAssess
				};
			}
		} catch {}
		
		// Garant√≠a final: siempre devolver un mensaje del docente usando datos del plan
		if (!skipGuarantee && (!message || !String(message).trim()) && (!followUp || !String(followUp).trim())) {
			try {
				const st = currentStep(state);
				const recent = await getRecentHistory(sessionKey, 4);
				if (st?.type === 'ASK') {
					const q2 = (st as any).data?.question || '';
					const llm2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q2, objective: String(((st as any).data?.objective) || state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm2.message || q2;
					followUp = llm2.followUp || followUp;
				} else {
					const d: any = (st as any)?.data || {};
					const parts = [d.title, ...(d.body || []), d.text, ...(d.items || [])].filter(Boolean) as string[];
					const bodyArr: string[] = parts as string[];
					const llm2 = await runDocenteLLM({ language: 'es', action: 'explain', stepType: (st?.type as any) || 'CONTENT', momentTitle: state.plan?.moments[(st as any)?.momentIndex || 0]?.title, objective: state.plan?.meta?.lesson_name || '', contentBody: bodyArr, recentHistory: recent });
					message = llm2.message || bodyArr.join(' ‚Äî ');
				}
			} catch {
				const st: any = currentStep(state);
				const q2 = st?.data?.question || '';
				message = q2 || message || '';
			}
		}
		// Persist history (JSONL/Mongo) - bot (AI)
		try {
			await appendHistory(sessionKey, {
				planUrl: state.planUrl,
				stepIdx: state.stepIdx,
				momentIdx: state.momentIdx,
				message,
				followUp,
				sender: 'ai'
			});
		} catch {}

		// Debug logging opcional
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st = currentStep(state);
				const messageType = (dbg && dbg.messageType) || (dbg && dbg.nextAction) || (st?.type === 'ASK' ? 'ask' : String(st?.type || '').toLowerCase());
				const payload = {
					tag: 'engine.turn',
					sessionKey,
					momentTitle: state.plan?.moments?.[st?.momentIndex || 0]?.title,
					momentKind: mapMomentKind(state.plan?.moments?.[st?.momentIndex || 0]?.title),
					stepType: st?.type,
					stepIdx: state.stepIdx,
					stepCode: (st as any)?.code || dbg?.stepCode,
					classification: dbg?.kind,
					feedbackKind: dbg?.feedbackKind || dbg?.kind,
					messageType,
					matched: dbg?.matched,
					missing: dbg?.missing,
					nextAction: dbg?.nextAction,
					messageChars: (message || '').length,
					followUpChars: (followUp || '').length,
					hasFollowUp: Boolean(followUp && String(followUp).trim()),
					userInputLen: (pendingInput || '').length,
					thresholds: { jaccardMin: 0.25, semThresh: 0.48, semBest: 0.40 },
					hintsUsed: Number(state.hintsByAskCode?.[(st as any)?.code || dbg?.stepCode] || 0)
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload));
			}
		} catch {}
		// Obtener m√©tricas de presupuesto si est√° disponible
		const budgetMetrics = state.budgetCentsLeft !== undefined ? {
			budgetCentsLeft: state.budgetCentsLeft,
			escalationsUsed: state.escalationsUsed || 0,
			adaptiveMode: state.adaptiveMode || false
		} : null;
		// Log estructurado del turno en engine_logs (si LOG_STORE=mongo)
		try {
			engineLogger.emit('engine.turn', {
				stepIdx: state.stepIdx,
				stepCode: (currentStep(state) as any)?.code || dbg?.stepCode,
				classification: dbg?.kind,
				feedbackKind: dbg?.feedbackKind || dbg?.kind,
				nextAction: dbg?.nextAction,
				messageChars: (message || '').length,
				followUpChars: (followUp || '').length,
				userInputLen: (pendingInput || '').length,
				momentIdx: state.momentIdx,
				budgetMetrics
			}, 'info', sessionKey);
		} catch {}

		// Enriquecer con hints usados para el paso actual y m√°ximo desde pol√≠ticas
		let hintsUsedOut = 0;
		try {
			const currCode = (currentStep(state) as any)?.code;
			hintsUsedOut = Number((state as any)?.hintsByAskCode?.[currCode || ''] || 0);
		} catch {}
		const maxHintsOut = Number((coursePolicies as any)?.hints?.maxHints ?? 3);

		return NextResponse.json({ 
			message, 
			followUp, 
			assessment,
			state: { stepIdx: state.stepIdx, done: state.done, hintsUsed: hintsUsedOut, maxHints: maxHintsOut },
			stepCode: (currentStep(state) as any)?.code || undefined,
			momentIdx: state.momentIdx,
			budgetMetrics 
		});
	} catch (err: any) {
		return NextResponse.json({ error: String(err?.message || err) }, { status: 500 });
	}
}


```
=== EOF: app\api\engine\turn\route.ts

===  app\api\audio\transcribe\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';

export async function POST(request: NextRequest) {
  try {
    const form = await request.formData();
    const file = form.get('audio') as File | null;
    const language = (form.get('language') as string) || 'es';

    if (!file) return NextResponse.json({ error: 'Archivo de audio requerido (field: audio)' }, { status: 400 });

    const ai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const aiFile = new File([buffer], file.name || 'audio.webm', { type: file.type || 'audio/webm' });

    const result = await ai.audio.transcriptions.create({ file: aiFile, model: 'whisper-1', language });
    return NextResponse.json({ text: (result as any)?.text || '' });
  } catch (error) {
    console.error('Transcribe error:', error);
    return NextResponse.json({ error: 'Error transcribiendo audio' }, { status: 500 });
  }
}


```
=== EOF: app\api\audio\transcribe\route.ts

===  app\api\auth\[...nextauth]\route.ts
```typescript
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/authOptions';

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };


```
=== EOF: app\api\auth\[...nextauth]\route.ts

