---
repository:
  name: docenteia-v2-monolith
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-23T00:12:05.157Z
  tool: FlatRepo
statistics:
  totalFiles: 72
  totalLines: 6578
  languages:
    typescript: 38
    json: 8
    javascript: 3
    markdown: 3
    tsx: 8
    css: 1
  fileTypes:
    .ts: 38
    .json: 8
    .js: 3
    .md: 3
    .tsx: 8
    "": 1
    .css: 1
    .jsonl: 10
---

===  vitest.config.ts
```typescript
import path from 'path';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});


```
=== EOF: vitest.config.ts

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "archive"]
}
```
=== EOF: tsconfig.json

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```
=== EOF: tailwind.config.js

===  REPORTE_ROUTING_MODELOS.md
```markdown
# Reporte: Implementaci√≥n de Routing de Modelos OpenAI

## üéØ **Objetivo**

Implementar un sistema de routing inteligente de modelos OpenAI para optimizar costos y rendimiento seg√∫n el tipo de tarea.

## üìä **Arquitectura Implementada**

### **1. Router de Modelos (`src/lib/ai.ts`)**

```typescript
export function pickModel(
  tier: "cheap" | "thinker" | "embed" = "cheap"
): string {
  if (tier === "thinker") return process.env.THINKER_MODEL || "o3-mini";
  if (tier === "embed")
    return process.env.EMBED_MODEL || "text-embedding-3-small";
  return process.env.CHEAP_MODEL || "gpt-4o-mini";
}
```

**Tiers implementados:**

- **`cheap`**: `gpt-4o-mini` - Para redacci√≥n docente, hints, reformulaciones
- **`thinker`**: `o3-mini` - Para decisiones dif√≠ciles de evaluaci√≥n
- **`embed`**: `text-embedding-3-small` - Para embeddings sem√°nticos

### **2. Escalamiento Inteligente (`src/engine/eval-escalation.ts`)**

```typescript
export async function escalateReasoning(input: {
  student: string;
  objective: string;
  acceptable: string[];
  expected: string[];
  matched: string[];
  missing: string[];
  hintsUsed: number;
}) {
  // Usa o3-mini con reasoning para decisiones complejas
  const res = await ai.responses.create({
    model: pickModel("thinker"),
    reasoning: { effort: "medium" },
    response_format: { type: "json_object" },
  });
}
```

**Caracter√≠sticas:**

- **JSON estricto** para decisiones
- **Reasoning con esfuerzo medio** para an√°lisis profundo
- **Fallback robusto** si falla el escalamiento

### **3. Integraci√≥n en Pipeline H√≠brido**

```typescript
// Escalamiento a thinker para casos borderline/ambiguos
if (cos >= 0.4 && cos < semThresh && (best?.cos || 0) >= 0.35) {
  const escalation = await escalateReasoning({...});

  if (escalation.decision === 'ACCEPT') {
    return { kind: 'ACCEPT', reason: 'THINKER_ESCALATION' };
  } else if (escalation.decision === 'HINT') {
    return { kind: 'HINT', reason: 'THINKER_ESCALATION' };
  }
}
```

**Criterios de escalamiento:**

- **Similitud sem√°ntica borderline** (0.4 ‚â§ cos < umbral)
- **Mejor match aceptable** (‚â• 0.35)
- **Solo cuando es necesario** para evitar costos innecesarios

## üîß **Cambios Implementados**

### **1. Orquestador (`src/ai/orchestrator.ts`)**

```typescript
// Antes
model: "gpt-4o-mini";

// Despu√©s
const model = pickModel("cheap"); // Usar modelo barato para redacci√≥n docente
```

### **2. Embeddings (`src/engine/semvec.ts`)**

```typescript
// Antes
const MODEL = process.env.EMBED_MODEL || "text-embedding-3-small";

// Despu√©s
const MODEL = pickModel("embed");
```

### **3. Evaluaci√≥n H√≠brida (`src/engine/eval.ts`)**

- **Agregado escalamiento** para casos borderline
- **Integraci√≥n con thinker** para decisiones complejas
- **Fallback robusto** en caso de errores

## üìà **Optimizaci√≥n de Costos**

### **Distribuci√≥n de Uso:**

- **80% cheap** (`gpt-4o-mini`) - Redacci√≥n docente, hints
- **15% embed** (`text-embedding-3-small`) - Similitud sem√°ntica
- **5% thinker** (`o3-mini`) - Decisiones complejas

### **Estimaci√≥n de Costos (por 1000 turnos):**

- **Cheap**: ~$0.50 (redacci√≥n docente)
- **Embed**: ~$0.10 (embeddings)
- **Thinker**: ~$0.25 (decisiones complejas)
- **Total**: ~$0.85 (vs $2.00+ con solo gpt-4o)

**Ahorro estimado: 57%**

## üß™ **Casos de Uso**

### **Caso 1: Redacci√≥n Docente**

```
Input: Sin input del estudiante
Model: cheap (gpt-4o-mini)
Output: Pregunta docente breve
Costo: M√≠nimo
```

### **Caso 2: Evaluaci√≥n Clara**

```
Input: "las partes del procedimiento"
Model: cheap + embed
Output: ACCEPT directo
Costo: Bajo
```

### **Caso 3: Evaluaci√≥n Borderline**

```
Input: "los peligros y los riesgos" (cos: 0.535)
Model: cheap + embed + thinker (o3-mini)
Output: Decisi√≥n basada en reasoning
Costo: Medio (solo cuando necesario)
```

## üîß **Configuraci√≥n de Variables de Entorno**

Agregar en `.env.local`:

```bash
CHEAP_MODEL=gpt-4o-mini
THINKER_MODEL=o3-mini
EMBED_MODEL=text-embedding-3-small
```

## üéØ **Beneficios Implementados**

### **1. Optimizaci√≥n de Costos:**

- **57% de ahorro** estimado en costos de API
- **Uso inteligente** de modelos seg√∫n complejidad
- **Escalamiento condicional** solo cuando es necesario

### **2. Mejor Calidad:**

- **o3-mini** para decisiones complejas con reasoning
- **gpt-4o-mini** para redacci√≥n r√°pida y eficiente
- **text-embedding-3-small** para similitud sem√°ntica

### **3. Robustez:**

- **Fallback autom√°tico** si falla el escalamiento
- **Logs de debug** para monitoreo
- **Configuraci√≥n flexible** por variables de entorno

## üìä **M√©tricas a Monitorear**

### **Uso de Modelos:**

- **Porcentaje de uso** de cada tier
- **Tasa de escalamiento** a thinker
- **Costos por turno** promedio

### **Calidad:**

- **Precisi√≥n de decisiones** con thinker
- **Tiempo de respuesta** por modelo
- **Satisfacci√≥n del usuario**

## üéØ **Estado Final**

**‚úÖ SISTEMA DE ROUTING IMPLEMENTADO**

El sistema ahora:

1. **Usa modelos apropiados** seg√∫n la complejidad de la tarea
2. **Optimiza costos** con escalamiento inteligente
3. **Mantiene calidad** con reasoning para decisiones complejas
4. **Es configurable** por variables de entorno

**Pr√≥ximo paso:** Monitorear m√©tricas de uso y costos para validar la optimizaci√≥n.
```
=== EOF: REPORTE_ROUTING_MODELOS.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia-v2-monolith",
  "version": "2.0.0",
  "description": "DocenteIA V2 - Sistema educativo monol√≠tico con Next.js",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "next lint",
    "test": "vitest",
    "chat-demo": "tsx src/index.ts",
    "chat-nose": "tsx scripts/chatNoSe.ts",
    "clean": "rm -rf .next node_modules package-lock.json && npm install",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@types/dompurify": "^3.2.0",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.6",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.536.0",
    "next": "^15.0.0",
    "openai": "^5.10.2",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/node": "^20.19.9",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^15.0.0",
    "flatrepo": "^1.2.0",
    "postcss": "^8.4.0",
    "react-test-renderer": "^18.3.1",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.7.0",
    "typescript": "^5.0.0",
    "vitest": "^3.2.4"
  },
  "keywords": [
    "education",
    "ai",
    "chatbot",
    "typescript",
    "nextjs",
    "openai"
  ],
  "author": "KIKE (Backend) + JANKARLO (Frontend)",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```
=== EOF: package.json

===  obejtivodocenteia.md
```markdown
1) Capa de textualizaci√≥n docente (LLM-orchestrator)
Explica y pregunta ‚Äúcomo docente‚Äù a partir de cada step (NARRATION/CONTENT/ASK), con persona, tono y estilo.
El motor determinista decide el paso; el LLM solo redacta con variedad, ejemplos y analog√≠as. ok
2) Persona y estilo por curso
Inyectar course.specialist (rol, tono, gu√≠as de estilo).
Variar frases gu√≠a: ‚ÄúAhora te explico‚Ä¶‚Äù, ‚ÄúBuen intento‚Ä¶‚Äù, ‚ÄúEstamos por buen camino‚Ä¶‚Äù, evitando repeticiones.
3) Pol√≠tica de turnos por tipo de step
NARRATION/CONTENT: 2‚Äì3 frases m√°ximas sin listas ni copiar literal; no pregunta en ese turno.
ASK: formular la pregunta exacta del JSON; validar; si no alcanza, re‚Äëpreguntar con micro-variaci√≥n.
4) Guardarra√≠les de avance
Umbrales claros (evidencia m√≠nima: par√°frasis, ejemplo, justificaci√≥n breve).
No avanzar si faltan preguntas del momento o la evidencia no cumple.
5) Evaluaci√≥n sem√°ntica con r√∫brica ligera
Matching contra acceptable_answers, y respaldo con objective/expected.
Parcialidades (matched/missing), y decisi√≥n ok/hint/refocus/advance.
6) Pistas escalonadas integradas al plan
Pista 1 (‚âà10 palabras), Pista 2 (‚âà20), Pista 3 (casi explicativa), derivadas de acceptable_answers y contentBody, sin spoilers.
7) Manejo de atascos y fuera de foco
Detecci√≥n de DONT_KNOW/IRRELEVANT reiterado; reconduce al objetivo o micro-contenido.
Anti‚Äëbucle y anti‚Äërepetici√≥n de la misma pregunta.
8) Se√±alizaci√≥n y transiciones pedag√≥gicas
Micro‚Äëresumen de cierre + puente al siguiente objetivo/paso.
‚ÄúTe adelanto qu√© veremos ahora‚Ä¶‚Äù sin spoilear respuestas.
9) Memoria de sesi√≥n docente
Intentos por pregunta, pistas usadas, matched/missing.
Referencias a aportes previos del estudiante para personalizar.
10) Biblioteca de preguntas socr√°ticas y reformulaciones
Micro‚Äëpreguntas de descomposici√≥n (‚â§8 palabras), alternativas A/B, enfoques por taxonom√≠a (recuerdo, comprensi√≥n, aplicaci√≥n‚Ä¶).
11) Anti‚Äërepetici√≥n y deduplicaci√≥n
Normalizaci√≥n y filtros para no repetir la misma pregunta o frase en turnos consecutivos.
12) Narrativa con ‚Äúvoz docente‚Äù
Reescritura del body en texto corrido, ejemplos laborales breves, lenguaje sencillo, evitando bullets y copia literal.
13) Cierre de momento y metacognici√≥n
Checklist de objetivos alcanzados y ‚Äúqu√© te llevas‚Äù, mini‚Äëreflexi√≥n o plan de acci√≥n.
14) Adaptaci√≥n de dificultad
Si responde con solvencia, ir a preguntas de mayor nivel; si no, simplificar y ejemplificar.
15) M√©tricas y trazabilidad
contentShown/Total, asksAsked/Total, attempts/hints per ask.
Logs de decisiones (acci√≥n, raz√≥n, paso).
16) Validaci√≥n y saneo del JSON
Asegurar steps completos y ordenados; sin preguntas en NARRATION.
Contenido en CONTENT.body; pregunta solo en ASK.
17) Internacionalizaci√≥n y normas de estilo
Longitudes m√°ximas por bloque, tono consistente, emojis/√©nfasis opcionales seg√∫n curso.
18) UI docente
Marcar visualmente: ‚ÄúExplicaci√≥n‚Äù, ‚ÄúPregunta‚Äù, ‚ÄúPista‚Äù.
Mostrar progreso por momento y paso sin distraer.
19) Pruebas de flujo end‚Äëto‚Äëend
Casos t√≠picos: correcto a la primera, parcial, ‚Äúno lo s√©‚Äù, offtopic, reiteraci√≥n.
Tests de anti‚Äërepetici√≥n y de avance.
20) Fallbacks robustos
Si falta ASK, generar una de verificaci√≥n coherente; si falta CONTENT, sintetizar a partir de KEY_*.
```
=== EOF: obejtivodocenteia.md

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    ignoreBuildErrors: false,
  },
  eslint: {
    ignoreDuringBuilds: false,
  },
}

module.exports = nextConfig
```
=== EOF: next.config.js

===  next-env.d.ts
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```
=== EOF: next-env.d.ts

===  test\prompt.spec.ts
```typescript
import { describe, expect, it } from 'vitest';
import { buildUserPrompt } from '../src/ai/prompt';

describe('prompt: hint anti-meta rule', () => {
  it('includes anti-meta guidance in hint prompts', () => {
    const prompt = buildUserPrompt({
      language: 'es',
      action: 'hint',
      stepType: 'ASK',
      questionText: '¬øQu√© esperas aprender sobre procedimientos de seguridad?',
      objective: 'procedimientos de seguridad',
      contentBody: ['partes del procedimiento', 'c√≥mo se aplica', 'importancia de seguirlos'],
      hintWordLimit: 18,
    } as any);
    expect(prompt).toMatch(/Evita frases meta/i);
  });
});


```
=== EOF: test\prompt.spec.ts

===  test\feedbackSequential.ui.spec.tsx
```tsx
import FeedbackSequential from '@/components/FeedbackSequential';
import TestRenderer, { act } from 'react-test-renderer';
import { describe, expect, it, vi } from 'vitest';

function setInput(root: TestRenderer.ReactTestRenderer['root'], value: string) {
  const input = root.findAll((n) => n.type === 'input')[0];
  act(() => input.props.onChange({ target: { value } }));
}

function clickSend(root: TestRenderer.ReactTestRenderer['root']) {
  const btn = root.findAll((n) => n.type === 'button')[0];
  act(() => btn.props.onClick());
}

function getLabels(root: TestRenderer.ReactTestRenderer['root']): string[] {
  const nodes = root.findAll((n) => n.type === 'span' && String(n.props.className || '').includes('font-semibold'));
  return nodes.map((n) => (Array.isArray(n.children) ? n.children.join('') : String(n.children || '')));
}

function getKinds(root: TestRenderer.ReactTestRenderer['root']): string[] {
  const nodes = root.findAll((n) => n.type === 'span' && String(n.props.className || '').includes('uppercase'));
  return nodes.map((n) => (Array.isArray(n.children) ? n.children.join('') : String(n.children || '')));
}

function getLastFeedback(root: TestRenderer.ReactTestRenderer['root']): string {
  const nodes = root.findAll((n) => n.type === 'div' && String(n.props.className || '').includes('whitespace-pre-wrap'));
  const last = nodes[nodes.length - 1];
  if (!last) return '';
  return Array.isArray(last.children) ? last.children.join('') : String(last.children || '');
}

describe('FeedbackSequential UI', () => {
  it('mapea HINT a F0/F1 seg√∫n intento (F0 en intentos 0 y 1, F1 en 2)', () => {
    let renderer: TestRenderer.ReactTestRenderer;
    act(() => {
      renderer = TestRenderer.create(
        <FeedbackSequential
          code="T-Q01"
          prompts={[
            'P0: pregunta',
            'P1: reintento',
            'P2: √∫ltimo'
          ]}
          objective="objetivo"
          acceptable={[]}
          expected={[]}
          answerType="list"
        />
      );
    });
    const root = (renderer as TestRenderer.ReactTestRenderer).root;

    // intento 0: vac√≠o ‚Üí HINT ‚Üí F0
    setInput(root, '');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F0']);
    expect(getKinds(root)[0]).toBe('HINT');

    // intento 1: basura ‚Üí HINT ‚Üí F0
    setInput(root, '???');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F0', 'F0']);

    // intento 2: basura ‚Üí HINT ‚Üí F1
    setInput(root, 'lorem ipsum');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F0', 'F0', 'F1']);
    expect(getKinds(root)[2]).toBe('HINT');
  });

  it('PARTIAL y ACCEPT se etiquetan F2 y completan acorde', () => {
    let onComplete = vi.fn();
    let renderer: TestRenderer.ReactTestRenderer;
    act(() => {
      renderer = TestRenderer.create(
        <FeedbackSequential
          code="T-Q02"
          prompts={[
            'P0', 'P1', 'P2'
          ]}
          objective="definir semilla"
          acceptable={["56"]}
          expected={["semilla"]}
          answerType="definition"
          onComplete={onComplete}
        />
      );
    });
    const root = (renderer as TestRenderer.ReactTestRenderer).root;

    // PARTIAL por expected
    setInput(root, 'La semilla...');
    clickSend(root);
    expect(getLabels(root)).toEqual(['F2']);
    expect(getKinds(root)[0]).toBe('PARTIAL');
    expect(onComplete).not.toHaveBeenCalled();

    // ACCEPT por acceptable
    setInput(root, '56');
    clickSend(root);
    const labels = getLabels(root);
    expect(labels[labels.length - 1]).toBe('F2');
    const kinds = getKinds(root);
    expect(kinds[kinds.length - 1]).toBe('ACCEPT');
    expect(onComplete).toHaveBeenCalledTimes(1);
    const call = onComplete.mock.calls[0][0];
    expect(call.status).toBe('cumplida');
    expect(call.score).toBe(2);
  });

  it('al agotar intentos con finalExplanation agrega F2 final y emite force_advance', () => {
    let onComplete = vi.fn();
    let renderer: TestRenderer.ReactTestRenderer;
    act(() => {
      renderer = TestRenderer.create(
        <FeedbackSequential
          code="T-Q03"
          prompts={[ 'P0', 'P1', 'P2' ]}
          objective="objetivo"
          acceptable={["respuesta-correcta"]}
          expected={[]}
          answerType="list"
          finalExplanation="Explicaci√≥n de cierre"
          onComplete={onComplete}
        />
      );
    });
    const root = (renderer as TestRenderer.ReactTestRenderer).root;

    // Tres intentos fallidos
    setInput(root, 'foo'); clickSend(root);
    setInput(root, 'bar'); clickSend(root);
    setInput(root, 'baz'); clickSend(root);

    const labels = getLabels(root);
    // deber√≠an ser: F0, F0, F1, F2 (cierre)
    expect(labels).toEqual(['F0', 'F0', 'F1', 'F2']);
    const lastText = getLastFeedback(root);
    expect(lastText).toContain('Explicaci√≥n de cierre');

    expect(onComplete).toHaveBeenCalledTimes(1);
    const call = onComplete.mock.calls[0][0];
    expect(call.status).toBe('force_advance');
    expect(call.score === 0 || call.score === 1).toBe(true);
  });
});



```
=== EOF: test\feedbackSequential.ui.spec.tsx

===  test\feedbackSequencer.spec.ts
```typescript
import { describe, expect, it } from 'vitest';
import { buildTraceEntry, computeFeedbackLabel } from '../src/engine/feedbackSequencer';

describe('feedbackSequencer', () => {
  it('computeFeedbackLabel: HINT ‚Üí F0/F1 seg√∫n intento', () => {
    expect(computeFeedbackLabel('HINT', 0)).toBe('F0');
    expect(computeFeedbackLabel('HINT', 1)).toBe('F0');
    expect(computeFeedbackLabel('HINT', 2)).toBe('F1');
  });

  it('computeFeedbackLabel: PARTIAL/ACCEPT ‚Üí F2', () => {
    expect(computeFeedbackLabel('PARTIAL', 0)).toBe('F2');
    expect(computeFeedbackLabel('ACCEPT', 1)).toBe('F2');
  });

  it('buildTraceEntry: estructura P/R/F con metadatos', () => {
    const t = buildTraceEntry({
      question: 'P0',
      response: 'R0',
      feedback: 'F0',
      kind: 'HINT',
      attempt: 1,
      hintsUsed: 2,
      stepCode: 'M1-Q01'
    });
    expect(t.label).toBe('F0');
    expect(t.kind).toBe('HINT');
    expect(t.p).toBe('P0');
    expect(t.r).toBe('R0');
    expect(t.f).toBe('F0');
    expect(t.attempt).toBe(1);
    expect(t.hintsUsed).toBe(2);
    expect(t.stepCode).toBe('M1-Q01');
  });
});



```
=== EOF: test\feedbackSequencer.spec.ts

===  test\eval.classify.spec.ts
```typescript
import { describe, expect, it, vi } from 'vitest';

// Mock semvec and escalation to evitar dependencias de IA en tests
vi.mock('@/engine/semvec', () => ({
  buildAskIndex: async () => ({ centroid: [1], texts: [] }),
  semanticScore: async () => ({ cos: 0, best: null })
}));
vi.mock('@/engine/eval-escalation', () => ({
  escalateReasoning: async () => ({ decision: 'HINT', short: 'stub' })
}));

import { classifyTurn, type AskPolicy } from '../src/engine/eval';

describe('evaluate/classifyTurn basic cases', () => {
  it('capital of France: ACCEPT with "Par√≠s"', () => {
    const policy: AskPolicy = { type: 'conceptual' };
    const acceptable = ['Paris', 'Par√≠s'];
    const expected: string[] = [];
    const r = classifyTurn('Par√≠s', policy, acceptable, expected);
    expect(r.kind).toBe('ACCEPT');
  });

  it('area circle: PARTIAL with mention of "pi"', () => {
    const policy: AskPolicy = { type: 'conceptual' };
    const acceptable: string[] = ['œÄr2', 'œÄr^2', 'pi r2'];
    const expected: string[] = ['pi', 'radio', 'cuadrado'];
    const r = classifyTurn('algo con pi', policy, acceptable, expected);
    expect(r.kind).toBe('PARTIAL');
  });

  it('listado: ACCEPT when k-of-n is met', () => {
    const policy: AskPolicy = { type: 'listado', thresholdK: 2 };
    const acceptable: string[] = ['casco', 'guantes', 'lentes'];
    const expected: string[] = [];
    const r = classifyTurn('casco y guantes obligatorios', policy, acceptable, expected);
    expect(r.kind).toBe('ACCEPT');
  });

  it('listado: PARTIAL when below k', () => {
    const policy: AskPolicy = { type: 'listado', thresholdK: 2 };
    const acceptable: string[] = ['casco', 'guantes', 'lentes'];
    const expected: string[] = [];
    const r = classifyTurn('casco', policy, acceptable, expected);
    expect(r.kind).toBe('PARTIAL');
  });

  it('no s√© -> HINT', () => {
    const policy: AskPolicy = { type: 'conceptual' };
    const acceptable: string[] = ['procedimiento'];
    const expected: string[] = ['partes', 'aplicaci√≥n'];
    const r = classifyTurn('no s√©', policy, acceptable, expected);
    expect(r.kind).toBe('HINT');
  });
});


```
=== EOF: test\eval.classify.spec.ts

===  test\engine.nose.spec.ts
```typescript
import { describe, expect, it, vi } from 'vitest';

// Mocks hoisted para aislar el handler del engine
let __hintCount = 0;
vi.mock('@/ai/orchestrator', () => ({
  runDocenteLLM: async (ctx: any) => {
    const action = ctx?.action;
    if (action === 'ask') {
      return { message: `PREGUNTA: ${ctx.questionText}`, followUp: ctx.questionText };
    }
    if (action === 'hint') {
      __hintCount += 1;
      const fu = __hintCount === 1
        ? '¬øUna micro‚Äëpregunta?'
        : (__hintCount === 2 ? '¬øUna micro‚Äëpregunta m√°s f√°cil?' : '¬øUna micro‚Äëpregunta?');
      return { message: 'Pista breve alineada al objetivo.', followUp: fu };
    }
    if (action === 'feedback') {
      return { message: 'FB: refuerzo/gu√≠a breve.' };
    }
    if (action === 'advance') {
      return { message: 'Puente breve al siguiente foco.' };
    }
    if (action === 'explain') {
      return { message: 'Explicaci√≥n breve del contenido.' };
    }
    return { message: '' };
  }
}));

// Mock semvec para evitar embeddings/OpenAI
vi.mock('@/engine/semvec', () => ({
  buildAskIndex: async () => ({ centroid: [1], texts: [] }),
  semanticScore: async () => ({ cos: 0, best: null })
}));

async function getPOST() {
  const mod = await import('../app/api/engine/turn/route');
  return (mod as any).POST as (req: Request) => Promise<Response>;
}

async function turn(body: any) {
  const req = new Request('http://localhost/api/engine/turn', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const POST = await getPOST();
  const res = await POST(req as any);
  return await (res as any).json();
}

describe('engine: tres "no se" consecutivos', () => {
  it('emite HINT dos veces y luego puente de avance (force_advance)', async () => {
    const sessionKey = 'it-3-no-se';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    // Inicio de sesi√≥n ‚Üí obtener primera pregunta
    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    // 1) no se ‚Üí HINT
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t1.message || '') + (t1.followUp || '')).length).toBeGreaterThan(0);
    // 2) no se ‚Üí HINT
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t2.message || '') + (t2.followUp || '')).length).toBeGreaterThan(0);
    // 3) no se ‚Üí avance forzado: debe incluir el puente de avance del mock
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect((t3.message || '').toLowerCase()).toContain('puente breve al siguiente foco');
    expect((t3.followUp || '').length).toBeGreaterThan(0);
  });

  it('valida feedback y followUp en HINT‚ÜíHINT/ADV‚Üíforce_advance', async () => {
    const sessionKey = 'it-3-no-se-fb';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    // 1) no se ‚Üí HINT con feedback/hint y micro‚Äëpregunta
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg1 = (t1.message || '').toLowerCase();
    const fu1 = (t1.followUp || '').toLowerCase();
    expect(msg1).toMatch(/fb: refuerzo|pista breve alineada|explicaci√≥n breve|puente breve/);
    expect(fu1.length).toBeGreaterThan(0);

    // 2) no se ‚Üí HINT o transici√≥n temprana seg√∫n pol√≠tica
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg2 = (t2.message || '').toLowerCase();
    const fu2 = (t2.followUp || '').toLowerCase();
    expect(msg2).toMatch(/fb: refuerzo|pista breve alineada|explicaci√≥n breve|puente breve/);
    expect(fu2.length).toBeGreaterThan(0);

    // 3) no se ‚Üí avance con puente y nueva followUp (force_advance)
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg3 = (t3.message || '').toLowerCase();
    const fu3 = (t3.followUp || '').toLowerCase();
    expect(msg3).toContain('puente breve al siguiente foco');
    expect(fu3.length).toBeGreaterThan(0);
  });

  it('no fuerza avance tras dos "no se"; lo hace en el tercero', async () => {
    const sessionKey = 'it-2-no-se-advance';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg1 = (t1.message || '').toLowerCase();
    expect(msg1.length).toBeGreaterThan(0);

    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg2 = (t2.message || '').toLowerCase();
    const fu2 = (t2.followUp || '').toLowerCase();
    // A√∫n NO debe forzar avance en el segundo "no se": debe seguir con hint
    expect(msg2).not.toContain('puente breve al siguiente foco');
    expect(fu2.length).toBeGreaterThan(0);
    // Tercer "no se" ‚Üí ahora s√≠ puente de avance
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg3 = (t3.message || '').toLowerCase();
    const fu3 = (t3.followUp || '').toLowerCase();
    expect(msg3).toContain('puente breve al siguiente foco');
    expect(fu3.length).toBeGreaterThan(0);
  });

  it('pregunta ‚Üí no se ‚Üí pista f√°cil ‚Üí no se ‚Üí pista m√°s f√°cil ‚Üí no se ‚Üí avance', async () => {
    const sessionKey = 'it-escalada-hints';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((t0.followUp || '').length).toBeGreaterThan(0);

    // 1) no se ‚Üí feedback+hint con followUp ‚Äúmicro‚Äëpregunta‚Äù
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t1.message || '').toLowerCase())).toMatch(/pista breve|fb: refuerzo/);
    const fu1s = (t1.followUp || '').toLowerCase();
    expect(fu1s.length).toBeGreaterThan(0);

    // 2) no se ‚Üí feedback+hint con followUp ‚Äúm√°s f√°cil‚Äù
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect(((t2.message || '').toLowerCase())).toMatch(/pista breve|fb: refuerzo|puente breve/);
    const fu2s = (t2.followUp || '').toLowerCase();
    expect(fu2s.length).toBeGreaterThan(0);
    // Si ya hubo avance en el segundo, igual debe haber followUp (siguiente pregunta)

    // 3) no se ‚Üí feedback + mensaje ‚Äúavancemos‚Äù (puente) y nueva pregunta
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    expect((t3.message || '').toLowerCase()).toContain('puente breve al siguiente foco');
    expect((t3.followUp || '').length).toBeGreaterThan(0);
  });
});


```
=== EOF: test\engine.nose.spec.ts

===  test\engine.integration.lesson02.spec.ts
```typescript
import { describe, expect, it, vi } from 'vitest';

// Mocks HOISTED antes de importar route.ts
vi.mock('@/ai/orchestrator', () => ({
  runDocenteLLM: async (ctx: any) => {
    const action = ctx?.action;
    if (action === 'ask') {
      return { message: `PREGUNTA: ${ctx.questionText}`, followUp: ctx.questionText };
    }
    if (action === 'hint') {
      return { message: 'Pista breve alineada al objetivo.', followUp: '¬øUna micro‚Äëpregunta?' };
    }
    if (action === 'feedback') {
      return { message: 'FB: refuerzo/gu√≠a breve.' };
    }
    if (action === 'advance') {
      return { message: 'Puente breve al siguiente foco.' };
    }
    if (action === 'explain') {
      return { message: 'Explicaci√≥n breve del contenido.' };
    }
    return { message: '' };
  }
}));

// Mock semvec para evitar llamadas a embeddings/OpenAI
vi.mock('@/engine/semvec', () => ({
  buildAskIndex: async () => ({ centroid: [1], texts: [] }),
  semanticScore: async () => ({ cos: 0, best: null })
}));

// Mock evaluaci√≥n sem√°ntica: clasifica por palabra clave en la respuesta (solo la funci√≥n usada)
vi.mock('@/engine/eval', () => ({
  evaluateSemanticOnly: async (user: string) => {
    const u = String(user || '').toLowerCase();
    if (/^correcta/.test(u) || /\bok\b/.test(u)) {
      return { kind: 'ACCEPT', reason: 'STUB', matched: ['ok'], missing: [], sem: { cos: 0.9, best: { text: 'ok', cos: 0.9 } } } as any;
    }
    if (/^parcial/.test(u)) {
      return { kind: 'PARTIAL', reason: 'STUB', matched: ['pi'], missing: ['radio'], sem: { cos: 0.6, best: { text: 'pi', cos: 0.6 } } } as any;
    }
    return { kind: 'HINT', reason: 'STUB', matched: [], missing: ['se√±al'], sem: { cos: 0.1, best: null } } as any;
  }
}));

async function getPOST() {
  const mod = await import('../app/api/engine/turn/route');
  return (mod as any).POST as (req: Request) => Promise<Response>;
}

async function turn(body: any) {
  const req = new Request('http://localhost/api/engine/turn', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const POST = await getPOST();
  const res = await POST(req as any);
  return await (res as any).json();
}

describe('engine integration: lesson02', () => {
  it('Tres "no se" consecutivos ‚Üí ver preguntas y feedback en logs', async () => {
    const sessionKey = 'it-lesson02-3-no-se';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    // Primer turno: iniciar sesi√≥n y obtener la primera pregunta
    const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    // Tres "no se"
    const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });

    // Logs visibles: pregunta y feedback + micro‚Äëpregunta en cada turno
    // eslint-disable-next-line no-console
    console.log('[3_NO_SE]', {
      q0: t0.followUp,
      turn1: { message: t1.message, followUp: t1.followUp },
      turn2: { message: t2.message, followUp: t2.followUp },
      turn3: { message: t3.message, followUp: t3.followUp },
    });

    // Aserciones m√≠nimas para asegurar contenido
    expect((t0.followUp || '').length).toBeGreaterThan(0);
    expect(((t1.message || '') + (t1.followUp || '')).length).toBeGreaterThan(0);
    expect(((t2.message || '') + (t2.followUp || '')).length).toBeGreaterThan(0);
    expect(((t3.message || '') + (t3.followUp || '')).length).toBeGreaterThan(0);
  });
  it('No s√© ‚Üí HINT (pista + micro‚Äëpregunta, sin explicaci√≥n)', async () => {
    const sessionKey = 'it-lesson02-nose';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const r0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    const q0 = r0.followUp || '';
    // Turno con "no se"
    const r1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
    const msg = r1.message || '';
    const fu = r1.followUp || '';
    // Debe ser pista, no explicaci√≥n
    expect(msg.toLowerCase()).toMatch(/pista|breve/);
    expect(fu.length).toBeGreaterThan(0);
    // eslint-disable-next-line no-console
    console.log('[NOSE]', { q0, msg, fu });
  });
  it('Caso 1: vac√≠o, vac√≠o, parcial ‚Üí avanza pendiente (2 ayudas, score 1)', async () => {
    const sessionKey = 'it-lesson02-caso1';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const r0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((r0.followUp || '').length).toBeGreaterThan(0);
    const r1 = await turn({ sessionKey, planUrl, userInput: '' });
    expect((r1.followUp || '').length).toBeGreaterThan(0);
    // incluir se√±ales esperadas y tokens suficientes
    const r2 = await turn({ sessionKey, planUrl, userInput: 'parcial radio pi' });
    // Validar que hubo interacci√≥n con pista/feedback y continuidad
    expect(((r2.message || '') + (r2.followUp || '')).length).toBeGreaterThan(0);
    // Log para inspecci√≥n manual
    // eslint-disable-next-line no-console
    console.log('[CASO1]', { m0: r0.message, f0: r0.followUp, m1: r1.message, f1: r1.followUp, m2: r2.message, f2: r2.followUp, assess: r2.assessment });
  });

  it('Caso 2: vac√≠o, vac√≠o, correcta ‚Üí avanza cumplida (2 ayudas, score 2)', async () => {
    const sessionKey = 'it-lesson02-caso2';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    const r0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    expect((r0.followUp || '').length).toBeGreaterThan(0);
    const r1 = await turn({ sessionKey, planUrl, userInput: '' });
    expect((r1.followUp || '').length).toBeGreaterThan(0);
    // cumplir minTokens y gatillar ACCEPT del stub
    const r2 = await turn({ sessionKey, planUrl, userInput: 'correcta ok ok' });
    expect(r2.assessment?.level).toBe('R2');
    expect(r2.assessment?.score).toBe(2);
  });

  it('Caso 5: vac√≠o, vac√≠o, vac√≠o ‚Üí force-advance (score 0)', async () => {
    const sessionKey = 'it-lesson02-caso5';
    const planUrl = '/courses/SSO001/lessons/lesson02.json';

    await turn({ sessionKey, planUrl, reset: true, userInput: '' });
    const r1 = await turn({ sessionKey, planUrl, userInput: '' });
    const r2 = await turn({ sessionKey, planUrl, userInput: '' });
    // No garantizamos assessment en vac√≠o, pero s√≠ un followUp (siguiente paso o re-ask)
    expect((r2.followUp || '').length).toBeGreaterThan(0);
  });
});


```
=== EOF: test\engine.integration.lesson02.spec.ts

===  test\clarify.spec.ts
```typescript
import { describe, expect, it } from 'vitest';
import { isNoSeInput, shouldClarifyQuestion, shouldGateByMinTokens } from '../src/engine/clarify';

describe('clarify helpers', () => {
  it('gates by min tokens', () => {
    expect(shouldGateByMinTokens('', 3)).toBe(true);
    expect(shouldGateByMinTokens('no se', 3)).toBe(true);
    expect(shouldGateByMinTokens('algo breve', 2)).toBe(false);
  });

  it('detects no se patterns', () => {
    expect(isNoSeInput('no se')).toBe(true);
    expect(isNoSeInput('No s√©')).toBe(true);
    expect(isNoSeInput('no estoy seguro')).toBe(true);
    expect(isNoSeInput('s√≠')).toBe(false);
  });

  it('clarify only when not vague/no and not hint', () => {
    expect(shouldClarifyQuestion({ isVague: false, isNo: false, classificationKind: 'PARTIAL', studentAsking: true })).toBe(true);
    expect(shouldClarifyQuestion({ isVague: true, isNo: false, classificationKind: 'PARTIAL', studentAsking: true })).toBe(false);
    expect(shouldClarifyQuestion({ isVague: false, isNo: true, classificationKind: 'PARTIAL', studentAsking: true })).toBe(false);
    expect(shouldClarifyQuestion({ isVague: false, isNo: false, classificationKind: 'HINT', studentAsking: true })).toBe(false);
    expect(shouldClarifyQuestion({ isVague: false, isNo: false, classificationKind: 'PARTIAL', studentAsking: false })).toBe(false);
  });
});


```
=== EOF: test\clarify.spec.ts

===  scripts\chatNoSe.ts
```typescript
// Simple chat runner against the engine turn endpoint (HTTP if available, otherwise direct import)
import 'dotenv/config';
import fs from 'fs';
import path from 'path';

// Ensure .env.local is loaded when available (Next.js style)
try {
  const localPath = path.join(process.cwd(), '.env.local');
  if (fs.existsSync(localPath)) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    require('dotenv').config({ path: localPath });
  }
} catch {}

const planUrl = '/courses/SSO001/lessons/lesson02.json';
const sessionKey = `cli-chat-${Date.now()}`;
const base = process.env.BASE_URL || 'http://localhost:3001';

type TurnRes = { message?: string; followUp?: string; assessment?: any; state?: any };

async function httpTurn(body: any): Promise<TurnRes> {
  const res = await fetch(`${base}/api/engine/turn`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return (await res.json()) as any;
}

async function directTurn(body: any): Promise<TurnRes> {
  const mod = await import('../app/api/engine/turn/route');
  const POST = (mod as any).POST as (req: Request) => Promise<Response>;
  const req = new Request('http://local/api/engine/turn', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const res = await POST(req as any);
  return (await (res as any).json()) as any;
}

async function turn(body: any) {
  try {
    return await httpTurn(body);
  } catch {
    return await directTurn(body);
  }
}

function logStep(tag: string, r: TurnRes) {
  const msg = (r.message || '').trim();
  const fu = (r.followUp || '').trim();
  const compose = (m: string, f: string) => {
    if (m && f) {
      const norm = (s: string) => s.replace(/\s+/g, ' ').trim().toLowerCase();
      if (norm(m).includes(norm(f))) return m; // evitar repetir la pregunta
      const endPunct = /[\.!?]$/.test(m) ? '' : '.';
      return `${m}${endPunct}\n\n${f}`;
    }
    return m || f || '';
  };
  const out = compose(msg, fu);
  console.log(`\n[${tag}]`);
  if (out) console.log(out);
}

async function main() {
  console.log(`Chat clave: ${sessionKey}`);
  // Inicio (reset) ‚Üí obtener pregunta inicial
  const t0 = await turn({ sessionKey, planUrl, reset: true, userInput: '' });
  logStep('INICIO', t0);

  // "no se" #1 ‚Üí HINT
  const t1 = await turn({ sessionKey, planUrl, userInput: 'no se' });
  logStep('NO_SE_1', t1);

  // "no se" #2 ‚Üí HINT (reask m√°s f√°cil)
  const t2 = await turn({ sessionKey, planUrl, userInput: 'no se' });
  logStep('NO_SE_2', t2);

  // "no se" #3 ‚Üí avance/puente
  const t3 = await turn({ sessionKey, planUrl, userInput: 'no se' });
  logStep('NO_SE_3', t3);

  // Respuesta tentativa post‚Äëavance
  const t4 = await turn({ sessionKey, planUrl, userInput: 'arnes casco guantes' });
  logStep('POST_AVANCE', t4);
}

main().catch((err) => {
  console.error('[CHAT_ERROR]', err);
  process.exit(1);
});


```
=== EOF: scripts\chatNoSe.ts

===  docs\ADAPTIVE_ENGINE.md
```markdown
# Motor Adaptativo con Control de Presupuesto

## Resumen

Este documento describe la implementaci√≥n del modelo-planificador acotado que permite adaptaci√≥n en tiempo real dentro de l√≠mites estrictos, manteniendo el JSON de la lecci√≥n como fuente de verdad.

## Arquitectura

### Componentes Principales

1. **Planificador Acotado** (`src/engine/planner.ts`)

   - Define comandos de adaptaci√≥n con Zod
   - Opera solo dentro del ciclo actual
   - Detecta desv√≠os de tema
   - Valida comandos antes de ejecutar

2. **Gestor de Presupuesto** (`src/engine/costs.ts`)

   - Controla uso de modelos por tiers
   - Limita escalaciones por sesi√≥n
   - Degrada autom√°ticamente cuando se agota presupuesto

3. **Evaluaci√≥n H√≠brida** (`src/engine/eval-escalation.ts`)

   - Validaci√≥n estricta con Zod
   - Escalaci√≥n inteligente solo cuando es necesaria
   - Fallback seguro en caso de errores

4. **Logger de Telemetr√≠a** (`src/engine/logger.ts`)
   - Registra todas las decisiones del motor
   - Exporta en formato JSONL para auditor√≠a
   - M√©tricas de uso por tier

## Comandos de Adaptaci√≥n

### AdaptCommand Schema

```typescript
{
  op: 'reask' | 'hint' | 'goto' | 'repeat' | 'insert_micro',
  targetAskCode?: string,
  note?: string,
  reason?: 'SEM_LOW' | 'THINKER_ESCALATION' | 'OFF_TOPIC' | 'BUDGET_LIMIT'
}
```

### Operaciones Permitidas

- **reask**: Solicitar reformulaci√≥n de respuesta vaga
- **hint**: Proporcionar pista determinista
- **goto**: Saltar a ASK espec√≠fica del cat√°logo
- **repeat**: Repetir paso actual sin avanzar
- **insert_micro**: Insertar micro-paso temporal (limitado)

## Control de Presupuesto

### Tiers de Modelos

| Tier    | Modelo                 | Costo/1K tokens | Uso                   |
| ------- | ---------------------- | --------------- | --------------------- |
| cheap   | gpt-4o-mini            | $0.005          | Docencia/redacci√≥n    |
| embed   | text-embedding-3-small | $0.001          | Similitud sem√°ntica   |
| thinker | o3-mini                | $0.025          | Razonamiento complejo |

### L√≠mites por Sesi√≥n

- **Presupuesto inicial**: $1.00 (100 centavos)
- **Escalaciones m√°ximas**: 5 por sesi√≥n
- **Umbral de degradaci√≥n**: 10 centavos restantes
- **Modo econ√≥mico**: < 5 centavos restantes

### Pol√≠tica de Uso

- **80% cheap**: Operaciones normales
- **15% embed**: Evaluaci√≥n sem√°ntica
- **5% thinker**: Escalaci√≥n solo cuando es necesaria

## Detecci√≥n de Desv√≠os

### Algoritmo de Clasificaci√≥n

```typescript
function detectTopicDeviation(
  response: string,
  step: any,
  objective: string
): TopicDeviation {
  const objectiveWords = objective
    .toLowerCase()
    .split(/\s+/)
    .filter((w) => w.length > 3);
  const objectiveMatches = objectiveWords.filter((word) =>
    response.includes(word)
  );
  const matchRatio =
    objectiveMatches.length / Math.max(1, objectiveWords.length);

  if (matchRatio >= 0.3) return "ON_TOPIC";
  if (matchRatio >= 0.1) return "VAGUE";
  return "OFF_TOPIC";
}
```

### Respuestas Autom√°ticas

- **ON_TOPIC**: Evaluaci√≥n normal
- **VAGUE**: REASK con solicitud de reformulaci√≥n
- **OFF_TOPIC**: GOTO a siguiente ASK del ciclo

## Integraci√≥n con el Frontend

### Toggle de Modo

```typescript
<select
  value={adaptiveMode ? "adaptive" : "deterministic"}
  onChange={(e) => setAdaptiveMode(e.target.value === "adaptive")}
>
  <option value="deterministic">Determinista</option>
  <option value="adaptive">Adaptativo</option>
</select>
```

### Barra de Presupuesto

```typescript
<div className="w-32 bg-gray-200 rounded-full h-2">
  <div
    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
    style={{ width: `${(budgetMetrics.budgetCentsLeft / 100) * 100}%` }}
  ></div>
</div>
```

## Variables de Entorno

```bash
# Modelos por tier
CHEAP_MODEL=gpt-4o-mini
THINKER_MODEL=o3-mini
EMBED_MODEL=text-embedding-3-small

# Debug
ENGINE_DEBUG=false
NEXT_PUBLIC_ENGINE_DEBUG=false

# Presupuesto
SESSION_BUDGET_CENTS=100
MAX_ESCALATIONS_PER_SESSION=5
ESCALATION_THRESHOLD_CENTS=10
```

## Telemetr√≠a

### Eventos Registrados

- `engine.turn.start`: Inicio de turno
- `evaluation.result`: Resultado de evaluaci√≥n
- `escalation.triggered`: Escalaci√≥n iniciada
- `adaptation.planned`: Adaptaci√≥n planificada
- `budget.usage`: Uso de presupuesto
- `advancement.accept/reject`: Avance del plan

### Formato JSONL

```json
{
  "timestamp": "2024-01-01T12:00:00Z",
  "level": "info",
  "event": "evaluation.result",
  "sessionId": "plan-123",
  "data": { "askCode": "ASK_001", "result": "ACCEPT", "reason": "SEM_LOW" }
}
```

## Riesgos y Mitigaciones

### Deriva del Tema

- **Riesgo**: El planificador inventa pasos persistentes
- **Mitigaci√≥n**: Solo opera dentro del ciclo actual con goto a ASK conocidas

### Costos Desbordados

- **Riesgo**: Presupuesto excedido
- **Mitigaci√≥n**: Hard cap con degradaci√≥n autom√°tica a modo determinista

### JSON Fr√°gil

- **Riesgo**: Respuestas malformadas del LLM
- **Mitigaci√≥n**: Validaci√≥n estricta con Zod antes de actuar

## Pruebas

### Ejecutar Tests

```bash
npm test src/engine/planner.test.ts
```

### Cobertura de Pruebas

- Detecci√≥n de desv√≠os de tema
- Validaci√≥n de comandos de adaptaci√≥n
- Aplicaci√≥n segura de comandos
- Control de presupuesto

## Uso en Producci√≥n

### Activaci√≥n

1. Configurar variables de entorno
2. Activar modo adaptativo en el frontend
3. Monitorear m√©tricas de presupuesto
4. Revisar logs de telemetr√≠a

### Monitoreo

- **M√©tricas clave**: Uso por tier, tasa de escalaci√≥n, costo por sesi√≥n
- **Alertas**: Presupuesto < 20%, escalaciones > 3 por sesi√≥n
- **Logs**: Revisar JSONL para auditor√≠a de decisiones

## Roadmap

### Pr√≥ximas Mejoras

1. **Historial corto**: Implementar contexto de conversaci√≥n reciente
2. **Micro-pasos**: Permitir inserci√≥n temporal de contenido
3. **Pol√≠ticas por curso**: Configuraci√≥n espec√≠fica de adaptaci√≥n
4. **Panel de m√©tricas**: Dashboard para monitoreo en tiempo real

### Optimizaciones

1. **Cache de embeddings**: Reutilizar embeddings calculados
2. **Batch processing**: Procesar m√∫ltiples evaluaciones juntas
3. **Predictive scaling**: Anticipar necesidad de escalaci√≥n
```
=== EOF: docs\ADAPTIVE_ENGINE.md

===  archive\.gitkeep
```


```
=== EOF: archive\.gitkeep

===  app\not-found.tsx
```tsx
export default function NotFound() {
  return (
    <div style={{ padding: 24 }}>
      <h1 style={{ fontWeight: 600, fontSize: 18 }}>P√°gina no encontrada</h1>
      <p style={{ marginTop: 8, color: '#475569' }}>La ruta solicitada no existe.</p>
    </div>
  );
}



```
=== EOF: app\not-found.tsx

===  app\layout.tsx
```tsx
import './globals.css';
export const metadata = { title: 'DocenteIA', description: 'Lecci√≥n guiada por JSON' };

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="es">
      <body className="min-h-screen">{children}</body>
    </html>
  )
}
```
=== EOF: app\layout.tsx

===  app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }
}

@layer base {
  * { @apply border-border; }
  body { @apply bg-background text-foreground; font-feature-settings: "rlig" 1, "calt" 1; }
}


```
=== EOF: app\globals.css

===  .claude\settings.local.json
```json
{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(rm:*)",
      "Bash(npm run dev:*)",
      "Bash(kill:*)"
    ],
    "deny": []
  }
}
```
=== EOF: .claude\settings.local.json

===  src\session\store.ts
```typescript
import type { SessionState } from '@/session/state';
import fs from 'fs/promises';
import path from 'path';

export interface SessionStore {
  get(sessionKey: string): Promise<SessionState | undefined>;
  set(sessionKey: string, state: SessionState): Promise<void>;
  delete(sessionKey: string): Promise<void>;
}

class MemoryStore implements SessionStore {
  private map = new Map<string, SessionState>();
  async get(k: string) { return this.map.get(k); }
  async set(k: string, v: SessionState) { this.map.set(k, v); }
  async delete(k: string) { this.map.delete(k); }
}

type FileShape = { sessions: Record<string, { state: SessionState; lastActivity: number }> };

class JsonFileStore implements SessionStore {
  private filePath: string;
  private data: FileShape = { sessions: {} };
  private writing = Promise.resolve();
  constructor(filePath?: string) {
    this.filePath = filePath || path.join(process.cwd(), '.data', 'sessions.json');
  }
  private async ensureLoaded() {
    if (Object.keys(this.data.sessions).length) return;
    try {
      await fs.mkdir(path.dirname(this.filePath), { recursive: true });
      const raw = await fs.readFile(this.filePath, 'utf-8');
      this.data = JSON.parse(raw) as FileShape;
    } catch {
      this.data = { sessions: {} };
    }
  }
  private async flush() {
    const payload = JSON.stringify(this.data);
    const tmp = this.filePath + '.tmp';
    await fs.writeFile(tmp, payload, 'utf-8');
    await fs.rename(tmp, this.filePath);
  }
  async get(k: string) {
    await this.ensureLoaded();
    return this.data.sessions[k]?.state;
  }
  async set(k: string, v: SessionState) {
    await this.ensureLoaded();
    this.data.sessions[k] = { state: v, lastActivity: Date.now() };
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
  async delete(k: string) {
    await this.ensureLoaded();
    delete this.data.sessions[k];
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
}

let storeInstance: SessionStore | null = null;
export function getSessionStore(): SessionStore {
  if (storeInstance) return storeInstance;
  const useFile = process.env.SESSION_STORE === 'file';
  storeInstance = useFile ? new JsonFileStore() : new MemoryStore();
  return storeInstance;
}


```
=== EOF: src\session\store.ts

===  src\session\state.ts
```typescript
import type { LessonPlan } from '@/plan/types';

export type SessionState = {
	planUrl: string;
	plan?: LessonPlan;
	momentIdx: number;
	stepIdx: number;
	attemptsByAskCode: Record<string, number>;
	hintsByAskCode?: Record<string, number>;
	lastAnswerByAskCode?: Record<string, string>;
	noSeCountByAskCode?: Record<string, number>;
	lastActionByAskCode?: Record<string, string>;
	teacherProfile?: any;
	justAskedFollowUp?: boolean;
	// Anti-repetici√≥n de narrativa por momento
	narrativesShownByMoment?: Record<number, boolean>;
	lastNarrativeHashByMoment?: Record<number, string>;
	// Blindaje anti-repetici√≥n de historias/contenidos
	shownByStepIndex?: Record<number, boolean>;
	shownByMomentIndex?: Record<number, boolean>;
	askedAskCodes: string[];
	answeredAskCodes: string[];
	partiallyAnsweredAskCodes?: string[];
	pendingRemediation?: Record<string, string[]>;
	done: boolean;
	// Nuevos campos para adaptaci√≥n y presupuesto
	dynamicQueue: Array<{
		op: 'reask' | 'hint' | 'goto' | 'repeat' | 'insert_micro';
		targetAskCode?: string;
		note?: string;
		reason?: 'SEM_LOW' | 'THINKER_ESCALATION' | 'OFF_TOPIC' | 'BUDGET_LIMIT';
	}>;
	budgetCentsLeft: number;
	escalationsUsed: number;
	// Modo de operaci√≥n
	adaptiveMode: boolean;
	// Contexto de consultas para pausar/retomar
	consultCtx?: {
		pausedAt?: { momentIndex: number; stepIndex: number };
	};
	lastFollowUpText?: string;
};

export function initSession(planUrl: string, plan: LessonPlan): SessionState {
	return {
		planUrl,
		plan,
		momentIdx: 0,
		stepIdx: 0,
		attemptsByAskCode: {},
		hintsByAskCode: {},
		lastAnswerByAskCode: {},
		noSeCountByAskCode: {},
		lastActionByAskCode: {},
		justAskedFollowUp: false,
		narrativesShownByMoment: {},
		lastNarrativeHashByMoment: {},
		shownByStepIndex: {},
		shownByMomentIndex: {},
		askedAskCodes: [],
		answeredAskCodes: [],
		done: false,
		// Inicializar nuevos campos
		dynamicQueue: [],
		budgetCentsLeft: 100, // 100 centavos = $1.00 por sesi√≥n
		escalationsUsed: 0,
		adaptiveMode: false, // Por defecto modo determinista
		consultCtx: {} // Contexto de consultas
	};
}


```
=== EOF: src\session\state.ts

===  src\session\history.ts
```typescript
import fs from 'fs/promises';
import path from 'path';

function historyPath(sessionKey: string) {
  const dir = path.join(process.cwd(), '.data', 'history');
  const file = path.join(dir, `${sessionKey}.jsonl`);
  return { dir, file };
}

export async function appendHistory(sessionKey: string, record: unknown): Promise<void> {
  const { dir, file } = historyPath(sessionKey);
  try { await fs.mkdir(dir, { recursive: true }); } catch {}
  const line = JSON.stringify({ ts: Date.now(), ...((record as object) || {}) }) + '\n';
  await fs.appendFile(file, line, 'utf-8');
}

export async function clearHistory(sessionKey: string): Promise<void> {
  const { file } = historyPath(sessionKey);
  try { await fs.unlink(file); } catch {}
}

export async function getRecentHistory(sessionKey: string, limit: number = 6): Promise<string[]> {
  const { file } = historyPath(sessionKey);
  try {
    const raw = await fs.readFile(file, 'utf-8');
    const lines = raw.trim().split(/\n+/).filter(Boolean);
    const tail = lines.slice(-limit);
    const out: string[] = [];
    for (const ln of tail) {
      try {
        const rec: any = JSON.parse(ln);
        if (typeof rec?.content === 'string') { out.push(rec.content); continue; }
        if (typeof rec?.message === 'string' || typeof rec?.followUp === 'string') {
          const combined = [rec.message, rec.followUp].filter(Boolean).join('\n\n');
          if (combined) out.push(combined);
          continue;
        }
      } catch {}
    }
    return out;
  } catch {
    return [];
  }
}


```
=== EOF: src\session\history.ts

===  src\schema\timeline.ts
```typescript
import { z } from 'zod';

export const TimelineStepSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	type: z.string(),
	// ASK
	question: z.string().optional(),
	objective: z.string().optional(),
	expected: z.array(z.string()).optional(),
	acceptable_answers: z.array(z.string()).optional(),
	question_type: z.string().optional(),
	answer_type: z.enum(['open', 'list', 'definition', 'procedure', 'choice']).optional(),
	// CONTENT / CASE / NARRATION / KEY_* / TOPICS / REFLECTION_AREAS
	title: z.string().optional(),
	body: z.array(z.string()).optional(),
	text: z.string().optional(),
	description: z.string().optional(),
	items: z.array(z.string()).optional(),
	variables: z.array(z.string()).optional()
});

export const TimelineMomentSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	title: z.string(),
	steps: z.array(TimelineStepSchema)
});

export const TimelineFileSchema = z.object({
	meta: z.object({
		lesson_id: z.string().optional(),
		lesson_name: z.string().optional(),
		version: z.string().optional(),
		language: z.string().optional(),
		ordered: z.boolean().optional(),
		generated_at: z.string().optional()
	}),
	moments: z.array(TimelineMomentSchema)
});

export type TimelineStep = z.infer<typeof TimelineStepSchema>;
export type TimelineMoment = z.infer<typeof TimelineMomentSchema>;
export type TimelineFile = z.infer<typeof TimelineFileSchema>;

export function assertTimeline(obj: unknown): TimelineFile {
	return TimelineFileSchema.parse(obj);
}


```
=== EOF: src\schema\timeline.ts

===  src\teacher\resolveProfile.ts
```typescript
import { DEFAULT_TEACHER_PROFILE } from './defaultProfile';

function deepmerge(a: any, b: any): any {
  if (Array.isArray(a) && Array.isArray(b)) return [...a, ...b];
  if (a && typeof a === 'object' && b && typeof b === 'object') {
    const out: any = { ...a };
    for (const k of Object.keys(b)) out[k] = deepmerge(a?.[k], b[k]);
    return out;
  }
  return b === undefined ? a : b;
}

export function resolveTeacherProfile({ reqProfile, planProfile, stateProfile }:{
  reqProfile?: any; planProfile?: any; stateProfile?: any;
}) {
  return deepmerge(DEFAULT_TEACHER_PROFILE, deepmerge(planProfile || {}, deepmerge(stateProfile || {}, reqProfile || {})));
}


```
=== EOF: src\teacher\resolveProfile.ts

===  src\teacher\defaultProfile.ts
```typescript
export const DEFAULT_TEACHER_PROFILE = {
  lang: { stopwords: ["de","la","y","el","en","que","por","para","con","un","una"] },
  feedback: { openers: { hint: ["Gracias por intentarlo.","Vas por buen camino.","Hag√°moslo paso a paso."] } },
  hints: {
    mentionCount: 2,
    wordLimits: [18, 28, 40],
    templates: {
      objective: "Enf√≥cate en: {{keywords}}. {{cueLine}}",
      reask: {
        list: "Menciona en pocas palabras {{base}} (2 elementos).",
        definition: "Define brevemente {{base}}.",
        procedure: "Enumera 2 pasos clave de {{base}}.",
        choice: "Elige la opci√≥n que aplica en {{base}} y di por qu√©."
      },
      open: {
        hint: "Comparte tus ideas (‚â•{{minWords}} palabras). Gu√≠ate por: {{cues}}.",
        reask: "En {{minWords}}‚Äì{{maxWords}} palabras, cu√©ntame tus ideas sobre ‚Äú{{objective}}‚Äù."
      }
    }
  },
  advance: {
    partial: { enabled: true, thresholds: { minMatched: 2, maxMissing: 1, minSem: 0.55 } },
    force:   { enabled: true, afterAttempts: 3 }
  },
  questions: {
    studentAskPhrases: ["te puedo hacer una pregunta","tengo una duda","una consulta","no entiendo","puedes aclarar"],
    resumeAffirmatives: ["s√≠","si","ok","listo","entendido","claro","ya"],
    intentCorpus: [
      "tengo una pregunta","tengo una duda","puedo preguntar","quisiera preguntar",
      "puedes aclarar","me puedes explicar","no entiendo esto","necesito aclaraci√≥n"
    ],
    intentTau: 0.55
  },
  eval: {
    values: { EMPTY: 0, PARTIAL: 1, ACCEPT: 2 },
    suffixHelp: true,
    vagueCenter: {
      corpus: [
        "no se","no s√©","no lo se","no lo s√©","no estoy seguro","no tengo idea",
        "no recuerdo","no me acuerdo","mmm","n/a","no s√© bien","no entend√≠",
        "ninguna idea","no sabr√≠a decir","no sabria decir"
      ],
      tauVagueMin: 0.60,
      delta: 0.05,
      tauObjOpen: 0.28,
      tauObjClosed: 0.44
    }
  }
} as const;

export type TeacherProfile = typeof DEFAULT_TEACHER_PROFILE;


```
=== EOF: src\teacher\defaultProfile.ts

===  src\plan\types.ts
```typescript
import type { TimelineFile, TimelineStep } from '@/schema/timeline';

export type StepType = 'NARRATION'|'CONTENT'|'ASK'|'CASE'|'KEY_CONTENT'|'KEY_POINTS'|'KEY_ELEMENTS'|'TOPICS'|'EXPECTED_LEARNING'|'REFLECTION_AREAS';

export type PlanStep = {
	momentIndex: number;
	stepIndex: number;
	code?: string;
	order?: number;
	type: StepType;
	data: TimelineStep;
};

export type LessonPlan = {
	meta: TimelineFile['meta'];
	moments: Array<{ title: string; code?: string; order?: number; steps: PlanStep[] }>;
	allSteps: PlanStep[];
	contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }>;
	askCatalog: Array<{ globalIndex: number; momentIndex: number; stepIndex: number; code?: string; question: string; acceptable: string[] }>;
};



```
=== EOF: src\plan\types.ts

===  src\plan\compilePlan.ts
```typescript
import { assertTimeline, TimelineFile } from '@/schema/timeline';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { LessonPlan, PlanStep, StepType } from './types';

function toStepType(t?: string): StepType {
	const u = String(t || '').toUpperCase();
	return (['NARRATION','CONTENT','ASK','CASE','KEY_CONTENT','KEY_POINTS','KEY_ELEMENTS','TOPICS','EXPECTED_LEARNING','REFLECTION_AREAS'] as StepType[])
		.find(x => x === u) || 'CONTENT';
}

export function compilePlan(tl: TimelineFile): LessonPlan {
	const moments = (tl.moments || []).map((m, mi) => {
		const steps: PlanStep[] = (m.steps || [])
			.sort((a, b) => (a.order || 0) - (b.order || 0))
			.map((s, si) => ({ momentIndex: mi, stepIndex: si, code: s.code, order: s.order, type: toStepType(s.type), data: s }));
		return { title: m.title, code: m.code, order: m.order, steps };
	});
	const allSteps = moments.flatMap(m => m.steps);
	// Construir ciclos CONTENT->ASK por proximidad
	const contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }> = [];
	let current: { contentStepIndex: number; askStepIndices: number[] } | null = null;
	for (let i = 0; i < allSteps.length; i++) {
		const s = allSteps[i];
		if (s.type === 'CONTENT') {
			if (current) contentCycles.push(current);
			current = { contentStepIndex: i, askStepIndices: [] };
		} else if (s.type === 'ASK') {
			if (!current) current = { contentStepIndex: -1, askStepIndices: [] };
			current.askStepIndices.push(i);
		}
	}
	if (current) contentCycles.push(current);
	// Cat√°logo de preguntas
	const askCatalog = allSteps
		.map((s, idx) => ({
			globalIndex: idx,
			momentIndex: s.momentIndex,
			stepIndex: s.stepIndex,
			code: s.code,
			question: s.data.question || '',
			acceptable: s.data.acceptable_answers || []
		}))
		.filter(x => !!x.question);
	return { meta: tl.meta, moments, allSteps, contentCycles, askCatalog };
}

export async function loadAndCompile(url: string): Promise<LessonPlan> {
	let obj: any;
	// Soporte server-side: si es ruta absoluta del sitio (/courses/..), leer desde /public
	if (/^https?:/i.test(url)) {
		const res = await fetch(url);
		obj = await res.json();
	} else if (url.startsWith('/')) {
		const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	} else {
		const filePath = path.isAbsolute(url) ? url : path.join(process.cwd(), url);
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	}
	const tl = assertTimeline(obj);
	return compilePlan(tl);
}


```
=== EOF: src\plan\compilePlan.ts

===  src\lib\ai.ts
```typescript
import OpenAI from 'openai';

let client: OpenAI | null = null;

export function pickModel(tier: 'cheap'|'thinker'|'embed'='cheap'): string {
  if (tier === 'thinker') return process.env.THINKER_MODEL || 'o3-mini';
  if (tier === 'embed')  return process.env.EMBED_MODEL  || 'text-embedding-3-small';
  return process.env.CHEAP_MODEL || 'gpt-4o-mini';
}

export function getClient() {
  if (client) return client;
  const key = process.env.OPENAI_API_KEY;
  if (!key) {
    throw new Error('OPENAI_API_KEY is required to initialize OpenAI client');
  }
  client = new OpenAI({ apiKey: key });
  return client;
}
```
=== EOF: src\lib\ai.ts

===  src\hooks\usePlanChat.ts
```typescript
import { useEffect, useRef, useState } from 'react';

export type PlanChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

function generateSessionKey(): string {
	return `plan-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
}

export function usePlanChat(planUrl: string = '/courses/SSO001/lessons/lesson02.json') {
	const [messages, setMessages] = useState<PlanChatMessage[]>([]);
	const [isTyping, setIsTyping] = useState<boolean>(false);
	const [done, setDone] = useState<boolean>(false);
	const [engineState, setEngineState] = useState<{ stepIdx: number; momentIdx: number; done: boolean; stepCode?: string } | null>(null);
	const [adaptiveMode, setAdaptiveMode] = useState<boolean>(false);
	const [budgetMetrics, setBudgetMetrics] = useState<any>(null);
	const sessionKeyRef = useRef<string>('');
	const idSeq = useRef<number>(1);
  const bootedRef = useRef<boolean>(false);

	useEffect(() => {
		if (!sessionKeyRef.current) {
			// Persistir la sesi√≥n para recargas superficiales
			try {
				const stored = typeof window !== 'undefined' ? window.sessionStorage.getItem('planSessionKey') : '';
				if (stored) sessionKeyRef.current = stored;
				else {
					sessionKeyRef.current = generateSessionKey();
					if (typeof window !== 'undefined') window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
				}
			} catch {
				sessionKeyRef.current = generateSessionKey();
			}
		}
		// Primer turno para obtener el primer paso del plan (evitar doble invocaci√≥n en StrictMode)
		if (!bootedRef.current) {
			bootedRef.current = true;
			void turn('');
		}
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [planUrl]);

  async function turn(userInput: string) {
		if (done) return;
		// Mostrar inmediatamente el mensaje del estudiante
		if (userInput && userInput.trim()) {
			setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'student', content: userInput, timestamp: new Date() }]);
		}
		setIsTyping(true);
		try {
			const res = await fetch('/api/engine/turn', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ 
					sessionKey: sessionKeyRef.current, 
					userInput, 
					planUrl, 
					reset: !messages.length,
					adaptiveMode 
				})
			});
			if (!res.ok) throw new Error('engine turn failed');
			const { message, followUp, state, budgetMetrics: newBudgetMetrics, stepCode, momentIdx } = await res.json();
			
			// Crear UNA sola burbuja del asistente (message + followUp)
			if (message || followUp) {
				const norm = (s: string) => s.replace(/\s+/g, ' ').trim().toLowerCase();
				const hasQ = followUp && norm(message || '').includes(norm(followUp));
				const combined = [message, (!hasQ && followUp) ? followUp : '']
					.map(s => (s || '').trim())
					.filter(Boolean)
					.join('\n\n');
				
				// Evitar repetir exactamente el mismo texto que la √∫ltima burbuja del assistant
				setMessages(prev => {
					const last = prev.slice().reverse().find(m => m.sender === 'ai');
					if (last && norm(last.content) === norm(combined)) return prev;
					return [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: combined, timestamp: new Date() }];
				});
			}
			setDone(Boolean(state?.done));
			setEngineState(state ? { ...state, stepCode: (stepCode || (state as any)?.stepCode), momentIdx: (typeof momentIdx === 'number' ? momentIdx : (state as any)?.momentIdx) } : null);
			if (newBudgetMetrics) {
				setBudgetMetrics(newBudgetMetrics);
			}
		} catch (_err) {
			// Emitir mensaje de error simple
			setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: 'Ocurri√≥ un error al avanzar el plan.', timestamp: new Date() }]);
		} finally {
			setIsTyping(false);
		}
	}

	function sendMessage(content: string) {
		if (!content || !content.trim()) return;
		void turn(content);
	}

	function clearMessages() {
		setMessages([]);
	}

	function resetSession() {
		// Limpiar sessionStorage y regenerar sessionKey
		if (typeof window !== 'undefined') {
			window.sessionStorage.removeItem('planSessionKey');
		}
		sessionKeyRef.current = generateSessionKey();
		if (typeof window !== 'undefined') {
			window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
		}
		// Resetear estado
		setMessages([]);
		setDone(false);
		setIsTyping(false);
		setBudgetMetrics(null);
		setEngineState(null);
		bootedRef.current = false;
		// Reiniciar con nuevo plan
		void turn('');
	}

	return { messages, isTyping, done, sendMessage, clearMessages, resetSession, adaptiveMode, setAdaptiveMode, budgetMetrics, state: engineState };
}


```
=== EOF: src\hooks\usePlanChat.ts

===  src\engine\sequencer.ts
```typescript

export function computeForceAdvanceTargets(state: any, nextAskIdx: number): { narrationIdx?: number; askIdx: number } {
  const steps: any[] = state?.plan?.allSteps || [];
  const ask = steps[nextAskIdx];
  if (!ask) return { askIdx: nextAskIdx };
  const targetMoment = ask.momentIndex;
  // Buscar el primer paso "mostrable" en el mismo momento antes del ASK
  let narrationIdx: number | undefined = undefined;
  for (let i = 0; i < steps.length; i++) {
    const s = steps[i];
    if (s?.momentIndex !== targetMoment) continue;
    // Solo considerar pasos anteriores al ASK y de tipo narrativo/contenido
    if (s.stepIndex < ask.stepIndex && (s.type === 'NARRATION' || s.type === 'CONTENT')) {
      narrationIdx = i;
      break;
    }
    // Si ya pasamos el ASK, detener
    if (s.stepIndex >= ask.stepIndex) break;
  }
  return { narrationIdx, askIdx: nextAskIdx };
}



```
=== EOF: src\engine\sequencer.ts

===  src\engine\semvec.ts
```typescript
import { getClient } from '@/lib/ai';
import { getBudgetManager, pickModelWithBudget } from './costs';

export type AskVectorIndex = {
	acceptables: string[];
	expected: string[];
	centroid: number[];
	byItem: { text: string; vec: number[] }[];
};

function cosine(a: number[], b: number[]): number {
	let dot = 0;
	let na = 0;
	let nb = 0;
	const len = Math.min(a.length, b.length);
	for (let i = 0; i < len; i++) { dot += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
	if (!na || !nb) return 0;
	return dot / (Math.sqrt(na) * Math.sqrt(nb));
}

export async function embedTexts(texts: string[]): Promise<number[][]> {
	if (!texts || texts.length === 0) return [];
	const model = pickModelWithBudget('embed');
	const client = getClient();
	const res = await client.embeddings.create({ model: model as any, input: texts });
	
	// Registrar uso de embeddings para costeo
	const budgetManager = getBudgetManager();
	const approxTokens = texts.reduce((total, text) => total + Math.ceil(text.length / 4), 0);
	budgetManager.recordUsage('embed', approxTokens);
	
	return res.data.map(x => (x as any).embedding as number[]);
}

export async function buildAskIndex(acceptables: string[] = [], expected: string[] = []): Promise<AskVectorIndex> {
	const items = Array.from(new Set([...(acceptables || []), ...(expected || [])].map(s => String(s || '').trim()).filter(Boolean)));
	if (items.length === 0) return { acceptables, expected, centroid: [], byItem: [] };
	const vecs = await embedTexts(items);
	const dim = vecs[0]?.length || 0;
	const centroid = dim ? Array.from({ length: dim }, (_, j) => vecs.reduce((acc, v) => acc + (v[j] || 0), 0) / vecs.length) : [];
	return {
		acceptables,
		expected,
		centroid,
		byItem: items.map((t, i) => ({ text: t, vec: vecs[i] || [] }))
	};
}

export async function semanticScore(answer: string, index: AskVectorIndex): Promise<{ cos: number; best?: { text: string; cos: number } }> {
	const text = String(answer || '').trim();
	if (!text || !index || !index.centroid || index.centroid.length === 0) return { cos: 0 };
	const [u] = await embedTexts([text]);
	const cosC = cosine(u || [], index.centroid || []);
	let best = { text: '', cos: 0 };
	for (const it of index.byItem || []) {
		const c = cosine(u || [], it.vec || []);
		if (c > best.cos) best = { text: it.text, cos: c };
	}
	return { cos: cosC, best };
}


```
=== EOF: src\engine\semvec.ts

===  src\engine\runner.ts
```typescript
import type { PlanStep } from '@/plan/types';
import type { SessionState } from '@/session/state';
import { getBudgetManager } from './costs';
import { log } from './logger';
import { applyAdaptCommand, planAdaptation, type PlanningContext } from './planner';

export type SkipAction = { kind: 'skip'; step?: PlanStep };
export type ExplainAction = { kind: 'explain'; step: PlanStep };
export type AskAction = { kind: 'ask'; step: PlanStep };
export type EndAction = { kind: 'end' };
export type EngineAction = SkipAction | ExplainAction | AskAction | EndAction;

export function currentStep(state?: SessionState): PlanStep | undefined {
	const steps = state?.plan?.allSteps || [];
	if (typeof state?.stepIdx !== 'number') return undefined;
	if (state.stepIdx < 0 || state.stepIdx >= steps.length) return undefined;
	return steps[state.stepIdx];
}

export function decideAction(step?: PlanStep, state?: SessionState): EngineAction {
	if (!step) return { kind: 'end' };
	
			// Si el modo adaptativo est√° activado y es un paso ASK, consultar al planificador
		if (state?.adaptiveMode && step.type === 'ASK') {
			const budgetManager = getBudgetManager();
			const metrics = budgetManager.getUsageMetrics();
			
			// Obtener historial corto para el contexto
			const shortHistory: Array<{
				stepIdx: number;
				action: string;
				response?: string;
			}> = []; // TODO: Implementar historial real cuando se necesite
			
			const context: PlanningContext = {
				state: state,
				shortHistory,
				budgetCentsLeft: metrics.budgetCentsLeft,
				escalationsUsed: state.escalationsUsed || 0
			};
			
			const adaptation = planAdaptation(context);
			if (adaptation) {
				// Aplicar la adaptaci√≥n al estado
				const adaptedState = applyAdaptCommand(adaptation, state);
				// Actualizar el estado global con la adaptaci√≥n
				Object.assign(state, adaptedState);
				// Log de adaptaci√≥n aplicada
				log.adaptation('session-' + Date.now(), adaptation);
			}
		}
	
	switch (step.type) {
		case 'ASK':
			return { kind: 'ask', step };
		case 'CONTENT':
		case 'NARRATION':
		case 'CASE':
		case 'REFLECTION_AREAS':
			return { kind: 'explain', step };
		case 'KEY_CONTENT':
		case 'KEY_POINTS':
		case 'KEY_ELEMENTS':
		case 'TOPICS':
		case 'EXPECTED_LEARNING':
		default:
			return { kind: 'skip', step } as SkipAction;
	}
}

export function next(state?: SessionState): SessionState {
	if (!state) {
		throw new Error('Session state not initialized');
	}
	const steps = state.plan?.allSteps || [];
	const nextIdx = (state.stepIdx ?? 0) + 1;
	if (nextIdx >= steps.length) {
		const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
		return { ...state, stepIdx: steps.length, momentIdx: lastMomentIdx, done: true };
	}
	const newStep = steps[nextIdx];
	const newMomentIdx = typeof newStep?.momentIndex === 'number' ? newStep.momentIndex : state.momentIdx;
	return { ...state, stepIdx: nextIdx, momentIdx: newMomentIdx, done: false };
}

export function advanceTo(state: SessionState, targetStepIndex?: number): SessionState {
  if (targetStepIndex === undefined || targetStepIndex === null) {
    const steps = state.plan?.allSteps || [];
    const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
    return { ...state, done: true, stepIdx: steps.length, momentIdx: lastMomentIdx };
  }
  const steps = state.plan?.allSteps || [];
  const boundedIndex = Math.max(0, Math.min(targetStepIndex, Math.max(0, steps.length)));
  const step = steps[boundedIndex];
  const newMomentIdx = typeof step?.momentIndex === 'number' ? step.momentIndex : state.momentIdx;
  return { ...state, stepIdx: boundedIndex, momentIdx: newMomentIdx, done: false };
}

export function getCycleIndexForStep(state: SessionState, stepIdx: number): number | undefined {
  const cycles = state.plan?.contentCycles || [];
  for (let i = 0; i < cycles.length; i++) {
    const c = cycles[i];
    if (c.contentStepIndex === stepIdx) return i;
    if (c.askStepIndices.includes(stepIdx)) return i;
  }
  return undefined;
}

export function getNextAskInSameCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const cycleIdx = getCycleIndexForStep(state, stepIdx);
  if (cycleIdx === undefined) return undefined;
  const cycle = cycles[cycleIdx];
  const askList = cycle.askStepIndices || [];
  const pos = askList.indexOf(stepIdx);
  if (pos === -1) return askList.length ? askList[0] : undefined; // si estamos en CONTENT, volver a la primera ASK
  return askList[pos + 1];
}

export function getFirstAskOfNextCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const currentCycleIdx = getCycleIndexForStep(state, stepIdx);
  const startIdx = currentCycleIdx === undefined ? 0 : currentCycleIdx + 1;
  for (let i = startIdx; i < cycles.length; i++) {
    const askList = cycles[i].askStepIndices || [];
    if (askList.length > 0) return askList[0];
  }
  return undefined;
}

export function decideNextAction(context: {
  lastAction: string;
  noSeCount: number;
  attempts: number;
  momentKind?: string;
}): 'reask' | 'hint' | 'explain' | 'options' | 'force_advance' {
  const { lastAction, noSeCount, attempts, momentKind } = context;
  
  // Solo permitir avance forzado en CONEXI√ìN (no SALUDO)
  const policyAllowsForce = ['CONEXION'].includes(momentKind || '');
  
  // Si no permite forzar y hay muchos intentos, usar transici√≥n pedag√≥gica
  if (!policyAllowsForce && attempts >= 2) {
    if (lastAction === 'hint') return 'explain';
    if (lastAction === 'explain') return 'options';
    if (lastAction === 'options') return 'reask';
    return 'hint';
  }
  
  // Si permite forzar, solo despu√©s de agotar opciones (umbral m√°s alto)
  if (policyAllowsForce && attempts >= 4) {
    return 'force_advance';
  }
  
  // L√≥gica normal de transici√≥n
  if (noSeCount > 0) return 'hint';
  if (lastAction === 'hint') return 'explain';
  if (lastAction === 'explain') return 'options';
  
  return 'reask';
}



```
=== EOF: src\engine\runner.ts

===  src\engine\questions.ts
```typescript
export function isStudentAskingQuestion(input: string, teacherProfile?: any): boolean {
  const normalized = (input || '').toLowerCase().trim();

  // signos de pregunta
  if (/\?\s*$/.test(input || '')) return true;

  // intenci√≥n de "pedir permiso para preguntar"
  const askIntent = Array.isArray(teacherProfile?.questions?.studentAskPhrases)
    ? teacherProfile.questions.studentAskPhrases
    : [
      'te puedo hacer una pregunta', 'puedo hacer una pregunta', 'tengo una pregunta',
      'tengo una duda', 'una consulta', 'puedo consultar', 'quiero preguntar'
    ];
  if (askIntent.some((p: string) => normalized.includes(p))) return true;

  // aclaraciones expl√≠citas
  const clarification = [
    'no entiendo', 'no comprendo', 'puedes aclarar', '¬øpuedes aclarar',
    'puedes explicar', 'qu√© significa', 'c√≥mo es que', 'por qu√©', 'cu√°l es',
    'd√≥nde est√°', 'cu√°ndo', 'qui√©n', 'qu√© es'
  ];
  return clarification.some((p: string) => normalized.includes(p));
}

export function isAffirmativeToResume(input: string, teacherProfile?: any): boolean {
  const n = (input || '').toLowerCase().trim();
  const ok = Array.isArray(teacherProfile?.questions?.resumeAffirmatives)
    ? teacherProfile.questions.resumeAffirmatives
    : ['s√≠','si','ok','listo','entendido','claro','ya'];
  return ok.includes(n) || /^si[,\.!\s]?/i.test(input||'');
}

// Detecci√≥n por embeddings (centro de intenci√≥n de pregunta). Mantiene la versi√≥n s√≠ncrona como atajo.
import { buildAskIndex, semanticScore } from '@/engine/semvec';

export async function isStudentAskingQuestionSem(input: string, teacherProfile?: any): Promise<boolean> {
  const text = String(input || '').trim();
  if (!text) return false;
  // Si trae signo de pregunta, ya es una pregunta
  if (/\?\s*$/.test(text)) return true;
  const corpus: string[] = Array.isArray(teacherProfile?.questions?.intentCorpus) && teacherProfile.questions.intentCorpus.length
    ? teacherProfile.questions.intentCorpus
    : [
        'tengo una pregunta','tengo una duda','puedo preguntar','quisiera preguntar',
        'puedes aclarar','me puedes explicar','no entiendo esto','necesito aclaraci√≥n'
      ];
  const tau: number = typeof teacherProfile?.questions?.intentTau === 'number' ? teacherProfile.questions.intentTau : 0.55;
  try {
    const idx = await buildAskIndex(corpus, []);
    const { cos } = await semanticScore(text, idx);
    return cos >= tau;
  } catch {
    return false;
  }
}
```
=== EOF: src\engine\questions.ts

===  src\engine\planner.ts
```typescript
import type { SessionState } from '@/session/state';
import { z } from 'zod';
import { getCycleIndexForStep, getNextAskInSameCycle } from './runner';

// Esquema Zod para comandos de adaptaci√≥n acotados
export const AdaptCommandSchema = z.object({
  op: z.enum(['reask', 'hint', 'goto', 'repeat', 'insert_micro']),
  targetAskCode: z.string().optional(),
  note: z.string().optional(),
  reason: z.enum(['SEM_LOW', 'THINKER_ESCALATION', 'OFF_TOPIC', 'BUDGET_LIMIT']).optional()
});

export type AdaptCommand = z.infer<typeof AdaptCommandSchema>;

// Tipos para el contexto de planificaci√≥n
export type PlanningContext = {
  state: SessionState;
  currentCycleIndex?: number;
  shortHistory: Array<{
    stepIdx: number;
    action: string;
    response?: string;
  }>;
  budgetCentsLeft: number;
  escalationsUsed: number;
};

// Evaluaci√≥n de desv√≠o de tema
export type TopicDeviation = 'ON_TOPIC' | 'VAGUE' | 'OFF_TOPIC';

export function detectTopicDeviation(
  studentResponse: string,
  currentStep: any,
  objective: string
): TopicDeviation {
  const response = studentResponse.toLowerCase().trim();
  const objectiveWords = objective.toLowerCase().split(/\s+/).filter(w => w.length > 3);
  
  // Palabras clave del objetivo presentes
  const objectiveMatches = objectiveWords.filter(word => response.includes(word));
  const matchRatio = objectiveMatches.length / Math.max(1, objectiveWords.length);
  
  if (matchRatio >= 0.3) return 'ON_TOPIC';
  if (matchRatio >= 0.1) return 'VAGUE';
  return 'OFF_TOPIC';
}

// Planificador principal acotado
export function planAdaptation(context: PlanningContext): AdaptCommand | null {
  const { state, budgetCentsLeft, escalationsUsed } = context;
  const currentStep = state.plan?.allSteps?.[state.stepIdx];
  
  if (!currentStep || currentStep.type !== 'ASK') {
    return null; // Solo adaptamos en pasos ASK
  }

  // Verificar presupuesto antes de escalar
  const canEscalate = budgetCentsLeft > 10 && escalationsUsed < 5;
  
  // Si no hay presupuesto, forzar HINT determinista
  if (!canEscalate) {
    return {
      op: 'hint',
      reason: 'BUDGET_LIMIT',
      note: 'Presupuesto agotado, usando hint determinista'
    };
  }

  // Detectar desv√≠o de tema
  const deviation = detectTopicDeviation(
    context.shortHistory[context.shortHistory.length - 1]?.response || '',
    currentStep,
    currentStep.data?.objective ?? ''
  );

  if (deviation === 'OFF_TOPIC') {
    // Proponer bridge corto y volver al ciclo actual
    const nextAskInCycle = getNextAskInSameCycle(state, state.stepIdx);
    if (nextAskInCycle !== undefined) {
      return {
        op: 'goto',
        targetAskCode: state.plan?.allSteps?.[nextAskInCycle]?.code,
        reason: 'OFF_TOPIC',
        note: 'Desv√≠o detectado, redirigiendo a siguiente pregunta del ciclo'
      };
    }
  }

  if (deviation === 'VAGUE') {
    return {
      op: 'reask',
      reason: 'SEM_LOW',
      note: 'Respuesta vaga, solicitando reformulaci√≥n'
    };
  }

  // Si est√° on-topic pero necesita escalaci√≥n, el evaluador decidir√°
  return null;
}

// Validar comando antes de ejecutar
export function validateAdaptCommand(command: AdaptCommand, state: SessionState): boolean {
  try {
    AdaptCommandSchema.parse(command);
    
    // Validaciones adicionales de contexto
    if (command.op === 'goto' && command.targetAskCode) {
      const targetStep = state.plan?.allSteps?.find(s => s.code === command.targetAskCode);
      if (!targetStep) return false;
    }
    
    return true;
  } catch {
    return false;
  }
}

// Aplicar comando al estado (sin modificar el plan)
export function applyAdaptCommand(command: AdaptCommand, state: SessionState): SessionState {
  if (!validateAdaptCommand(command, state)) {
    return state; // No aplicar si no es v√°lido
  }

  switch (command.op) {
    case 'repeat':
      // Repetir el paso actual sin avanzar
      return { ...state };
      
    case 'goto':
      if (command.targetAskCode) {
        const targetIdx = state.plan?.allSteps?.findIndex(s => s.code === command.targetAskCode);
        if (targetIdx !== undefined && targetIdx >= 0) {
          return { ...state, stepIdx: targetIdx };
        }
      }
      return state;
      
    case 'reask':
    case 'hint':
      // No avanzar, mantener en el paso actual
      return { ...state };
      
    case 'insert_micro':
      // Solo permitir micro-pasos dentro del ciclo actual
      const currentCycle = getCycleIndexForStep(state, state.stepIdx);
      if (currentCycle !== undefined) {
        // Aqu√≠ se podr√≠a insertar un paso temporal, pero por ahora solo mantenemos posici√≥n
        return { ...state };
      }
      return state;
      
    default:
      return state;
  }
}
```
=== EOF: src\engine\planner.ts

===  src\engine\logger.ts
```typescript
import type { SessionState } from '@/session/state';
import type { EscalationResponse } from './eval-escalation';
import type { AdaptCommand } from './planner';

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export type LogEvent = {
  timestamp: string;
  level: LogLevel;
  event: string;
  sessionId?: string;
  data: Record<string, any>;
};

class EngineLogger {
  private logs: LogEvent[] = [];
  private debugMode: boolean;

  constructor() {
    this.debugMode = process.env.ENGINE_DEBUG === 'true' || 
                    process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true';
  }

  private log(level: LogLevel, event: string, data: Record<string, any> = {}, sessionId?: string) {
    const logEvent: LogEvent = {
      timestamp: new Date().toISOString(),
      level,
      event,
      sessionId,
      data
    };

    this.logs.push(logEvent);

    // Log a consola si est√° en modo debug
    if (this.debugMode) {
      console.log(`[${level.toUpperCase()}] ${event}:`, data);
    }
  }

  // Eventos del motor
  engineTurnStart(sessionId: string, stepIdx: number, stepType: string) {
    this.log('info', 'engine.turn.start', { stepIdx, stepType }, sessionId);
  }

  engineTurnEnd(sessionId: string, stepIdx: number, action: string) {
    this.log('info', 'engine.turn.end', { stepIdx, action }, sessionId);
  }

  // Eventos de evaluaci√≥n
  evaluationStart(sessionId: string, askCode: string, studentResponse: string) {
    this.log('info', 'evaluation.start', { askCode, responseLength: studentResponse.length }, sessionId);
  }

  evaluationResult(sessionId: string, askCode: string, result: 'ACCEPT' | 'HINT' | 'REASK', reason?: string) {
    this.log('info', 'evaluation.result', { askCode, result, reason }, sessionId);
  }

  escalationTriggered(sessionId: string, askCode: string, reason: string) {
    this.log('info', 'escalation.triggered', { askCode, reason }, sessionId);
  }

  escalationResult(sessionId: string, askCode: string, result: EscalationResponse) {
    this.log('info', 'escalation.result', { askCode, decision: result.decision, reason: result.reason }, sessionId);
  }

  // Eventos de planificaci√≥n adaptativa
  adaptationPlanned(sessionId: string, command: AdaptCommand) {
    this.log('info', 'adaptation.planned', { 
      op: command.op, 
      targetAskCode: command.targetAskCode,
      reason: command.reason 
    }, sessionId);
  }

  adaptationApplied(sessionId: string, command: AdaptCommand, success: boolean) {
    this.log('info', 'adaptation.applied', { 
      op: command.op, 
      success,
      reason: command.reason 
    }, sessionId);
  }

  // Eventos de presupuesto
  budgetCheck(sessionId: string, tier: string, allowed: boolean, budgetLeft: number) {
    this.log('info', 'budget.check', { tier, allowed, budgetLeft }, sessionId);
  }

  budgetUsage(sessionId: string, tier: string, cost: number, tokens: number) {
    this.log('info', 'budget.usage', { tier, cost, tokens }, sessionId);
  }

  budgetLimit(sessionId: string, tier: string) {
    this.log('warn', 'budget.limit', { tier }, sessionId);
  }

  // Eventos de avance
  advancementAccept(sessionId: string, stepIdx: number, askCode: string) {
    this.log('info', 'advancement.accept', { stepIdx, askCode }, sessionId);
  }

  advancementReject(sessionId: string, stepIdx: number, askCode: string, reason: string) {
    this.log('info', 'advancement.reject', { stepIdx, askCode, reason }, sessionId);
  }

  // Eventos de error
  error(sessionId: string, error: string, context?: Record<string, any>) {
    this.log('error', 'engine.error', { error, context }, sessionId);
  }

  // M√©tricas de sesi√≥n
  sessionMetrics(sessionId: string, state: SessionState, budgetMetrics: any) {
    this.log('info', 'session.metrics', {
      stepIdx: state.stepIdx,
      momentIdx: state.momentIdx,
      attemptsByAskCode: state.attemptsByAskCode,
      escalationsUsed: state.escalationsUsed,
      budgetCentsLeft: state.budgetCentsLeft,
      adaptiveMode: state.adaptiveMode,
      budgetMetrics
    }, sessionId);
  }

  // Obtener logs para auditor√≠a
  getLogs(): LogEvent[] {
    return [...this.logs];
  }

  // Exportar logs en formato JSONL
  exportJSONL(): string {
    return this.logs.map(log => JSON.stringify(log)).join('\n');
  }

  // Limpiar logs (√∫til para sesiones largas)
  clear() {
    this.logs = [];
  }
}

// Instancia global del logger
export const engineLogger = new EngineLogger();

// Funciones de conveniencia para uso directo
export const log = {
  turnStart: (sessionId: string, stepIdx: number, stepType: string) => 
    engineLogger.engineTurnStart(sessionId, stepIdx, stepType),
  
  turnEnd: (sessionId: string, stepIdx: number, action: string) => 
    engineLogger.engineTurnEnd(sessionId, stepIdx, action),
  
  evalStart: (sessionId: string, askCode: string, response: string) => 
    engineLogger.evaluationStart(sessionId, askCode, response),
  
  evalResult: (sessionId: string, askCode: string, result: 'ACCEPT' | 'HINT' | 'REASK', reason?: string) => 
    engineLogger.evaluationResult(sessionId, askCode, result, reason),
  
  escalation: (sessionId: string, askCode: string, result: EscalationResponse) => 
    engineLogger.escalationResult(sessionId, askCode, result),
  
  adaptation: (sessionId: string, command: AdaptCommand) => 
    engineLogger.adaptationPlanned(sessionId, command),
  
  budget: (sessionId: string, tier: string, cost: number, tokens: number) => 
    engineLogger.budgetUsage(sessionId, tier, cost, tokens),
  
  error: (sessionId: string, error: string, context?: Record<string, any>) => 
    engineLogger.error(sessionId, error, context),
  
  metrics: (sessionId: string, state: SessionState, budgetMetrics: any) => 
    engineLogger.sessionMetrics(sessionId, state, budgetMetrics)
};
```
=== EOF: src\engine\logger.ts

===  src\engine\hints.ts
```typescript
type HintPolicies = {
  mentionCount?: number;
  wordLimits?: number[]; // [S1, S2, S3]
  variants?: string[];
  templates?: {
    objective?: string;
    reask?: Record<'list'|'definition'|'procedure'|'choice', string>;
    open?: { hint: string; reask: string };
  };
};

type LangPolicies = { stopwords?: string[] };

export function makeTokenizer(stop: string[] = []) {
  const STOP = new Set(stop);
  return (s: string) =>
    (s || '')
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/["'()\[\]{}]/g, '')
      .split(/[^a-z√°√©√≠√≥√∫√±0-9]+/)
      .filter(Boolean)
      .filter(w => w.length > 2 && !STOP.has(w));
}

export function extractKeywords(from: string[], stop: string[] = []): string[] {
  const tok = makeTokenizer(stop);
  const uniq: string[] = [];
  for (const item of from) for (const w of tok(item)) if (!uniq.includes(w)) uniq.push(w);
  return uniq.slice(0, 40);
}

export function buildStudentFacingBase(questionText: string, objective: string, expected: string[]): string {
  return (questionText && questionText.toLowerCase().includes('sobre '))
    ? `lo que esperas aprender sobre ${questionText.split('sobre ')[1].replace(/[?¬ø.]/g,'').trim()}`
    : (expected?.[0] || objective || 'el tema actual');
}

// Nivel de severidad seg√∫n intentos/pistas
function severity(attempts: number, hintsUsed: number): 0|1|2 {
  if (attempts <= 1 && hintsUsed === 0) return 0; // S1
  if (hintsUsed <= 1) return 1;                    // S2
  return 2;                                        // S3
}

export function makeHintMessage(opts: {
  questionText: string;
  objective: string;
  expected: string[];
  missing: string[];
  answerType?: 'open'|'list'|'definition'|'procedure'|'choice';
  hintsUsed: number;
  attempts: number;
  coursePolicies?: { hints?: HintPolicies; language?: LangPolicies; feedback?: any };
  teacherProfile?: any;
}) {
  const { questionText, objective, expected, missing, answerType = 'list', hintsUsed, attempts } = opts as any;
  const policy = (opts as any).teacherProfile || (opts as any).coursePolicies || {};
  const hp = policy?.hints || {};
  const lp = policy?.language || policy?.lang || {};
  const wordLimits = hp.wordLimits || [16, 22, 28];
  const mentionCount = hp.mentionCount ?? 2;
  const sev = severity(attempts, hintsUsed);
  const maxMsgChars = wordLimits[Math.min(sev, wordLimits.length-1)] * 5;

  const stop = lp.stopwords || [];
  const kws = extractKeywords([objective, ...(expected||[])], stop).slice(0, 6);

  // cues: prioriza missing; si no hay, usa expected
  const cuesArr = (missing?.length ? missing : expected || []).slice(0, mentionCount);
  const cueLine = cuesArr.length ? `Menciona ${cuesArr.join(', ')}.` : '';

  const variants = hp.variants || [];
  const opener = variants.length ? variants[hintsUsed % variants.length] : '';
  const openerClean = opener ? (/[.!?]$/.test(opener.trim()) ? opener.trim() : `${opener.trim()}.`) : '';

  const replaceTokens = (tmpl: string, tokens: Record<string, string>): string => {
    let out = String(tmpl || '');
    for (const [k, v] of Object.entries(tokens)) {
      const re2 = new RegExp(`\\{\\{\s*${k}\s*\\}\\}`, 'g');
      const re1 = new RegExp(`\\{\s*${k}\s*\\}`, 'g');
      out = out.replace(re2, v).replace(re1, v);
    }
    return out;
  };

  if (answerType === 'open') {
    const fallbackAspects: string[] = (hp.templates as any)?.open?.fallbackAspects || [];
    const aspects = cuesArr.length ? cuesArr : fallbackAspects;
    const cuesLine = aspects.length ? `Por ejemplo, considera ${aspects.join(', ')}.` : '';
    const msg = [`Comparte tus ideas en al menos ${wordLimits[0]} palabras.`, cuesLine]
      .map(s => s.trim())
      .filter(Boolean)
      .join(' ')
      .replace(/gu[i√≠]ate\s+por\s*:\s*/i, '');
    return msg.trim();
  }

  // Construcci√≥n m√°s natural: oraciones separadas y sin duplicados
  const focus = kws.length ? `Enf√≥cate en ${kws.join(', ')}.` : '';
  const parts = [openerClean, focus, cueLine].map(s => (s || '').trim()).filter(Boolean);
  const msg = parts.join(' ');
  return msg.slice(0, maxMsgChars);
}

export function makeReaskMessage(opts: {
  questionText: string;
  objective: string;
  expected: string[];
  answerType?: 'open'|'list'|'definition'|'procedure'|'choice';
  coursePolicies?: { hints?: HintPolicies };
  teacherProfile?: any;
}) {
  const { questionText, objective, expected, answerType = 'list' } = opts as any;
  const policy = (opts as any).teacherProfile || (opts as any).coursePolicies || {};
  const hp = policy?.hints || {};
  const baseStr = buildStudentFacingBase(questionText, objective, expected);
  if (answerType === 'open') {
    const tmpl = hp.templates?.open?.reask || 'En {minWords}-{maxWords} palabras, cu√©ntame {aspects} sobre "{objective}".';
    const minw = (hp.wordLimits || [16])[0];
    const base = buildStudentFacingBase(questionText, objective, expected);
    const aspectsLabel = (hp.templates as any)?.open?.aspectsLabel || 'tus ideas principales';
    const replaceTokens = (s: string, tokens: Record<string, string>) => {
      let out = s;
      for (const [k, v] of Object.entries(tokens)) {
        const re2 = new RegExp(`\\{\\{\s*${k}\s*\\}\\}`, 'g');
        const re1 = new RegExp(`\\{\s*${k}\s*\\}`, 'g');
        out = out.replace(re2, v).replace(re1, v);
      }
      return out;
    };
    return replaceTokens(tmpl, {
      minWords: String(minw),
      maxWords: String(minw + 8),
      aspects: aspectsLabel,
      objective: base
    });
  }
  const reaskTmpls = (hp.templates?.reask || {}) as Record<'list'|'definition'|'procedure'|'choice', string>;
  const maxWords = (hp.wordLimits || [16])[0];
  const map: Record<string, string> = {
    list: reaskTmpls.list || '',
    definition: reaskTmpls.definition || '',
    procedure: reaskTmpls.procedure || '',
    choice: reaskTmpls.choice || ''
  };
  const fallback = `Menciona en ${maxWords} palabras 2 elementos de ${baseStr}.`;
  const replaceTokens = (s: string, tokens: Record<string, string>) => {
    let out = s;
    for (const [k, v] of Object.entries(tokens)) {
      const re2 = new RegExp(`\\{\\{\s*${k}\s*\\}\\}`, 'g');
      const re1 = new RegExp(`\\{\s*${k}\s*\\}`, 'g');
      out = out.replace(re2, v).replace(re1, v);
    }
    return out;
  };
  const raw = map[answerType] || '';
  const rendered = replaceTokens(raw, { maxWords: String(maxWords), base: baseStr });
  return rendered || fallback;
}

// Funciones legacy para compatibilidad - eliminar despu√©s de migraci√≥n
// (legacy wrappers eliminados tras migraci√≥n)








```
=== EOF: src\engine\hints.ts

===  src\engine\feedbackSequencer.ts
```typescript
export type FeedbackKind = 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS' | string;

export function computeFeedbackLabel(kind: FeedbackKind, attempt: number): 'F0'|'F1'|'F2' {
  const a = Math.max(0, Number(attempt || 0));
  if (String(kind).toUpperCase() === 'HINT') {
    return a <= 1 ? 'F0' : 'F1';
  }
  return 'F2';
}

export function buildTraceEntry(args: {
  question: string;
  response: string;
  feedback: string;
  kind: FeedbackKind;
  attempt: number;
  hintsUsed?: number;
  stepCode?: string;
}) {
  const { question, response, feedback, kind, attempt, hintsUsed = 0, stepCode = '' } = args;
  const label = computeFeedbackLabel(kind, attempt);
  return {
    label, // F0/F1/F2
    kind,
    p: String(question || ''),
    r: String(response || ''),
    f: String(feedback || ''),
    attempt: Number(attempt || 0),
    hintsUsed: Number(hintsUsed || 0),
    stepCode: String(stepCode || '')
  };
}


```
=== EOF: src\engine\feedbackSequencer.ts

===  src\engine\feedback.ts
```typescript
export type FeedbackClass = {
  kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS';
  matched?: string[];
  missing?: string[];
};

export function buildDeterministicFeedback(
  cls: FeedbackClass,
  opts: {
    attempts: number;            // intentos de respuesta del alumno
    hintsUsed: number;           // pistas ya usadas en ESTA pregunta
    coursePolicies?: any;        // policies.json ya cargadas
  }
): string {
  const has = (arr?: string[]) => Array.isArray(arr) && arr.length > 0;

  // 1) Mensajes cortos por estado (evita muletillas)
  if (cls.kind === 'ACCEPT' && has(cls.matched)) {
    return `Bien: mencionaste ${cls.matched!.join(', ')}.`;
  }
  if (cls.kind === 'PARTIAL') {
    const a = has(cls.matched) ? `acertaste ${cls.matched!.join(', ')}` : 'ya est√°s cerca';
    const missTop = has(cls.missing) ? `Te falta incluir ${cls.missing!.slice(0,2).join(', ')}.` : '';
    return `Vas bien: ${a}. ${missTop}`.trim();
  }

  // 2) Abridores configurables (rotar por n√∫mero de pistas, no por attempts)
  const openers: string[] = (opts.coursePolicies?.feedback?.openers?.hint || []) as string[];
  const idx = (opts.hintsUsed % Math.max(1, openers.length || 1)); // <‚Äî ROTA DE VERDAD
  const opener = openers[idx] || 'Intenta precisar un poco m√°s.';

  // 3) Reducir "Menciona‚Ä¶" a DOS elementos para no sonar rob√≥tico
  if (has(cls.missing)) {
    const top = cls.missing!.slice(0, 2);
    return `${opener} Menciona: ${top.join(', ')}.`;
  }
  return `${opener} Da un ejemplo o una idea concreta.`;
}
```
=== EOF: src\engine\feedback.ts

===  src\engine\eval.ts
```typescript
export function normalize(input: string): string {
	return (input || '')
		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		// Colapsa repeticiones largas de caracteres: accidenteee -> accidentee
		.replace(/([a-z√±])\1{2,}/g, '$1$1')
		.replace(/[^\w\s]/g, ' ')
		.replace(/\s+/g, ' ')
		.trim();
}

export function matchesAcceptable(user: string, acceptable: string[]): boolean {
	const u = normalize(user);
	return acceptable.some(a => {
		const n = normalize(a);
		return n.length > 0 && (u === n || u.includes(n) || n.includes(u));
	});
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
}

function tokenSet(s: string): Set<string> {
  return new Set(normalize(s).split(' ').filter(Boolean));
}

function jaccard(a: string, b: string): number {
  const A = tokenSet(a), B = tokenSet(b);
  const interArr: string[] = [];
  A.forEach(v => { if (B.has(v)) interArr.push(v); });
  const inter = interArr.length;
  const unionSet = new Set<string>();
  A.forEach(v => unionSet.add(v));
  B.forEach(v => unionSet.add(v));
  const union = unionSet.size || 1;
  return inter / union;
}

export function computeMatchedMissing(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const u = normalize(user);
	const essentials = acceptable;
	const matched: string[] = [];
	const uTokens = u.split(' ').filter(Boolean);
	for (const a of essentials) {
		const n = normalize(a);
		if (!n) continue;
		// Coincidencia estricta por frase completa
		if (u === n || u.includes(n) || n.includes(u)) { matched.push(a); continue; }
		if (fuzzy) {
			const dist = levenshtein(u, n);
			const sim = jaccard(u, n);
			if ((fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin)) { matched.push(a); continue; }
			// Fuzzy a nivel de tokens: si alg√∫n token del usuario se parece a un token del aceptable
			const nTokens = n.split(/\s+/).filter(t => t.length >= 4);
			const uStrong = uTokens.filter(t => t.length >= 4);
			const tokenHit = uStrong.some(ut => nTokens.some(nt => {
				if (!ut || !nt) return false;
				if (ut === nt || ut.includes(nt) || nt.includes(ut)) return true;
				const d = levenshtein(ut, nt);
				return typeof fuzzy.maxEditDistance === 'number' ? d <= fuzzy.maxEditDistance : d <= 1;
			}));
			if (tokenHit) { matched.push(a); continue; }
			// Soft token match conservador por inclusi√≥n directa
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) { matched.push(a); }
			continue;
		}
		// Sin fuzzy: aplicar soft token match m√≠nimo
		const tokens = n.split(/\s+/).filter(t => t.length >= 4);
		if (tokens.some(t => u.includes(t))) { matched.push(a); continue; }
	}
	if (matched.length === 0 && expected?.length) {
		const extras = expected.filter(e => {
			const n = normalize(e);
			if (!n) return false;
			if (u.includes(n)) return true;
			if (fuzzy) {
				const dist = levenshtein(u, n);
				const sim = jaccard(u, n);
				return (fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin);
			}
			// Soft token para expected
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) return true;
			return false;
		}).slice(0, 2);
		matched.push(...extras);
	}
	const missing = essentials.filter(a => !matched.includes(a)).slice(0, 3);
	return { matched, missing };
}

export function evaluateAnswer(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const { matched, missing } = computeMatchedMissing(user, acceptable, expected, fuzzy);
	return { ok: matched.length > 0, matched, missing };
}

export type AskPolicy = {
	type: 'conceptual'|'listado'|'aplicacion'|'identificacion'|'experiencial'|'metacognitiva'|'reflexiva'|string;
	thresholdK?: number; // para listado
	requiresJustification?: boolean; // para aplicacion
};

export function classifyTurn(
	user: string,
	policy: AskPolicy,
	acceptable: string[] = [],
	expected: string[] = [],
	fuzzy?: { maxEditDistance?: number; similarityMin?: number }
): { kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; matched: string[]; missing: string[]; reason: string } {
	const u = normalize(user);
	if (!u) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	// Gate duro: si el alumno dice "no s√©" o equivalente, no intentamos ACCEPT/PARTIAL
	if (isNoSe(user)) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	const { matched, missing } = computeMatchedMissing(u, acceptable, expected, fuzzy);
	const hasAny = matched.length > 0;
	// Aceptaci√≥n estricta solo por se√±ales "acceptable" (no por extras de expected)
	const hasAcceptable = matchesAcceptable(user, acceptable);
	if (policy.type === 'listado') {
		const k = Math.max(1, policy.thresholdK || 2);
		if (matched.length >= k) return { kind: 'ACCEPT', matched, missing, reason: 'K_OF_N' };
		if (matched.length > 0 || expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'PARTIAL_LISTADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	if (policy.type === 'aplicacion') {
		if (hasAny && (!policy.requiresJustification || /porque|para|ya que/i.test(user))) return { kind: 'ACCEPT', matched, missing, reason: 'APLICACION_OK' };
		if (hasAny) return { kind: 'PARTIAL', matched, missing, reason: 'FALTA_JUSTIFICACION' };
		if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	// conceptual, identificacion, etc.
	if (hasAcceptable) return { kind: 'ACCEPT', matched, missing, reason: 'MATCH_ACCEPTABLE' };
	if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
	return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
}

export function isVagueAnswer(
	user: string,
	question?: string,
	opts?: { stopwords?: string[]; minUsefulTokens?: number; maxStopwordRatio?: number; echoOverlap?: number; repeatSimilarity?: number; lastAnswer?: string }
): boolean {
	const u = normalize(user);
	if (!u) return true;
	const tokens = u.split(' ').filter(Boolean);
	const stop = new Set((opts?.stopwords || []).map(s => normalize(s)));
	const useful = tokens.filter(t => !stop.has(t));
	const stopRatio = tokens.length ? (tokens.length - useful.length) / tokens.length : 1;
	if (useful.length < (opts?.minUsefulTokens ?? 3)) return true;
	if (stopRatio > (opts?.maxStopwordRatio ?? 0.6)) return true;
	const q = question ? normalize(question) : '';
	if (q) {
		const overlap = jaccard(u, q);
		if (overlap >= (opts?.echoOverlap ?? 0.7)) return true;
	}
	const last = normalize(opts?.lastAnswer || '');
	if (last) {
		const sim = jaccard(u, last);
		if (sim >= (opts?.repeatSimilarity ?? 0.8)) return true;
	}
	return false;
}

export function isNoSe(answer?: string): boolean {
	const a = (answer || '').trim().toLowerCase();
	if (!a) return true;
	const patterns = [
		/^no\s*se$/, /^no\s*lo\s*se$/, /^no\s*s√©$/, /^no\s*lo\s*s√©$/,
		/^ns$/, /^n\/a$/, /^no\s*sab[o√≥]$/, /^no\s*est[o√≥]\s*seguro$/,
		/^no$/, /^mmm$/, /^mm$/,
		/^[\.\!\?‚Ä¶]+$/
	];
	if (patterns.some(rx => rx.test(a))) return true;
	const words = a.split(/\s+/).filter(Boolean);
	return false; // deja solo patrones expl√≠citos (no, no s√©, n/a, mmm‚Ä¶)
}

export function detectTopicDeviation(
	studentResponse: string,
	currentStep: any,
	objective: string
): 'ON_TOPIC' | 'VAGUE' | 'OFF_TOPIC' {
	const response = studentResponse.toLowerCase().trim();
	const objectiveWords = objective.toLowerCase().split(/\s+/).filter(w => w.length > 3);
	
	// Palabras clave del objetivo presentes
	const objectiveMatches = objectiveWords.filter(word => response.includes(word));
	const matchRatio = objectiveMatches.length / Math.max(1, objectiveWords.length);
	
	if (matchRatio >= 0.3) return 'ON_TOPIC';
	if (matchRatio >= 0.1) return 'VAGUE';
	return 'OFF_TOPIC';
}



// Evaluaci√≥n h√≠brida (vaguedad ‚Üí r√°pido ‚Üí sem√°ntico)
// Importes din√°micos para evitar dependencias de IA (OpenAI) durante carga en tests

export type HybridOpts = {
  fuzzy?: { maxEditDistance?: number; similarityMin?: number };
  semThresh?: number;
  semBestThresh?: number;
  maxHints?: number;
};

export async function evaluateHybrid(
  user: string,
  acceptable: string[] = [],
  expected: string[] = [],
  policy: AskPolicy = { type: 'conceptual' },
  opts: HybridOpts = { fuzzy: { maxEditDistance: 1, similarityMin: 0.35 }, semThresh: 0.78, semBestThresh: 0.65, maxHints: 2 },
  context?: { lastAnswer?: string; hintsUsed?: number }
): Promise<{ kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; reason: string; matched: string[]; missing: string[]; sem?: { cos: number; best?: { text: string; cos: number } } }> {
  // Umbrales de embeddings por tipo de pregunta (MUY PERMISIVOS)
  const getThresholdsByType = (type: string) => {
    switch (type) {
      case 'diagn√≥stica':
        return { semThresh: 0.45, semBestThresh: 0.35 };
      case 'conceptual':
        return { semThresh: 0.50, semBestThresh: 0.40 };
      case 'aplicaci√≥n':
        return { semThresh: 0.48, semBestThresh: 0.38 };
      case 'listado':
        return { semThresh: 0.46, semBestThresh: 0.36 };
      default:
        	return { semThresh: opts.semThresh ?? 0.48, semBestThresh: opts.semBestThresh ?? 0.40 };
    }
  };
  
  const thresholds = getThresholdsByType(policy.type);
  const semThresh = thresholds.semThresh;
  const semBestThresh = thresholds.semBestThresh;
  const u = normalize(user);
  if (!u) return { kind: 'HINT', reason: 'EMPTY', matched: [], missing: acceptable.slice(0,3) };
  if (isNoSe(user)) return { kind: 'HINT', reason: 'DONT_KNOW', matched: [], missing: acceptable.slice(0,3) };

  // 1) Gate de vaguedad (barato) - M√ÅS PERMISIVO
  const vague = isVagueAnswer(u, undefined, { minUsefulTokens: 2, echoOverlap: 0.8, lastAnswer: context?.lastAnswer });
  if (vague) return { kind: 'HINT', reason: 'VAGUE', matched: [], missing: acceptable.slice(0,3) };
  
  // 2) Detecci√≥n de "eco" (repetici√≥n de pregunta/respuesta anterior) - M√ÅS PERMISIVO
  if (context?.lastAnswer) {
    const overlap = jaccard(u, normalize(context.lastAnswer));
    if (overlap >= 0.8) return { kind: 'HINT', reason: 'ECHO', matched: [], missing: acceptable.slice(0,3) };
  }

  // 2) Match r√°pido (barato)
  const fast = classifyTurn(u, policy, acceptable, expected, opts.fuzzy);
  if (fast.kind === 'ACCEPT' || fast.kind === 'PARTIAL') return { ...fast, reason: fast.reason, sem: undefined } as any;

  // 3) Sem√°ntico (costoso): embeddings (carga diferida)
  let idx: any = null;
  let cos = 0; let best: any = null;
  try {
    const sem = await import('@/engine/semvec');
    idx = await sem.buildAskIndex(acceptable, expected);
    if (!idx || !idx.centroid?.length) return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
    const res = await sem.semanticScore(u, idx);
    cos = res.cos; best = res.best;
  } catch {
    return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
  }
  
  // Debug: embeddings activos
  if (process.env.ENGINE_DEBUG === 'true') {
    console.log('[EMBEDDINGS]', { 
      user: u.slice(0, 50), 
      cos, 
      best: best?.text?.slice(0, 30), 
      semThresh: opts.semThresh,
      semBestThresh: opts.semBestThresh 
    });
  }
  // Usar umbrales calculados por tipo de pregunta
  if (cos >= semThresh) {
    if (policy.type === 'aplicacion') {
      const justifica = /porque|para|ya que/i.test(user);
      return { kind: (justifica ? 'ACCEPT' : 'PARTIAL'), reason: (justifica ? 'SEM_APLICACION_OK' : 'SEM_FALTA_JUSTIFICACION'), matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } } as any;
    }
    return { kind: 'PARTIAL', reason: 'SEM_SIMILAR', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((best?.cos || 0) >= semBestThresh) {
    return { kind: 'PARTIAL', reason: 'SEM_BEST', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((context?.hintsUsed || 0) >= (opts.maxHints ?? 2)) {
    return { kind: 'REFOCUS', reason: 'MAX_HINTS', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
  }
  
  // Escalamiento a thinker para casos borderline/ambiguos
  if (cos >= 0.4 && cos < semThresh && (best?.cos || 0) >= 0.35) {
    try {
      const { escalateReasoning } = await import('./eval-escalation');
      const escalation = await escalateReasoning({
        student: user,
        objective: policy.type,
        acceptable,
        expected,
        matched: best?.text ? [best.text] : [],
        missing: acceptable.filter(a => a !== best?.text).slice(0,2),
        hintsUsed: context?.hintsUsed || 0
      });
      
      if (escalation.decision === 'ACCEPT') {
        return { kind: 'ACCEPT', reason: 'THINKER_ESCALATION', matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } };
      } else if (escalation.decision === 'HINT') {
        return { kind: 'HINT', reason: 'THINKER_ESCALATION', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
      }
    } catch (error) {
      // Si falla el escalamiento, continuar con la l√≥gica normal
      console.warn('[ESCALATION_ERROR]', error);
    }
  }
  
  return { kind: 'HINT', reason: 'SEM_LOW', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
}

// Evaluaci√≥n SOLO sem√°ntica (sin gates r√°pidos ni heur√≠sticas de vaguedad)
export type SemanticOpts = { semThresh?: number; semBestThresh?: number; maxHints?: number; vagueCenter?: { corpus?: string[]; tauVagueMin?: number; delta?: number; tauObj?: number } };

export async function evaluateSemanticOnly(
  user: string,
  acceptable: string[] = [],
  expected: string[] = [],
  policy: AskPolicy = { type: 'conceptual' },
  opts: SemanticOpts = { semThresh: 0.50, semBestThresh: 0.40, maxHints: 2 },
  context?: { hintsUsed?: number }
): Promise<{ kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; reason: string; matched: string[]; missing: string[]; sem?: { cos: number; best?: { text: string; cos: number } } }> {
  const u = normalize(user);
  if (!u) return { kind: 'HINT', reason: 'EMPTY', matched: [], missing: acceptable.slice(0,3) };

  // Umbrales por tipo (solo sem√°nticos)
  const t = normalize(String(policy.type || ''));
  const getThresholds = () => {
    switch (t) {
      case 'diagnostica': return { semThresh: opts.semThresh ?? 0.40, semBestThresh: opts.semBestThresh ?? 0.30 };
      case 'conceptual':  return { semThresh: opts.semThresh ?? 0.44, semBestThresh: opts.semBestThresh ?? 0.34 };
      case 'aplicacion':  return { semThresh: opts.semThresh ?? 0.42, semBestThresh: opts.semBestThresh ?? 0.32 };
      case 'listado':     return { semThresh: opts.semThresh ?? 0.42, semBestThresh: opts.semBestThresh ?? 0.32 };
      default:            return { semThresh: opts.semThresh ?? 0.44, semBestThresh: opts.semBestThresh ?? 0.34 };
    }
  };
  const { semThresh, semBestThresh } = getThresholds();

  // √çndice + score sem√°ntico (objetivo)
  let idx: any = null;
  let cos = 0; let best: any = null;
  try {
    const sem = await import('@/engine/semvec');
    idx = await sem.buildAskIndex(acceptable, expected);
    if (!idx || !idx.centroid?.length) return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
    const res = await sem.semanticScore(u, idx);
    cos = res.cos; best = res.best;
  } catch {
    return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) } as any;
  }

  // Centro vago por embeddings (opcional y configurable)
  if (opts?.vagueCenter?.corpus && Array.isArray(opts.vagueCenter.corpus) && opts.vagueCenter.corpus.length > 0) {
    try {
      const sem = await import('@/engine/semvec');
      const idxV = await sem.buildAskIndex(opts.vagueCenter.corpus as any, []);
      const { cos: cosVague } = await sem.semanticScore(u, idxV);
      const tauV = typeof opts.vagueCenter.tauVagueMin === 'number' ? opts.vagueCenter.tauVagueMin : 0.60;
      const delta = typeof opts.vagueCenter.delta === 'number' ? opts.vagueCenter.delta : 0.05;
      const tauObj = typeof opts.vagueCenter.tauObj === 'number' ? opts.vagueCenter.tauObj : semThresh;
      const emptyByCenter = (cosVague >= (cos + delta)) || ((cos < tauObj) && (cosVague >= tauV));
      if (emptyByCenter) {
        return { kind: 'HINT', reason: 'EMPTY_CENTER', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } } as any;
      }
    } catch {}
  }

  // Decisi√≥n SOLO por embeddings
  if (cos >= semThresh) {
    if (t === 'aplicacion') {
      const justifica = /porque|para|ya que/i.test(user);
      return {
        kind: (justifica ? 'ACCEPT' : 'PARTIAL'),
        reason: (justifica ? 'SEM_APLICACION_OK' : 'SEM_FALTA_JUSTIFICACION'),
        matched: best?.text ? [best.text] : [],
        missing: [],
        sem: { cos, best }
      } as any;
    }
    return {
      kind: 'PARTIAL',
      reason: 'SEM_SIMILAR',
      matched: best?.text ? [best.text] : [],
      missing: acceptable.filter(a => a !== best?.text).slice(0,2),
      sem: { cos, best }
    };
  }

  if ((best?.cos || 0) >= semBestThresh) {
    return {
      kind: 'PARTIAL',
      reason: 'SEM_BEST',
      matched: best?.text ? [best.text] : [],
      missing: acceptable.filter(a => a !== best?.text).slice(0,2),
      sem: { cos, best }
    };
  }

  // Sin suficiente similitud ‚Üí pista o refocus determinista
  const hintsUsed = context?.hintsUsed || 0;
  if (hintsUsed >= (opts.maxHints ?? 2)) {
    return { kind: 'REFOCUS', reason: 'MAX_HINTS', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } } as any;
  }

  return { kind: 'HINT', reason: 'SEM_LOW', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } } as any;
}
```
=== EOF: src\engine\eval.ts

===  src\engine\eval-escalation.ts
```typescript
import { getClient } from '@/lib/ai';
import { z } from 'zod';
import { getBudgetManager, pickModelWithBudget } from './costs';

// Esquema Zod para validaci√≥n estricta del JSON
const EscalationResponseSchema = z.object({
  decision: z.enum(['ACCEPT', 'HINT', 'REASK']),
  short: z.string().min(1).max(200),
  reason: z.enum(['SEM_LOW', 'THINKER_ESCALATION', 'OFF_TOPIC', 'BUDGET_LIMIT']).optional()
});

export type EscalationResponse = z.infer<typeof EscalationResponseSchema>;

export async function escalateReasoning(input: {
  student: string;
  objective: string;
  acceptable: string[];
  expected: string[];
  matched: string[];
  missing: string[];
  hintsUsed: number;
}): Promise<EscalationResponse> {
  const budgetManager = getBudgetManager();
  
  // Verificar presupuesto antes de escalar
  if (!budgetManager.canEscalate()) {
    return {
      decision: 'HINT',
      short: 'Considera revisar los conceptos clave mencionados.',
      reason: 'BUDGET_LIMIT'
    };
  }

  const ai = getClient();
  const model = pickModelWithBudget('thinker');
  
  const sys = [
    'Eres un evaluador estricto.',
    'Devuelve SOLO JSON con: { "decision": "ACCEPT|HINT|REASK", "short": "texto breve", "reason": "SEM_LOW|THINKER_ESCALATION|OFF_TOPIC" }. Sin comentarios.'
  ].join('\n');

  const user = `
Objetivo: ${input.objective}
Respuesta del alumno: ${input.student}
Acceptable: ${input.acceptable.join(', ')}
Expected: ${input.expected.join(', ')}
Matched: ${input.matched.join(', ')}
Missing: ${input.missing.join(', ')}
Hints usadas: ${input.hintsUsed}
Regla: si faltan conceptos cr√≠ticos -> HINT con pista breve; si es off-topic/vago -> REASK; si cumple -> ACCEPT.
`;

  try {
    const res = await ai.responses.create({
      model,
      reasoning: { effort: 'medium' },
      input: [
        { role: 'system', content: sys },
        { role: 'user',   content: user }
      ],
      max_output_tokens: 120
    });

    const raw = res.output_text || '{}';
    
    // Validar con Zod antes de usar
    const parsed = JSON.parse(raw);
    const validated = EscalationResponseSchema.parse(parsed);
    
    // Registrar uso en el presupuesto
    budgetManager.recordUsage('thinker', 200);
    
    return validated;
  } catch (error) {
    // Fallback seguro si falla la validaci√≥n o la llamada
    return {
      decision: 'REASK',
      short: 'Reformula tu respuesta con m√°s precisi√≥n.',
      reason: 'THINKER_ESCALATION'
    };
  }
}
```
=== EOF: src\engine\eval-escalation.ts

===  src\engine\costs.ts
```typescript
// Configuraci√≥n de costos por modelo (en centavos por 1K tokens)
const COST_CONFIG = {
  cheap: 0.5,    // gpt-4o-mini
  embed: 0.1,    // text-embedding-3-small  
  thinker: 2.5   // o3-mini
};

// Estimaci√≥n de tokens por tipo de operaci√≥n
const TOKEN_ESTIMATES = {
  response: 150,    // Respuesta t√≠pica
  embedding: 50,    // Embedding de texto
  escalation: 200   // Escalaci√≥n con razonamiento
};

export type CostTier = 'cheap' | 'embed' | 'thinker';

export class BudgetManager {
  private budgetCentsLeft: number;
  private usageByTier: Record<CostTier, number> = {
    cheap: 0,
    embed: 0,
    thinker: 0
  };

  constructor(initialBudgetCents: number = 100) {
    this.budgetCentsLeft = initialBudgetCents;
  }

  // Verificar si se puede usar un tier espec√≠fico
  canUseTier(tier: CostTier): boolean {
    const estimatedCost = this.estimateCost(tier);
    return this.budgetCentsLeft >= estimatedCost;
  }

  // Registrar uso y actualizar presupuesto
  recordUsage(tier: CostTier, actualTokens?: number): number {
    const tokens = actualTokens || TOKEN_ESTIMATES[tier === 'embed' ? 'embedding' : 'response'];
    const cost = (tokens / 1000) * COST_CONFIG[tier];
    
    this.usageByTier[tier] += tokens;
    this.budgetCentsLeft = Math.max(0, this.budgetCentsLeft - cost);
    
    return cost;
  }

  // Estimaci√≥n de costo para una operaci√≥n
  private estimateCost(tier: CostTier): number {
    const tokens = TOKEN_ESTIMATES[tier === 'embed' ? 'embedding' : 'response'];
    return (tokens / 1000) * COST_CONFIG[tier];
  }

  // Obtener m√©tricas de uso
  getUsageMetrics() {
    return {
      budgetCentsLeft: this.budgetCentsLeft,
      usageByTier: { ...this.usageByTier },
      totalCost: 100 - this.budgetCentsLeft,
      canEscalate: this.canUseTier('thinker')
    };
  }

  // Verificar si se puede escalar (thinker)
  canEscalate(): boolean {
    return this.canUseTier('thinker') && this.budgetCentsLeft > 10;
  }

  // Forzar modo econ√≥mico (solo cheap)
  forceCheapMode(): boolean {
    return this.budgetCentsLeft < 5;
  }
}

// Instancia global del gestor de presupuesto
let globalBudgetManager: BudgetManager | null = null;

export function getBudgetManager(): BudgetManager {
  if (!globalBudgetManager) {
    globalBudgetManager = new BudgetManager();
  }
  return globalBudgetManager;
}

export function resetBudgetManager(budgetCents: number = 100): BudgetManager {
  globalBudgetManager = new BudgetManager(budgetCents);
  return globalBudgetManager;
}

// Wrapper para pickModel que respeta el presupuesto
export function pickModelWithBudget(tier: CostTier): string {
  const budgetManager = getBudgetManager();
  
  // Si no hay presupuesto para el tier solicitado, degradar
  if (!budgetManager.canUseTier(tier)) {
    if (tier === 'thinker') return process.env.CHEAP_MODEL || 'gpt-4o-mini';
    if (tier === 'embed') return process.env.CHEAP_MODEL || 'gpt-4o-mini';
    return process.env.CHEAP_MODEL || 'gpt-4o-mini';
  }
  
  // Usar el modelo original
  if (tier === 'thinker') return process.env.THINKER_MODEL || 'o3-mini';
  if (tier === 'embed') return process.env.EMBED_MODEL || 'text-embedding-3-small';
  return process.env.CHEAP_MODEL || 'gpt-4o-mini';
}
```
=== EOF: src\engine\costs.ts

===  src\engine\clarify.ts
```typescript
export type ClassificationKind = 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS' | string;

export function shouldClarifyQuestion(opts: {
  isVague: boolean;
  isNo: boolean;
  classificationKind: ClassificationKind;
  studentAsking: boolean;
}): boolean {
  const { isVague, isNo, classificationKind, studentAsking } = opts;
  return !isVague && !isNo && classificationKind !== 'HINT' && Boolean(studentAsking);
}

export function shouldGateByMinTokens(text: string, minTokens: number = 3): boolean {
  const raw = String(text || '').trim();
  if (!raw) return true;
  const tokens = raw.split(/\s+/).filter(Boolean);
  return tokens.length < Math.max(1, Math.floor(minTokens));
}

export function isNoSeInput(text?: string): boolean {
  const t = String(text || '').trim();
  if (!t) return true;
  return /^(no\s*(lo\s*)?s[e√©]|no\s*est[o√≥]y?\s*seguro|no\s*s[e√©]\s*bien)$/i.test(t);
}


```
=== EOF: src\engine\clarify.ts

===  src\engine\advance.ts
```typescript
export function shouldAdvanceOnPartial({ cls, teacherProfile, stepData }: any) {
  const tp = teacherProfile || {};
  const thr = (stepData && (stepData as any).partial_thresholds) || tp?.advance?.partial?.thresholds || {};
  const minMatched = Number((thr as any).minMatched ?? 2);
  const maxMissing = Number((thr as any).maxMissing ?? 1);
  const minSem = Number((thr as any).minSem ?? 0.55);
  const matched = Array.isArray(cls?.matched) ? cls.matched.length : Number(cls?.matched || 0);
  const missing = Array.isArray(cls?.missing) ? cls.missing.length : Number(cls?.missing || 0);
  // Permitir que cls.sem sea un n√∫mero o un objeto { cos }
  const sem = typeof cls?.sem === 'number' ? Number(cls.sem) : Number(cls?.sem?.cos || 0);
  return tp?.advance?.partial?.enabled === true &&
    ((matched >= minMatched && missing <= maxMissing) || (sem >= minSem));
}

export function shouldForceAdvance({ attempts, teacherProfile }: any) {
  const tp = teacherProfile || {};
  const enabled = tp?.advance?.force?.enabled === true;
  const after = Number(tp?.advance?.force?.afterAttempts ?? 3);
  return Boolean(enabled && attempts >= after);
}


```
=== EOF: src\engine\advance.ts

===  src\components\VoiceRecorder.tsx
```tsx
'use client';
import { Mic } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

export default function VoiceRecorder({ onResult, language = 'es' }: { onResult: (text: string) => void; language?: string }) {
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const [recording, setRecording] = useState(false);
  const [supported, setSupported] = useState(true);

  useEffect(() => {
    if (!navigator.mediaDevices || typeof window === 'undefined' || !(window as any).MediaRecorder) {
      setSupported(false);
    }
  }, []);

  const start = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mr = new MediaRecorder(stream);
      mediaRecorderRef.current = mr;
      chunksRef.current = [];
      mr.ondataavailable = e => { if (e.data && e.data.size > 0) chunksRef.current.push(e.data); };
      mr.onstop = async () => {
        try {
          const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
          const form = new FormData();
          form.append('audio', blob, 'audio.webm');
          form.append('language', language);
          const res = await fetch('/api/audio/transcribe', { method: 'POST', body: form });
          const data = await res.json();
          if (data?.text) onResult(data.text);
        } catch {}
      };
      mr.start();
      setRecording(true);
    } catch {
      setSupported(false);
    }
  };

  const stop = () => {
    const mr = mediaRecorderRef.current;
    if (mr && mr.state !== 'inactive') {
      mr.stop();
      setRecording(false);
    }
  };

  if (!supported) return null;

  return (
    <button
      onClick={() => (recording ? stop() : start())}
      className={`rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg ${
        recording ? 'bg-gradient-to-r from-rose-600 to-red-600 text-white p-3' : 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white p-3'
      }`}
      title={recording ? 'Detener dictado' : 'Dictar con voz'}
      aria-label={recording ? 'Detener dictado' : 'Dictar con voz'}
      type="button"
    >
      <Mic className="w-5 h-5" />
    </button>
  );
}


```
=== EOF: src\components\VoiceRecorder.tsx

===  src\components\FeedbackSequential.tsx
```tsx
"use client";
import { classifyTurn, isNoSe } from "@/engine/eval";
import { buildTraceEntry, computeFeedbackLabel } from "@/engine/feedbackSequencer";
import { makeHintMessage, makeReaskMessage } from "@/engine/hints";
import { DEFAULT_TEACHER_PROFILE } from "@/teacher/defaultProfile";
import FeedbackSequentialInjected, { type FeedbackSequentialInjectedProps } from "./FeedbackSequential.deps-injected";

export type AttemptOutcome = {
  label: "F0" | "F1" | "F2";
  kind: "HINT" | "PARTIAL" | "ACCEPT" | "REFOCUS";
  feedback: string;
  scoreDelta: 0 | 1 | 2;
};

export type FeedbackSequentialProps = Omit<FeedbackSequentialInjectedProps, "overrides"> & {
  teacherProfile?: any;
};

export default function FeedbackSequential(props: FeedbackSequentialProps) {
  const teacher = props.teacherProfile || DEFAULT_TEACHER_PROFILE;

  const overrides: NonNullable<FeedbackSequentialInjectedProps["overrides"]> = {
    maxAttempts: 3,
    isEmpty: (answer: string) => !String(answer || "").trim() || isNoSe(answer),
    evaluate: (answer, ctx) => {
      const res = classifyTurn(
        answer,
        { type: ctx.policyType as any },
        ctx.acceptable,
        ctx.expected,
        { maxEditDistance: 1, similarityMin: 0.35 }
      );
      return { kind: res.kind as any, matched: res.matched || [], missing: res.missing || [], reason: res.reason };
    },
    label: (kind, attempt) => computeFeedbackLabel(kind, attempt),
    makeHint: (opts) => makeHintMessage({
      questionText: opts.questionText,
      objective: opts.objective,
      expected: opts.expected,
      missing: opts.missing,
      answerType: props.answerType as any,
      hintsUsed: opts.hintsUsed,
      attempts: opts.attempts,
      coursePolicies: undefined,
      teacherProfile: teacher,
    }),
    makeReask: (opts) => makeReaskMessage({
      questionText: opts.questionText,
      objective: opts.objective,
      expected: opts.expected,
      answerType: props.answerType as any,
      coursePolicies: undefined,
      teacherProfile: teacher,
    }),
    buildTrace: (args) => buildTraceEntry(args as any),
    scorePolicy: ({ attempts, lastKind, hintsUsed, acceptedAt, exhausted, hadPartial }) => {
      if (lastKind === "ACCEPT") return { status: "cumplida", score: 2 } as const;
      if (exhausted) {
        if (hadPartial) return { status: props.finalExplanation ? "force_advance" : "pendiente", score: 1 } as const;
        return { status: props.finalExplanation ? "force_advance" : "pendiente", score: 0 } as const;
      }
      return { status: "pendiente", score: 0 } as const;
    },
  };

  return <FeedbackSequentialInjected {...props} overrides={overrides} teacherProfile={teacher} />;
}


```
=== EOF: src\components\FeedbackSequential.tsx

===  src\components\FeedbackSequential.deps-injected.tsx
```tsx
"use client";
import { useCallback, useMemo, useState } from "react";

// Tipos compartidos entre versiones
export type AttemptOutcome = {
  label: "F0" | "F1" | "F2";
  kind: "HINT" | "PARTIAL" | "ACCEPT" | "REFOCUS";
  feedback: string;
  scoreDelta: 0 | 1 | 2;
};

export type FeedbackSequentialInjectedProps = {
  code?: string;
  prompts: [string, string, string];
  objective: string;
  acceptable: string[];
  expected?: string[];
  answerType?: "open" | "list" | "definition" | "procedure" | "choice";
  finalExplanation?: string;
  teacherProfile?: any;
  onComplete?: (result: {
    status: "cumplida" | "pendiente" | "force_advance";
    score: 0 | 1 | 2;
    hints: number;
    attempts: number;
    trace: Array<any>;
  }) => void;
  uiText?: {
    inputPlaceholder?: string;
    sendLabel?: string;
  };
  overrides?: {
    maxAttempts?: number;
    isEmpty?: (answer: string) => boolean;
    evaluate?: (
      answer: string,
      ctx: {
        policyType: string;
        acceptable: string[];
        expected: string[];
        answerType: FeedbackSequentialInjectedProps["answerType"];
        hintsUsed: number;
        attempt: number;
      }
    ) => { kind: "HINT" | "PARTIAL" | "ACCEPT" | "REFOCUS"; matched: string[]; missing: string[]; reason?: string };
    label?: (kind: AttemptOutcome["kind"], attempt: number) => AttemptOutcome["label"];
    makeHint?: (opts: {
      questionText: string;
      objective: string;
      expected: string[];
      missing: string[];
      answerType?: FeedbackSequentialInjectedProps["answerType"];
      hintsUsed: number;
      attempts: number;
      teacherProfile?: any;
    }) => string;
    makeReask?: (opts: {
      questionText: string;
      objective: string;
      expected: string[];
      answerType?: FeedbackSequentialInjectedProps["answerType"];
      teacherProfile?: any;
    }) => string;
    buildTrace?: (args: {
      question: string;
      response: string;
      feedback: string;
      kind: AttemptOutcome["kind"];
      attempt: number;
      hintsUsed?: number;
      stepCode?: string;
    }) => any;
    scorePolicy?: (args: {
      attempts: number;
      lastKind: AttemptOutcome["kind"];
      hintsUsed: number;
      acceptedAt?: number | null;
      exhausted: boolean;
      hadPartial?: boolean;
    }) => { status: "cumplida" | "pendiente" | "force_advance"; score: 0 | 1 | 2 };
  };
};

function usePolicyType(answerType?: FeedbackSequentialInjectedProps["answerType"]) {
  // Map flexible, se puede sobreescribir desde overrides.evaluate
  return useMemo(() => {
    switch (answerType) {
      case "list":
        return "listado";
      case "procedure":
        return "aplicacion";
      case "choice":
        return "identificacion";
      case "definition":
      case "open":
      default:
        return "conceptual";
    }
  }, [answerType]);
}

export default function FeedbackSequentialInjected(props: FeedbackSequentialInjectedProps) {
  const {
    code = "",
    prompts,
    objective,
    acceptable,
    expected = [],
    answerType = "list",
    finalExplanation,
    teacherProfile,
    onComplete,
    uiText,
    overrides,
  } = props;

  const policyType = usePolicyType(answerType);
  const maxAttempts = overrides?.maxAttempts ?? 3;
  const [attempt, setAttempt] = useState<number>(0);
  const [input, setInput] = useState<string>("");
  const [hintsUsed, setHintsUsed] = useState<number>(0);
  const [trace, setTrace] = useState<any[]>([]);
  const [done, setDone] = useState<boolean>(false);
  const [outcomes, setOutcomes] = useState<AttemptOutcome[]>([]);

  const currentQuestion = prompts[Math.min(attempt, prompts.length - 1)] || "";

  const buildFeedbackText = useCallback((kind: AttemptOutcome["kind"], ctx: { missing: string[]; matched: string[] }) => {
    // HINT/REFOCUS ‚Üí usar generadores; PARTIAL ‚Üí gu√≠a + reask; ACCEPT ‚Üí reforzar con matched (si hay)
    if (kind === "HINT" || kind === "REFOCUS") {
      const hintMsg = overrides?.makeHint?.({
        questionText: currentQuestion,
        objective,
        expected,
        missing: ctx.missing,
        answerType,
        hintsUsed,
        attempts: attempt,
        teacherProfile,
      }) || "";
      const reask = overrides?.makeReask?.({
        questionText: currentQuestion,
        objective,
        expected,
        answerType,
        teacherProfile,
      }) || "";
      return [hintMsg, reask].filter(Boolean).join(" ").trim();
    }
    if (kind === "PARTIAL") {
      const reask = overrides?.makeReask?.({
        questionText: currentQuestion,
        objective,
        expected,
        answerType,
        teacherProfile,
      }) || "";
      // Mensaje centrado en completar elementos faltantes, evitando cadenas est√°ticas
      const dynamicSuffix = ctx.missing.length ? ctx.missing.join(", ") : "";
      return [reask, dynamicSuffix].filter(Boolean).join(" ¬∑ ").trim();
    }
    // ACCEPT ‚Üí sin reask; devolver se√±ales/matched como refuerzo m√≠nimo
    return (ctx.matched || []).join(", ");
  }, [answerType, attempt, currentQuestion, expected, objective, overrides, teacherProfile, hintsUsed]);

  const handleSend = useCallback(() => {
    if (done) return;
    const value = String(input || "").trim();
    if (!value) {
      // vac√≠o expl√≠cito ‚Üí HINT
      const kind: AttemptOutcome["kind"] = "HINT";
      const label = overrides?.label ? overrides.label(kind, attempt) : ("F0" as AttemptOutcome["label"]);
      const feedback = buildFeedbackText(kind, { matched: [], missing: acceptable.slice(0, 3) });
      const outcome: AttemptOutcome = { label, kind, feedback, scoreDelta: 0 };
      setOutcomes(prev => [...prev, outcome]);
      setHintsUsed(h => h + 1);
      const t = overrides?.buildTrace?.({
        question: currentQuestion,
        response: value,
        feedback,
        kind,
        attempt,
        hintsUsed,
        stepCode: code,
      });
      if (t) setTrace(prev => [...prev, t]);
      setAttempt(a => a + 1);
      setInput("");
      return;
    }

    const res = overrides?.evaluate?.(value, {
      policyType,
      acceptable,
      expected,
      answerType,
      hintsUsed,
      attempt,
    }) || { kind: "HINT" as const, matched: [], missing: acceptable.slice(0, 3) };

    const label = overrides?.label ? overrides.label(res.kind, attempt) : ("F2" as AttemptOutcome["label"]);
    const feedback = buildFeedbackText(res.kind, { matched: res.matched || [], missing: res.missing || [] });
    const outcome: AttemptOutcome = {
      label,
      kind: res.kind,
      feedback,
      scoreDelta: res.kind === "ACCEPT" ? 2 : res.kind === "PARTIAL" ? 1 : 0,
    };
    setOutcomes(prev => [...prev, outcome]);
    if (res.kind === "HINT" || res.kind === "REFOCUS") setHintsUsed(h => h + 1);

    const t = overrides?.buildTrace?.({
      question: currentQuestion,
      response: value,
      feedback,
      kind: res.kind,
      attempt,
      hintsUsed,
      stepCode: code,
    });
    if (t) setTrace(prev => [...prev, t]);

    const nextAttempt = attempt + 1;
    const exhausted = nextAttempt >= maxAttempts;
    const accepted = res.kind === "ACCEPT";

    if (accepted || exhausted) {
      const hadPartial = (!accepted && outcomes.some(o => o.kind === "PARTIAL")) || res.kind === "PARTIAL";
      const decision = overrides?.scorePolicy?.({
        attempts: nextAttempt,
        lastKind: res.kind,
        hintsUsed: hintsUsed + (res.kind === "HINT" || res.kind === "REFOCUS" ? 1 : 0),
        acceptedAt: accepted ? nextAttempt : null,
        exhausted,
        hadPartial,
      }) || { status: accepted ? "cumplida" : (finalExplanation ? "force_advance" : "pendiente"), score: accepted ? 2 : (hadPartial ? 1 : 0) };

      // En caso de fuerza de avance con explicaci√≥n final, registrar una √∫ltima entrada F2 sin respuesta
      let extraTrace: any | null = null;
      if (!accepted && exhausted && finalExplanation) {
        const fk: AttemptOutcome["kind"] = "REFOCUS";
        const flabel = overrides?.label ? overrides.label(fk, nextAttempt) : ("F2" as AttemptOutcome["label"]);
        const extraOutcome: AttemptOutcome = { label: flabel, kind: fk, feedback: finalExplanation, scoreDelta: 0 };
        setOutcomes(prev => [...prev, extraOutcome]);
        const te = overrides?.buildTrace?.({
          question: currentQuestion,
          response: "",
          feedback: finalExplanation,
          kind: fk,
          attempt: nextAttempt,
          hintsUsed: hintsUsed,
          stepCode: code,
        });
        if (te) { setTrace(prev => [...prev, te]); extraTrace = te; }
      }

      setDone(true);
      // Ensamblar traza final localmente para no depender del setState as√≠ncrono
      const finalTrace = [
        ...trace,
        ...(t ? [t] : []),
        ...(extraTrace ? [extraTrace] : []),
      ];
      onComplete?.({
        status: decision.status,
        score: decision.score as 0 | 1 | 2,
        hints: hintsUsed + (res.kind === "HINT" || res.kind === "REFOCUS" ? 1 : 0),
        attempts: nextAttempt,
        trace: finalTrace,
      });
    } else {
      setAttempt(nextAttempt);
    }
    setInput("");
  }, [acceptable, expected, answerType, attempt, buildFeedbackText, code, currentQuestion, done, finalExplanation, hintsUsed, maxAttempts, objective, onComplete, overrides, policyType, input, trace, outcomes]);

  // UI m√≠nima (tailwind), sin textos fijos: usa uiText cuando aplique
  return (
    <div className="w-full">
      <div className="space-y-3">
        <div className="text-sm text-slate-700">
          <span className="font-medium">{code ? `${code} ¬∑ ` : ""}</span>
          <span>{currentQuestion}</span>
        </div>

        <div className="space-y-2">
          {outcomes.map((o, idx) => (
            <div key={idx} className="border rounded-lg p-2 text-sm">
              <div className="flex items-center justify-between">
                <span className="font-semibold">{o.label}</span>
                <span className="text-xs uppercase tracking-wide text-slate-500">{o.kind}</span>
              </div>
              {o.feedback ? (
                <div className="mt-1 text-slate-800 whitespace-pre-wrap">{o.feedback}</div>
              ) : null}
            </div>
          ))}
        </div>

        <div className="flex gap-2 items-center">
          <input
            className="flex-1 border rounded-lg px-3 py-2 text-sm"
            placeholder={uiText?.inputPlaceholder || ""}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            disabled={done}
          />
          <button
            className="px-3 py-2 text-sm rounded-lg bg-blue-600 text-white disabled:opacity-50"
            onClick={handleSend}
            disabled={done}
          >
            {uiText?.sendLabel || "‚Üí"}
          </button>
        </div>
      </div>
    </div>
  );
}


```
=== EOF: src\components\FeedbackSequential.deps-injected.tsx

===  src\components\EngineChatLayout.tsx
```tsx
'use client';
// Legacy layout: remove tight coupling with legacy core types
type LessonVM = any;
type EngineState = any;
import { Clock, Menu, Send, User, X } from 'lucide-react';
import Image from 'next/image';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import VoiceRecorder from './VoiceRecorder';

export type EngineChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

export default function EngineChatLayout({
  messages,
  isTyping,
  onSend,
  vm,
  state
}: {
  messages: EngineChatMessage[];
  isTyping: boolean;
  onSend: (text: string) => void;
  vm: LessonVM | null;
  state: EngineState | null;
}) {
  const [inputValue, setInputValue] = useState('');
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [previewSrc, setPreviewSrc] = useState<string | null>(null);
  const stickRef = useRef<boolean>(true);
  const [mediaIdx, setMediaIdx] = useState<number>(0);

  const mediaImages: string[] = useMemo(() => {
    try {
      const stepCode: string | undefined = (state as any)?.stepCode || (state as any)?.state?.stepCode;
      const images = (vm as any)?.media?.[stepCode || '']?.images;
      return Array.isArray(images) ? images.filter(Boolean) : [];
    } catch { return []; }
  }, [vm, state]);

  useEffect(() => { setMediaIdx(0); }, [mediaImages?.length]);

  useEffect(() => {
    if (stickRef.current) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, isTyping]);

  const onMessagesScroll = (e: React.UIEvent<HTMLDivElement>) => {
    try {
      const el = e.currentTarget;
      const distanceFromBottom = el.scrollHeight - el.scrollTop - el.clientHeight;
      stickRef.current = distanceFromBottom < 120; // pegarse al fondo salvo que el usuario suba
    } catch { stickRef.current = true; }
  };

  const handleSend = () => {
    if (!inputValue.trim()) return;
    onSend(inputValue);
    setInputValue('');
  };

  const handleKey = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }
  };

  return (
    <div className="min-h-screen bg-slate-100">
      {/* Header */}
      <header className="bg-white border-b border-slate-200 px-4 md:px-6 py-3 md:py-4 sticky top-0 z-40">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="bg-gradient-to-br from-blue-600 to-indigo-600 p-2.5 rounded-xl shadow-lg" />
            <div>
              <h1 className="text-lg md:text-xl font-bold text-slate-900">{vm?.title || 'DocenteIA'}</h1>
              <p className="text-xs md:text-sm text-slate-600">Versi√≥n {vm?.version} ¬∑ {vm?.locale}</p>
            </div>
          </div>
          <button onClick={() => setSidebarOpen(!sidebarOpen)} className="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 transition-colors">
            {sidebarOpen ? <X className="w-5 h-5" /> : <Menu className="w-5 h-5" />}
          </button>
        </div>
      </header>

      <div className="flex h-[calc(100vh-72px)] max-w-screen-2xl mx-auto">
        {/* Left side: Panel informativo (Aprendizaje esperado, Puntos clave y Progreso) */}
        <div className={`hidden lg:block transition-all duration-300 pl-3 ${sidebarOpen ? 'lg:basis-[22%] xl:basis-[22%] opacity-100' : 'lg:basis-0 opacity-0 pointer-events-none'} min-w-[240px]`}>
          <div className={`h-full m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col bg-white transition-all duration-300 ${sidebarOpen ? 'scale-100' : 'scale-95'}`}>
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="font-semibold text-slate-900 flex items-center gap-2">
                <span className="inline-block w-2 h-2 rounded-full bg-blue-600" />
                Resumen de la sesi√≥n
              </h3>
            </div>
            <div className="p-6 space-y-4 overflow-y-auto">
              {vm && state && (
                <>
                  {Array.isArray(vm.expectedLearning) && vm.expectedLearning.length > 0 && (
                    <div>
                      <h4 className="text-xs font-medium text-slate-700 mb-2 flex items-center gap-2">
                        <span className="inline-block w-1.5 h-1.5 rounded-full bg-blue-500" />
                        Aprendizaje esperado
                      </h4>
                      <div className="space-y-2">
                        {vm.expectedLearning.map((it: string, i: number) => (
                          <div key={`el-${i}`} className="text-xs text-slate-800 bg-gradient-to-br from-blue-50 to-indigo-50 border border-blue-100 rounded-lg px-3 py-2">
                            {it}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  <div>
                    {vm.keyPoints && vm.keyPoints.length > 0 && (
                      <div>
                        <h4 className="text-xs font-medium text-slate-700 mb-2 flex items-center gap-2">
                          <span className="inline-block w-1.5 h-1.5 rounded-full bg-blue-500" />
                          Puntos clave
                        </h4>
                        <div className="space-y-2">
                          {vm.keyPoints.map((kp: any) => (
                            <div key={kp.id} className={`p-3 rounded-lg border ${kp.completed ? 'bg-gradient-to-br from-green-50 to-green-100 border-green-200' : 'bg-gradient-to-br from-blue-50 to-indigo-50 border-blue-100'}`}>
                              <div className="text-xs font-medium text-slate-800">{kp.title}</div>
                              {kp.description && <div className="text-[11px] text-slate-600 mt-1">{kp.description}</div>}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                  <div className="pt-2 border-t border-slate-200">
                    <div className="flex justify-between text-sm mb-1">
                      <span className="text-slate-600">Momento</span>
                      <span className="font-medium text-slate-900">{vm.moments.length > 0 ? Math.min(state.momentIdx + 1, vm.moments.length) : 0}/{vm.moments.length}</span>
                    </div>
                    <div className="w-full bg-slate-100 rounded-full h-2">
                      <div className="bg-gradient-to-r from-blue-600 to-indigo-600 h-2 rounded-full transition-all" style={{ width: `${Math.round(((vm.moments.length > 0 ? Math.min(state.momentIdx + 1, vm.moments.length) : 0) / Math.max(1, vm.moments.length)) * 100)}%` }} />
                    </div>
                    <div className="mt-3">
                      <h4 className="text-xs font-medium text-slate-700 mb-2">Momentos</h4>
                      <div className="space-y-2">
                        {vm.moments.map((m: any, i: number) => (
                          <div key={`${m.title}-${i}`} className={`flex items-center gap-2 text-xs ${i < state.momentIdx ? 'text-green-700' : (i === state.momentIdx ? 'text-blue-700' : 'text-slate-500')}`}>
                            <span className={`w-2 h-2 rounded-full ${i < state.momentIdx ? 'bg-green-600' : (i === state.momentIdx ? 'bg-blue-600' : 'bg-slate-300')}`} />
                            <span className="truncate">{m.title}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </>
              )}
            </div>
          </div>
        </div>

        {/* Main chat (centro, m√°s ancho que multimedia) */}
        <div className={`transition-all duration-300 w-full flex-1 min-w-[420px]`}>
          <div className="h-full bg-white m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-6 space-y-6" onScroll={onMessagesScroll}>
              {messages.map((m) => (
                <div key={m.id} className={`flex items-start space-x-4 ${m.sender === 'student' ? 'flex-row-reverse space-x-reverse' : ''}`}>
                  {m.sender === 'ai' ? (
                    <button
                      type="button"
                      className="w-10 h-10 rounded-full overflow-hidden ring-2 ring-blue-500 shadow-md bg-white flex items-center justify-center cursor-pointer"
                      onClick={() => vm?.avatarUrl && setPreviewSrc(vm.avatarUrl)}
                      aria-label="Ver foto de la instructora"
                    >
                      {vm?.avatarUrl ? (
                        <Image src={vm.avatarUrl} alt="Instructora" width={40} height={40} className="object-cover w-10 h-10" />
                      ) : (
                        <div className="w-10 h-10 flex items-center justify-center text-sm font-semibold bg-gradient-to-br from-blue-600 to-indigo-600 text-white">AI</div>
                      )}
                    </button>
                  ) : (
                    <div className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold shadow-md bg-gradient-to-br from-slate-600 to-slate-700 text-white">
                      <User className="w-5 h-5" />
                    </div>
                  )}
                  <div className={`flex-1 ${m.sender === 'student' ? 'text-right' : ''}`}>
                    <div className={`inline-block px-5 py-3 rounded-2xl shadow-sm max-w-[70ch] ${m.sender === 'student' ? 'bg-gradient-to-r from-blue-600 to-blue-700 text-white' : 'bg-white border border-slate-200 text-slate-900'}`}>
                      <p className="text-sm leading-relaxed whitespace-pre-wrap">{m.content}</p>
                    </div>
                    <div className={`mt-2 flex items-center space-x-2 ${m.sender === 'student' ? 'justify-end' : 'justify-start'}`}>
                      <Clock className="w-3 h-3 text-slate-400" />
                      <span className="text-xs text-slate-500">{m.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    </div>
                  </div>
                </div>
              ))}
              {isTyping && (
                <div className="flex items-start space-x-4">
                  <button
                    type="button"
                    className="w-10 h-10 rounded-full overflow-hidden ring-2 ring-blue-500 shadow-md bg-white flex items-center justify-center cursor-pointer"
                    onClick={() => vm?.avatarUrl && setPreviewSrc(vm.avatarUrl)}
                    aria-label="Ver foto de la instructora"
                  >
                    {vm?.avatarUrl ? (
                      <Image src={vm.avatarUrl} alt="Instructora" width={40} height={40} className="object-cover w-10 h-10" />
                    ) : (
                      <div className="w-10 h-10 flex items-center justify-center text-sm font-semibold bg-gradient-to-br from-blue-600 to-indigo-600 text-white">AI</div>
                    )}
                  </button>
                  <div className="inline-flex items-center gap-1 bg-white border border-slate-200 text-slate-500 px-3 py-2 rounded-2xl">
                    <span className="sr-only">Escribiendo‚Ä¶</span>
                    <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.2s]"></span>
                    <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.1s]"></span>
                    <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce"></span>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <div className="px-6 py-3 border-t border-slate-200 bg-slate-50 rounded-b-2xl">
              <div className="flex items-end space-x-2">
                <textarea
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKey}
                  placeholder="Escribe tu respuesta..."
                  rows={1}
                  className="flex-1 w-full px-4 py-3 bg-white border border-slate-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  style={{ minHeight: '48px', maxHeight: '120px' }}
                />
                <VoiceRecorder onResult={(t)=>setInputValue((v)=> (v ? (v+ ' ' + t) : t))} />
                <button onClick={handleSend} disabled={!inputValue.trim()} className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-slate-300 disabled:to-slate-400 text-white p-3 rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg disabled:shadow-none">
                  <Send className="w-5 h-5" />
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Right side: Contenido Multimedia */}
        <div className={`hidden lg:block transition-all duration-300 ${sidebarOpen ? 'lg:basis-[42%] xl:basis-[44%]' : 'lg:basis-[42%] xl:basis-[44%]'} min-w-[360px]`}>
          <div className="h-full bg-white m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="font-semibold text-slate-900">Contenido Multimedia</h3>
            </div>
            <div className="flex-1 p-6">
              {isTyping || !mediaImages?.length ? (
                <div className="bg-gradient-to-br from-slate-100 to-slate-200 rounded-xl text-slate-400 border border-slate-200 flex items-center justify-center aspect-video min-h-[180px]">
                  <span className="text-xs">{isTyping ? 'Pensando‚Ä¶' : 'Sin contenido para este paso'}</span>
                </div>
              ) : (
                <>
                  <div className="relative rounded-xl overflow-hidden border border-slate-200 aspect-video bg-black/5">
                    <Image
                      src={mediaImages[Math.min(mediaIdx, mediaImages.length - 1)]}
                      alt="Paso"
                      fill
                      sizes="(min-width: 1024px) 33vw, 100vw"
                      className="object-cover"
                    />
                  </div>
                  {mediaImages.length > 1 && (
                    <div className="flex items-center gap-2 mt-3 justify-center">
                      {mediaImages.map((_, i) => (
                        <label key={`dot-${i}`} className="inline-flex items-center cursor-pointer">
                          <input
                            type="radio"
                            name="mediaIdx"
                            className="sr-only"
                            checked={mediaIdx === i}
                            onChange={() => setMediaIdx(i)}
                          />
                          <span className={`w-2.5 h-2.5 rounded-full ${mediaIdx === i ? 'bg-blue-600' : 'bg-slate-300'}`} />
                        </label>
                      ))}
                    </div>
                  )}
                </>
              )}
              <div className="mt-4 text-xs text-slate-600">Contenido multimedia de la sesi√≥n</div>
            </div>
          </div>
        </div>
      </div>
      {previewSrc && (
        <div
          className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4"
          onClick={() => setPreviewSrc(null)}
        >
          <div className="relative bg-white rounded-xl shadow-xl p-2" onClick={(e) => e.stopPropagation()}>
            <button
              type="button"
              className="absolute -top-3 -right-3 bg-white rounded-full shadow p-1 border"
              onClick={() => setPreviewSrc(null)}
              aria-label="Cerrar"
            >
              <X className="w-4 h-4" />
            </button>
            <Image
              src={previewSrc}
              alt="Instructora"
              width={640}
              height={640}
              className="max-h-[80vh] h-auto w-auto rounded-lg"
              priority
            />
          </div>
        </div>
      )}
    </div>
  );
}


```
=== EOF: src\components\EngineChatLayout.tsx

===  src\ai\prompt.ts
```typescript
export type DocenteAction = 'explain' | 'ask' | 'hint' | 'ok' | 'advance' | 'end' | 'ask_simple' | 'ask_options' | 'feedback';

export type DocentePromptContext = {
  language?: string;
  course?: { role?: string; tone?: string; style_guidelines?: string };
  action: DocenteAction;
  stepType: string;
  momentTitle?: string;
  objective?: string;
  contentBody?: string[];
  narrationText?: string;
  caseText?: string;
  questionText?: string;
  acceptable?: string[];
  userAnswer?: string;
  matched?: string[];
  missing?: string[];
  recentHistory?: string[];
  hintWordLimit?: number;
  simpleOptions?: string[];
  optionItems?: string[];
  kind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  closureCriteria?: string;
  allowQuestions?: boolean;
  // contexto pedag√≥gico para severidad de ayudas
  attempts?: number;
  hintsUsed?: number;
};

export function buildSystemPrompt(ctx: DocentePromptContext): string {
  const lang = ctx.language || 'es';
  const role = ctx.course?.role ? `Act√∫a como ${ctx.course.role}.` : '';
  const tone = ctx.course?.tone ? `Tono: ${ctx.course.tone}.` : '';
  const style = ctx.course?.style_guidelines ? `Gu√≠a de estilo: ${ctx.course.style_guidelines}.` : '';
  const rules = [
    `Eres un Docente IA uno-a-uno. Responde en ${lang}.`,
    role,
    tone,
    style,
    'Sigue estrictamente el paso actual del plan. No avances ni mezcles pasos.',
    'Nunca copies literal el JSON; reescribe con tus palabras. Evita vi√±etas/listas y par√°grafos largos.',
    'Preferentemente 2‚Äì3 frases por bloque; usar hasta 4‚Äì5 cuando el objetivo requiera retroalimentaci√≥n concreta. Lenguaje claro. No spoilers.',
    'Si el estudiante responde "no s√©" repetidamente, reduce dificultad seg√∫n la acci√≥n solicitada.',
    'Normaliza el error y la duda: valida el esfuerzo y anima a continuar antes de orientar.',
    'Al interpretar la respuesta del estudiante, considera equivalencias sem√°nticas razonables (t√©rminos extremos/coloquiales ‚âà categor√≠as profesionales) y reencuadra con lenguaje t√©cnico sin a√±adir conceptos fuera del objetivo/contenido.',
    'Mant√©n continuidad con el √∫ltimo turno: si ya respondi√≥, no repitas la misma pregunta; contin√∫a dentro del paso seg√∫n el plan.',
    'Evita repetir el mismo ejemplo en turnos consecutivos; var√≠alo o ad√°ptalo al contexto de la respuesta.',
    'No repitas exactamente la misma idea en dos turnos seguidos; a√±ade un matiz o detalle nuevo.',
    'Solo avanza cuando se cumpla el criterio de cierre del paso actual (si aplica).',
    'En acciones ask, hint, feedback, ask_simple y ask_options no re-narres el caso ni describas la situaci√≥n inicial; si fuera imprescindible, referencia en UNA sola frase sin repetir detalles. Reserva la narraci√≥n extensa solo para explain.',
    // Principios para repreguntas y pistas (aplican a cualquier curso; √©nfasis en primera clase)
    'Principios de repreguntas y pistas (especialmente en la primera clase):',
    '‚Ä¢ Criterio de gradualidad cognitiva: cada repregunta baja UN nivel de complejidad respecto a la anterior; construye una escalera descendente hasta que el estudiante conecta.',
    '‚Ä¢ Criterio de andamiaje progresivo: cada pista aporta la m√≠nima ayuda necesaria para habilitar el siguiente paso; evita resolver el problema por completo.',
    '‚Ä¢ Criterio de conexi√≥n experiencial: parte de lo que el estudiante ya conoce o vivi√≥; ve de lo familiar a lo desconocido.',
    '‚Ä¢ Criterio de preservaci√≥n del desaf√≠o: mant√©n activo el esfuerzo cognitivo; evita pistas tan directas que eliminen la necesidad de pensar.',
    '‚Ä¢ Criterio de diagn√≥stico continuo: usa cada repregunta para revelar qu√© elemento espec√≠fico no comprende, y adapta la siguiente intervenci√≥n.',
    '‚Ä¢ Criterio de construcci√≥n sem√°ntica: introduce gradualmente vocabulario y conceptos de la disciplina sobre bases comprensibles.',
    '‚Ä¢ Criterio de econom√≠a pedag√≥gica: usa la menor cantidad de informaci√≥n adicional posible en cada pista, maximizando el aprendizaje autogenerado.'
  ].filter(Boolean).join(' ');
  return rules;
}

export function buildUserPrompt(ctx: DocentePromptContext): string {
  const lines: string[] = [];

  // Helpers
  const pushIf = (cond: any, s: string) => { if (cond) lines.push(s.trim()); };
  const hasAny = (...vals: Array<string | string[] | undefined | null>) =>
    vals.some(v => Array.isArray(v) ? v.filter(Boolean).length > 0 : !!v);

  // Header
  pushIf(true, `Momento: ${ctx.momentTitle || ''}`); // permite vac√≠o pero mantiene etiqueta
  pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);

  // Normalizaciones
  const contentItems = Array.from(new Set((ctx.contentBody || [])
    .filter(Boolean)
    .map(s => String(s).trim())))
    .slice(0, 20);
  const safeAnswer = String(ctx.userAnswer || '').trim().slice(0, 300);
  const matched = Array.from(new Set(ctx.matched || [])).filter(Boolean).slice(0, 8);
  const missing = Array.from(new Set(ctx.missing || [])).filter(Boolean).slice(0, 8);
  const recent = (ctx.recentHistory || []).slice(-3).join(' | ');
  pushIf(recent, `Historial reciente: ${recent}`);
  pushIf(ctx.closureCriteria, `Criterio de cierre: ${ctx.closureCriteria}`);

  switch (ctx.action) {
    case 'explain': {
      if (!hasAny(ctx.narrationText, contentItems, ctx.caseText)) {
        lines.push('Faltan insumos para explicar (narraci√≥n, contenido o caso).');
      }
      const payload = [
        ctx.narrationText ? `Narraci√≥n: ${ctx.narrationText}` : '',
        contentItems.length ? `Contenido: ${contentItems.join(' | ')}` : '',
        ctx.caseText ? `Caso: ${ctx.caseText}` : ''
      ].filter(Boolean).join('\n');
      pushIf(payload, payload);
      lines.push('Tarea: explica con TUS PALABRAS el contenido en 2‚Äì3 frases, sin listas ni preguntas.');
      lines.push('Reglas: si ya se us√≥ este ejemplo, var√≠alo o ad√°ptalo; no avances si el criterio de cierre no se cumple.');
      break;
    }

    case 'ask': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      lines.push('Tarea: enmarca brevemente y cierra con la PREGUNTA EXACTA tal cual. No a√±adas contenido nuevo.');
      lines.push('Reglas: si el estudiante ya respondi√≥ esta pregunta en el turno previo, no la repitas; produce una transici√≥n breve y contin√∫a dentro del paso sin avanzar al siguiente hasta cumplir el criterio de cierre. No re-narres el caso ni repitas la historia.');
      break;
    }

    case 'hint': {
      if (!ctx.questionText) lines.push('Falta la pregunta para la pista.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      pushIf(contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
      pushIf(safeAnswer, `Respuesta del estudiante: ${safeAnswer}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      const limit = ctx.hintWordLimit || 18;
      const att = Number(ctx.attempts || 0);
      const sev = att <= 0 ? 'S1' : (att === 1 ? 'S2' : 'S3');
      lines.push(
        `Tarea: primero escribe UNA sola micro‚Äëpregunta (‚â§8 palabras) centrada en el objetivo o el primer faltante, y en una l√≠nea aparte. ` +
        `Luego, escribe UNA pista (${limit} palabras aprox., sin signos de interrogaci√≥n) orientada al OBJETIVO (concreta, sin definiciones generales). Nunca devuelvas solo preguntas.`
      );
      lines.push('Formato de salida: EXACTAMENTE 2 l√≠neas; usa etiquetas:');
      lines.push('MICRO: <tu micro‚Äëpregunta (‚â§8 palabras)>');
      lines.push('PISTA: Te doy una pista: <1‚Äì2 keywords de Faltantes/Contenido y orientaci√≥n concreta>');
      // Vincular con los criterios pedag√≥gicos
      lines.push('Alinea ambas l√≠neas con los principios: gradualidad cognitiva, andamiaje progresivo, conexi√≥n experiencial, diagn√≥stico continuo, construcci√≥n sem√°ntica, econom√≠a pedag√≥gica y preservaci√≥n del desaf√≠o.');
      lines.push('MICRO debe apuntar al primer Faltante (diagn√≥stico), referenciar si procede algo del Historial reciente o del contexto del estudiante (conexi√≥n experiencial) y mantener el desaf√≠o (‚â§8 palabras, sin dar contenido nuevo).');
      lines.push(`PISTA debe ofrecer el apoyo m√≠nimo necesario (andamiaje) usando 1‚Äì2 keywords de Faltantes/Contenido (econom√≠a), sin revelar la respuesta (preservar desaf√≠o) y pudiendo introducir gradualmente 1 t√©rmino clave de la disciplina si aporta (construcci√≥n sem√°ntica). L√≠mite ‚âà ${limit} palabras.`);
      if (sev === 'S1') {
        lines.push('Severidad S1: pista neutral y breve; NO ofrecer opciones todav√≠a; micro‚Äëpregunta directa (‚â§8 palabras).');
      } else if (sev === 'S2') {
        lines.push('Severidad S2: facilita con OPCI√ìN: "elige 1" (usa Faltantes o Pistas de contenido), permite respuesta corta (8‚Äì12 palabras). Micro‚Äëpregunta ‚â§8 palabras.');
      } else {
        lines.push('Severidad S3: solicita formato ‚ÄúElemento ‚Üí funci√≥n‚Äù en UNA frase. Despu√©s, prepara transici√≥n breve si persiste la duda.');
      }
      lines.push('Reglas: empieza la pista con ‚ÄúTe doy una pista:‚Äù y, a continuaci√≥n, nombra 1‚Äì2 palabras clave tomadas de Faltantes o Pistas de contenido. Mant√©n tono cercano; evita definiciones generales y no re‚Äënarrar el caso. No repitas literalmente frases del contenido (por ejemplo, evita repetir ‚ÄúLos procedimientos de seguridad incluyen ‚Ä¶‚Äù). Evita repetir la misma micro‚Äëpregunta usada en el turno previo (usa Historial reciente). No dupliques frases dentro del mismo mensaje. No a√±adas l√≠neas extra ni encabezados.');
      break;
    }

    case 'ask_simple': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const opts = Array.from(new Set(ctx.simpleOptions || [])).filter(Boolean).slice(0, 5);
      if (opts.length) {
        lines.push(`Opciones (elige una): ${opts.join(' / ')}`);
      }
      lines.push('Tarea: formula la elecci√≥n de forma clara y breve. No re‚Äënarrar el caso.');
      break;
    }

    case 'ask_options': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const items = Array.from(new Set(ctx.optionItems || [])).filter(Boolean).slice(0, 5);
      if (items.length) {
        const labeled = items.map((s, i) => `${String.fromCharCode(65 + i)}) ${s}`);
        lines.push(`Opciones: ${labeled.join(' | ')}`);
      }
      lines.push('Tarea: pide que elija una opci√≥n (A, B, C, ‚Ä¶) y espera su selecci√≥n. No re‚Äënarrar el caso.');
      break;
    }

    case 'ok': {
      if (!ctx.questionText) lines.push('Falta la pregunta que se est√° validando.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      lines.push('Tarea: en 1‚Äì2 frases, reconoce lo correcto citando los aciertos y, si aplica, orienta brevemente lo que falta, sin preguntas. No introduzcas contenido nuevo.');
      break;
    }

    case 'advance': {
      lines.push('Tarea: puente corto al siguiente foco en ‚â§14 palabras.');
      lines.push('Formato de salida: EXACTAMENTE 1 l√≠nea:');
      lines.push('PUENTE: <tu puente breve>');
      break;
    }

    case 'end': {
      lines.push('Tarea: cierre final breve.');
      break;
    }

    case 'feedback': {
      const limit = ctx.hintWordLimit || 3; // n√∫mero de frases esperado, controlable por policies.feedback.maxSentences via caller
      const allowQ = ctx.allowQuestions !== false; // default: true
      pushIf(true, `Momento: ${ctx.momentTitle || ''}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.userAnswer, `Respuesta del estudiante: ${safeAnswer}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      pushIf(contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
      // Sem√°ntica para reencuadre sin hardcodeos
      const sem = [
        Array.isArray(ctx.acceptable) && ctx.acceptable.length ? `Aceptables: ${ctx.acceptable.join(' | ')}` : '',
        matched.length ? `Se√±ales presentes: ${matched.join(' | ')}` : '',
        missing.length ? `Se√±ales faltantes: ${missing.join(' | ')}` : ''
      ].filter(Boolean).join('\n');
      pushIf(sem, sem);
      const kind = (ctx.kind || 'HINT').toUpperCase();
      if (kind === 'ACCEPT') {
        lines.push(
          `Tarea (feedback: ACCEPT): escribe hasta ${limit} frases: ` +
          `1) empieza con una frase de refuerzo espec√≠fica citando 1‚Äì2 aciertos (usa Aciertos); ` +
          `2) si procede, orienta brevemente el siguiente foco` + (allowQ ? '' : `, sin preguntas`) + `, sin revelar respuestas. No re‚Äënarrar el caso.`
        );
      } else if (kind === 'PARTIAL') {
        lines.push(
          `Tarea (feedback: PARTIAL): escribe ${limit} frases: ` +
          `1) valida el esfuerzo y nombra lo correcto (usa Aciertos) sin repetir f√≥rmulas de √°nimo ya usadas; ` +
          `2) si el t√©rmino del estudiante es extremo/coloquial (p. ej., "se muere"), infiere su categor√≠a sem√°ntica pr√≥xima (p. ej., lesi√≥n grave por ca√≠da) y reencuadra con lenguaje profesional; ` +
          `orienta 1 faltante con una pista concreta alineada al objetivo/contenido (usa Faltantes y Pistas de contenido). ` +
          (allowQ ? '' : `No incluyas preguntas. `) + `Evita definiciones generales y no reveles soluciones completas.`
        );
      } else if (kind === 'REFOCUS') {
        lines.push(
          `Tarea (feedback: REFOCUS): escribe hasta ${limit} frases: ` +
          `1) ofrece √°nimo (sin repetirlo si ya fue expresado) y se√±ala con amabilidad el desv√≠o; ` +
          `2) redirige al criterio/objetivo central en forma concreta` + (allowQ ? '' : `, sin preguntas`) + `. No re‚Äënarrar el caso.`
        );
      } else {
        // HINT o evasiva
        lines.push(
          `Tarea (feedback: HINT): escribe ${limit} frases: ` +
          `1) empieza con ‚ÄúTe ayudo a ‚Ä¶‚Äù (tono cercano) y normaliza la duda sin repetir empat√≠a del turno previo; ` +
          `2) da una pista concreta alineada al objetivo (usa Pistas de contenido o el primer Faltante); si el t√©rmino es extremo/coloquial, reencuadra con lenguaje profesional. No re‚Äënarrar el caso ni repetir frases literales. No dupliques frases.` + (allowQ ? '' : ` No incluyas preguntas.`)
        );
      }
      break;
    }

    default: {
      lines.push(`Acci√≥n desconocida: ${String((ctx as any).action)}`);
      break;
    }
  }

  // Limpieza final: sin l√≠neas vac√≠as y con espacios normalizados
  return lines
    .map(s => s.trim())
    .filter(Boolean)
    .join('\n');
}


```
=== EOF: src\ai\prompt.ts

===  src\ai\orchestrator.ts
```typescript
import { getClient, pickModel } from '@/lib/ai';
import { DocentePromptContext, buildSystemPrompt, buildUserPrompt } from './prompt';

function stripQuestions(text?: string): string {
  const raw = (text || '').trim();
  if (!raw) return '';
  // Quita oraciones que terminen en ? o ¬ø a nivel de frase, manteniendo el resto
  const sentences = raw.split(/(?<=[\.!?¬ø])\s+/).filter(Boolean);
  return sentences.filter(s => !/[?¬ø]\s*$/.test(s.trim())).join(' ');
}

function lastQuestion(text?: string): string {
  const lines = (text || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
  const qs = lines.filter(l => /[?¬ø]\s*$/.test(l));
  return qs[qs.length - 1] || '';
}

function normalizeForMatch(s: string): string {
  return s
    		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		.replace(/\s+/g, ' ')
		.trim();
}

// Anti re‚Äënarraci√≥n: elimina p√°rrafos exactos presentes en el historial reciente
function stripRepeatedFromHistory(text: string, ctx: DocentePromptContext): string {
  const raw = (text || '').trim();
  if (!raw || !Array.isArray(ctx.recentHistory) || ctx.recentHistory.length === 0) return raw;
  const historyBlob = normalizeForMatch(ctx.recentHistory.join(' \n '));
  const paras = raw.split(/\n\n+/).map(s => s.trim()).filter(Boolean);
  const kept: string[] = [];
  for (const p of paras) {
    const pNorm = normalizeForMatch(p);
    const isRepeated = pNorm.length >= 60 && historyBlob.includes(pNorm);
    if (!isRepeated) kept.push(p);
  }
  return kept.join('\n\n').trim();
}

// Antiduplicaci√≥n interna: elimina oraciones repetidas dentro del mismo mensaje
function stripSelfDuplicates(text: string): string {
  const raw = (text || '').trim();
  if (!raw) return '';
  const bannedStart = /^los\s+procedimientos\s+de\s+seguridad\s+incluyen/i;
  const normMap = new Set<string>();
  const bannedSeen = new Set<string>();

  const paragraphs = raw.split(/\n\n+/).map(s => s.trim()).filter(Boolean);
  const keptParas: string[] = [];
  for (const p of paragraphs) {
    const sentences = p.split(/(?<=[\.!?])\s+/).map(s => s.trim()).filter(Boolean);
    const keptSentences: string[] = [];
    for (const s of sentences) {
      if (!s) continue;
      const n = normalizeForMatch(s);
      if (!n) continue;
      if (bannedStart.test(s)) {
        const key = 'banned:los_procedimientos_de_seguridad_incluyen';
        if (bannedSeen.has(key)) continue;
        bannedSeen.add(key);
      }
      if (normMap.has(n)) continue;
      normMap.add(n);
      keptSentences.push(s);
    }
    const joined = keptSentences.join(' ')
      .replace(/\s+\n/g, '\n')
      .trim();
    if (joined) keptParas.push(joined);
  }
  return keptParas.join('\n\n').trim();
}

export async function runDocenteLLM(ctx: DocentePromptContext): Promise<{ message: string; followUp?: string }> {
  const system = buildSystemPrompt(ctx);
  const user = buildUserPrompt(ctx);
  const model = pickModel('cheap');
  let offline = false;
  let out = '';
  try {
    const client = getClient();
    const r = await client.responses.create({
      model,
      input: [
        { role: 'system', content: system },
        { role: 'user', content: user },
      ],
      temperature: 0.30,
    });
    out = ((r as any).output_text || '').trim();
  } catch {
    offline = true;
  }

  if (!offline) {
    if (ctx.action === 'explain') {
      return { message: stripQuestions(out) };
    }
    if (ctx.action === 'ask') {
      const q = (ctx.questionText || '').trim();
      let msg = stripQuestions(out).replace(/^\s*Docente\s*:\s*/i, '').trim();
      msg = stripRepeatedFromHistory(msg, ctx);
      msg = stripSelfDuplicates(msg);
      const norm = (s: string) => s.replace(/\s+/g, ' ').toLowerCase();
      const already = norm(msg).includes(norm(q));
      const merged = already ? msg : [msg, q].filter(Boolean).join('\n\n');
      return { message: merged };
    }
    if (ctx.action === 'ok' || ctx.action === 'advance') {
      let raw = out.replace(/^\s*Docente\s*:\s*/i, '').trim();
      // Intentar parsear PUENTE: en advance
      if (ctx.action === 'advance') {
        const m = raw.match(/PUENTE\s*:\s*(.+)$/im);
        if (m) {
          const bridge = stripSelfDuplicates(stripQuestions(m[1] || '').trim());
          return { message: bridge };
        }
      }
      let msg = stripQuestions(raw);
      msg = stripRepeatedFromHistory(msg, ctx);
      msg = stripSelfDuplicates(msg);
      return { message: msg };
    }
    if (ctx.action === 'hint') {
      let raw = out.replace(/^\s*Docente\s*:\s*/i, '').trim();
      // Parse labels: MICRO / PISTA
      const microMatch = raw.match(/^\s*MICRO\s*:\s*(.+)$/im);
      const pistaMatch = raw.match(/^\s*PISTA\s*:\s*(.+)$/im);
      if (microMatch || pistaMatch) {
        const fu = (microMatch?.[1] || '').trim();
        const hint = (pistaMatch?.[1] || '').trim();
        const message = stripSelfDuplicates(stripRepeatedFromHistory(stripQuestions(`MICRO: ${fu}\n\nPISTA: ${hint}`), ctx));
        return { message, followUp: fu };
      }
      // Fallback a l√≥gica anterior si no hay etiquetas
      let msg = stripQuestions(raw).trim();
      msg = stripRepeatedFromHistory(msg, ctx);
      msg = stripSelfDuplicates(msg);
      const follow = lastQuestion(raw);
      return { message: msg, followUp: follow };
    }
    if (ctx.action === 'ask_simple' || ctx.action === 'ask_options') {
      const msg = stripSelfDuplicates(stripRepeatedFromHistory(out.replace(/^\s*Docente\s*:\s*/i, '').trim(), ctx));
      return { message: msg };
    }
    if (ctx.action === 'feedback') {
      const msg = stripSelfDuplicates(stripRepeatedFromHistory(out.replace(/^\s*Docente\s*:\s*/i, '').trim(), ctx));
      return { message: msg };
    }
    return { message: out };
  }

  // Offline fallback determinista (sin OpenAI)
  const q = (ctx.questionText || '').trim();
  if (ctx.action === 'explain') {
    const parts = [
      ctx.narrationText,
      ...(Array.isArray(ctx.contentBody) ? ctx.contentBody : []),
      ctx.caseText,
      ctx.objective,
    ].filter(Boolean).join(' ');
    return { message: stripQuestions(parts).slice(0, 400) };
  }
  if (ctx.action === 'ask') {
    return { message: q };
  }
  if (ctx.action === 'advance') {
    return { message: 'Puente breve al siguiente foco.' };
  }
  if (ctx.action === 'hint') {
    return { message: 'Te doy una pista: menciona 1‚Äì2 elementos clave del objetivo.', followUp: q ? q : '¬øUna micro‚Äëpregunta?' };
  }
  if (ctx.action === 'ask_simple' || ctx.action === 'ask_options') {
    return { message: q };
  }
  if (ctx.action === 'feedback') {
    return { message: 'FB: refuerzo/gu√≠a breve.' };
  }
  return { message: q };
}


```
=== EOF: src\ai\orchestrator.ts

===  public\courses\registry.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "SSO001",
      "lessons": [
        {
          "id": "lesson02",
          "name": "Lecci√≥n 02",
          "planUrl": "/courses/SSO001/lessons/lesson02.json"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\registry.json

===  app\engine-chat\page.tsx
```tsx
"use client";
import EngineChatLayout from '@/components/EngineChatLayout';
import { usePlanChat } from '@/hooks/usePlanChat';
import { useEffect, useMemo, useState } from 'react';

type LessonRef = { id: string; name?: string; planUrl: string };
type CourseRef = { id: string; name?: string; lessons: LessonRef[] };
type Registry = { courses: CourseRef[] };

export default function EngineChatPage() {
  const [registry, setRegistry] = useState<Registry | null>(null);
  const [selectedCourseId, setSelectedCourseId] = useState<string>('');
  const [selectedLessonId, setSelectedLessonId] = useState<string>('');
  const [lessonVM, setLessonVM] = useState<any>(null);

  // derive current planUrl from selection
  const planUrl: string | null = useMemo(() => {
    if (!registry || !selectedCourseId || !selectedLessonId) return null;
    const course = registry.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return lesson?.planUrl || null;
  }, [registry, selectedCourseId, selectedLessonId]);

  const { messages, isTyping, done, sendMessage, clearMessages, adaptiveMode, setAdaptiveMode, budgetMetrics, state } = usePlanChat(planUrl || '/courses/SSO001/lessons/lesson02.json');
  const showControls = process.env.NEXT_PUBLIC_ENGINE_CONTROLS !== 'false';

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        const res = await fetch('/courses/registry.json');
        if (!res.ok) return;
        const json = (await res.json()) as Registry;
        if (!alive) return;
        setRegistry(json);
        // default selection: first course/lesson
        const c = json.courses?.[0];
        if (c) {
          setSelectedCourseId(prev => prev || c.id);
          const l = c.lessons?.[0];
          if (l) setSelectedLessonId(prev => prev || l.id);
        }
      } catch {}
    })();
    return () => { alive = false; };
  }, []);

  // Cargar el plan y construir VM (aprendizaje esperado, puntos clave y momentos) al cambiar planUrl
  useEffect(() => {
    let alive = true;
    if (!planUrl) return;
    (async () => {
      try {
        const res = await fetch(planUrl);
        if (!res.ok) return;
        const plan = await res.json();
        if (!alive) return;
        const moments = (plan.moments || []).map((m: any) => ({ title: m.title }));
        const keyPoints: Array<{ id: string; title: string; description?: string; completed?: boolean }> = [];
        const expectedLearning: string[] = [];
        (plan.moments || []).forEach((m: any, mi: number) => {
          (m.steps || []).forEach((s: any) => {
            if (String(s.type || '').toUpperCase() === 'EXPECTED_LEARNING') {
              (s.items || []).forEach((it: string) => expectedLearning.push(it));
            }
            if (String(s.type || '').toUpperCase() === 'KEY_POINTS') {
              (s.items || []).forEach((title: string, idx: number) => {
                keyPoints.push({ id: `${s.code || `M${mi + 1}-KP`}-${idx}` , title, completed: false });
              });
            }
          });
        });
        setLessonVM({
          version: plan?.meta?.version || 'plan',
          locale: plan?.meta?.language || 'es',
          moments,
          keyPoints,
          expectedLearning,
          avatarUrl: '/image/sophia_fuentes.png',
          media: plan?.media || {}
        });
      } catch {}
    })();
    return () => { alive = false; };
  }, [planUrl]);

  // Simple VM/state placeholders for EngineChatLayout
  const vm = useMemo(() => {
    const course = registry?.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return {
      title: [course?.name || course?.id, lesson?.name || lesson?.id].filter(Boolean).join(' ¬∑ ') || 'DocenteIA',
      version: lessonVM?.version || 'plan',
      locale: lessonVM?.locale || 'es-CL',
      moments: lessonVM?.moments || [],
      keyPoints: lessonVM?.keyPoints || [],
      expectedLearning: lessonVM?.expectedLearning || [],
      avatarUrl: lessonVM?.avatarUrl || '/image/sophia_fuentes.png'
    } as any;
  }, [registry, selectedCourseId, selectedLessonId, lessonVM]);

  const layoutState = useMemo(() => ({ momentIdx: state?.momentIdx || 0, stepCode: (state as any)?.stepCode }), [state?.momentIdx, (state as any)?.stepCode]);

  return (
    <div className="min-h-screen bg-slate-100">
      <div className="w-full px-2 md:px-4 py-4">
        {showControls && (
          <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4 mb-4 flex flex-col md:flex-row gap-3">
            <div className="flex-1 grid grid-cols-1 md:grid-cols-3 gap-3">
              <select
                className="border rounded-lg px-3 py-2"
                value={selectedCourseId}
                onChange={(e) => { setSelectedCourseId(e.target.value); setSelectedLessonId(''); clearMessages(); }}
              >
                <option value="">Selecciona curso‚Ä¶</option>
                {registry?.courses.map(c => (
                  <option key={c.id} value={c.id}>{c.name || c.id}</option>
                ))}
              </select>
              <select
                className="border rounded-lg px-3 py-2"
                value={selectedLessonId}
                onChange={(e) => { setSelectedLessonId(e.target.value); clearMessages(); }}
                disabled={!selectedCourseId}
              >
                <option value="">Selecciona lecci√≥n‚Ä¶</option>
                {registry?.courses.find(c => c.id === selectedCourseId)?.lessons.map(l => (
                  <option key={l.id} value={l.id}>{l.name || l.id}</option>
                ))}
              </select>
              <div className="flex items-center gap-2">
                <button onClick={() => clearMessages()} className="border rounded-lg px-3 py-2">Nueva sesi√≥n</button>
                {done && <span className="text-green-600 text-sm">Fin de la lecci√≥n</span>}
              </div>
            </div>
            
            {/* Controles de modo adaptativo y presupuesto */}
            <div className="flex items-center gap-4 border-t pt-4 mt-4">
              <div className="flex items-center gap-2">
                <label className="text-sm font-medium">Modo:</label>
                <select 
                  value={adaptiveMode ? 'adaptive' : 'deterministic'} 
                  onChange={(e) => setAdaptiveMode(e.target.value === 'adaptive')}
                  className="border rounded-lg px-2 py-1 text-sm"
                >
                  <option value="deterministic">Determinista</option>
                  <option value="adaptive">Adaptativo</option>
                </select>
              </div>
              
              {budgetMetrics && (
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium">Presupuesto:</span>
                  <div className="w-32 bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${(budgetMetrics.budgetCentsLeft / 100) * 100}%` }}
                    ></div>
                  </div>
                  <span className="text-xs text-gray-600">
                    ${(budgetMetrics.budgetCentsLeft / 100).toFixed(2)}
                  </span>
                </div>
              )}
            </div>
          </div>
        )}

        <EngineChatLayout
          messages={messages as any}
          isTyping={isTyping}
          onSend={(t) => sendMessage(t)}
          vm={vm}
          state={layoutState as any}
        />
      </div>
    </div>
  );
}


```
=== EOF: app\engine-chat\page.tsx

===  .data\history\plan-1755889757922-469bd53k.jsonl
```
{"ts":1755903264205,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"¬°Hola! Hoy vamos a hablar sobre los procedimientos de seguridad y por qu√© son tan importantes en el entorno laboral. Estos procedimientos nos ayudan a prevenir accidentes y a garantizar un ambiente de trabajo seguro para todos. A lo largo de la sesi√≥n, exploraremos c√≥mo implementarlos de manera efectiva.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903279087,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Te ayudo a aclarar tus dudas sobre los procedimientos de seguridad. Es importante conocer las diferentes partes de un procedimiento, como las medidas preventivas y las instrucciones espec√≠ficas. Esto te permitir√° entender mejor c√≥mo se aplican en el entorno laboral y por qu√© seguirlos es esencial para mantener un ambiente seguro.\n\n¬øQu√© partes del procedimiento conoces?\n\nPISTA: Te doy una pista: piensa en la importancia de seguir los procedimientos y c√≥mo se aplican.","followUp":"¬øQu√© partes del procedimiento conoces?"}
{"ts":1755903338107,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Te ayudo a entender que es normal tener dudas al comenzar a aprender sobre un tema nuevo. Piensa en las partes de un procedimiento de seguridad, como las medidas que se deben tomar para evitar accidentes. Esto te ayudar√° a ver c√≥mo se aplican en el trabajo y por qu√© son tan importantes.\n\n¬øQu√© medidas de seguridad conoces?\n\nPISTA: Te doy una pista: piensa en las medidas preventivas y su funci√≥n en el trabajo.","followUp":"¬øQu√© medidas de seguridad conoces?"}
{"ts":1755903381245,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"En un entorno laboral, los procedimientos de seguridad son esenciales para prevenir accidentes y proteger a los trabajadores. Por ejemplo, al instalar ventanas en un tercer piso, es crucial que el trabajador use un arn√©s adecuado, especialmente si no tiene experiencia en trabajos en altura. Seguir estas medidas garantiza un ambiente seguro y minimiza riesgos.\n\nAhora exploraremos c√≥mo implementar estas medidas de seguridad en el entorno laboral.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\plan-1755889757922-469bd53k.jsonl

===  .data\history\it-lesson02-nose.jsonl
```
{"ts":1755903242428,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242433,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
```
=== EOF: .data\history\it-lesson02-nose.jsonl

===  .data\history\it-lesson02-caso5.jsonl
```
{"ts":1755903242464,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
```
=== EOF: .data\history\it-lesson02-caso5.jsonl

===  .data\history\it-lesson02-caso2.jsonl
```
{"ts":1755903242452,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242457,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"FB: refuerzo/gu√≠a breve.\n\nExplicaci√≥n breve del contenido.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\it-lesson02-caso2.jsonl

===  .data\history\it-lesson02-caso1.jsonl
```
{"ts":1755903242439,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242446,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
```
=== EOF: .data\history\it-lesson02-caso1.jsonl

===  .data\history\it-lesson02-3-no-se.jsonl
```
{"ts":1755903242403,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242410,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
{"ts":1755903242415,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242419,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"Explicaci√≥n breve del contenido.\n\nPuente breve al siguiente foco.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\it-lesson02-3-no-se.jsonl

===  .data\history\it-escalada-hints.jsonl
```
{"ts":1755903242471,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242475,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
{"ts":1755903242478,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242481,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"Explicaci√≥n breve del contenido.\n\nPuente breve al siguiente foco.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\it-escalada-hints.jsonl

===  .data\history\it-3-no-se.jsonl
```
{"ts":1755903242411,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242419,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
{"ts":1755903242423,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta m√°s f√°cil?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta m√°s f√°cil?"}
{"ts":1755903242427,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"Explicaci√≥n breve del contenido.\n\nPuente breve al siguiente foco.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\it-3-no-se.jsonl

===  .data\history\it-3-no-se-fb.jsonl
```
{"ts":1755903242435,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242441,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
{"ts":1755903242444,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242448,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"Explicaci√≥n breve del contenido.\n\nPuente breve al siguiente foco.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\it-3-no-se-fb.jsonl

===  .data\history\it-2-no-se-advance.jsonl
```
{"ts":1755903242454,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Explicaci√≥n breve del contenido.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242458,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øUna micro‚Äëpregunta?"}
{"ts":1755903242461,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"FB: refuerzo/gu√≠a breve.\n\n¬øUna micro‚Äëpregunta?\n\nPista breve alineada al objetivo.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755903242465,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"Explicaci√≥n breve del contenido.\n\nPuente breve al siguiente foco.","followUp":"¬øQu√© elementos de seguridad identificas en esta situaci√≥n?"}
```
=== EOF: .data\history\it-2-no-se-advance.jsonl

===  src\engine\flow\transition.ts
```typescript
export type TransitionAction = 'ask' | 'hint' | 'ask_simple' | 'ask_options' | 'explain' | 'ok';

export type EscalationConfig = {
  noSeToHint?: number;
  hintToAskSimple?: number;
  askSimpleToOptions?: number;
  hardStopToExplain?: number;
};

export function decideNextAction(params: {
  lastAction?: TransitionAction;
  classKind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  attempts: number;
  noSeCount: number;
  cfg?: EscalationConfig;
}): { nextAction: TransitionAction; resetNoSe?: boolean } {
  const { lastAction, classKind, attempts, noSeCount, cfg } = params;

  // Acierto expl√≠cito del clasificador
  if (classKind === 'ACCEPT') {
    return { nextAction: 'ok', resetNoSe: true };
  }

  // Si hay configuraci√≥n expl√≠cita, resp√©tala
  if (cfg) {
    const toHint = cfg.noSeToHint ?? Number.POSITIVE_INFINITY;
    const toSimple = cfg.hintToAskSimple ?? Number.POSITIVE_INFINITY;
    const toOptions = cfg.askSimpleToOptions ?? Number.POSITIVE_INFINITY;
    const toExplain = cfg.hardStopToExplain ?? Number.POSITIVE_INFINITY;

    if (lastAction === 'ask') {
      if (noSeCount >= toHint) return { nextAction: 'hint' };
      return { nextAction: 'ask' };
    }
    if (lastAction === 'hint') {
      if (noSeCount >= toSimple) return { nextAction: 'ask_simple' };
      return { nextAction: 'hint' };
    }
    if (lastAction === 'ask_simple') {
      if (noSeCount >= toOptions) return { nextAction: 'ask_options' };
      return { nextAction: 'ask_simple' };
    }
    if (lastAction === 'ask_options') {
      if (noSeCount >= toExplain) return { nextAction: 'explain' };
      return { nextAction: 'ask_options' };
    }
    // Fallback config-driven: empezar por ask
    return { nextAction: 'ask' };
  }

  // Sin configuraci√≥n: preferir feedback primero cuando hay se√±ales parciales
  if (classKind === 'PARTIAL') {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  } else {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  }
  return { nextAction: 'ask' };
}


```
=== EOF: src\engine\flow\transition.ts

===  public\courses\SSO001\policies.json
```json
{
  "language": {
    "stopwords": ["el","la","los","las","un","una","unos","unas","de","en","y","o","a","para","con","sobre","que","es","son","del","al","por","se","como","mas","m√°s","menos","no","si","s√≠","qu√©","cuales","cu√°les"]
  },
  "evaluation": {
    "attemptsMax": 3,
    "levels": {
      "R0": { "description": "vac√≠o/vago/fuera de tema" },
      "R1": { "description": "parcial" },
      "R2": { "description": "correcta" }
    },
    "thresholds": {
      "similarityMin": 0.50,
      "similarityBest": 0.62,
      "keywordMin": 1,
      "minTokens": 3
    },
    "scoring": { "R2": 2, "R1": 1, "R0": 0 },
    "semantic": {
      "open":   { "semThresh": 0.35, "semBestThresh": 0.30 },
      "closed": { "semThresh": 0.46, "semBestThresh": 0.40 }
    }
  },
  "thresholds": {
    "conceptual": { "min": 1 },
    "identificacion": { "min": 1 },
    "listado": { "kDefault": 2 },
    "aplicacion": { "requiresJustification": true },
    "metacognitiva": { "min": 1 },
    "experiencial": { "min": 1 },
    "reflexiva": { "min": 1 }
  },
  "hints": {
    "wordLimits": [16, 28, 40],
    "maxHints": 2,
    "escalateAfterAttempts": [1, 2, 3],
    "variants": [
      "Piensa en los criterios del EPP",
      "Recuerda los riesgos antes de actuar"
    ],
    "rotateVariants": true,
    "templates": {
      "objective": "{opener} Enf√≥cate en {keywords}. {cueLine}",
      "reask": {
        "list": "Menciona en {maxWords} palabras 2 elementos de {base}.",
        "definition": "Define brevemente {base} (‚â§{maxWords} palabras).",
        "procedure": "En {maxWords} palabras, describe 2 pasos clave de {base}.",
        "choice": "Elige 1 aspecto de {base} y justifica en {maxWords} palabras."
      },
      "open": {
        "hint": "Comparte tus ideas en al menos {minWords} palabras. {cuesLine}",
        "reask": "En {minWords}-{maxWords} palabras, cu√©ntame tus ideas principales sobre \"{objective}\".",
        "fallbackAspects": ["prop√≥sito", "criterios", "ejemplo"]
      }
    }
  },

  "feedback": {
    "openers": {
      "hint": [
        "Considera revisar",
        "Piensa en",
        "Recuerda que",
        "Ten en cuenta"
      ]
    },
    "showDeterministic": false,
    "maxSentences": 3,
    "allowQuestions": true
  },
  "advance": {
    "allowForcedOn": ["SALUDO", "CONEXION", "ADQUISICION", "APLICACION", "DISCUSION", "REFLEXION", "OTRO"],
    "maxAttemptsBeforeForce": 3
  },
  "vague": {
    "minUsefulTokens": 3,
    "maxStopwordRatio": 0.6,
    "echoOverlap": 0.7,
    "repeatSimilarity": 0.8,
    "vagueAttemptsBeforeAB": 2,
    "vagueAttemptsBeforeExplain": 3,
    "simplifiedAskMaxWords": 10
  },
  "typeMap": {
    "abierta": "metacognitiva",
    "diagnostica": "identificacion",
    "diagn√≥stica": "identificacion",
    "aplicacion_practica": "aplicacion",
    "aplicacion": "aplicacion",
    "analisis": "conceptual",
    "analisis_comparativo": "conceptual",
    "analisis_critico": "conceptual",
    "seleccion_justificada": "aplicacion",
    "planificacion_aplicacion": "aplicacion",
    "autoevaluacion": "reflexiva",
    "identificacion": "identificacion",
    "conceptual": "conceptual",
    "listado": "listado",
    "reflexiva": "reflexiva",
    "experiencial": "experiencial"
  }
}


```
=== EOF: public\courses\SSO001\policies.json

===  public\courses\SSO001\overrides.json
```json
{
  "steps": {
    "M3-Q02": { "type": "listado", "k": 4 },
    "M4-Q01": { "type": "aplicacion", "requiresJustification": true }
  }
}



```
=== EOF: public\courses\SSO001\overrides.json

===  public\courses\SSO001\course.json
```json
{
  "id": "SSO001",
  "name": "Seguridad y Salud Ocupacional",
  "version": "1.0.0",
  "language": "es",
  "objectives": [
    "Identificar riesgos",
    "Aplicar procedimientos"
  ],
  "specialist": {},
  "lessons": [
    {
      "id": "lesson02",
      "title": "Procedimientos de Seguridad",
      "order": 2,
      "path": "/courses/SSO001/lessons/lesson02.json"
    }
  ]
}


```
=== EOF: public\courses\SSO001\course.json

===  public\courses\SSO001\lessons\lesson02.json
```json
{
  "meta": {
    "lesson_id": "SSO001_lesson02",
    "lesson_name": "Procedimientos de Seguridad",
    "version": "1.0.0",
    "language": "es",
    "ordered": true,
    "generated_at": "2025-08-14T00:00:00Z"
  },
  "media": {
    "M1-EL01": { "images": ["/courses/SSO001/images/saludo-minero.jpg"] },
    "M1-N01":  { "images": ["/courses/SSO001/images/saludo-minero.jpg"] },
    "M1-Q01":  { "images": ["/courses/SSO001/images/saludo-minero.jpg"] },
    "M2-N01":  { "images": ["/courses/SSO001/images/instalar-ventanas.png", "/courses/SSO001/images/seguridad-3.jpg"] },
    "M2-Q01":  { "images": ["/courses/SSO001/images/seguridad-3.jpg"] },
    "M2-Q02":  { "images": ["/courses/SSO001/images/seguridad-3.jpg"] },
    "M3-C01":  { "images": ["/courses/SSO001/images/arnes.jpg"] },
    "M3-Q01":  { "images": ["/courses/SSO001/images/arnes.jpg"] },
    "M4-CASE01": { "images": ["/courses/SSO001/images/instalar-ventanas-2.jpg"] },
    "M4-Q01":  { "images": ["/courses/SSO001/images/instalar-ventanas-2.jpg"] },
    "M5-TOP01": { "images": ["/courses/SSO001/images/accidente.jpg"] },
    "M5-Q01":  { "images": ["/courses/SSO001/images/accidente.jpg"] },
    "M6-REF01": { "images": ["/courses/SSO001/images/accidente-2.jpg"] },
    "M6-Q01":  { "images": ["/courses/SSO001/images/accidente-2.jpg"] }
  },
  "moments": [
    {
      "code": "M1",
      "order": 1,
      "title": "Saludo",
      "steps": [
        { "code": "M1-EL01", "order": 1, "type": "EXPECTED_LEARNING", "items": [
          "Explicar los componentes del procedimiento de seguridad en situaciones de trabajo, de acuerdo con los est√°ndares y normativas vigentes."
        ]},
        { "code": "M1-KP01", "order": 2, "type": "KEY_POINTS", "items": [
          "Qu√© es un procedimiento", "Por qu√© es importante", "C√≥mo se aplica"
        ]},
        { "code": "M1-N01", "order": 3, "type": "NARRATION", "text": "Bienvenida y objetivo de la sesi√≥n. Exploraremos qu√© son los procedimientos de seguridad y su relevancia en el trabajo." },
        { "code": "M1-Q01", "order": 4, "type": "ASK",
          "question": "¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?",
          "objective": "Elicitar expectativas del estudiante",
          "answer_type": "open",
          "expected": ["experiencias previas", "dudas espec√≠ficas", "aplicaci√≥n en el trabajo"],
          "acceptable_answers": ["partes del procedimiento", "c√≥mo se aplica", "importancia de seguirlos", "selecci√≥n de EPP"],
          "question_type": "metacognitiva"
        }
      ]
    },
    {
      "code": "M2",
      "order": 2,
      "title": "Conexi√≥n",
      "steps": [
        { "code": "M2-N01", "order": 1, "type": "NARRATION",
          "text": "Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arn√©s, pero no ha trabajado en altura antes." },
        { "code": "M2-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© elementos de seguridad identificas en esta situaci√≥n?",
          "objective": "Activar conocimientos previos",
          "expected": ["arn√©s", "l√≠nea de vida", "casco", "guantes", "inspecci√≥n previa", "supervisi√≥n"],
          "acceptable_answers": ["arn√©s", "arn√©s de seguridad", "l√≠nea", "l√≠nea de vida", "casco", "guantes", "inspecci√≥n previa", "supervisi√≥n"],
          "question_type": "diagn√≥stica"
          
        },


        { "code": "M2-Q02", "order": 3, "type": "ASK",
          "question": "¬øQu√© podr√≠a pasar si no se siguen los procedimientos correctos?",
          "objective": "Conciencia de riesgos",
          "expected": ["ca√≠das", "lesiones", "accidentes", "sanciones", "multas", "fatalidad"],
          "acceptable_answers": ["ca√≠das", "lesiones", "accidentes", "sanciones", "multas", "muerte", "fatalidad", "accidente mortal", "da√±o grave"],
          "question_type": "reflexiva"
        }
      ]
    },
    {
      "code": "M3",
      "order": 3,
      "title": "Adquisici√≥n",
      "steps": [
        { "code": "M3-C01", "order": 1, "type": "CONTENT",
          "title": "Definici√≥n de procedimiento de seguridad",
          "body": [
            "PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos espec√≠ficos para realizar una tarea de forma segura, minimizando riesgos laborales"
          ]
        },
        { "code": "M3-Q01", "order": 2, "type": "ASK",
          "question": "¬øC√≥mo definir√≠as un procedimiento de seguridad con tus palabras?",
          "objective": "Comprender la definici√≥n",
          "answer_type": "definition",
          "expected": ["secuencia de pasos", "seguridad", "minimizar riesgos", "documentado"],
          "acceptable_answers": ["secuencia documentada de pasos", "realizar una tarea de forma segura", "minimizar riesgos laborales"],
          "question_type": "conceptual"
        },
        { "code": "M3-C02", "order": 3, "type": "CONTENT",
          "title": "Partes de un procedimiento",
          "body": [
            "Objetivo", "Alcance", "Responsabilidades", "Pasos espec√≠ficos", "EPP requerido", "Medidas de emergencia", "Registros"
          ]
        },
        { "code": "M3-Q02", "order": 4, "type": "ASK",
          "question": "¬øQu√© partes debe incluir un procedimiento de seguridad completo?",
          "objective": "Identificar componentes",
          "expected": ["objetivo", "alcance", "responsabilidades", "pasos espec√≠ficos", "EPP", "emergencias", "registros"],
          "acceptable_answers": ["objetivo", "alcance", "responsabilidades", "pasos espec√≠ficos", "epp requerido", "medidas de emergencia", "registros"],
          "question_type": "listado"
        },
        { "code": "M3-C03", "order": 5, "type": "CONTENT",
          "title": "Criterios para seleccionar EPP",
          "body": [
            "Evaluar tipo de riesgo y nivel de exposici√≥n",
            "Compatibilidad, ajuste y comodidad",
            "Cumplimiento normativo y certificaciones"
          ]
        },
        { "code": "M3-Q03", "order": 6, "type": "ASK",
          "question": "Menciona dos criterios para seleccionar EPP adecuadamente.",
          "objective": "Dominar criterios de selecci√≥n de EPP",
          "answer_type": "list",
          "expected": ["tipo de riesgo", "nivel de exposici√≥n", "compatibilidad", "ajuste", "certificaciones"],
          "acceptable_answers": ["tipo de riesgo", "nivel de exposici√≥n", "compatibilidad", "ajuste", "normativa", "certificaciones"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M4",
      "order": 4,
      "title": "Aplicaci√≥n",
      "steps": [
        { "code": "M4-CASE01", "order": 1, "type": "CASE",
          "title": "Trabajo en altura en fachada",
          "description": "Instalaci√≥n de ventanas en tercer piso con uso de arn√©s y l√≠nea de vida.",
          "variables": ["altura > 2 m", "arn√©s", "l√≠nea de vida", "supervisi√≥n", "verificaci√≥n de anclajes"]
        },
        { "code": "M4-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© EPP m√≠nimo usar√≠as y por qu√©?",
          "objective": "Justificar selecci√≥n de EPP",
          "answer_type": "procedure",
          "expected": ["arn√©s con l√≠nea de vida", "casco", "guantes", "calzado antideslizante", "justificaci√≥n"],
          "acceptable_answers": ["arn√©s con l√≠nea de vida", "casco", "guantes", "calzado antideslizante"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M5",
      "order": 5,
      "title": "Discusi√≥n",
      "steps": [
        { "code": "M5-TOP01", "order": 1, "type": "TOPICS",
          "items": ["Protocolizar vs. improvisar", "Cultura de seguridad"]
        },
        { "code": "M5-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© ventajas tiene documentar procedimientos frente a improvisar?",
          "objective": "Comparar enfoques",
          "expected": ["estandarizaci√≥n", "reducci√≥n de errores", "trazabilidad", "cumplimiento"],
          "acceptable_answers": ["estandariza", "reduce errores", "trazabilidad", "cumplimiento"],
          "question_type": "argumentativa"
        }
      ]
    },
    {
      "code": "M6",
      "order": 6,
      "title": "Reflexi√≥n",
      "steps": [
        { "code": "M6-REF01", "order": 1, "type": "REFLECTION_AREAS",
          "items": ["H√°bitos personales de seguridad", "Compromisos inmediatos"]
        },
        { "code": "M6-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© cambio aplicar√°s esta semana para mejorar tu seguridad?",
          "objective": "Plan de mejora personal",
          "answer_type": "open",
          "expected": ["compromiso espec√≠fico", "c√≥mo lo implementar√°s", "beneficios esperados"],
          "acceptable_answers": ["ejemplo personal", "compromiso concreto"],
          "question_type": "reflexiva"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\SSO001\lessons\lesson02.json

===  app\api\engine\turn\route.ts
```typescript
import { runDocenteLLM } from '@/ai/orchestrator';
import { isNoSeInput, shouldGateByMinTokens } from '@/engine/clarify';
import { evaluateSemanticOnly, type AskPolicy } from '@/engine/eval';
import { extractKeywords } from '@/engine/hints';
import { isAffirmativeToResume, isStudentAskingQuestion, isStudentAskingQuestionSem } from '@/engine/questions';
import { advanceTo, currentStep, decideAction, decideNextAction, getNextAskInSameCycle, next } from '@/engine/runner';
import { loadAndCompile } from '@/plan/compilePlan';
import { appendHistory, clearHistory, getRecentHistory } from '@/session/history';
import { SessionState, initSession } from '@/session/state';
import { getSessionStore } from '@/session/store';
import { resolveTeacherProfile } from '@/teacher/resolveProfile';
import fs from 'fs/promises';
import { NextResponse } from 'next/server';
import path from 'path';


// Evita repetir frases casi id√©nticas al componer mensajes
function composeUniqueText(...parts: Array<string | undefined>): string {
	const norm = (s: string) => s
		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		.replace(/\s+/g, ' ')
		.trim();
	const seen = new Set<string>();
	const out: string[] = [];
	for (const p of parts) {
		const text = String(p || '').trim();
		if (!text) continue;
		const lines = text.split(/\n+/).map(s => s.trim()).filter(Boolean);
		for (const line of lines) {
			const key = norm(line);
			if (key && !seen.has(key)) {
				seen.add(key);
				out.push(line);
			}
		}
	}
	return out.join('\n\n');
}


type ClientState = {
  momentIdx?: number;
  stepIdx?: number;
  attemptsByAskCode?: Record<string, number>;
  noSeCountByAskCode?: Record<string, number>;
  lastActionByAskCode?: Record<string, string>;
  lastAnswerByAskCode?: Record<string, string>;
  done?: boolean;
};

type Body = { sessionKey: string; userInput?: string; planUrl?: string; reset?: boolean; clientState?: ClientState; adaptiveMode?: boolean };

const SESSIONS = new Map<string, SessionState>();
const COURSE_POLICIES_CACHE = new Map<string, any>();

function mapMomentKind(title?: string): 'SALUDO'|'CONEXION'|'ADQUISICION'|'APLICACION'|'DISCUSION'|'REFLEXION'|'OTRO' {
  const t = (title || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  if (t.includes('saludo')) return 'SALUDO';
  if (t.includes('conexion')) return 'CONEXION';
  if (t.includes('adquisicion')) return 'ADQUISICION';
  if (t.includes('aplicacion')) return 'APLICACION';
  if (t.includes('discusion')) return 'DISCUSION';
  if (t.includes('reflexion')) return 'REFLEXION';
  return 'OTRO';
}

function deriveCourseId(planUrl: string): string | undefined {
  const m = planUrl.match(/\/courses\/(.*?)\//);
  return m?.[1];
}

async function loadCoursePolicies(courseId?: string) {
  if (!courseId) return undefined;
  if (COURSE_POLICIES_CACHE.has(courseId)) return COURSE_POLICIES_CACHE.get(courseId);

  try {
    const url = `/courses/${courseId}/policies.json`;
    let json: any;
    if (/^https?:/i.test(url)) {                       // remoto
      const res = await fetch(url);
      if (!res.ok) return undefined;
      json = await res.json();
    } else {                                           // relativo -> public/
      const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
      const raw = await fs.readFile(filePath, 'utf-8');
      json = JSON.parse(raw);
    }
    COURSE_POLICIES_CACHE.set(courseId, json);
    return json;
  } catch {
    return undefined;
  }
}

// buildStudentFacingBase eliminado: reutilizar el de src/engine/hints

export async function POST(req: Request) {
	try {
		const body = (await req.json()) as Body;
		const { sessionKey, userInput = '', planUrl = '/courses/SSO001/lessons/lesson02.json', reset = false, clientState, adaptiveMode = false } = body;
		let pendingInput = (userInput || '').toString();
		if (reset) {
			SESSIONS.delete(sessionKey);
			try { await getSessionStore().delete(sessionKey); } catch {}
			try { await clearHistory(sessionKey); } catch {}
		}
		let state = (await getSessionStore().get(sessionKey)) || SESSIONS.get(sessionKey);
    		if (!state) {
			const plan = await loadAndCompile(planUrl);
			state = initSession(planUrl, plan);
			// Aplicar modo adaptativo si se solicita
			if (adaptiveMode) {
				state.adaptiveMode = true;
			}
			SESSIONS.set(sessionKey, state);
			try { await getSessionStore().set(sessionKey, state); } catch {}
		}
    if (!state) {
      throw new Error('No se pudo inicializar la sesi√≥n');
    }
    // Rehidratar desde clientState si viene en el request (persistencia sin servidor)
    if (clientState) {
      // No sobrescribir con √≠ndices m√°s antiguos del cliente
      if (typeof clientState.momentIdx === 'number') {
        const m = Number(clientState.momentIdx);
        if (typeof state.momentIdx !== 'number' || m > (state.momentIdx as number)) {
          state.momentIdx = m;
        }
      }
      if (typeof clientState.stepIdx === 'number') {
        const sIdx = Number(clientState.stepIdx);
        if (typeof state.stepIdx !== 'number' || sIdx > (state.stepIdx as number)) {
          state.stepIdx = sIdx;
        }
      }
      state.attemptsByAskCode = { ...(state.attemptsByAskCode || {}), ...(clientState.attemptsByAskCode || {}) };
      state.noSeCountByAskCode = { ...(state.noSeCountByAskCode || {}), ...(clientState.noSeCountByAskCode || {}) };
      state.lastActionByAskCode = { ...(state.lastActionByAskCode || {}), ...(clientState.lastActionByAskCode || {}) };
      state.lastAnswerByAskCode = { ...(state.lastAnswerByAskCode || {}), ...(clientState.lastAnswerByAskCode || {}) };
      // Flag opcional
      if (typeof (clientState as any).justAskedFollowUp === 'boolean') {
        state.justAskedFollowUp = Boolean((clientState as any).justAskedFollowUp);
      }
		}
    const coursePolicies = await loadCoursePolicies(deriveCourseId(state.planUrl));
    const teacherProfile = resolveTeacherProfile({
      reqProfile: (body as any)?.teacherProfile,
      planProfile: (state as any)?.plan?.meta?.teacherProfile,
      stateProfile: (state as any)?.teacherProfile
    });
    (state as any).teacherProfile = teacherProfile;
		const step = currentStep(state);
		// Debug inicio de turno
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st0 = currentStep(state);
				const payload0 = {
					tag: 'engine.turn.start',
					sessionKey,
					momentTitle: state.plan?.moments?.[st0?.momentIndex || 0]?.title,
					stepType: st0?.type,
					stepIdx: state.stepIdx,
					userInputLen: (pendingInput || '').length
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload0));
			}
		} catch {}
		
		// Interceptor universal de consultas (antes de evaluar el ASK)
		state.consultCtx = state.consultCtx || {};
		
		// Variables de salida
		let message = '';
		let followUp = '';
		let displayValue: string | undefined;
		// Variables para r√∫brica/evaluaci√≥n
		let assessment: any = null;
		let lastClsKind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'|null = null;
		let lastMatched: string[] = [];
		let lastMissing: string[] = [];
		let lastAttempts = 0;
		let lastHints = 0;
		let lastStepCodeForAssess = '';
		
		// --- REEMITIR REPREGUNTA SI A√öN NO RESPONDE (continuidad) ---
		if (!pendingInput.trim() && state.justAskedFollowUp && state.lastFollowUpText) {
			return NextResponse.json({
				message: '',
				followUp: state.lastFollowUpText,
				state
			});
		}
		
		// 1) Si el alumno pide "permiso" para preguntar (detecci√≥n sem√°ntica de intenci√≥n)
		const isNoSeRegex = /^\s*(no\s*(lo\s*)?s[e√©]|no\s*est[o√≥]y?\s*seguro|no\s*s[e√©]\s*bien)\s*$/i;
		if (!isNoSeRegex.test(pendingInput) && (await isStudentAskingQuestionSem(pendingInput, (state as any).teacherProfile)) && /\?\s*$/.test(pendingInput)) {
			message = '¬°Claro! Dime cu√°l es tu consulta y, cuando quede claro, me lo confirmas para continuar con la clase.';
			// "pausa": recuerda d√≥nde est√°s para retomar
			state.consultCtx.pausedAt = { momentIndex: state.momentIdx!, stepIndex: state.stepIdx! };
			// Debug log
			if (process.env.ENGINE_DEBUG === 'true') {
				console.log('[CONSULTA_INTENCION]', { pausedAt: state.consultCtx.pausedAt });
			}
			// No avances el plan ni eval√∫es; solo responde
			return NextResponse.json({ message, followUp: '', state });
		}
		
		// 2) Si trae una pregunta concreta (termina en ?)
		if (!isNoSeRegex.test(pendingInput) && (await isStudentAskingQuestionSem(pendingInput, (state as any).teacherProfile)) && /\?\s*$/.test(pendingInput)) {
			const recent = await getRecentHistory(sessionKey, 6);
			const qa = await runDocenteLLM({
				language: 'es',
				action: 'feedback',
				stepType: 'ASK',
				questionText: pendingInput,
				objective: String(state.plan?.meta?.lesson_name || ''),
				recentHistory: recent
			});
			message = (qa.message || '').trim();
			// pides confirmaci√≥n para retomar
			const tail = '\n\n¬øTe qued√≥ claro? Responde "s√≠" para continuar o formula otra pregunta.';
			// Debug log
			if (process.env.ENGINE_DEBUG === 'true') {
				console.log('[CONSULTA_QA]', { len: message.length });
			}
			return NextResponse.json({ message: message + tail, followUp: '', state });
		}
		
		// 3) Si el alumno confirma que ya entendi√≥, retomas donde qued√≥
		if (state.consultCtx.pausedAt && isAffirmativeToResume(pendingInput, (state as any).teacherProfile)) {
			// Debug log
			if (process.env.ENGINE_DEBUG === 'true') {
				console.log('[CONSULTA_RESUME]', { resumedFrom: state.consultCtx.pausedAt });
			}
			// Limpiar contexto de pausa
			state.consultCtx.pausedAt = undefined;
			
			// Si estamos sobre una ASK, re-emitirla ya
			const st = currentStep(state);
			if (st?.type === 'ASK') {
				const q = st.data?.question || '';
				message = 'Perfecto, retomemos.';
				followUp = q;
				state.justAskedFollowUp = Boolean(followUp);
				return NextResponse.json({ message, followUp, state });
			}
			// Si no es ASK, contin√∫a flujo normal
		}
		
		// Bucle: saltar SKIP consecutivos y construir salida adecuada
		// Debug vars
		let dbg: any = null;
		let safety = 0;
    let skipGuarantee = false;
		while (safety++ < 20) {
			const act = decideAction(currentStep(state));
			if (act.kind === 'skip') {
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				continue;
			}
			if (act.kind === 'explain') {
				const data = act.step.data;
				const parts = [data.title, ...(data.body || []), data.text, ...(data.items || [])].filter(Boolean) as string[];
				const bodyArr: string[] = parts as string[];
				try {
					// Anti-repetici√≥n: emite narrativa s√≥lo una vez por momento
					const mIdx = act.step.momentIndex;
					const already = Boolean(state.narrativesShownByMoment?.[mIdx]);
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({
						language: 'es',
						action: 'explain',
						stepType: act.step.type,
						momentTitle: state.plan?.moments[act.step.momentIndex]?.title,
						objective: state.plan?.meta?.lesson_name || '',
						contentBody: bodyArr,
						recentHistory: recent
					});
					message = already ? '' : llm.message;
				} catch {
					message = bodyArr.join(' ‚Äî ') || 'Continuemos con el contenido.';
				}
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				// Buscar la siguiente ASK saltando pasos de metadatos y avanzar el puntero a ella
				const steps = state.plan?.allSteps || [];
				let targetIdx: number | undefined;
				for (let i = state.stepIdx; i < steps.length; i++) {
					const s = steps[i];
					const t = s.type;
					if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'EXPECTED_LEARNING') continue;
					if (t === 'ASK') { followUp = s.data.question || ''; targetIdx = i; }
					break;
				}
				// marcar flag para evitar eco y adelantar estado a la ASK
				state.justAskedFollowUp = Boolean(followUp);
				state.lastFollowUpText = followUp;
				// marca narrativa mostrada
				try { (state.narrativesShownByMoment ||= {})[act.step.momentIndex] = true; } catch {}
				if (typeof targetIdx === 'number') { state = advanceTo(state, targetIdx); }
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				break;
			}
        if (act.kind === 'ask') {
				const q = act.step.data.question || '';
				const acceptable = act.step.data.acceptable_answers || [];
				// Pol√≠tica por tipo con K din√°mico para LISTADO
				const qtype = String(act.step.data.question_type || '').toLowerCase();
				// Identificador del paso para contar intentos/acciones previas
				const stepCodeDyn = act.step.code || `Q:${q.substring(0,50)}`;
				const attemptsSoFar = Number(state.attemptsByAskCode?.[stepCodeDyn] || 0);
				const lastActionForStep = String(state.lastActionByAskCode?.[stepCodeDyn] || 'ask');
				const firstAttempt = attemptsSoFar === 0;
				const afterHint = lastActionForStep === 'hint';
				// Escala por intento: S1 exige 2; S2/S3 exige 1
				const dynamicK = qtype.includes('lista') ? (firstAttempt ? 2 : 1) : undefined;
				const policy: AskPolicy = qtype.includes('lista') ? { type: 'listado', thresholdK: dynamicK }
					: qtype.includes('aplica') ? { type: 'aplicacion', requiresJustification: true }
					: (qtype.includes('abierta') ? { type: 'metacognitiva' } : { type: (qtype as any) || 'conceptual' });
				// Derivar expected desde pasos previos (CONTENT/KEY_*) del mismo momento
				let expected: string[] = [];
				try {
					const moment = state.plan?.moments?.[act.step.momentIndex];
					const prior = (moment?.steps || []).slice(0, act.step.stepIndex);
					const texts: string[] = [];
					for (const ps of prior) {
						const t = ps.type;
						const d: any = ps.data;
						if (t === 'CONTENT') {
							if (d.title) texts.push(String(d.title));
							if (Array.isArray(d.body)) texts.push(...d.body.map((x: any)=>String(x)));
						} else if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'KEY_ELEMENTS' || t === 'TOPICS') {
							if (Array.isArray(d.items)) texts.push(...d.items.map((x: any)=>String(x)));
						} else if (t === 'NARRATION' && d.text) {
							texts.push(String(d.text));
						}
					}
					const explicit: string[] = Array.isArray(act.step.data?.expected) ? (act.step.data.expected as string[]) : [];
					const derived = extractKeywords(texts);
					const union = Array.from(new Set([...(explicit || []), ...(derived || [])]));
					expected = union;
				} catch {}
          const momentKind = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
          const maxAttempts = Number(coursePolicies?.advance?.maxAttemptsBeforeForce ?? 3);
          const allowForcedOn: string[] = Array.isArray(coursePolicies?.advance?.allowForcedOn) ? coursePolicies.advance.allowForcedOn : ['CONEXION'];
          const forceNoSeThreshold = Number((coursePolicies as any)?.advance?.forceOnNoSeThreshold ?? 3);
          const stepCode = act.step.code || `Q:${q.substring(0,50)}`;
          if (!pendingInput.trim()) {
            // evitar eco si acabamos de adjuntar followUp
            if (state.justAskedFollowUp) {
              message = '';
              followUp = '';
              state.justAskedFollowUp = false;
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
              skipGuarantee = true;
              break;
            }
            // F0/F1: emitir pista motivadora + micro-pregunta y contabilizar intento/ayuda
            try {
              const askData: any = (act as any)?.step?.data || {};
              const recent = await getRecentHistory(sessionKey, 4);
              const llmHint = await runDocenteLLM({
                language: 'es',
                action: 'hint',
                stepType: 'ASK',
                questionText: q,
                objective: String(askData.objective || ''),
                contentBody: Array.isArray(expected) ? expected : [],
                hintWordLimit: Number((coursePolicies?.hints?.wordLimits || [16])[0] || 16),
                allowQuestions: true,
                recentHistory: recent,
                attempts: Number(state.attemptsByAskCode?.[stepCode] || 0),
                hintsUsed: Number(state.hintsByAskCode?.[stepCode] || 0)
              } as any);
              const fu0 = (llmHint.followUp || q).trim();
              message = composeUniqueText(fu0, llmHint.message || '');
              followUp = fu0;
            } catch {
              message = '';
              followUp = q;
            }
            // Contadores y estado de hint
            const attemptsMap: any = state.attemptsByAskCode || (state.attemptsByAskCode = {} as any);
            const hintsMap0: any = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
            const lastActionMap0: any = state.lastActionByAskCode || (state.lastActionByAskCode = {} as any);
            attemptsMap[stepCode] = (attemptsMap[stepCode] || 0) + 1;
            hintsMap0[stepCode] = (hintsMap0[stepCode] || 0) + 1;
            lastActionMap0[stepCode] = 'hint';
            state.justAskedFollowUp = Boolean(followUp);
            state.lastFollowUpText = followUp;
            // Force advance si aplica tras intentos
            if ((state.attemptsByAskCode[stepCode] || 0) >= maxAttempts && allowForcedOn.includes(momentKind)) {
              const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
              if (typeof nextAskIdx === 'number') {
                state = advanceTo(state, nextAskIdx);
                followUp = (currentStep(state) as any)?.data?.question || '';
                state.justAskedFollowUp = Boolean(followUp);
              }
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                message = [message, bridge.message].filter(Boolean).join('\n\n');
              } catch {}
            }
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            break;
          }
          // Evaluaci√≥n para preguntas abiertas (answer_type: "open")
          const answerType = (act.step.data as any)?.answer_type || '';
          const rubric = (act.step.data as any)?.rubric || {};
          const objText = String(act.step.data?.objective || '');
          const isOpen = (answerType === 'open') || String((act.step.data as any)?.question_type || '').toLowerCase().includes('abierta') || ['SALUDO','CONEXION'].includes(momentKind);
          
          let cls: any;
          let vague: boolean = false;
          const hintsUsed = Number(state.hintsByAskCode?.[stepCode] || 0);
          const attempts = state.attemptsByAskCode?.[stepCode] || 0;
          
          {
            // Gate previo por tokens √∫tiles (evitar PARTIAL fantasma)
            const minTokens = Number(((coursePolicies as any)?.evaluation?.thresholds?.minTokens) ?? 3);
            if (shouldGateByMinTokens(pendingInput, minTokens)) {
              cls = { kind: 'HINT', reason: 'MIN_TOKENS', matched: [], missing: (Array.isArray(acceptable) && acceptable.length ? acceptable : (expected||[])).slice(0,3) } as any;
              vague = true;
            }
            // Evaluaci√≥n SOLO con embeddings (incluye abiertas), con umbral de parcial m√°s cercano configurable
            const evalCfg = (coursePolicies as any)?.evaluation?.semantic || {};
            const semOpen = evalCfg.open || { semThresh: 0.28, semBestThresh: 0.24 };
            const semClosed = evalCfg.closed || { semThresh: 0.44, semBestThresh: 0.34 };
            const th = isOpen ? semOpen : semClosed;
            const acceptablesEff = isOpen ? ((Array.isArray(acceptable) && acceptable.length) ? acceptable : (expected || [])) : acceptable;
            if (!vague) {
              const sem = await evaluateSemanticOnly(
                pendingInput,
                acceptablesEff,
                expected,
                policy,
                { semThresh: Number(th.semThresh ?? (isOpen ? 0.28 : 0.44)), semBestThresh: Number(th.semBestThresh ?? (isOpen ? 0.22 : 0.34)), maxHints: Number(coursePolicies?.hints?.maxHints ?? 2), vagueCenter: {
                  corpus: (state as any)?.teacherProfile?.eval?.vagueCenter?.corpus,
                  tauVagueMin: (state as any)?.teacherProfile?.eval?.vagueCenter?.tauVagueMin,
                  delta: (state as any)?.teacherProfile?.eval?.vagueCenter?.delta,
                  tauObj: isOpen ? (Number((state as any)?.teacherProfile?.eval?.vagueCenter?.tauObjOpen ?? th.semThresh)) : (Number((state as any)?.teacherProfile?.eval?.vagueCenter?.tauObjClosed ?? th.semThresh))
                } },
                { hintsUsed }
              );
              cls = { kind: sem.kind, matched: sem.matched, missing: sem.missing, sem: sem.sem };
              vague = false;
            }
            // Exigir al menos 1 keyword para PARTIAL (no aplica si ACCEPT)
            if (!vague && cls?.kind !== 'ACCEPT') {
              try {
                const kwMin = Number(((coursePolicies as any)?.evaluation?.thresholds?.keywordMin) ?? 1);
                const kws = Array.isArray(expected) ? expected : [];
                const textN = String(pendingInput || '').toLowerCase();
                const kwHits = kws.filter(k => textN.includes(String(k).toLowerCase())).length;
                if (kwHits < kwMin) { (cls as any).kind = 'HINT'; }
              } catch {}
            }
            // Capturar evaluaci√≥n para r√∫brica
            lastClsKind = cls.kind as any;
            lastMatched = Array.isArray(cls.matched) ? cls.matched : [];
            lastMissing = Array.isArray(cls.missing) ? cls.missing : [];
            lastAttempts = attempts;
            lastHints = hintsUsed;
            lastStepCodeForAssess = stepCode;
          }
          
          // Endurecer aceptaci√≥n en SALUDO/CONEXI√ìN (evitar falsos ACCEPT)
          const isSaludoConexion = ['SALUDO','CONEXION'].includes(momentKind);
          const isMeta = String(qtype).includes('abierta') || isSaludoConexion;
          
          // Aceptaci√≥n en metacognitivas: permitir avance con 1 se√±al v√°lida
          if (isMeta && cls.kind === 'ACCEPT') {
            const matchedCount = (cls.matched || []).length;
            const strongEnough = matchedCount >= 1;
            if (!strongEnough) {
              (cls as any).kind = 'HINT';
            }
          }
          
          // Regla del cuadro: PARTIAL -> Avanza y registra pendientes (sin reask)
          if (!vague && cls.kind === 'PARTIAL') {
            try {
              // Registrar pendientes y marcar como parcialmente respondida
              const faltos = Array.isArray(cls.missing) ? cls.missing.slice(0, 3) : [];
              (state as any).partiallyAnsweredAskCodes = Array.from(new Set([
                (((state as any).partiallyAnsweredAskCodes || []) as string[]), stepCode
              ]));
              (state as any).pendingRemediation = (state as any).pendingRemediation || {};
              if (faltos.length) (state as any).pendingRemediation[stepCode] = faltos;

              // Feedback breve de tipo PARCIAL
              let fb = '';
              try {
                const fbCfg: any = (coursePolicies as any)?.feedback || {};
                const recent = await getRecentHistory(sessionKey, 4);
                const llm = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 2), allowQuestions: fbCfg.allowQuestions !== false, kind: 'PARTIAL' as any, recentHistory: recent });
                fb = llm.message || '';
              } catch {}

              // Avanzar y preparar siguiente paso
              state = next(state);
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}

              let nextMsg = '';
              const nextStep = currentStep(state);
              if (nextStep?.type === 'NARRATION' || nextStep?.type === 'CONTENT') {
                const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                const stepKey = `${nextStep.momentIndex}-${nextStep.stepIndex}`;
                if (!(shownMap as any)[stepKey]) {
                  try {
                    const recent = await getRecentHistory(sessionKey, 4);
                    const explain = await runDocenteLLM({ language: 'es', action: 'explain', stepType: nextStep.type, narrationText: nextStep.data?.text || '', contentBody: nextStep.data?.body || [], caseText: (nextStep.data as any)?.case || '', objective: String(nextStep.data?.objective || state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                    if ((explain.message || '').trim()) { nextMsg = explain.message!; (shownMap as any)[stepKey] = true; }
                  } catch { nextMsg = ''; }
                }
                state = next(state);
                SESSIONS.set(sessionKey, state);
                try { await getSessionStore().set(sessionKey, state); } catch {}
              }

              const nextAskStep = currentStep(state);
              if (nextAskStep?.type === 'ASK') {
                followUp = nextAskStep.data?.question || '';
                state.justAskedFollowUp = Boolean(followUp);
              }
              message = [fb, nextMsg].filter(Boolean).join('\n\n');
              dbg = { ...(dbg || {}), kind: 'PARTIAL', feedbackKind: 'PARTIAL', matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], stepCode };
              pendingInput = '';
              break;
            } catch {}
          }
          
          // En metacognitiva (Saludo) NO aceptar respuestas DONT_KNOW/VAGUE ni por longitud.
          // La aceptaci√≥n debe basarse en se√±ales reales del objetivo/expected o acceptable.
          // Feedback determinista usando util reutilizable
          if (!vague && cls.kind === 'ACCEPT') {
            let fb = '';
            try {
              const fbCfg: any = (coursePolicies as any)?.feedback || {};
              const recent = await getRecentHistory(sessionKey, 4);
              const llm = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: fbCfg.allowQuestions !== false, kind: 'ACCEPT' as any, recentHistory: recent });
              fb = llm.message || '';
            } catch {}
            
            // ‚úÖ Marcar cumplimiento de la ASK actual
            state.answeredAskCodes = Array.isArray(state.answeredAskCodes) ? state.answeredAskCodes : [];
            const code = act.step.data?.code || stepCode;
            if (!state.answeredAskCodes.includes(code)) {
              state.answeredAskCodes.push(code);
            }
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            
            // Protecci√≥n de cumplimiento: verificar que la ASK actual est√© respondida antes de avanzar
            const currentStepCode = act.step.code || stepCode;
            const isAnswered = Array.isArray(state.answeredAskCodes) && state.answeredAskCodes.includes(currentStepCode);

            if (!isAnswered && act.step.type === 'ASK') {
              // No avanzar si la ASK actual no est√° respondida (excepto SALUDO/CONEXI√ìN)
              const mk = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
              const policyAllowsForce = ['SALUDO', 'CONEXION'].includes(mk);

              if (!policyAllowsForce) {
                // Re-preguntar la ASK actual
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'reask', stepCode };
                pendingInput = '';
                break;
              }
            }
            
            // Avanzar al siguiente paso en orden secuencial (no saltar ASKs)
            state = next(state);
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            
            // Componer salida seg√∫n el tipo de paso siguiente
            let nextMsg = '';
            const nextStep = currentStep(state);
            
            // Debug: verificar qu√© paso es el siguiente
            if (process.env.ENGINE_DEBUG === 'true') {
              console.log('[AVANCE_ACCEPT]', { 
                nextStepType: nextStep?.type, 
                nextStepCode: nextStep?.code,
                nextStepText: nextStep?.data?.text?.slice(0, 50),
                momentIndex: nextStep?.momentIndex,
                stepIndex: nextStep?.stepIndex
              });
            }
            
            if (nextStep?.type === 'NARRATION' || nextStep?.type === 'CONTENT') {
              // Blindaje anti-repetici√≥n: verificar si ya se mostr√≥ este contenido
              const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
              const stepKey = `${nextStep.momentIndex}-${nextStep.stepIndex}`;
              
              if (!(shownMap as any)[stepKey]) {
                // Si NO se ha mostrado, ejecutarlo y marcar como mostrado
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const explain = await runDocenteLLM({ 
                    language: 'es', 
                    action: 'explain', 
                    stepType: nextStep.type, 
                    narrationText: nextStep.data?.text || '',
                    contentBody: nextStep.data?.body || [],
                    caseText: (nextStep.data as any)?.case || '',
                    objective: String(nextStep.data?.objective || state.plan?.meta?.lesson_name || ''),
                    recentHistory: recent 
                  });
                  // Blindaje: solo marcar como mostrado si hay contenido real
                  if ((explain.message || '').trim()) {
                    nextMsg = explain.message!;
                    (shownMap as any)[stepKey] = true; // marca solo si hubo contenido
                  } else {
                    nextMsg = '';
                    // NO marcar shownMap si est√° vac√≠o
                  }
                  
                  // Debug: confirmar que se ejecut√≥ la narrativa
                  if (process.env.ENGINE_DEBUG === 'true') {
                    console.log('[NARRATIVA_EJECUTADA]', { 
                      stepKey, 
                      nextMsgLength: nextMsg.length,
                      nextMsgPreview: nextMsg.slice(0, 100)
                    });
                  }
                } catch (error) { 
                  nextMsg = '';
                  if (process.env.ENGINE_DEBUG === 'true') {
                    console.log('[NARRATIVA_ERROR]', { stepKey, error: String(error) });
                  }
                }
              } else {
                // Debug: confirmar que ya se mostr√≥
                if (process.env.ENGINE_DEBUG === 'true') {
                  console.log('[NARRATIVA_YA_MOSTRADA]', { stepKey });
                }
              }
              // Avanzar al siguiente paso despu√©s de la narrativa (se haya mostrado o no)
              state = next(state);
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
            }
            
            // Si hay una pregunta siguiente, ponerla como followUp
            const nextAskStep = currentStep(state);
            if (nextAskStep?.type === 'ASK') {
              followUp = nextAskStep.data?.question || '';
              state.justAskedFollowUp = Boolean(followUp);
              dbg = { ...(dbg || {}), messageType: 'ask', nextAction: 'ask' };
            }
            
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            message = composeUniqueText(fb, nextMsg);
            
            // Debug: verificar la composici√≥n final del mensaje
            if (process.env.ENGINE_DEBUG === 'true') {
              console.log('[MENSAJE_FINAL]', { 
                fbLength: fb.length,
                nextMsgLength: nextMsg.length,
                messageLength: message.length,
                messagePreview: message.slice(0, 200),
                hasNarrativa: nextMsg.length > 0
              });
            }
            dbg = { ...(dbg || {}), kind: 'ACCEPT', feedbackKind: 'ACCEPT', matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], stepCode };
					pendingInput = '';
            break;
				}
          // Contabilizar respuesta previa y contadores separados para 'no s√©'
          state.lastAnswerByAskCode![stepCode] = pendingInput;
          const noSeMap = state.noSeCountByAskCode || (state.noSeCountByAskCode = {});
          // Detecci√≥n real de "no s√©" / evasivas - M√ÅS PERMISIVO
          const isNo = isNoSeInput(pendingInput);
          if (isNo) {
            noSeMap[stepCode] = (noSeMap[stepCode] || 0) + 1;
            // Si es "no s√©", adem√°s de noSeCount, cuenta intento pedag√≥gico
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          } else {
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          }
          const vagueCfg = coursePolicies?.vague || {};
          if (vague || cls.kind === 'HINT' || isNo || cls.reason === 'MAX_HINTS' || cls.reason === 'SEM_LOW') {
            // Pol√≠tica de reintentos por pregunta (loop control)
            const lastActionMap = state.lastActionByAskCode || (state.lastActionByAskCode = {});
            const hintsMap = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
            const attempts = state.attemptsByAskCode[stepCode] || 0;
            const currentHints = hintsMap[stepCode] || 0;
            const lastAction = (lastActionMap[stepCode] as any) || 'ask';
            // Avance forzado temprano: tras 2 "no se" consecutivos en momentos permitidos
            try {
              const momentKindNow = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
              const noSeCountNow = state.noSeCountByAskCode?.[stepCode] || 0;
              if (isNo && forceNoSeThreshold > 0 && noSeCountNow >= forceNoSeThreshold && Array.isArray(allowForcedOn) && allowForcedOn.includes(momentKindNow)) {
                // Mover a la siguiente ASK del mismo ciclo, respetando narrativa previa
                const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
                if (typeof nextAskIdx === 'number') {
                  try {
                    const steps: any[] = state?.plan?.allSteps || [];
                    const ask = steps[nextAskIdx];
                    const targetMoment = ask?.momentIndex;
                    let narrationIdx: number | undefined = undefined;
                    for (let i = 0; i < steps.length; i++) {
                      const s = steps[i];
                      if (s?.momentIndex !== targetMoment) continue;
                      if (s.stepIndex < ask.stepIndex && (s.type === 'NARRATION' || s.type === 'CONTENT')) { narrationIdx = i; break; }
                      if (s.stepIndex >= ask.stepIndex) break;
                    }
                    if (typeof narrationIdx === 'number') {
                      const stKey = `${steps[narrationIdx].momentIndex}-${steps[narrationIdx].stepIndex}`;
                      const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                      if (!(shownMap as any)[stKey]) {
                        try {
                          const recent = await getRecentHistory(sessionKey, 4);
                          const explain = await runDocenteLLM({ language: 'es', action: 'explain', stepType: steps[narrationIdx].type, narrationText: steps[narrationIdx].data?.text || '', contentBody: steps[narrationIdx].data?.body || [], objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                          message = composeUniqueText(message, explain.message || '');
                          (shownMap as any)[stKey] = true;
                        } catch {}
                      }
                    }
                  } catch {}
                  state = advanceTo(state, nextAskIdx);
                  followUp = (currentStep(state) as any)?.data?.question || '';
                  state.justAskedFollowUp = Boolean(followUp);
                  state.lastFollowUpText = followUp;
                }
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = composeUniqueText(message, bridge.message);
                } catch {}
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'force_advance', stepCode };
                pendingInput = '';
                break;
              }
            } catch {}
            
            // Actualizar contadores
            if (cls.kind === 'HINT' || vague || isNo) {
              hintsMap[stepCode] = (currentHints || 0) + 1;   // <‚Äî SIEMPRE suma
              lastActionMap[stepCode] = 'hint';
            }
            
            // Detectar si el estudiante est√° haciendo una pregunta (solo si NO es no‚Äës√©/vago/HINT)
            const shouldClarify = !vague && !isNo && cls.kind !== 'HINT' && isStudentAskingQuestion(pendingInput, (state as any).teacherProfile);
            if (shouldClarify) {
              // Ruta clarify: insertar micro-explicaci√≥n del objetivo actual
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const clarify = await runDocenteLLM({ 
                  language: 'es', 
                  action: 'explain', 
                  stepType: 'ASK', 
                  objective: String(act.step.data.objective || ''),
                  contentBody: [String(act.step.data.objective || '')],
                  recentHistory: recent 
                });
                message = clarify.message || '';
                // Re-preguntar la ASK actual con reformulaci√≥n
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                dbg = { kind: 'CLARIFY', matched: [], missing: [], nextAction: 'clarify', stepCode };
              } catch {
                message = '';
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
              }
              pendingInput = '';
              break;
            }
            
            // Pol√≠tica de reintentos: 0‚ÜíHINT_1, 1‚ÜíHINT_2, ‚â•2‚Üíopciones o transici√≥n pedag√≥gica
            let fb = '';
            if (attempts < maxAttempts && (cls.kind === 'HINT' || vague || isNo)) {
              // Mensaje alentador exclusivamente desde LLM
              try {
                const fbCfg: any = (coursePolicies as any)?.feedback || {};
                const recent = await getRecentHistory(sessionKey, 4);
                const llmFb = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: fbCfg.allowQuestions !== false, kind: cls.kind as any, recentHistory: recent });
                fb = llmFb.message || '';
              } catch {}
              // Pista y micro‚Äëpregunta exclusivamente desde LLM
              {
                const objText = String(act.step.data.objective || state.plan?.meta?.lesson_name || '');
                const expectedArr = Array.isArray(expected) ? expected : [];
                const missingArr = Array.isArray(cls.missing) ? cls.missing : [];
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const llmHint = await runDocenteLLM({
                    language: 'es',
                    action: 'hint',
                    stepType: 'ASK',
                    questionText: q,
                    userAnswer: pendingInput,
                    matched: cls.matched,
                    missing: missingArr,
                    objective: objText,
                    contentBody: expectedArr,
                    hintWordLimit: Number((coursePolicies?.hints?.wordLimits || [16])[0] || 16),
                    allowQuestions: true,
                    recentHistory: recent,
                    attempts,
                    hintsUsed
                  } as any);
                  const hintMsg = llmHint.message || '';
                  // Micro‚Äëpregunta primero y luego la pista (y mantener followUp)
                  let fu = (llmHint.followUp || '').trim();
                  if (!fu) {
                    try {
                      const recent2 = await getRecentHistory(sessionKey, 4);
                      const reask2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: objText, recentHistory: recent2 });
                      fu = (reask2.followUp || reask2.message || q || '').trim();
                    } catch {
                      fu = q;
                    }
                  }
                  message = composeUniqueText(fb, fu, hintMsg);
                  followUp = fu || q;
                } catch {
                  message = fb || '';
                  followUp = q;
                }

                // Anti‚Äërepetici√≥n de follow‚Äëup con LLM
                if (state.lastFollowUpText && state.lastFollowUpText === followUp) {
                  try {
                    const recent2 = await getRecentHistory(sessionKey, 4);
                    const reask2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: objText, recentHistory: recent2 });
                    followUp = reask2.followUp || reask2.message || q;
                  } catch { followUp = q; }
                }
                state.justAskedFollowUp = Boolean(followUp);
                state.lastFollowUpText = followUp;
                hintsMap[stepCode] = (hintsMap[stepCode] || 0) + 1;   // solo si emitimos hint
              }
              dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              pendingInput = '';
              break;
            }
            // Transici√≥n pedag√≥gica: usar decideNextAction en lugar de DEFAULT_ACCEPT agresivo
            {
              const momentKind = state.plan?.moments?.[act.step.momentIndex]?.code || '';
              const lastAction = state.lastActionByAskCode?.[stepCode] || '';
              const noSeCount = state.noSeCountByAskCode?.[stepCode] || 0;
              
              const earlyForce = (cls.kind === 'HINT') && (forceNoSeThreshold > 0) && (noSeCount >= forceNoSeThreshold) && allowForcedOn.includes(momentKind);
              const nextAction = (earlyForce || (attempts >= maxAttempts && cls.kind === 'HINT')) ? 'force_advance' : decideNextAction({
                lastAction,
                noSeCount,
                attempts,
                momentKind
              });
              
              if (nextAction === 'force_advance') {
                // En avance forzado: omitir feedback determinista; el puente vendr√° del LLM
                // Avance forzado respetando orden del JSON: NARRATION/CONTENT -> ASK
                const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
                if (typeof nextAskIdx === 'number') {
                  try {
                    // Intentar emitir narrativa previa del mismo momento si existe
                    const steps: any[] = state?.plan?.allSteps || [];
                    const ask = steps[nextAskIdx];
                    const targetMoment = ask?.momentIndex;
                    let narrationIdx: number | undefined = undefined;
                    for (let i = 0; i < steps.length; i++) {
                      const s = steps[i];
                      if (s?.momentIndex !== targetMoment) continue;
                      if (s.stepIndex < ask.stepIndex && (s.type === 'NARRATION' || s.type === 'CONTENT')) { narrationIdx = i; break; }
                      if (s.stepIndex >= ask.stepIndex) break;
                    }
                    if (typeof narrationIdx === 'number') {
                      // Emitir narrativa si no se mostr√≥
                      const stKey = `${steps[narrationIdx].momentIndex}-${steps[narrationIdx].stepIndex}`;
                      const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
                      if (!(shownMap as any)[stKey]) {
                        try {
                          const recent = await getRecentHistory(sessionKey, 4);
                          const explain = await runDocenteLLM({ language: 'es', action: 'explain', stepType: steps[narrationIdx].type, narrationText: steps[narrationIdx].data?.text || '', contentBody: steps[narrationIdx].data?.body || [], objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                          message = composeUniqueText(message, explain.message || '');
                          (shownMap as any)[stKey] = true;
                        } catch {}
                      }
                    }
                  } catch {}
                  // Posicionar en la ASK objetivo y setear followUp
                  state = advanceTo(state, nextAskIdx);
                  followUp = (currentStep(state) as any)?.data?.question || '';
                  state.justAskedFollowUp = Boolean(followUp);
                  state.lastFollowUpText = followUp;
                }
                // Puente breve (si procede)
                try {
                  // Feedback breve del LLM antes del puente
                  try {
                    const fbCfg: any = (coursePolicies as any)?.feedback || {};
                    const recent = await getRecentHistory(sessionKey, 4);
                    const llmFb = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 2), allowQuestions: fbCfg.allowQuestions !== false, kind: cls.kind as any, recentHistory: recent });
                    message = composeUniqueText(message, llmFb.message || '');
                  } catch {}
                  const recent = await getRecentHistory(sessionKey, 4);
                  const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = composeUniqueText(message, bridge.message);
                } catch {}
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'force_advance', stepCode };
              } else if (nextAction === 'options') {
                // Presentar opciones basadas en expected
                const items = (expected || []).filter(Boolean).slice(0, 5);
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const llm = await runDocenteLLM({
                    language: 'es',
                    action: 'ask_options',
                    stepType: 'ASK',
                    questionText: q,
                    optionItems: items,
                    recentHistory: recent
                  } as any);
                  message = llm.message || '';
                  followUp = '';
                  state.justAskedFollowUp = false;
                } catch {
                  message = q;
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'options';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'options', stepCode };
              } else if (nextAction === 'reask') {
                // Reformular pregunta breve con LLM
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const reask = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = '';
                  followUp = reask.followUp || reask.message || q;
                  state.justAskedFollowUp = Boolean(followUp);
                } catch {
                  message = '';
                  followUp = q;
                  state.justAskedFollowUp = Boolean(followUp);
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'reask';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'reask', stepCode };
              } else if (nextAction === 'hint') {
                // Emitir una pista adicional breve exclusivamente desde LLM
                try {
                  const objText = String(act.step.data.objective || state.plan?.meta?.lesson_name || '');
                  const expectedArr = Array.isArray(expected) ? expected : [];
                  const missingArr = Array.isArray(cls.missing) ? cls.missing : [];
                  const recent = await getRecentHistory(sessionKey, 4);
                  const llmHint2 = await runDocenteLLM({
                    language: 'es',
                    action: 'hint',
                    stepType: 'ASK',
                    questionText: q,
                    userAnswer: pendingInput,
                    matched: cls.matched,
                    missing: missingArr,
                    objective: objText,
                    contentBody: expectedArr,
                    hintWordLimit: Number((coursePolicies?.hints?.wordLimits || [16])[0] || 16),
                    allowQuestions: true,
                    recentHistory: recent
                  } as any);
                  message = llmHint2.message || '';
                  followUp = llmHint2.followUp || '';
                  state.justAskedFollowUp = Boolean(followUp);
                } catch {
                  message = '';
                  followUp = '';
                  state.justAskedFollowUp = false;
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'hint';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              } else {
                // Transici√≥n pedag√≥gica por defecto
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction, stepCode };
              }
              pendingInput = '';
              break;
            }
          }
			}
			if (act.kind === 'end') {
				try {
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({ language: 'es', action: 'end', stepType: 'END', objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm.message || '';
				} catch {
					message = '';
				}
				break;
			}
		}
		// Componer assessment (r√∫brica) si hubo una evaluaci√≥n reciente
		try {
			if (lastClsKind) {
				const ev: any = (coursePolicies as any)?.evaluation || {};
				const scoring: Record<string, number> = ev.scoring || { R2: 2, R1: 1, R0: 0 };
				const level = lastClsKind === 'ACCEPT' ? 'R2' : (lastClsKind === 'PARTIAL' ? 'R1' : 'R0');
				const levelNum = level === 'R2' ? 2 : (level === 'R1' ? 1 : 0);
				const aids = Math.max(0, lastHints);
				const aidTag = aids > 0 ? `${levelNum}${'A'.repeat(Math.min(aids, 2))}` : undefined;
				assessment = {
					level,
					score: typeof scoring[level] === 'number' ? scoring[level] : levelNum,
					tags: aidTag ? [aidTag] : [],
					matched: lastMatched,
					missing: lastMissing,
					attempt: lastAttempts,
					hintsUsed: lastHints,
					stepCode: lastStepCodeForAssess
				};
			}
		} catch {}
		
		// Garant√≠a final: siempre devolver un mensaje del docente usando datos del plan
		if (!skipGuarantee && (!message || !String(message).trim()) && (!followUp || !String(followUp).trim())) {
			try {
				const st = currentStep(state);
				const recent = await getRecentHistory(sessionKey, 4);
				if (st?.type === 'ASK') {
					const q2 = (st as any).data?.question || '';
					const llm2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q2, objective: String(((st as any).data?.objective) || state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm2.message || q2;
					followUp = llm2.followUp || followUp;
				} else {
					const d: any = (st as any)?.data || {};
					const parts = [d.title, ...(d.body || []), d.text, ...(d.items || [])].filter(Boolean) as string[];
					const bodyArr: string[] = parts as string[];
					const llm2 = await runDocenteLLM({ language: 'es', action: 'explain', stepType: (st?.type as any) || 'CONTENT', momentTitle: state.plan?.moments[(st as any)?.momentIndex || 0]?.title, objective: state.plan?.meta?.lesson_name || '', contentBody: bodyArr, recentHistory: recent });
					message = llm2.message || bodyArr.join(' ‚Äî ');
				}
			} catch {
				const st: any = currentStep(state);
				const q2 = st?.data?.question || '';
				message = q2 || message || '';
			}
		}
		// Persist history (JSONL estilo MongoDB-like)
		try {
			await appendHistory(sessionKey, {
				planUrl: state.planUrl,
				stepIdx: state.stepIdx,
				momentIdx: state.momentIdx,
				message,
				followUp
			});
		} catch {}

		// Debug logging opcional
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st = currentStep(state);
				const messageType = (dbg && dbg.messageType) || (dbg && dbg.nextAction) || (st?.type === 'ASK' ? 'ask' : String(st?.type || '').toLowerCase());
				const payload = {
					tag: 'engine.turn',
					sessionKey,
					momentTitle: state.plan?.moments?.[st?.momentIndex || 0]?.title,
					momentKind: mapMomentKind(state.plan?.moments?.[st?.momentIndex || 0]?.title),
					stepType: st?.type,
					stepIdx: state.stepIdx,
					stepCode: (st as any)?.code || dbg?.stepCode,
					classification: dbg?.kind,
					feedbackKind: dbg?.feedbackKind || dbg?.kind,
					messageType,
					matched: dbg?.matched,
					missing: dbg?.missing,
					nextAction: dbg?.nextAction,
					messageChars: (message || '').length,
					followUpChars: (followUp || '').length,
					hasFollowUp: Boolean(followUp && String(followUp).trim()),
					userInputLen: (pendingInput || '').length,
					thresholds: { jaccardMin: 0.25, semThresh: 0.48, semBest: 0.40 },
					hintsUsed: Number(state.hintsByAskCode?.[(st as any)?.code || dbg?.stepCode] || 0)
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload));
			}
		} catch {}
		// Obtener m√©tricas de presupuesto si est√° disponible
		const budgetMetrics = state.budgetCentsLeft !== undefined ? {
			budgetCentsLeft: state.budgetCentsLeft,
			escalationsUsed: state.escalationsUsed || 0,
			adaptiveMode: state.adaptiveMode || false
		} : null;

		return NextResponse.json({ 
			message, 
			followUp, 
			assessment,
			state: { stepIdx: state.stepIdx, done: state.done },
			stepCode: (currentStep(state) as any)?.code || undefined,
			momentIdx: state.momentIdx,
			budgetMetrics 
		});
	} catch (err: any) {
		return NextResponse.json({ error: String(err?.message || err) }, { status: 500 });
	}
}


```
=== EOF: app\api\engine\turn\route.ts

===  app\api\audio\transcribe\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';

export async function POST(request: NextRequest) {
  try {
    const form = await request.formData();
    const file = form.get('audio') as File | null;
    const language = (form.get('language') as string) || 'es';

    if (!file) return NextResponse.json({ error: 'Archivo de audio requerido (field: audio)' }, { status: 400 });

    const ai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const aiFile = new File([buffer], file.name || 'audio.webm', { type: file.type || 'audio/webm' });

    const result = await ai.audio.transcriptions.create({ file: aiFile, model: 'whisper-1', language });
    return NextResponse.json({ text: (result as any)?.text || '' });
  } catch (error) {
    console.error('Transcribe error:', error);
    return NextResponse.json({ error: 'Error transcribiendo audio' }, { status: 500 });
  }
}


```
=== EOF: app\api\audio\transcribe\route.ts

