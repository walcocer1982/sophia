---
repository:
  name: docenteia-v2-monolith
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-17T03:28:39.165Z
  tool: FlatRepo
statistics:
  totalFiles: 45
  totalLines: 2951
  languages:
    json: 12
    javascript: 3
    markdown: 1
    typescript: 19
    tsx: 4
    css: 1
  fileTypes:
    .json: 12
    .js: 3
    .md: 1
    .ts: 19
    "": 2
    .tsx: 4
    .css: 1
    .jsonl: 3
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "archive"]
}
```
=== EOF: tsconfig.json

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```
=== EOF: tailwind.config.js

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia-v2-monolith",
  "version": "2.0.0",
  "description": "DocenteIA V2 - Sistema educativo monolítico con Next.js",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "next lint",
    "test": "jest",
    "chat-demo": "tsx src/index.ts",
    "clean": "rm -rf .next node_modules package-lock.json && npm install",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@types/dompurify": "^3.2.0",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.6",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.536.0",
    "next": "^15.0.0",
    "openai": "^5.10.2",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/node": "^20.19.9",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^15.0.0",
    "flatrepo": "^1.2.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.7.0",
    "typescript": "^5.0.0"
  },
  "keywords": [
    "education",
    "ai",
    "chatbot",
    "typescript",
    "nextjs",
    "openai"
  ],
  "author": "KIKE (Backend) + JANKARLO (Frontend)",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```
=== EOF: package.json

===  obejtivodocenteia.md
```markdown
1) Capa de textualización docente (LLM-orchestrator)
Explica y pregunta “como docente” a partir de cada step (NARRATION/CONTENT/ASK), con persona, tono y estilo.
El motor determinista decide el paso; el LLM solo redacta con variedad, ejemplos y analogías. ok
2) Persona y estilo por curso
Inyectar course.specialist (rol, tono, guías de estilo).
Variar frases guía: “Ahora te explico…”, “Buen intento…”, “Estamos por buen camino…”, evitando repeticiones.
3) Política de turnos por tipo de step
NARRATION/CONTENT: 2–3 frases máximas sin listas ni copiar literal; no pregunta en ese turno.
ASK: formular la pregunta exacta del JSON; validar; si no alcanza, re‑preguntar con micro-variación.
4) Guardarraíles de avance
Umbrales claros (evidencia mínima: paráfrasis, ejemplo, justificación breve).
No avanzar si faltan preguntas del momento o la evidencia no cumple.
5) Evaluación semántica con rúbrica ligera
Matching contra acceptable_answers, y respaldo con objective/expected.
Parcialidades (matched/missing), y decisión ok/hint/refocus/advance.
6) Pistas escalonadas integradas al plan
Pista 1 (≈10 palabras), Pista 2 (≈20), Pista 3 (casi explicativa), derivadas de acceptable_answers y contentBody, sin spoilers.
7) Manejo de atascos y fuera de foco
Detección de DONT_KNOW/IRRELEVANT reiterado; reconduce al objetivo o micro-contenido.
Anti‑bucle y anti‑repetición de la misma pregunta.
8) Señalización y transiciones pedagógicas
Micro‑resumen de cierre + puente al siguiente objetivo/paso.
“Te adelanto qué veremos ahora…” sin spoilear respuestas.
9) Memoria de sesión docente
Intentos por pregunta, pistas usadas, matched/missing.
Referencias a aportes previos del estudiante para personalizar.
10) Biblioteca de preguntas socráticas y reformulaciones
Micro‑preguntas de descomposición (≤8 palabras), alternativas A/B, enfoques por taxonomía (recuerdo, comprensión, aplicación…).
11) Anti‑repetición y deduplicación
Normalización y filtros para no repetir la misma pregunta o frase en turnos consecutivos.
12) Narrativa con “voz docente”
Reescritura del body en texto corrido, ejemplos laborales breves, lenguaje sencillo, evitando bullets y copia literal.
13) Cierre de momento y metacognición
Checklist de objetivos alcanzados y “qué te llevas”, mini‑reflexión o plan de acción.
14) Adaptación de dificultad
Si responde con solvencia, ir a preguntas de mayor nivel; si no, simplificar y ejemplificar.
15) Métricas y trazabilidad
contentShown/Total, asksAsked/Total, attempts/hints per ask.
Logs de decisiones (acción, razón, paso).
16) Validación y saneo del JSON
Asegurar steps completos y ordenados; sin preguntas en NARRATION.
Contenido en CONTENT.body; pregunta solo en ASK.
17) Internacionalización y normas de estilo
Longitudes máximas por bloque, tono consistente, emojis/énfasis opcionales según curso.
18) UI docente
Marcar visualmente: “Explicación”, “Pregunta”, “Pista”.
Mostrar progreso por momento y paso sin distraer.
19) Pruebas de flujo end‑to‑end
Casos típicos: correcto a la primera, parcial, “no lo sé”, offtopic, reiteración.
Tests de anti‑repetición y de avance.
20) Fallbacks robustos
Si falta ASK, generar una de verificación coherente; si falta CONTENT, sintetizar a partir de KEY_*.
```
=== EOF: obejtivodocenteia.md

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    ignoreBuildErrors: false,
  },
  eslint: {
    ignoreDuringBuilds: false,
  },
}

module.exports = nextConfig
```
=== EOF: next.config.js

===  next-env.d.ts
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```
=== EOF: next-env.d.ts

===  .npmrc
```
target_platform=linux
target_arch=x64
cache=/tmp/.npm
force=true
```
=== EOF: .npmrc

===  archive\.gitkeep
```


```
=== EOF: archive\.gitkeep

===  app\layout.tsx
```tsx
import './globals.css';
export const metadata = { title: 'DocenteIA', description: 'Lección guiada por JSON' };

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="es">
      <body className="min-h-screen">{children}</body>
    </html>
  )
}
```
=== EOF: app\layout.tsx

===  app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }
}

@layer base {
  * { @apply border-border; }
  body { @apply bg-background text-foreground; font-feature-settings: "rlig" 1, "calt" 1; }
}


```
=== EOF: app\globals.css

===  .vscode\settings.json
```json
{
    "files.autoSave": "afterDelay",
    "files.autoSaveDelay": 1000,
    "files.autoSaveWorkspaceFilesOnly": false,
    "files.autoSaveDelay": 1000,
    "editor.formatOnSave": true,
    "editor.formatOnPaste": true,
    "editor.formatOnType": true,
    "typescript.preferences.includePackageJsonAutoImports": "on",
    "typescript.suggest.autoImports": true,
    "typescript.updateImportsOnFileMove.enabled": "always",
    "editor.codeActionsOnSave": {
        "source.fixAll.eslint": "explicit",
        "source.organizeImports": "explicit"
    },
    "files.exclude": {
        "**/.git": true,
        "**/.svn": true,
        "**/.hg": true,
        "**/CVS": true,
        "**/.DS_Store": true,
        "**/Thumbs.db": true,
        "**/node_modules": true,
        "**/.next": true,
        "**/dist": true,
        "**/build": true
    },
    "search.exclude": {
        "**/node_modules": true,
        "**/.next": true,
        "**/dist": true,
        "**/build": true,
        "**/package-lock.json": true
    },
    "files.watcherExclude": {
        "**/.git/objects/**": true,
        "**/.git/subtree-cache/**": true,
        "**/node_modules/**": true,
        "**/.next/**": true,
        "**/dist/**": true,
        "**/build/**": true
    }
}
```
=== EOF: .vscode\settings.json

===  .vscode\launch.json
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Next.js: debug server-side",
            "type": "node",
            "request": "launch",
            "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
            "args": [
                "dev"
            ],
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal",
            "skipFiles": [
                "<node_internals>/**"
            ]
        },
        {
            "name": "Next.js: debug client-side",
            "type": "chrome",
            "request": "launch",
            "url": "http://localhost:3000"
        },
        {
            "name": "Next.js: debug full stack",
            "type": "node",
            "request": "launch",
            "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
            "args": [
                "dev"
            ],
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "serverReadyAction": {
                "pattern": "started server on .+, url: (https?://.+)",
                "uriFormat": "%s",
                "action": "debugWithChrome"
            }
        }
    ]
}
```
=== EOF: .vscode\launch.json

===  .vscode\extensions.json
```json
{
    "recommendations": [
        "bradlc.vscode-tailwindcss",
        "esbenp.prettier-vscode",
        "dbaeumer.vscode-eslint",
        "ms-vscode.vscode-typescript-next",
        "formulahendry.auto-rename-tag",
        "christian-kohler.path-intellisense",
        "ms-vscode.vscode-json"
    ]
}
```
=== EOF: .vscode\extensions.json

===  .data\sessions.json
```json
{"sessions":{"plan-1755304529774-nofsde57":{"state":{"planUrl":"/courses/SSO001/lessons/lesson02.json","plan":{"meta":{"lesson_id":"SSO001_lesson02","lesson_name":"Procedimientos de Seguridad","version":"1.0.0","language":"es","ordered":true,"generated_at":"2025-08-14T00:00:00Z"},"moments":[{"title":"Saludo","code":"M1","order":1,"steps":[{"momentIndex":0,"stepIndex":0,"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","data":{"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","items":["Comprender qué es un procedimiento de seguridad","Identificar sus componentes principales","Aplicar criterios básicos de selección de EPP"]}},{"momentIndex":0,"stepIndex":1,"code":"M1-KP01","order":2,"type":"KEY_POINTS","data":{"code":"M1-KP01","order":2,"type":"KEY_POINTS","items":["Qué es un procedimiento","Por qué es importante","Cómo se aplica"]}},{"momentIndex":0,"stepIndex":2,"code":"M1-N01","order":3,"type":"NARRATION","data":{"code":"M1-N01","order":3,"type":"NARRATION","text":"Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo."}},{"momentIndex":0,"stepIndex":3,"code":"M1-Q01","order":4,"type":"ASK","data":{"code":"M1-Q01","order":4,"type":"ASK","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","objective":"Elicitar expectativas del estudiante","acceptable_answers":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"],"question_type":"metacognitiva"}}]},{"title":"Conexión","code":"M2","order":2,"steps":[{"momentIndex":1,"stepIndex":0,"code":"M2-N01","order":1,"type":"NARRATION","data":{"code":"M2-N01","order":1,"type":"NARRATION","text":"Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes."}},{"momentIndex":1,"stepIndex":1,"code":"M2-Q01","order":2,"type":"ASK","data":{"code":"M2-Q01","order":2,"type":"ASK","question":"¿Qué elementos de seguridad identificas en esta situación?","objective":"Activar conocimientos previos","acceptable_answers":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"],"question_type":"diagnóstica"}},{"momentIndex":1,"stepIndex":2,"code":"M2-Q02","order":3,"type":"ASK","data":{"code":"M2-Q02","order":3,"type":"ASK","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","objective":"Conciencia de riesgos","acceptable_answers":["caídas","lesiones","accidentes","sanciones","multas"],"question_type":"reflexiva"}}]},{"title":"Adquisición","code":"M3","order":3,"steps":[{"momentIndex":2,"stepIndex":0,"code":"M3-C01","order":1,"type":"CONTENT","data":{"code":"M3-C01","order":1,"type":"CONTENT","title":"Definición de procedimiento de seguridad","body":["PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"]}},{"momentIndex":2,"stepIndex":1,"code":"M3-Q01","order":2,"type":"ASK","data":{"code":"M3-Q01","order":2,"type":"ASK","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","objective":"Comprender la definición","acceptable_answers":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"],"question_type":"conceptual"}},{"momentIndex":2,"stepIndex":2,"code":"M3-C02","order":3,"type":"CONTENT","data":{"code":"M3-C02","order":3,"type":"CONTENT","title":"Partes de un procedimiento","body":["Objetivo","Alcance","Responsabilidades","Pasos específicos","EPP requerido","Medidas de emergencia","Registros"]}},{"momentIndex":2,"stepIndex":3,"code":"M3-Q02","order":4,"type":"ASK","data":{"code":"M3-Q02","order":4,"type":"ASK","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","objective":"Identificar componentes","acceptable_answers":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"],"question_type":"listado"}},{"momentIndex":2,"stepIndex":4,"code":"M3-C03","order":5,"type":"CONTENT","data":{"code":"M3-C03","order":5,"type":"CONTENT","title":"Criterios para seleccionar EPP","body":["Evaluar tipo de riesgo y nivel de exposición","Compatibilidad, ajuste y comodidad","Cumplimiento normativo y certificaciones"]}},{"momentIndex":2,"stepIndex":5,"code":"M3-Q03","order":6,"type":"ASK","data":{"code":"M3-Q03","order":6,"type":"ASK","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","objective":"Dominar criterios de selección de EPP","acceptable_answers":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"],"question_type":"aplicación"}}]},{"title":"Aplicación","code":"M4","order":4,"steps":[{"momentIndex":3,"stepIndex":0,"code":"M4-CASE01","order":1,"type":"CASE","data":{"code":"M4-CASE01","order":1,"type":"CASE","title":"Trabajo en altura en fachada","description":"Instalación de ventanas en tercer piso con uso de arnés y línea de vida.","variables":["altura > 2 m","arnés","línea de vida","supervisión","verificación de anclajes"]}},{"momentIndex":3,"stepIndex":1,"code":"M4-Q01","order":2,"type":"ASK","data":{"code":"M4-Q01","order":2,"type":"ASK","question":"¿Qué EPP mínimo usarías y por qué?","objective":"Justificar selección de EPP","acceptable_answers":["arnés con línea de vida","casco","guantes","calzado antideslizante"],"question_type":"aplicación"}}]},{"title":"Discusión","code":"M5","order":5,"steps":[{"momentIndex":4,"stepIndex":0,"code":"M5-TOP01","order":1,"type":"TOPICS","data":{"code":"M5-TOP01","order":1,"type":"TOPICS","items":["Protocolizar vs. improvisar","Cultura de seguridad"]}},{"momentIndex":4,"stepIndex":1,"code":"M5-Q01","order":2,"type":"ASK","data":{"code":"M5-Q01","order":2,"type":"ASK","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","objective":"Comparar enfoques","acceptable_answers":["estandariza","reduce errores","trazabilidad","cumplimiento"],"question_type":"argumentativa"}}]},{"title":"Reflexión","code":"M6","order":6,"steps":[{"momentIndex":5,"stepIndex":0,"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","data":{"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","items":["Hábitos personales de seguridad","Compromisos inmediatos"]}},{"momentIndex":5,"stepIndex":1,"code":"M6-Q01","order":2,"type":"ASK","data":{"code":"M6-Q01","order":2,"type":"ASK","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","objective":"Plan de mejora personal","acceptable_answers":["ejemplo personal","compromiso concreto"],"question_type":"reflexiva"}}]}],"allSteps":[{"momentIndex":0,"stepIndex":0,"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","data":{"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","items":["Comprender qué es un procedimiento de seguridad","Identificar sus componentes principales","Aplicar criterios básicos de selección de EPP"]}},{"momentIndex":0,"stepIndex":1,"code":"M1-KP01","order":2,"type":"KEY_POINTS","data":{"code":"M1-KP01","order":2,"type":"KEY_POINTS","items":["Qué es un procedimiento","Por qué es importante","Cómo se aplica"]}},{"momentIndex":0,"stepIndex":2,"code":"M1-N01","order":3,"type":"NARRATION","data":{"code":"M1-N01","order":3,"type":"NARRATION","text":"Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo."}},{"momentIndex":0,"stepIndex":3,"code":"M1-Q01","order":4,"type":"ASK","data":{"code":"M1-Q01","order":4,"type":"ASK","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","objective":"Elicitar expectativas del estudiante","acceptable_answers":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"],"question_type":"metacognitiva"}},{"momentIndex":1,"stepIndex":0,"code":"M2-N01","order":1,"type":"NARRATION","data":{"code":"M2-N01","order":1,"type":"NARRATION","text":"Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes."}},{"momentIndex":1,"stepIndex":1,"code":"M2-Q01","order":2,"type":"ASK","data":{"code":"M2-Q01","order":2,"type":"ASK","question":"¿Qué elementos de seguridad identificas en esta situación?","objective":"Activar conocimientos previos","acceptable_answers":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"],"question_type":"diagnóstica"}},{"momentIndex":1,"stepIndex":2,"code":"M2-Q02","order":3,"type":"ASK","data":{"code":"M2-Q02","order":3,"type":"ASK","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","objective":"Conciencia de riesgos","acceptable_answers":["caídas","lesiones","accidentes","sanciones","multas"],"question_type":"reflexiva"}},{"momentIndex":2,"stepIndex":0,"code":"M3-C01","order":1,"type":"CONTENT","data":{"code":"M3-C01","order":1,"type":"CONTENT","title":"Definición de procedimiento de seguridad","body":["PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"]}},{"momentIndex":2,"stepIndex":1,"code":"M3-Q01","order":2,"type":"ASK","data":{"code":"M3-Q01","order":2,"type":"ASK","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","objective":"Comprender la definición","acceptable_answers":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"],"question_type":"conceptual"}},{"momentIndex":2,"stepIndex":2,"code":"M3-C02","order":3,"type":"CONTENT","data":{"code":"M3-C02","order":3,"type":"CONTENT","title":"Partes de un procedimiento","body":["Objetivo","Alcance","Responsabilidades","Pasos específicos","EPP requerido","Medidas de emergencia","Registros"]}},{"momentIndex":2,"stepIndex":3,"code":"M3-Q02","order":4,"type":"ASK","data":{"code":"M3-Q02","order":4,"type":"ASK","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","objective":"Identificar componentes","acceptable_answers":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"],"question_type":"listado"}},{"momentIndex":2,"stepIndex":4,"code":"M3-C03","order":5,"type":"CONTENT","data":{"code":"M3-C03","order":5,"type":"CONTENT","title":"Criterios para seleccionar EPP","body":["Evaluar tipo de riesgo y nivel de exposición","Compatibilidad, ajuste y comodidad","Cumplimiento normativo y certificaciones"]}},{"momentIndex":2,"stepIndex":5,"code":"M3-Q03","order":6,"type":"ASK","data":{"code":"M3-Q03","order":6,"type":"ASK","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","objective":"Dominar criterios de selección de EPP","acceptable_answers":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"],"question_type":"aplicación"}},{"momentIndex":3,"stepIndex":0,"code":"M4-CASE01","order":1,"type":"CASE","data":{"code":"M4-CASE01","order":1,"type":"CASE","title":"Trabajo en altura en fachada","description":"Instalación de ventanas en tercer piso con uso de arnés y línea de vida.","variables":["altura > 2 m","arnés","línea de vida","supervisión","verificación de anclajes"]}},{"momentIndex":3,"stepIndex":1,"code":"M4-Q01","order":2,"type":"ASK","data":{"code":"M4-Q01","order":2,"type":"ASK","question":"¿Qué EPP mínimo usarías y por qué?","objective":"Justificar selección de EPP","acceptable_answers":["arnés con línea de vida","casco","guantes","calzado antideslizante"],"question_type":"aplicación"}},{"momentIndex":4,"stepIndex":0,"code":"M5-TOP01","order":1,"type":"TOPICS","data":{"code":"M5-TOP01","order":1,"type":"TOPICS","items":["Protocolizar vs. improvisar","Cultura de seguridad"]}},{"momentIndex":4,"stepIndex":1,"code":"M5-Q01","order":2,"type":"ASK","data":{"code":"M5-Q01","order":2,"type":"ASK","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","objective":"Comparar enfoques","acceptable_answers":["estandariza","reduce errores","trazabilidad","cumplimiento"],"question_type":"argumentativa"}},{"momentIndex":5,"stepIndex":0,"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","data":{"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","items":["Hábitos personales de seguridad","Compromisos inmediatos"]}},{"momentIndex":5,"stepIndex":1,"code":"M6-Q01","order":2,"type":"ASK","data":{"code":"M6-Q01","order":2,"type":"ASK","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","objective":"Plan de mejora personal","acceptable_answers":["ejemplo personal","compromiso concreto"],"question_type":"reflexiva"}}],"contentCycles":[{"contentStepIndex":-1,"askStepIndices":[3,5,6]},{"contentStepIndex":7,"askStepIndices":[8]},{"contentStepIndex":9,"askStepIndices":[10]},{"contentStepIndex":11,"askStepIndices":[12,14,16,18]}],"askCatalog":[{"globalIndex":3,"momentIndex":0,"stepIndex":3,"code":"M1-Q01","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","acceptable":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"]},{"globalIndex":5,"momentIndex":1,"stepIndex":1,"code":"M2-Q01","question":"¿Qué elementos de seguridad identificas en esta situación?","acceptable":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"]},{"globalIndex":6,"momentIndex":1,"stepIndex":2,"code":"M2-Q02","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","acceptable":["caídas","lesiones","accidentes","sanciones","multas"]},{"globalIndex":8,"momentIndex":2,"stepIndex":1,"code":"M3-Q01","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","acceptable":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"]},{"globalIndex":10,"momentIndex":2,"stepIndex":3,"code":"M3-Q02","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","acceptable":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"]},{"globalIndex":12,"momentIndex":2,"stepIndex":5,"code":"M3-Q03","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","acceptable":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"]},{"globalIndex":14,"momentIndex":3,"stepIndex":1,"code":"M4-Q01","question":"¿Qué EPP mínimo usarías y por qué?","acceptable":["arnés con línea de vida","casco","guantes","calzado antideslizante"]},{"globalIndex":16,"momentIndex":4,"stepIndex":1,"code":"M5-Q01","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","acceptable":["estandariza","reduce errores","trazabilidad","cumplimiento"]},{"globalIndex":18,"momentIndex":5,"stepIndex":1,"code":"M6-Q01","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","acceptable":["ejemplo personal","compromiso concreto"]}]},"momentIdx":1,"stepIdx":5,"attemptsByAskCode":{},"hintsByAskCode":{},"lastAnswerByAskCode":{},"noSeCountByAskCode":{},"lastActionByAskCode":{},"justAskedFollowUp":true,"askedAskCodes":[],"answeredAskCodes":[],"done":false},"lastActivity":1755311817742},"plan-1755314867175-r5b9uhf3":{"state":{"planUrl":"/courses/SSO001/lessons/lesson02.json","plan":{"meta":{"lesson_id":"SSO001_lesson02","lesson_name":"Procedimientos de Seguridad","version":"1.0.0","language":"es","ordered":true,"generated_at":"2025-08-14T00:00:00Z"},"moments":[{"title":"Saludo","code":"M1","order":1,"steps":[{"momentIndex":0,"stepIndex":0,"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","data":{"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","items":["Comprender qué es un procedimiento de seguridad","Identificar sus componentes principales","Aplicar criterios básicos de selección de EPP"]}},{"momentIndex":0,"stepIndex":1,"code":"M1-KP01","order":2,"type":"KEY_POINTS","data":{"code":"M1-KP01","order":2,"type":"KEY_POINTS","items":["Qué es un procedimiento","Por qué es importante","Cómo se aplica"]}},{"momentIndex":0,"stepIndex":2,"code":"M1-N01","order":3,"type":"NARRATION","data":{"code":"M1-N01","order":3,"type":"NARRATION","text":"Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo."}},{"momentIndex":0,"stepIndex":3,"code":"M1-Q01","order":4,"type":"ASK","data":{"code":"M1-Q01","order":4,"type":"ASK","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","objective":"Elicitar expectativas del estudiante","acceptable_answers":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"],"question_type":"metacognitiva"}}]},{"title":"Conexión","code":"M2","order":2,"steps":[{"momentIndex":1,"stepIndex":0,"code":"M2-N01","order":1,"type":"NARRATION","data":{"code":"M2-N01","order":1,"type":"NARRATION","text":"Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes."}},{"momentIndex":1,"stepIndex":1,"code":"M2-Q01","order":2,"type":"ASK","data":{"code":"M2-Q01","order":2,"type":"ASK","question":"¿Qué elementos de seguridad identificas en esta situación?","objective":"Activar conocimientos previos","acceptable_answers":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"],"question_type":"diagnóstica"}},{"momentIndex":1,"stepIndex":2,"code":"M2-Q02","order":3,"type":"ASK","data":{"code":"M2-Q02","order":3,"type":"ASK","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","objective":"Conciencia de riesgos","acceptable_answers":["caídas","lesiones","accidentes","sanciones","multas"],"question_type":"reflexiva"}}]},{"title":"Adquisición","code":"M3","order":3,"steps":[{"momentIndex":2,"stepIndex":0,"code":"M3-C01","order":1,"type":"CONTENT","data":{"code":"M3-C01","order":1,"type":"CONTENT","title":"Definición de procedimiento de seguridad","body":["PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"]}},{"momentIndex":2,"stepIndex":1,"code":"M3-Q01","order":2,"type":"ASK","data":{"code":"M3-Q01","order":2,"type":"ASK","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","objective":"Comprender la definición","acceptable_answers":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"],"question_type":"conceptual"}},{"momentIndex":2,"stepIndex":2,"code":"M3-C02","order":3,"type":"CONTENT","data":{"code":"M3-C02","order":3,"type":"CONTENT","title":"Partes de un procedimiento","body":["Objetivo","Alcance","Responsabilidades","Pasos específicos","EPP requerido","Medidas de emergencia","Registros"]}},{"momentIndex":2,"stepIndex":3,"code":"M3-Q02","order":4,"type":"ASK","data":{"code":"M3-Q02","order":4,"type":"ASK","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","objective":"Identificar componentes","acceptable_answers":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"],"question_type":"listado"}},{"momentIndex":2,"stepIndex":4,"code":"M3-C03","order":5,"type":"CONTENT","data":{"code":"M3-C03","order":5,"type":"CONTENT","title":"Criterios para seleccionar EPP","body":["Evaluar tipo de riesgo y nivel de exposición","Compatibilidad, ajuste y comodidad","Cumplimiento normativo y certificaciones"]}},{"momentIndex":2,"stepIndex":5,"code":"M3-Q03","order":6,"type":"ASK","data":{"code":"M3-Q03","order":6,"type":"ASK","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","objective":"Dominar criterios de selección de EPP","acceptable_answers":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"],"question_type":"aplicación"}}]},{"title":"Aplicación","code":"M4","order":4,"steps":[{"momentIndex":3,"stepIndex":0,"code":"M4-CASE01","order":1,"type":"CASE","data":{"code":"M4-CASE01","order":1,"type":"CASE","title":"Trabajo en altura en fachada","description":"Instalación de ventanas en tercer piso con uso de arnés y línea de vida.","variables":["altura > 2 m","arnés","línea de vida","supervisión","verificación de anclajes"]}},{"momentIndex":3,"stepIndex":1,"code":"M4-Q01","order":2,"type":"ASK","data":{"code":"M4-Q01","order":2,"type":"ASK","question":"¿Qué EPP mínimo usarías y por qué?","objective":"Justificar selección de EPP","acceptable_answers":["arnés con línea de vida","casco","guantes","calzado antideslizante"],"question_type":"aplicación"}}]},{"title":"Discusión","code":"M5","order":5,"steps":[{"momentIndex":4,"stepIndex":0,"code":"M5-TOP01","order":1,"type":"TOPICS","data":{"code":"M5-TOP01","order":1,"type":"TOPICS","items":["Protocolizar vs. improvisar","Cultura de seguridad"]}},{"momentIndex":4,"stepIndex":1,"code":"M5-Q01","order":2,"type":"ASK","data":{"code":"M5-Q01","order":2,"type":"ASK","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","objective":"Comparar enfoques","acceptable_answers":["estandariza","reduce errores","trazabilidad","cumplimiento"],"question_type":"argumentativa"}}]},{"title":"Reflexión","code":"M6","order":6,"steps":[{"momentIndex":5,"stepIndex":0,"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","data":{"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","items":["Hábitos personales de seguridad","Compromisos inmediatos"]}},{"momentIndex":5,"stepIndex":1,"code":"M6-Q01","order":2,"type":"ASK","data":{"code":"M6-Q01","order":2,"type":"ASK","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","objective":"Plan de mejora personal","acceptable_answers":["ejemplo personal","compromiso concreto"],"question_type":"reflexiva"}}]}],"allSteps":[{"momentIndex":0,"stepIndex":0,"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","data":{"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","items":["Comprender qué es un procedimiento de seguridad","Identificar sus componentes principales","Aplicar criterios básicos de selección de EPP"]}},{"momentIndex":0,"stepIndex":1,"code":"M1-KP01","order":2,"type":"KEY_POINTS","data":{"code":"M1-KP01","order":2,"type":"KEY_POINTS","items":["Qué es un procedimiento","Por qué es importante","Cómo se aplica"]}},{"momentIndex":0,"stepIndex":2,"code":"M1-N01","order":3,"type":"NARRATION","data":{"code":"M1-N01","order":3,"type":"NARRATION","text":"Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo."}},{"momentIndex":0,"stepIndex":3,"code":"M1-Q01","order":4,"type":"ASK","data":{"code":"M1-Q01","order":4,"type":"ASK","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","objective":"Elicitar expectativas del estudiante","acceptable_answers":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"],"question_type":"metacognitiva"}},{"momentIndex":1,"stepIndex":0,"code":"M2-N01","order":1,"type":"NARRATION","data":{"code":"M2-N01","order":1,"type":"NARRATION","text":"Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes."}},{"momentIndex":1,"stepIndex":1,"code":"M2-Q01","order":2,"type":"ASK","data":{"code":"M2-Q01","order":2,"type":"ASK","question":"¿Qué elementos de seguridad identificas en esta situación?","objective":"Activar conocimientos previos","acceptable_answers":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"],"question_type":"diagnóstica"}},{"momentIndex":1,"stepIndex":2,"code":"M2-Q02","order":3,"type":"ASK","data":{"code":"M2-Q02","order":3,"type":"ASK","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","objective":"Conciencia de riesgos","acceptable_answers":["caídas","lesiones","accidentes","sanciones","multas"],"question_type":"reflexiva"}},{"momentIndex":2,"stepIndex":0,"code":"M3-C01","order":1,"type":"CONTENT","data":{"code":"M3-C01","order":1,"type":"CONTENT","title":"Definición de procedimiento de seguridad","body":["PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"]}},{"momentIndex":2,"stepIndex":1,"code":"M3-Q01","order":2,"type":"ASK","data":{"code":"M3-Q01","order":2,"type":"ASK","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","objective":"Comprender la definición","acceptable_answers":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"],"question_type":"conceptual"}},{"momentIndex":2,"stepIndex":2,"code":"M3-C02","order":3,"type":"CONTENT","data":{"code":"M3-C02","order":3,"type":"CONTENT","title":"Partes de un procedimiento","body":["Objetivo","Alcance","Responsabilidades","Pasos específicos","EPP requerido","Medidas de emergencia","Registros"]}},{"momentIndex":2,"stepIndex":3,"code":"M3-Q02","order":4,"type":"ASK","data":{"code":"M3-Q02","order":4,"type":"ASK","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","objective":"Identificar componentes","acceptable_answers":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"],"question_type":"listado"}},{"momentIndex":2,"stepIndex":4,"code":"M3-C03","order":5,"type":"CONTENT","data":{"code":"M3-C03","order":5,"type":"CONTENT","title":"Criterios para seleccionar EPP","body":["Evaluar tipo de riesgo y nivel de exposición","Compatibilidad, ajuste y comodidad","Cumplimiento normativo y certificaciones"]}},{"momentIndex":2,"stepIndex":5,"code":"M3-Q03","order":6,"type":"ASK","data":{"code":"M3-Q03","order":6,"type":"ASK","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","objective":"Dominar criterios de selección de EPP","acceptable_answers":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"],"question_type":"aplicación"}},{"momentIndex":3,"stepIndex":0,"code":"M4-CASE01","order":1,"type":"CASE","data":{"code":"M4-CASE01","order":1,"type":"CASE","title":"Trabajo en altura en fachada","description":"Instalación de ventanas en tercer piso con uso de arnés y línea de vida.","variables":["altura > 2 m","arnés","línea de vida","supervisión","verificación de anclajes"]}},{"momentIndex":3,"stepIndex":1,"code":"M4-Q01","order":2,"type":"ASK","data":{"code":"M4-Q01","order":2,"type":"ASK","question":"¿Qué EPP mínimo usarías y por qué?","objective":"Justificar selección de EPP","acceptable_answers":["arnés con línea de vida","casco","guantes","calzado antideslizante"],"question_type":"aplicación"}},{"momentIndex":4,"stepIndex":0,"code":"M5-TOP01","order":1,"type":"TOPICS","data":{"code":"M5-TOP01","order":1,"type":"TOPICS","items":["Protocolizar vs. improvisar","Cultura de seguridad"]}},{"momentIndex":4,"stepIndex":1,"code":"M5-Q01","order":2,"type":"ASK","data":{"code":"M5-Q01","order":2,"type":"ASK","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","objective":"Comparar enfoques","acceptable_answers":["estandariza","reduce errores","trazabilidad","cumplimiento"],"question_type":"argumentativa"}},{"momentIndex":5,"stepIndex":0,"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","data":{"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","items":["Hábitos personales de seguridad","Compromisos inmediatos"]}},{"momentIndex":5,"stepIndex":1,"code":"M6-Q01","order":2,"type":"ASK","data":{"code":"M6-Q01","order":2,"type":"ASK","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","objective":"Plan de mejora personal","acceptable_answers":["ejemplo personal","compromiso concreto"],"question_type":"reflexiva"}}],"contentCycles":[{"contentStepIndex":-1,"askStepIndices":[3,5,6]},{"contentStepIndex":7,"askStepIndices":[8]},{"contentStepIndex":9,"askStepIndices":[10]},{"contentStepIndex":11,"askStepIndices":[12,14,16,18]}],"askCatalog":[{"globalIndex":3,"momentIndex":0,"stepIndex":3,"code":"M1-Q01","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","acceptable":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"]},{"globalIndex":5,"momentIndex":1,"stepIndex":1,"code":"M2-Q01","question":"¿Qué elementos de seguridad identificas en esta situación?","acceptable":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"]},{"globalIndex":6,"momentIndex":1,"stepIndex":2,"code":"M2-Q02","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","acceptable":["caídas","lesiones","accidentes","sanciones","multas"]},{"globalIndex":8,"momentIndex":2,"stepIndex":1,"code":"M3-Q01","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","acceptable":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"]},{"globalIndex":10,"momentIndex":2,"stepIndex":3,"code":"M3-Q02","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","acceptable":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"]},{"globalIndex":12,"momentIndex":2,"stepIndex":5,"code":"M3-Q03","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","acceptable":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"]},{"globalIndex":14,"momentIndex":3,"stepIndex":1,"code":"M4-Q01","question":"¿Qué EPP mínimo usarías y por qué?","acceptable":["arnés con línea de vida","casco","guantes","calzado antideslizante"]},{"globalIndex":16,"momentIndex":4,"stepIndex":1,"code":"M5-Q01","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","acceptable":["estandariza","reduce errores","trazabilidad","cumplimiento"]},{"globalIndex":18,"momentIndex":5,"stepIndex":1,"code":"M6-Q01","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","acceptable":["ejemplo personal","compromiso concreto"]}]},"momentIdx":2,"stepIdx":8,"attemptsByAskCode":{},"hintsByAskCode":{},"lastAnswerByAskCode":{},"noSeCountByAskCode":{},"lastActionByAskCode":{},"justAskedFollowUp":true,"askedAskCodes":[],"answeredAskCodes":[],"done":false},"lastActivity":1755319705765},"plan-1755385171765-9zn2rxmp":{"state":{"planUrl":"/courses/SSO001/lessons/lesson02.json","plan":{"meta":{"lesson_id":"SSO001_lesson02","lesson_name":"Procedimientos de Seguridad","version":"1.0.0","language":"es","ordered":true,"generated_at":"2025-08-14T00:00:00Z"},"moments":[{"title":"Saludo","code":"M1","order":1,"steps":[{"momentIndex":0,"stepIndex":0,"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","data":{"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","items":["Comprender qué es un procedimiento de seguridad","Identificar sus componentes principales","Aplicar criterios básicos de selección de EPP"]}},{"momentIndex":0,"stepIndex":1,"code":"M1-KP01","order":2,"type":"KEY_POINTS","data":{"code":"M1-KP01","order":2,"type":"KEY_POINTS","items":["Qué es un procedimiento","Por qué es importante","Cómo se aplica"]}},{"momentIndex":0,"stepIndex":2,"code":"M1-N01","order":3,"type":"NARRATION","data":{"code":"M1-N01","order":3,"type":"NARRATION","text":"Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo."}},{"momentIndex":0,"stepIndex":3,"code":"M1-Q01","order":4,"type":"ASK","data":{"code":"M1-Q01","order":4,"type":"ASK","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","objective":"Elicitar expectativas del estudiante","acceptable_answers":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"],"question_type":"metacognitiva"}}]},{"title":"Conexión","code":"M2","order":2,"steps":[{"momentIndex":1,"stepIndex":0,"code":"M2-N01","order":1,"type":"NARRATION","data":{"code":"M2-N01","order":1,"type":"NARRATION","text":"Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes."}},{"momentIndex":1,"stepIndex":1,"code":"M2-Q01","order":2,"type":"ASK","data":{"code":"M2-Q01","order":2,"type":"ASK","question":"¿Qué elementos de seguridad identificas en esta situación?","objective":"Activar conocimientos previos","acceptable_answers":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"],"question_type":"diagnóstica"}},{"momentIndex":1,"stepIndex":2,"code":"M2-Q02","order":3,"type":"ASK","data":{"code":"M2-Q02","order":3,"type":"ASK","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","objective":"Conciencia de riesgos","acceptable_answers":["caídas","lesiones","accidentes","sanciones","multas"],"question_type":"reflexiva"}}]},{"title":"Adquisición","code":"M3","order":3,"steps":[{"momentIndex":2,"stepIndex":0,"code":"M3-C01","order":1,"type":"CONTENT","data":{"code":"M3-C01","order":1,"type":"CONTENT","title":"Definición de procedimiento de seguridad","body":["PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"]}},{"momentIndex":2,"stepIndex":1,"code":"M3-Q01","order":2,"type":"ASK","data":{"code":"M3-Q01","order":2,"type":"ASK","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","objective":"Comprender la definición","acceptable_answers":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"],"question_type":"conceptual"}},{"momentIndex":2,"stepIndex":2,"code":"M3-C02","order":3,"type":"CONTENT","data":{"code":"M3-C02","order":3,"type":"CONTENT","title":"Partes de un procedimiento","body":["Objetivo","Alcance","Responsabilidades","Pasos específicos","EPP requerido","Medidas de emergencia","Registros"]}},{"momentIndex":2,"stepIndex":3,"code":"M3-Q02","order":4,"type":"ASK","data":{"code":"M3-Q02","order":4,"type":"ASK","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","objective":"Identificar componentes","acceptable_answers":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"],"question_type":"listado"}},{"momentIndex":2,"stepIndex":4,"code":"M3-C03","order":5,"type":"CONTENT","data":{"code":"M3-C03","order":5,"type":"CONTENT","title":"Criterios para seleccionar EPP","body":["Evaluar tipo de riesgo y nivel de exposición","Compatibilidad, ajuste y comodidad","Cumplimiento normativo y certificaciones"]}},{"momentIndex":2,"stepIndex":5,"code":"M3-Q03","order":6,"type":"ASK","data":{"code":"M3-Q03","order":6,"type":"ASK","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","objective":"Dominar criterios de selección de EPP","acceptable_answers":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"],"question_type":"aplicación"}}]},{"title":"Aplicación","code":"M4","order":4,"steps":[{"momentIndex":3,"stepIndex":0,"code":"M4-CASE01","order":1,"type":"CASE","data":{"code":"M4-CASE01","order":1,"type":"CASE","title":"Trabajo en altura en fachada","description":"Instalación de ventanas en tercer piso con uso de arnés y línea de vida.","variables":["altura > 2 m","arnés","línea de vida","supervisión","verificación de anclajes"]}},{"momentIndex":3,"stepIndex":1,"code":"M4-Q01","order":2,"type":"ASK","data":{"code":"M4-Q01","order":2,"type":"ASK","question":"¿Qué EPP mínimo usarías y por qué?","objective":"Justificar selección de EPP","acceptable_answers":["arnés con línea de vida","casco","guantes","calzado antideslizante"],"question_type":"aplicación"}}]},{"title":"Discusión","code":"M5","order":5,"steps":[{"momentIndex":4,"stepIndex":0,"code":"M5-TOP01","order":1,"type":"TOPICS","data":{"code":"M5-TOP01","order":1,"type":"TOPICS","items":["Protocolizar vs. improvisar","Cultura de seguridad"]}},{"momentIndex":4,"stepIndex":1,"code":"M5-Q01","order":2,"type":"ASK","data":{"code":"M5-Q01","order":2,"type":"ASK","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","objective":"Comparar enfoques","acceptable_answers":["estandariza","reduce errores","trazabilidad","cumplimiento"],"question_type":"argumentativa"}}]},{"title":"Reflexión","code":"M6","order":6,"steps":[{"momentIndex":5,"stepIndex":0,"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","data":{"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","items":["Hábitos personales de seguridad","Compromisos inmediatos"]}},{"momentIndex":5,"stepIndex":1,"code":"M6-Q01","order":2,"type":"ASK","data":{"code":"M6-Q01","order":2,"type":"ASK","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","objective":"Plan de mejora personal","acceptable_answers":["ejemplo personal","compromiso concreto"],"question_type":"reflexiva"}}]}],"allSteps":[{"momentIndex":0,"stepIndex":0,"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","data":{"code":"M1-EL01","order":1,"type":"EXPECTED_LEARNING","items":["Comprender qué es un procedimiento de seguridad","Identificar sus componentes principales","Aplicar criterios básicos de selección de EPP"]}},{"momentIndex":0,"stepIndex":1,"code":"M1-KP01","order":2,"type":"KEY_POINTS","data":{"code":"M1-KP01","order":2,"type":"KEY_POINTS","items":["Qué es un procedimiento","Por qué es importante","Cómo se aplica"]}},{"momentIndex":0,"stepIndex":2,"code":"M1-N01","order":3,"type":"NARRATION","data":{"code":"M1-N01","order":3,"type":"NARRATION","text":"Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo."}},{"momentIndex":0,"stepIndex":3,"code":"M1-Q01","order":4,"type":"ASK","data":{"code":"M1-Q01","order":4,"type":"ASK","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","objective":"Elicitar expectativas del estudiante","acceptable_answers":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"],"question_type":"metacognitiva"}},{"momentIndex":1,"stepIndex":0,"code":"M2-N01","order":1,"type":"NARRATION","data":{"code":"M2-N01","order":1,"type":"NARRATION","text":"Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes."}},{"momentIndex":1,"stepIndex":1,"code":"M2-Q01","order":2,"type":"ASK","data":{"code":"M2-Q01","order":2,"type":"ASK","question":"¿Qué elementos de seguridad identificas en esta situación?","objective":"Activar conocimientos previos","acceptable_answers":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"],"question_type":"diagnóstica"}},{"momentIndex":1,"stepIndex":2,"code":"M2-Q02","order":3,"type":"ASK","data":{"code":"M2-Q02","order":3,"type":"ASK","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","objective":"Conciencia de riesgos","acceptable_answers":["caídas","lesiones","accidentes","sanciones","multas"],"question_type":"reflexiva"}},{"momentIndex":2,"stepIndex":0,"code":"M3-C01","order":1,"type":"CONTENT","data":{"code":"M3-C01","order":1,"type":"CONTENT","title":"Definición de procedimiento de seguridad","body":["PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"]}},{"momentIndex":2,"stepIndex":1,"code":"M3-Q01","order":2,"type":"ASK","data":{"code":"M3-Q01","order":2,"type":"ASK","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","objective":"Comprender la definición","acceptable_answers":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"],"question_type":"conceptual"}},{"momentIndex":2,"stepIndex":2,"code":"M3-C02","order":3,"type":"CONTENT","data":{"code":"M3-C02","order":3,"type":"CONTENT","title":"Partes de un procedimiento","body":["Objetivo","Alcance","Responsabilidades","Pasos específicos","EPP requerido","Medidas de emergencia","Registros"]}},{"momentIndex":2,"stepIndex":3,"code":"M3-Q02","order":4,"type":"ASK","data":{"code":"M3-Q02","order":4,"type":"ASK","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","objective":"Identificar componentes","acceptable_answers":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"],"question_type":"listado"}},{"momentIndex":2,"stepIndex":4,"code":"M3-C03","order":5,"type":"CONTENT","data":{"code":"M3-C03","order":5,"type":"CONTENT","title":"Criterios para seleccionar EPP","body":["Evaluar tipo de riesgo y nivel de exposición","Compatibilidad, ajuste y comodidad","Cumplimiento normativo y certificaciones"]}},{"momentIndex":2,"stepIndex":5,"code":"M3-Q03","order":6,"type":"ASK","data":{"code":"M3-Q03","order":6,"type":"ASK","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","objective":"Dominar criterios de selección de EPP","acceptable_answers":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"],"question_type":"aplicación"}},{"momentIndex":3,"stepIndex":0,"code":"M4-CASE01","order":1,"type":"CASE","data":{"code":"M4-CASE01","order":1,"type":"CASE","title":"Trabajo en altura en fachada","description":"Instalación de ventanas en tercer piso con uso de arnés y línea de vida.","variables":["altura > 2 m","arnés","línea de vida","supervisión","verificación de anclajes"]}},{"momentIndex":3,"stepIndex":1,"code":"M4-Q01","order":2,"type":"ASK","data":{"code":"M4-Q01","order":2,"type":"ASK","question":"¿Qué EPP mínimo usarías y por qué?","objective":"Justificar selección de EPP","acceptable_answers":["arnés con línea de vida","casco","guantes","calzado antideslizante"],"question_type":"aplicación"}},{"momentIndex":4,"stepIndex":0,"code":"M5-TOP01","order":1,"type":"TOPICS","data":{"code":"M5-TOP01","order":1,"type":"TOPICS","items":["Protocolizar vs. improvisar","Cultura de seguridad"]}},{"momentIndex":4,"stepIndex":1,"code":"M5-Q01","order":2,"type":"ASK","data":{"code":"M5-Q01","order":2,"type":"ASK","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","objective":"Comparar enfoques","acceptable_answers":["estandariza","reduce errores","trazabilidad","cumplimiento"],"question_type":"argumentativa"}},{"momentIndex":5,"stepIndex":0,"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","data":{"code":"M6-REF01","order":1,"type":"REFLECTION_AREAS","items":["Hábitos personales de seguridad","Compromisos inmediatos"]}},{"momentIndex":5,"stepIndex":1,"code":"M6-Q01","order":2,"type":"ASK","data":{"code":"M6-Q01","order":2,"type":"ASK","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","objective":"Plan de mejora personal","acceptable_answers":["ejemplo personal","compromiso concreto"],"question_type":"reflexiva"}}],"contentCycles":[{"contentStepIndex":-1,"askStepIndices":[3,5,6]},{"contentStepIndex":7,"askStepIndices":[8]},{"contentStepIndex":9,"askStepIndices":[10]},{"contentStepIndex":11,"askStepIndices":[12,14,16,18]}],"askCatalog":[{"globalIndex":3,"momentIndex":0,"stepIndex":3,"code":"M1-Q01","question":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?","acceptable":["partes del procedimiento","cómo se aplica","importancia de seguirlos","selección de EPP"]},{"globalIndex":5,"momentIndex":1,"stepIndex":1,"code":"M2-Q01","question":"¿Qué elementos de seguridad identificas en esta situación?","acceptable":["arnés","arnés de seguridad","línea","línea de vida","casco","guantes","inspección previa","supervisión"]},{"globalIndex":6,"momentIndex":1,"stepIndex":2,"code":"M2-Q02","question":"¿Qué podría pasar si no se siguen los procedimientos correctos?","acceptable":["caídas","lesiones","accidentes","sanciones","multas"]},{"globalIndex":8,"momentIndex":2,"stepIndex":1,"code":"M3-Q01","question":"¿Cómo definirías un procedimiento de seguridad con tus palabras?","acceptable":["secuencia documentada de pasos","realizar una tarea de forma segura","minimizar riesgos laborales"]},{"globalIndex":10,"momentIndex":2,"stepIndex":3,"code":"M3-Q02","question":"¿Qué partes debe incluir un procedimiento de seguridad completo?","acceptable":["objetivo","alcance","responsabilidades","pasos específicos","epp requerido","medidas de emergencia","registros"]},{"globalIndex":12,"momentIndex":2,"stepIndex":5,"code":"M3-Q03","question":"Menciona dos criterios para seleccionar EPP adecuadamente.","acceptable":["tipo de riesgo","nivel de exposición","compatibilidad","ajuste","normativa","certificaciones"]},{"globalIndex":14,"momentIndex":3,"stepIndex":1,"code":"M4-Q01","question":"¿Qué EPP mínimo usarías y por qué?","acceptable":["arnés con línea de vida","casco","guantes","calzado antideslizante"]},{"globalIndex":16,"momentIndex":4,"stepIndex":1,"code":"M5-Q01","question":"¿Qué ventajas tiene documentar procedimientos frente a improvisar?","acceptable":["estandariza","reduce errores","trazabilidad","cumplimiento"]},{"globalIndex":18,"momentIndex":5,"stepIndex":1,"code":"M6-Q01","question":"¿Qué cambio aplicarás esta semana para mejorar tu seguridad?","acceptable":["ejemplo personal","compromiso concreto"]}]},"momentIdx":0,"stepIdx":3,"attemptsByAskCode":{},"hintsByAskCode":{},"lastAnswerByAskCode":{},"noSeCountByAskCode":{},"lastActionByAskCode":{},"justAskedFollowUp":true,"askedAskCodes":[],"answeredAskCodes":[],"done":false},"lastActivity":1755400734458}}}
```
=== EOF: .data\sessions.json

===  .claude\settings.local.json
```json
{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(rm:*)",
      "Bash(npm run dev:*)",
      "Bash(kill:*)"
    ],
    "deny": []
  }
}
```
=== EOF: .claude\settings.local.json

===  src\session\store.ts
```typescript
import type { SessionState } from '@/session/state';
import fs from 'fs/promises';
import path from 'path';

export interface SessionStore {
  get(sessionKey: string): Promise<SessionState | undefined>;
  set(sessionKey: string, state: SessionState): Promise<void>;
  delete(sessionKey: string): Promise<void>;
}

class MemoryStore implements SessionStore {
  private map = new Map<string, SessionState>();
  async get(k: string) { return this.map.get(k); }
  async set(k: string, v: SessionState) { this.map.set(k, v); }
  async delete(k: string) { this.map.delete(k); }
}

type FileShape = { sessions: Record<string, { state: SessionState; lastActivity: number }> };

class JsonFileStore implements SessionStore {
  private filePath: string;
  private data: FileShape = { sessions: {} };
  private writing = Promise.resolve();
  constructor(filePath?: string) {
    this.filePath = filePath || path.join(process.cwd(), '.data', 'sessions.json');
  }
  private async ensureLoaded() {
    if (Object.keys(this.data.sessions).length) return;
    try {
      await fs.mkdir(path.dirname(this.filePath), { recursive: true });
      const raw = await fs.readFile(this.filePath, 'utf-8');
      this.data = JSON.parse(raw) as FileShape;
    } catch {
      this.data = { sessions: {} };
    }
  }
  private async flush() {
    const payload = JSON.stringify(this.data);
    const tmp = this.filePath + '.tmp';
    await fs.writeFile(tmp, payload, 'utf-8');
    await fs.rename(tmp, this.filePath);
  }
  async get(k: string) {
    await this.ensureLoaded();
    return this.data.sessions[k]?.state;
  }
  async set(k: string, v: SessionState) {
    await this.ensureLoaded();
    this.data.sessions[k] = { state: v, lastActivity: Date.now() };
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
  async delete(k: string) {
    await this.ensureLoaded();
    delete this.data.sessions[k];
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
}

let storeInstance: SessionStore | null = null;
export function getSessionStore(): SessionStore {
  if (storeInstance) return storeInstance;
  const useFile = process.env.SESSION_STORE === 'file';
  storeInstance = useFile ? new JsonFileStore() : new MemoryStore();
  return storeInstance;
}


```
=== EOF: src\session\store.ts

===  src\session\state.ts
```typescript
import type { LessonPlan } from '@/plan/types';

export type SessionState = {
	planUrl: string;
	plan?: LessonPlan;
	momentIdx: number;
	stepIdx: number;
	attemptsByAskCode: Record<string, number>;
	hintsByAskCode?: Record<string, number>;
	lastAnswerByAskCode?: Record<string, string>;
	noSeCountByAskCode?: Record<string, number>;
	lastActionByAskCode?: Record<string, string>;
	justAskedFollowUp?: boolean;
	askedAskCodes: string[];
	answeredAskCodes: string[];
	done: boolean;
};

export function initSession(planUrl: string, plan: LessonPlan): SessionState {
	return {
		planUrl,
		plan,
		momentIdx: 0,
		stepIdx: 0,
		attemptsByAskCode: {},
		hintsByAskCode: {},
		lastAnswerByAskCode: {},
		noSeCountByAskCode: {},
		lastActionByAskCode: {},
		justAskedFollowUp: false,
		askedAskCodes: [],
		answeredAskCodes: [],
		done: false
	};
}


```
=== EOF: src\session\state.ts

===  src\session\history.ts
```typescript
import fs from 'fs/promises';
import path from 'path';

function historyPath(sessionKey: string) {
  const dir = path.join(process.cwd(), '.data', 'history');
  const file = path.join(dir, `${sessionKey}.jsonl`);
  return { dir, file };
}

export async function appendHistory(sessionKey: string, record: unknown): Promise<void> {
  const { dir, file } = historyPath(sessionKey);
  try { await fs.mkdir(dir, { recursive: true }); } catch {}
  const line = JSON.stringify({ ts: Date.now(), ...((record as object) || {}) }) + '\n';
  await fs.appendFile(file, line, 'utf-8');
}

export async function clearHistory(sessionKey: string): Promise<void> {
  const { file } = historyPath(sessionKey);
  try { await fs.unlink(file); } catch {}
}

export async function getRecentHistory(sessionKey: string, limit: number = 6): Promise<string[]> {
  const { file } = historyPath(sessionKey);
  try {
    const raw = await fs.readFile(file, 'utf-8');
    const lines = raw.trim().split(/\n+/).filter(Boolean);
    const tail = lines.slice(-limit);
    const out: string[] = [];
    for (const ln of tail) {
      try {
        const rec: any = JSON.parse(ln);
        if (typeof rec?.content === 'string') { out.push(rec.content); continue; }
        if (typeof rec?.message === 'string' || typeof rec?.followUp === 'string') {
          const combined = [rec.message, rec.followUp].filter(Boolean).join('\n\n');
          if (combined) out.push(combined);
          continue;
        }
      } catch {}
    }
    return out;
  } catch {
    return [];
  }
}


```
=== EOF: src\session\history.ts

===  src\schema\timeline.ts
```typescript
import { z } from 'zod';

export const TimelineStepSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	type: z.string(),
	// ASK
	question: z.string().optional(),
	objective: z.string().optional(),
	acceptable_answers: z.array(z.string()).optional(),
	question_type: z.string().optional(),
	// CONTENT / CASE / NARRATION / KEY_* / TOPICS / REFLECTION_AREAS
	title: z.string().optional(),
	body: z.array(z.string()).optional(),
	text: z.string().optional(),
	description: z.string().optional(),
	items: z.array(z.string()).optional(),
	variables: z.array(z.string()).optional()
});

export const TimelineMomentSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	title: z.string(),
	steps: z.array(TimelineStepSchema)
});

export const TimelineFileSchema = z.object({
	meta: z.object({
		lesson_id: z.string().optional(),
		lesson_name: z.string().optional(),
		version: z.string().optional(),
		language: z.string().optional(),
		ordered: z.boolean().optional(),
		generated_at: z.string().optional()
	}),
	moments: z.array(TimelineMomentSchema)
});

export type TimelineStep = z.infer<typeof TimelineStepSchema>;
export type TimelineMoment = z.infer<typeof TimelineMomentSchema>;
export type TimelineFile = z.infer<typeof TimelineFileSchema>;

export function assertTimeline(obj: unknown): TimelineFile {
	return TimelineFileSchema.parse(obj);
}


```
=== EOF: src\schema\timeline.ts

===  src\plan\types.ts
```typescript
import type { TimelineFile, TimelineStep } from '@/schema/timeline';

export type StepType = 'NARRATION'|'CONTENT'|'ASK'|'CASE'|'KEY_CONTENT'|'KEY_POINTS'|'KEY_ELEMENTS'|'TOPICS'|'EXPECTED_LEARNING'|'REFLECTION_AREAS';

export type PlanStep = {
	momentIndex: number;
	stepIndex: number;
	code?: string;
	order?: number;
	type: StepType;
	data: TimelineStep;
};

export type LessonPlan = {
	meta: TimelineFile['meta'];
	moments: Array<{ title: string; code?: string; order?: number; steps: PlanStep[] }>;
	allSteps: PlanStep[];
	contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }>;
	askCatalog: Array<{ globalIndex: number; momentIndex: number; stepIndex: number; code?: string; question: string; acceptable: string[] }>;
};



```
=== EOF: src\plan\types.ts

===  src\plan\compilePlan.ts
```typescript
import { assertTimeline, TimelineFile } from '@/schema/timeline';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { LessonPlan, PlanStep, StepType } from './types';

function toStepType(t?: string): StepType {
	const u = String(t || '').toUpperCase();
	return (['NARRATION','CONTENT','ASK','CASE','KEY_CONTENT','KEY_POINTS','KEY_ELEMENTS','TOPICS','EXPECTED_LEARNING','REFLECTION_AREAS'] as StepType[])
		.find(x => x === u) || 'CONTENT';
}

export function compilePlan(tl: TimelineFile): LessonPlan {
	const moments = (tl.moments || []).map((m, mi) => {
		const steps: PlanStep[] = (m.steps || [])
			.sort((a, b) => (a.order || 0) - (b.order || 0))
			.map((s, si) => ({ momentIndex: mi, stepIndex: si, code: s.code, order: s.order, type: toStepType(s.type), data: s }));
		return { title: m.title, code: m.code, order: m.order, steps };
	});
	const allSteps = moments.flatMap(m => m.steps);
	// Construir ciclos CONTENT->ASK por proximidad
	const contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }> = [];
	let current: { contentStepIndex: number; askStepIndices: number[] } | null = null;
	for (let i = 0; i < allSteps.length; i++) {
		const s = allSteps[i];
		if (s.type === 'CONTENT') {
			if (current) contentCycles.push(current);
			current = { contentStepIndex: i, askStepIndices: [] };
		} else if (s.type === 'ASK') {
			if (!current) current = { contentStepIndex: -1, askStepIndices: [] };
			current.askStepIndices.push(i);
		}
	}
	if (current) contentCycles.push(current);
	// Catálogo de preguntas
	const askCatalog = allSteps
		.map((s, idx) => ({
			globalIndex: idx,
			momentIndex: s.momentIndex,
			stepIndex: s.stepIndex,
			code: s.code,
			question: s.data.question || '',
			acceptable: s.data.acceptable_answers || []
		}))
		.filter(x => !!x.question);
	return { meta: tl.meta, moments, allSteps, contentCycles, askCatalog };
}

export async function loadAndCompile(url: string): Promise<LessonPlan> {
	let obj: any;
	// Soporte server-side: si es ruta absoluta del sitio (/courses/..), leer desde /public
	if (/^https?:/i.test(url)) {
		const res = await fetch(url);
		obj = await res.json();
	} else if (url.startsWith('/')) {
		const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	} else {
		const filePath = path.isAbsolute(url) ? url : path.join(process.cwd(), url);
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	}
	const tl = assertTimeline(obj);
	return compilePlan(tl);
}


```
=== EOF: src\plan\compilePlan.ts

===  src\engine\semvec.ts
```typescript
import OpenAI from 'openai';

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const MODEL = process.env.EMBED_MODEL || 'text-embedding-3-small';

export type AskVectorIndex = {
	acceptables: string[];
	expected: string[];
	centroid: number[];
	byItem: { text: string; vec: number[] }[];
};

function cosine(a: number[], b: number[]): number {
	let dot = 0;
	let na = 0;
	let nb = 0;
	const len = Math.min(a.length, b.length);
	for (let i = 0; i < len; i++) { dot += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
	if (!na || !nb) return 0;
	return dot / (Math.sqrt(na) * Math.sqrt(nb));
}

export async function embedTexts(texts: string[]): Promise<number[][]> {
	if (!texts || texts.length === 0) return [];
	const res = await client.embeddings.create({ model: MODEL as any, input: texts });
	return res.data.map(x => (x as any).embedding as number[]);
}

export async function buildAskIndex(acceptables: string[] = [], expected: string[] = []): Promise<AskVectorIndex> {
	const items = Array.from(new Set([...(acceptables || []), ...(expected || [])].map(s => String(s || '').trim()).filter(Boolean)));
	if (items.length === 0) return { acceptables, expected, centroid: [], byItem: [] };
	const vecs = await embedTexts(items);
	const dim = vecs[0]?.length || 0;
	const centroid = dim ? Array.from({ length: dim }, (_, j) => vecs.reduce((acc, v) => acc + (v[j] || 0), 0) / vecs.length) : [];
	return {
		acceptables,
		expected,
		centroid,
		byItem: items.map((t, i) => ({ text: t, vec: vecs[i] || [] }))
	};
}

export async function semanticScore(answer: string, index: AskVectorIndex): Promise<{ cos: number; best?: { text: string; cos: number } }> {
	const text = String(answer || '').trim();
	if (!text || !index || !index.centroid || index.centroid.length === 0) return { cos: 0 };
	const [u] = await embedTexts([text]);
	const cosC = cosine(u || [], index.centroid || []);
	let best = { text: '', cos: 0 };
	for (const it of index.byItem || []) {
		const c = cosine(u || [], it.vec || []);
		if (c > best.cos) best = { text: it.text, cos: c };
	}
	return { cos: cosC, best };
}


```
=== EOF: src\engine\semvec.ts

===  src\engine\runner.ts
```typescript
import type { PlanStep } from '@/plan/types';
import type { SessionState } from '@/session/state';

export type SkipAction = { kind: 'skip'; step?: PlanStep };
export type ExplainAction = { kind: 'explain'; step: PlanStep };
export type AskAction = { kind: 'ask'; step: PlanStep };
export type EndAction = { kind: 'end' };
export type EngineAction = SkipAction | ExplainAction | AskAction | EndAction;

export function currentStep(state?: SessionState): PlanStep | undefined {
	const steps = state?.plan?.allSteps || [];
	if (typeof state?.stepIdx !== 'number') return undefined;
	if (state.stepIdx < 0 || state.stepIdx >= steps.length) return undefined;
	return steps[state.stepIdx];
}

export function decideAction(step?: PlanStep): EngineAction {
	if (!step) return { kind: 'end' };
	switch (step.type) {
		case 'ASK':
			return { kind: 'ask', step };
		case 'CONTENT':
		case 'NARRATION':
		case 'CASE':
		case 'REFLECTION_AREAS':
			return { kind: 'explain', step };
		case 'KEY_CONTENT':
		case 'KEY_POINTS':
		case 'KEY_ELEMENTS':
		case 'TOPICS':
		case 'EXPECTED_LEARNING':
		default:
			return { kind: 'skip', step } as SkipAction;
	}
}

export function next(state?: SessionState): SessionState {
	if (!state) {
		throw new Error('Session state not initialized');
	}
	const steps = state.plan?.allSteps || [];
	const nextIdx = (state.stepIdx ?? 0) + 1;
	if (nextIdx >= steps.length) {
		const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
		return { ...state, stepIdx: steps.length, momentIdx: lastMomentIdx, done: true };
	}
	const newStep = steps[nextIdx];
	const newMomentIdx = typeof newStep?.momentIndex === 'number' ? newStep.momentIndex : state.momentIdx;
	return { ...state, stepIdx: nextIdx, momentIdx: newMomentIdx, done: false };
}

export function advanceTo(state: SessionState, targetStepIndex?: number): SessionState {
  if (targetStepIndex === undefined || targetStepIndex === null) {
    const steps = state.plan?.allSteps || [];
    const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
    return { ...state, done: true, stepIdx: steps.length, momentIdx: lastMomentIdx };
  }
  const steps = state.plan?.allSteps || [];
  const boundedIndex = Math.max(0, Math.min(targetStepIndex, Math.max(0, steps.length)));
  const step = steps[boundedIndex];
  const newMomentIdx = typeof step?.momentIndex === 'number' ? step.momentIndex : state.momentIdx;
  return { ...state, stepIdx: boundedIndex, momentIdx: newMomentIdx, done: false };
}

export function getCycleIndexForStep(state: SessionState, stepIdx: number): number | undefined {
  const cycles = state.plan?.contentCycles || [];
  for (let i = 0; i < cycles.length; i++) {
    const c = cycles[i];
    if (c.contentStepIndex === stepIdx) return i;
    if (c.askStepIndices.includes(stepIdx)) return i;
  }
  return undefined;
}

export function getNextAskInSameCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const cycleIdx = getCycleIndexForStep(state, stepIdx);
  if (cycleIdx === undefined) return undefined;
  const cycle = cycles[cycleIdx];
  const askList = cycle.askStepIndices || [];
  const pos = askList.indexOf(stepIdx);
  if (pos === -1) return askList.length ? askList[0] : undefined; // si estamos en CONTENT, volver a la primera ASK
  return askList[pos + 1];
}

export function getFirstAskOfNextCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const currentCycleIdx = getCycleIndexForStep(state, stepIdx);
  const startIdx = currentCycleIdx === undefined ? 0 : currentCycleIdx + 1;
  for (let i = startIdx; i < cycles.length; i++) {
    const askList = cycles[i].askStepIndices || [];
    if (askList.length > 0) return askList[0];
  }
  return undefined;
}



```
=== EOF: src\engine\runner.ts

===  src\engine\hints.ts
```typescript
const STOPWORDS = new Set(['el','la','los','las','un','una','unos','unas','de','en','y','o','a','para','con','sobre','que','es','son','del','al','por','se','como','mas','más','menos','no','si','sí','qué','cuales','cuáles']);

function tokenize(s: string): string[] {
	return (s || '')
		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		.replace(/["'()\[\]{}]/g, '')
		.split(/[^a-záéíóúñ0-9]+/)
		.filter(Boolean)
		.filter(w => w.length > 2 && !STOPWORDS.has(w));
}

export function extractKeywords(from: string[]): string[] {
	const out: string[] = [];
	for (const item of from) {
		for (const w of tokenize(item)) {
			if (!out.includes(w)) out.push(w);
		}
	}
	return out.slice(0, 40);
}

export function buildHint10(keywords: string[]): string {
	return `Incluye ideas como ${keywords.slice(0, 6).join(', ')}`.trim();
}

export function buildHint20(keywords: string[]): string {
	return `Explica brevemente criterios y ejemplos, enfocándote en ${keywords.slice(0, 10).join(', ')}`.trim();
}








```
=== EOF: src\engine\hints.ts

===  src\engine\eval.ts
```typescript
export function normalize(input: string): string {
	return (input || '')
		.toLowerCase()
		.normalize('NFD')
		.replace(/\p{Diacritic}/gu, '')
		// Colapsa repeticiones largas de caracteres: accidenteee -> accidentee
		.replace(/([a-zñ])\1{2,}/g, '$1$1')
		.replace(/[^\p{L}\p{N}\s]/gu, ' ')
		.replace(/\s+/g, ' ')
		.trim();
}

export function matchesAcceptable(user: string, acceptable: string[]): boolean {
	const u = normalize(user);
	return acceptable.some(a => {
		const n = normalize(a);
		return n.length > 0 && (u === n || u.includes(n) || n.includes(u));
	});
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
}

function tokenSet(s: string): Set<string> {
  return new Set(normalize(s).split(' ').filter(Boolean));
}

function jaccard(a: string, b: string): number {
  const A = tokenSet(a), B = tokenSet(b);
  const interArr: string[] = [];
  A.forEach(v => { if (B.has(v)) interArr.push(v); });
  const inter = interArr.length;
  const unionSet = new Set<string>();
  A.forEach(v => unionSet.add(v));
  B.forEach(v => unionSet.add(v));
  const union = unionSet.size || 1;
  return inter / union;
}

export function computeMatchedMissing(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const u = normalize(user);
	const essentials = acceptable;
	const matched: string[] = [];
	const uTokens = u.split(' ').filter(Boolean);
	for (const a of essentials) {
		const n = normalize(a);
		if (!n) continue;
		// Coincidencia estricta por frase completa
		if (u === n || u.includes(n) || n.includes(u)) { matched.push(a); continue; }
		if (fuzzy) {
			const dist = levenshtein(u, n);
			const sim = jaccard(u, n);
			if ((fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin)) { matched.push(a); continue; }
			// Fuzzy a nivel de tokens: si algún token del usuario se parece a un token del aceptable
			const nTokens = n.split(/\s+/).filter(t => t.length >= 4);
			const uStrong = uTokens.filter(t => t.length >= 4);
			const tokenHit = uStrong.some(ut => nTokens.some(nt => {
				if (!ut || !nt) return false;
				if (ut === nt || ut.includes(nt) || nt.includes(ut)) return true;
				const d = levenshtein(ut, nt);
				return typeof fuzzy.maxEditDistance === 'number' ? d <= fuzzy.maxEditDistance : d <= 1;
			}));
			if (tokenHit) { matched.push(a); continue; }
			// Soft token match conservador por inclusión directa
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) { matched.push(a); }
			continue;
		}
		// Sin fuzzy: aplicar soft token match mínimo
		const tokens = n.split(/\s+/).filter(t => t.length >= 4);
		if (tokens.some(t => u.includes(t))) { matched.push(a); continue; }
	}
	if (matched.length === 0 && expected?.length) {
		const extras = expected.filter(e => {
			const n = normalize(e);
			if (!n) return false;
			if (u.includes(n)) return true;
			if (fuzzy) {
				const dist = levenshtein(u, n);
				const sim = jaccard(u, n);
				return (fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin);
			}
			// Soft token para expected
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) return true;
			return false;
		}).slice(0, 2);
		matched.push(...extras);
	}
	const missing = essentials.filter(a => !matched.includes(a)).slice(0, 3);
	return { matched, missing };
}

export function evaluateAnswer(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const { matched, missing } = computeMatchedMissing(user, acceptable, expected, fuzzy);
	return { ok: matched.length > 0, matched, missing };
}

export type AskPolicy = {
	type: 'conceptual'|'listado'|'aplicacion'|'identificacion'|'experiencial'|'metacognitiva'|'reflexiva'|string;
	thresholdK?: number; // para listado
	requiresJustification?: boolean; // para aplicacion
};

export function classifyTurn(
	user: string,
	policy: AskPolicy,
	acceptable: string[] = [],
	expected: string[] = [],
	fuzzy?: { maxEditDistance?: number; similarityMin?: number }
): { kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; matched: string[]; missing: string[]; reason: string } {
	const u = normalize(user);
	if (!u) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	// Gate duro: si el alumno dice "no sé" o equivalente, no intentamos ACCEPT/PARTIAL
	if (isNoSe(user)) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	const { matched, missing } = computeMatchedMissing(u, acceptable, expected, fuzzy);
	const hasAny = matched.length > 0;
	if (policy.type === 'listado') {
		const k = Math.max(1, policy.thresholdK || 2);
		if (matched.length >= k) return { kind: 'ACCEPT', matched, missing, reason: 'K_OF_N' };
		if (matched.length > 0 || expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'PARTIAL_LISTADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	if (policy.type === 'aplicacion') {
		if (hasAny && (!policy.requiresJustification || /porque|para|ya que/i.test(user))) return { kind: 'ACCEPT', matched, missing, reason: 'APLICACION_OK' };
		if (hasAny) return { kind: 'PARTIAL', matched, missing, reason: 'FALTA_JUSTIFICACION' };
		if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	// conceptual, identificacion, etc.
	if (hasAny) return { kind: 'ACCEPT', matched, missing, reason: 'MATCH_ACCEPTABLE' };
	if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
	return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
}

export function isVagueAnswer(
	user: string,
	question?: string,
	opts?: { stopwords?: string[]; minUsefulTokens?: number; maxStopwordRatio?: number; echoOverlap?: number; repeatSimilarity?: number; lastAnswer?: string }
): boolean {
	const u = normalize(user);
	if (!u) return true;
	const tokens = u.split(' ').filter(Boolean);
	const stop = new Set((opts?.stopwords || []).map(s => normalize(s)));
	const useful = tokens.filter(t => !stop.has(t));
	const stopRatio = tokens.length ? (tokens.length - useful.length) / tokens.length : 1;
	if (useful.length < (opts?.minUsefulTokens ?? 3)) return true;
	if (stopRatio > (opts?.maxStopwordRatio ?? 0.6)) return true;
	const q = question ? normalize(question) : '';
	if (q) {
		const overlap = jaccard(u, q);
		if (overlap >= (opts?.echoOverlap ?? 0.7)) return true;
	}
	const last = normalize(opts?.lastAnswer || '');
	if (last) {
		const sim = jaccard(u, last);
		if (sim >= (opts?.repeatSimilarity ?? 0.8)) return true;
	}
	return false;
}

export function isNoSe(answer?: string): boolean {
	const a = (answer || '').trim().toLowerCase();
	if (!a) return true;
	const patterns = [
		/^no\s*se$/, /^no\s*lo\s*se$/, /^no\s*sé$/, /^no\s*lo\s*sé$/,
		/^ns$/, /^n\/a$/, /^no\s*sab[oó]$/, /^no\s*est[oó]\s*seguro$/,
		/^no$/,
		/^[\.\!\?…]+$/
	];
	if (patterns.some(rx => rx.test(a))) return true;
	const words = a.split(/\s+/).filter(Boolean);
	return words.length <= 2;
}

// Evaluación híbrida (vaguedad → rápido → semántico)
import { buildAskIndex, semanticScore, type AskVectorIndex } from '@/engine/semvec';

export type HybridOpts = {
  fuzzy?: { maxEditDistance?: number; similarityMin?: number };
  semThresh?: number;
  semBestThresh?: number;
  maxHints?: number;
};

export async function evaluateHybrid(
  user: string,
  acceptable: string[] = [],
  expected: string[] = [],
  policy: AskPolicy = { type: 'conceptual' },
  opts: HybridOpts = { fuzzy: { maxEditDistance: 1, similarityMin: 0.35 }, semThresh: 0.78, semBestThresh: 0.65, maxHints: 2 },
  context?: { lastAnswer?: string; hintsUsed?: number }
): Promise<{ kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; reason: string; matched: string[]; missing: string[]; sem?: { cos: number; best?: { text: string; cos: number } } }> {
  const u = normalize(user);
  if (!u) return { kind: 'HINT', reason: 'EMPTY', matched: [], missing: acceptable.slice(0,3) };
  if (isNoSe(user)) return { kind: 'HINT', reason: 'DONT_KNOW', matched: [], missing: acceptable.slice(0,3) };

  // 1) Gate de vaguedad (barato)
  const vague = isVagueAnswer(u, undefined, { minUsefulTokens: 3, echoOverlap: 0.7, lastAnswer: context?.lastAnswer });
  if (vague) return { kind: 'HINT', reason: 'VAGUE', matched: [], missing: acceptable.slice(0,3) };

  // 2) Match rápido (barato)
  const fast = classifyTurn(u, policy, acceptable, expected, opts.fuzzy);
  if (fast.kind === 'ACCEPT' || fast.kind === 'PARTIAL') return { ...fast, reason: fast.reason, sem: undefined } as any;

  // 3) Semántico (costoso): embeddings
  let idx: AskVectorIndex | null = null;
  try { idx = await buildAskIndex(acceptable, expected); } catch { idx = null; }
  if (!idx || !idx.centroid?.length) return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
  const { cos, best } = await semanticScore(u, idx);
  const semThresh = opts.semThresh ?? 0.78;
  const semBestThresh = opts.semBestThresh ?? 0.72;
  if (cos >= semThresh) {
    if (policy.type === 'aplicacion') {
      const justifica = /porque|para|ya que/i.test(user);
      return { kind: (justifica ? 'ACCEPT' : 'PARTIAL'), reason: (justifica ? 'SEM_APLICACION_OK' : 'SEM_FALTA_JUSTIFICACION'), matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } } as any;
    }
    return { kind: 'PARTIAL', reason: 'SEM_SIMILAR', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((best?.cos || 0) >= semBestThresh) {
    return { kind: 'PARTIAL', reason: 'SEM_BEST', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((context?.hintsUsed || 0) >= (opts.maxHints ?? 2)) {
    return { kind: 'REFOCUS', reason: 'MAX_HINTS', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
  }
  return { kind: 'HINT', reason: 'SEM_LOW', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
}
```
=== EOF: src\engine\eval.ts

===  src\hooks\usePlanChat.ts
```typescript
import { useEffect, useRef, useState } from 'react';

export type PlanChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

function generateSessionKey(): string {
	return `plan-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
}

export function usePlanChat(planUrl: string = '/courses/SSO001/lessons/lesson02.json') {
	const [messages, setMessages] = useState<PlanChatMessage[]>([]);
	const [isTyping, setIsTyping] = useState<boolean>(false);
	const [done, setDone] = useState<boolean>(false);
	const sessionKeyRef = useRef<string>('');
	const idSeq = useRef<number>(1);
  const bootedRef = useRef<boolean>(false);

	useEffect(() => {
		if (!sessionKeyRef.current) {
			// Persistir la sesión para recargas superficiales
			try {
				const stored = typeof window !== 'undefined' ? window.sessionStorage.getItem('planSessionKey') : '';
				if (stored) sessionKeyRef.current = stored;
				else {
					sessionKeyRef.current = generateSessionKey();
					if (typeof window !== 'undefined') window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
				}
			} catch {
				sessionKeyRef.current = generateSessionKey();
			}
		}
		// Primer turno para obtener el primer paso del plan (evitar doble invocación en StrictMode)
		if (!bootedRef.current) {
			bootedRef.current = true;
			void turn('');
		}
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [planUrl]);

  async function turn(userInput: string) {
		if (done) return;
		setIsTyping(true);
		try {
			const res = await fetch('/api/engine/turn', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ sessionKey: sessionKeyRef.current, userInput, planUrl, reset: !messages.length })
			});
			if (!res.ok) throw new Error('engine turn failed');
			const { message, followUp, state } = await res.json();
			const chunks = [message, followUp].filter(Boolean) as string[];
			if (userInput && userInput.trim()) {
				setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'student', content: userInput, timestamp: new Date() }]);
			}
			if (chunks.length) {
				setMessages(prev => {
					let out = prev;
					for (const c of chunks) {
						out = [...out, { id: `${idSeq.current++}`, sender: 'ai', content: c, timestamp: new Date() }];
					}
					return out;
				});
			}
			setDone(Boolean(state?.done));
		} catch (_err) {
			// Emitir mensaje de error simple
			setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: 'Ocurrió un error al avanzar el plan.', timestamp: new Date() }]);
		} finally {
			setIsTyping(false);
		}
	}

	function sendMessage(content: string) {
		if (!content || !content.trim()) return;
		void turn(content);
	}

	function clearMessages() {
		setMessages([]);
	}

	return { messages, isTyping, done, sendMessage, clearMessages };
}


```
=== EOF: src\hooks\usePlanChat.ts

===  src\core\types.ts
```typescript
import { z } from 'zod';

// 🚀 ESQUEMAS ZOD PARA VALIDACIÓN GARANTIZADA

export const PedagogicalResponseSchema = z.object({
  respuesta: z.string().min(10, "La respuesta debe tener al menos 10 caracteres"),
  momento_actual: z.string().min(1, "Debe especificar el momento actual"),
  progreso: z.number().int().min(1, "El progreso debe ser un número entero positivo"),
  total_momentos: z.number().int().min(1, "El total de momentos debe ser positivo"),
  debe_avanzar: z.boolean(),
  razon_avance: z.string().min(5, "La razón debe tener al menos 5 caracteres"),
  siguiente_momento: z.string(),
  preguntas_pendientes: z.number().int().min(0, "Las preguntas pendientes no pueden ser negativas"),
  preguntas_respondidas: z.number().int().min(0, "Las preguntas respondidas no pueden ser negativas"),
  // ✨ NUEVOS CAMPOS PARA FEEDBACK Y VALIDACIÓN
  feedback_tipo: z.enum(['POSITIVO', 'CONSTRUCTIVO', 'CORRECTIVO']).optional(),
  respuesta_valida: z.boolean().optional(),
  criterios_cumplidos: z.array(z.string()).optional(),
  nueva_pregunta: z.string().nullable().optional(),
  pistas_graduales: z.array(z.string()).nullable().optional(),
  intentos_restantes: z.number().int().min(0).nullable().optional()
});

export const SessionInfoSchema = z.object({
  sessionKey: z.string().min(1),
  progress: z.string(),
  currentMoment: z.string(),
  pendingQuestions: z.number().int().min(0)
});

// 🎯 TIPOS INFERIDOS DE LOS ESQUEMAS

export type PedagogicalResponse = z.infer<typeof PedagogicalResponseSchema>;
export type SessionInfo = z.infer<typeof SessionInfoSchema>;

// 📚 TIPOS ADICIONALES

export interface Course {
  id: string;
  name: string;
  specialist_role: string;
  description: string;
}

export interface Session {
  id: string;
  name: string;
  learning_objective: string;
  key_points: string[];
}

export interface Momento {
  momento: string;
  preguntas?: string[];
  preguntas_evaluacion?: Array<{
    id_pregunta?: string;
    pregunta: string;
    tipo: string;
    objetivo: string;
    respuestas_aceptables: string[];
  }>;
  contenido_tecnico?: string[];
  historia?: string;
  caso?: string;
  instrucciones_docenteia?: string;
  objetivo?: string;
  contenido_clave?: string[];
  contenido_tecnico_detallado?: any[];
}

export interface SessionData {
  courseId: string;
  sessionId: string;
  course: Course;
  session: Session;
  momentos: Momento[];
  currentMomentIndex: number;
  preguntasPendientes: string[];
  preguntasRespondidas: string[];
  startTime: Date;
  lastActivity: Date;
  // 🆕 Estado pedagógico
  contenidoNarrado?: string[];
  // 🆕 Palabras clave derivadas por momento para clasificación temática
  momentKeywords?: string[][];
  // 🆕 Métricas por momento
  momentMetrics?: Array<{
    contentChunksTotal: number;
    contentChunksShown: number;
    definitionsTotal: number;
    definitionsShown: number;
    questionsTotal: number;
    questionsAsked: number;
  }>;
  // 🆕 Políticas de sesión (configurables por instancia)
  policies?: {
    noSpoilers?: boolean;
    hintStyle?: 'ABSTRACT' | 'KEYWORD';
    vaguePhrases?: string[];
    ackPhrases?: string[];
    forbiddenPhrases?: string[];
  };
}

// 🔧 TIPOS DE CONFIGURACIÓN

export interface OpenAIConfig {
  apiKey: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
}

export interface CostTrackingConfig {
  enabled: boolean;
  maxCostPerSession: number;
  currency: string;
}

// 🧠 INTERFACES PARA ANÁLISIS PEDAGÓGICO
export interface ResponseAnalysis {
  contentScore: number;
  relevanceScore: number;
  completenessScore: number;
  pedagogicalValue: number;
  feedback: string;
  extractedConcepts: string[];
  extractedInsights: string[];
  type: 'CORRECT' | 'PARTIALLY_CORRECT' | 'ATTEMPTED' | 'EVADED';
  confidence: number;
  // Motivo opcional de clasificación (para trazabilidad: vaga, incoherente, etc.)
  reasonCode?: 'VAGUE' | 'INCOHERENT' | 'OFF_TOPIC' | 'THRESHOLD';
}
```
=== EOF: src\core\types.ts

===  src\core\courseLoader.ts
```typescript
export type CourseLessonRef = { id: string; title?: string; order?: number; path: string };

export type CourseSpecialist = {
  role?: string;
  expertise?: string;
  years?: number;
  tone?: string;
  style_guidelines?: string;
};

export type CourseVM = {
  id: string;
  name: string;
  version: string;
  language: string;
  objectives: string[];
  specialist: CourseSpecialist;
  lessons: CourseLessonRef[];
  policiesUrl?: string;
  overridesUrl?: string;
};

export async function loadCourseVM(path = '/courses/SSO001/course.json'): Promise<CourseVM> {
  const res = await fetch(path);
  if (!res.ok) throw new Error(`No se pudo cargar el curso: ${path}`);
  const raw = await res.json();
  return {
    id: raw.id,
    name: raw.name,
    version: raw.version,
    language: raw.language || 'es',
    objectives: Array.isArray(raw.objectives) ? raw.objectives : [],
    specialist: (raw.specialist || {}) as CourseSpecialist,
    lessons: Array.isArray(raw.lessons) ? raw.lessons : [],
    policiesUrl: raw.policiesUrl || `/courses/${raw.id}/policies.json`,
    overridesUrl: raw.overridesUrl || `/courses/${raw.id}/overrides.json`,
  } as CourseVM;
}


```
=== EOF: src\core\courseLoader.ts

===  src\components\VoiceRecorder.tsx
```tsx
'use client';
import { Mic } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

export default function VoiceRecorder({ onResult, language = 'es' }: { onResult: (text: string) => void; language?: string }) {
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const [recording, setRecording] = useState(false);
  const [supported, setSupported] = useState(true);

  useEffect(() => {
    if (!navigator.mediaDevices || typeof window === 'undefined' || !(window as any).MediaRecorder) {
      setSupported(false);
    }
  }, []);

  const start = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mr = new MediaRecorder(stream);
      mediaRecorderRef.current = mr;
      chunksRef.current = [];
      mr.ondataavailable = e => { if (e.data && e.data.size > 0) chunksRef.current.push(e.data); };
      mr.onstop = async () => {
        try {
          const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
          const form = new FormData();
          form.append('audio', blob, 'audio.webm');
          form.append('language', language);
          const res = await fetch('/api/audio/transcribe', { method: 'POST', body: form });
          const data = await res.json();
          if (data?.text) onResult(data.text);
        } catch {}
      };
      mr.start();
      setRecording(true);
    } catch {
      setSupported(false);
    }
  };

  const stop = () => {
    const mr = mediaRecorderRef.current;
    if (mr && mr.state !== 'inactive') {
      mr.stop();
      setRecording(false);
    }
  };

  if (!supported) return null;

  return (
    <button
      onClick={() => (recording ? stop() : start())}
      className={`rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg ${
        recording ? 'bg-gradient-to-r from-rose-600 to-red-600 text-white p-3' : 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white p-3'
      }`}
      title={recording ? 'Detener dictado' : 'Dictar con voz'}
      aria-label={recording ? 'Detener dictado' : 'Dictar con voz'}
      type="button"
    >
      <Mic className="w-5 h-5" />
    </button>
  );
}


```
=== EOF: src\components\VoiceRecorder.tsx

===  src\components\EngineChatLayout.tsx
```tsx
'use client';
// Legacy layout: remove tight coupling with legacy core types
type LessonVM = any;
type EngineState = any;
import { Clock, Menu, Send, User, X } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import VoiceRecorder from './VoiceRecorder';

export type EngineChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

export default function EngineChatLayout({
  messages,
  isTyping,
  onSend,
  vm,
  state
}: {
  messages: EngineChatMessage[];
  isTyping: boolean;
  onSend: (text: string) => void;
  vm: LessonVM | null;
  state: EngineState | null;
}) {
  const [inputValue, setInputValue] = useState('');
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages, isTyping]);

  const handleSend = () => {
    if (!inputValue.trim()) return;
    onSend(inputValue);
    setInputValue('');
  };

  const handleKey = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }
  };

  return (
    <div className="min-h-screen bg-slate-100">
      {/* Header */}
      <header className="bg-white border-b border-slate-200 px-4 md:px-6 py-3 md:py-4 sticky top-0 z-40">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="bg-gradient-to-br from-blue-600 to-indigo-600 p-2.5 rounded-xl shadow-lg" />
            <div>
              <h1 className="text-lg md:text-xl font-bold text-slate-900">{vm?.title || 'DocenteIA'}</h1>
              <p className="text-xs md:text-sm text-slate-600">Versión {vm?.version} · {vm?.locale}</p>
            </div>
          </div>
          <button onClick={() => setSidebarOpen(!sidebarOpen)} className="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 transition-colors">
            {sidebarOpen ? <X className="w-5 h-5" /> : <Menu className="w-5 h-5" />}
          </button>
        </div>
      </header>

      <div className="flex h-[calc(100vh-72px)]">
        {/* Main chat (más ancho que multimedia) */}
        <div className={`transition-all duration-300 w-full ${sidebarOpen ? 'lg:basis-[60%] xl:basis-[65%]' : 'lg:basis-[70%] xl:basis-[75%]'}`}>
          <div className="h-full bg-white m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-6 space-y-6">
              {messages.map((m) => (
                <div key={m.id} className={`flex items-start space-x-4 ${m.sender === 'student' ? 'flex-row-reverse space-x-reverse' : ''}`}>
                  <div className={`w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold shadow-md ${m.sender === 'ai' ? 'bg-gradient-to-br from-blue-600 to-indigo-600 text-white' : 'bg-gradient-to-br from-slate-600 to-slate-700 text-white'}`}>
                    {m.sender === 'ai' ? 'AI' : <User className="w-5 h-5" />}
                  </div>
                  <div className={`flex-1 max-w-[85%] ${m.sender === 'student' ? 'text-right' : ''}`}>
                    <div className={`inline-block px-5 py-3 rounded-2xl shadow-sm ${m.sender === 'student' ? 'bg-gradient-to-r from-blue-600 to-blue-700 text-white' : 'bg-white border border-slate-200 text-slate-900'}`}>
                      <p className="text-sm leading-relaxed whitespace-pre-wrap">{m.content}</p>
                    </div>
                    <div className={`mt-2 flex items-center space-x-2 ${m.sender === 'student' ? 'justify-end' : 'justify-start'}`}>
                      <Clock className="w-3 h-3 text-slate-400" />
                      <span className="text-xs text-slate-500">{m.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    </div>
                  </div>
                </div>
              ))}
              {isTyping && (
                <div className="text-xs text-slate-500">Docente escribiendo…</div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <div className="px-6 py-3 border-t border-slate-200 bg-slate-50 rounded-b-2xl">
              <div className="flex items-end space-x-2">
                <textarea
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKey}
                  placeholder="Escribe tu respuesta..."
                  rows={1}
                  className="flex-1 w-full px-4 py-3 bg-white border border-slate-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  style={{ minHeight: '48px', maxHeight: '120px' }}
                />
                <VoiceRecorder onResult={(t)=>setInputValue((v)=> (v ? (v+ ' ' + t) : t))} />
                <button onClick={handleSend} disabled={!inputValue.trim()} className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-slate-300 disabled:to-slate-400 text-white p-3 rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg disabled:shadow-none">
                  <Send className="w-5 h-5" />
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Middle: Contenido Multimedia */}
        <div className={`hidden lg:block transition-all duration-300 ${sidebarOpen ? 'lg:basis-[25%] xl:basis-[20%]' : 'lg:basis-[30%] xl:basis-[25%]'} `}>
          <div className="h-full bg-white m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="font-semibold text-slate-900">Contenido Multimedia</h3>
            </div>
            <div className="flex-1 p-6">
              <div className="bg-gradient-to-br from-slate-100 to-slate-200 rounded-xl text-slate-400 border border-slate-200 flex items-center justify-center aspect-video min-h-[180px]">
                <span className="text-xs">Imagen/Video</span>
              </div>
              <div className="mt-4 text-xs text-slate-600">Contenido multimedia de la sesión</div>
            </div>
          </div>
        </div>

        {/* Right side: Progreso (animado al cerrar) */}
        <div className={`hidden lg:block transition-all duration-300 pr-3 ${sidebarOpen ? 'lg:basis-[15%] xl:basis-[15%] opacity-100' : 'lg:basis-0 opacity-0 pointer-events-none'}`}>
          <div className={`h-full m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col bg-white transition-all duration-300 ${sidebarOpen ? 'scale-100' : 'scale-95'}`}>
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="font-semibold text-slate-900">Progreso de la sesión</h3>
            </div>
            <div className="p-6 space-y-4 overflow-y-auto">
              {vm && state && (
                <>
                  <div>
                    <div className="flex justify-between text-sm mb-1">
                      <span className="text-slate-600">Momento</span>
                      <span className="font-medium text-slate-900">{state.momentIdx + 1}/{vm.moments.length}</span>
                    </div>
                    <div className="w-full bg-slate-100 rounded-full h-2">
                      <div className="bg-gradient-to-r from-blue-600 to-indigo-600 h-2 rounded-full transition-all" style={{ width: `${Math.round(((state.momentIdx + 1) / Math.max(1, vm.moments.length)) * 100)}%` }} />
                    </div>
                  </div>
                  <div>
                    <h4 className="text-xs font-medium text-slate-700 mb-2">Momentos</h4>
                    <div className="space-y-2">
                      {vm.moments.map((m, i) => (
                        <div key={`${m.title}-${i}`} className={`flex items-center gap-2 text-xs ${i === state.momentIdx ? 'text-blue-700' : 'text-slate-500'}`}>
                          <span className={`w-2 h-2 rounded-full ${i === state.momentIdx ? 'bg-blue-600' : 'bg-slate-300'}`} />
                          <span className="truncate">{m.title}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                  {vm.keyPoints && vm.keyPoints.length > 0 && (
                    <div>
                      <h4 className="text-xs font-medium text-slate-700 mb-2">Puntos Clave</h4>
                      <div className="space-y-2">
                        {vm.keyPoints.map(kp => (
                          <div key={kp.id} className={`p-3 rounded-lg border ${kp.completed ? 'bg-green-50 border-green-200' : 'bg-slate-50 border-slate-200'}`}>
                            <div className="text-xs font-medium text-slate-800">{kp.title}</div>
                            {kp.description && <div className="text-[11px] text-slate-600 mt-1">{kp.description}</div>}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


```
=== EOF: src\components\EngineChatLayout.tsx

===  public\courses\registry.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "SSO001",
      "lessons": [
        {
          "id": "lesson02",
          "name": "Lección 02",
          "planUrl": "/courses/SSO001/lessons/lesson02.json"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\registry.json

===  src\ai\prompt.ts
```typescript
export type DocenteAction = 'explain' | 'ask' | 'hint' | 'ok' | 'advance' | 'end' | 'ask_simple' | 'ask_options' | 'feedback';

export type DocentePromptContext = {
  language?: string;
  course?: { role?: string; tone?: string; style_guidelines?: string };
  action: DocenteAction;
  stepType: string;
  momentTitle?: string;
  objective?: string;
  contentBody?: string[];
  narrationText?: string;
  caseText?: string;
  questionText?: string;
  acceptable?: string[];
  userAnswer?: string;
  matched?: string[];
  missing?: string[];
  recentHistory?: string[];
  hintWordLimit?: number;
  simpleOptions?: string[];
  optionItems?: string[];
  kind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  closureCriteria?: string;
  allowQuestions?: boolean;
};

export function buildSystemPrompt(ctx: DocentePromptContext): string {
  const lang = ctx.language || 'es';
  const role = ctx.course?.role ? `Actúa como ${ctx.course.role}.` : '';
  const tone = ctx.course?.tone ? `Tono: ${ctx.course.tone}.` : '';
  const style = ctx.course?.style_guidelines ? `Guía de estilo: ${ctx.course.style_guidelines}.` : '';
  const rules = [
    `Eres un Docente IA uno-a-uno. Responde en ${lang}.`,
    role,
    tone,
    style,
    'Sigue estrictamente el paso actual del plan. No avances ni mezcles pasos.',
    'Nunca copies literal el JSON; reescribe con tus palabras. Evita viñetas/listas y parágrafos largos.',
    'Preferentemente 2–3 frases por bloque; usar hasta 4–5 cuando el objetivo requiera retroalimentación concreta. Lenguaje claro. No spoilers.',
    'Si el estudiante responde "no sé" repetidamente, reduce dificultad según la acción solicitada.',
    'Normaliza el error y la duda: valida el esfuerzo y anima a continuar antes de orientar.',
    'Al interpretar la respuesta del estudiante, considera equivalencias semánticas razonables (términos extremos/coloquiales ≈ categorías profesionales) y reencuadra con lenguaje técnico sin añadir conceptos fuera del objetivo/contenido.',
    'Mantén continuidad con el último turno: si ya respondió, no repitas la misma pregunta; continúa dentro del paso según el plan.',
    'Evita repetir el mismo ejemplo en turnos consecutivos; varíalo o adáptalo al contexto de la respuesta.',
    'No repitas exactamente la misma idea en dos turnos seguidos; añade un matiz o detalle nuevo.',
    'Solo avanza cuando se cumpla el criterio de cierre del paso actual (si aplica).',
    'En acciones ask, hint, feedback, ask_simple y ask_options no re-narres el caso ni describas la situación inicial; si fuera imprescindible, referencia en UNA sola frase sin repetir detalles. Reserva la narración extensa solo para explain.'
  ].filter(Boolean).join(' ');
  return rules;
}

export function buildUserPrompt(ctx: DocentePromptContext): string {
  const lines: string[] = [];

  // Helpers
  const pushIf = (cond: any, s: string) => { if (cond) lines.push(s.trim()); };
  const hasAny = (...vals: Array<string | string[] | undefined | null>) =>
    vals.some(v => Array.isArray(v) ? v.filter(Boolean).length > 0 : !!v);

  // Header
  pushIf(true, `Momento: ${ctx.momentTitle || ''}`); // permite vacío pero mantiene etiqueta
  pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);

  // Normalizaciones
  const contentItems = Array.from(new Set((ctx.contentBody || [])
    .filter(Boolean)
    .map(s => String(s).trim())))
    .slice(0, 20);
  const safeAnswer = String(ctx.userAnswer || '').trim().slice(0, 300);
  const matched = Array.from(new Set(ctx.matched || [])).filter(Boolean).slice(0, 8);
  const missing = Array.from(new Set(ctx.missing || [])).filter(Boolean).slice(0, 8);
  const recent = (ctx.recentHistory || []).slice(-3).join(' | ');
  pushIf(recent, `Historial reciente: ${recent}`);
  pushIf(ctx.closureCriteria, `Criterio de cierre: ${ctx.closureCriteria}`);

  switch (ctx.action) {
    case 'explain': {
      if (!hasAny(ctx.narrationText, contentItems, ctx.caseText)) {
        lines.push('Faltan insumos para explicar (narración, contenido o caso).');
      }
      const payload = [
        ctx.narrationText ? `Narración: ${ctx.narrationText}` : '',
        contentItems.length ? `Contenido: ${contentItems.join(' | ')}` : '',
        ctx.caseText ? `Caso: ${ctx.caseText}` : ''
      ].filter(Boolean).join('\n');
      pushIf(payload, payload);
      lines.push('Tarea: explica con TUS PALABRAS el contenido en 2–3 frases, sin listas ni preguntas.');
      lines.push('Reglas: si ya se usó este ejemplo, varíalo o adáptalo; no avances si el criterio de cierre no se cumple.');
      break;
    }

    case 'ask': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      lines.push('Tarea: enmarca brevemente y cierra con la PREGUNTA EXACTA tal cual. No añadas contenido nuevo.');
      lines.push('Reglas: si el estudiante ya respondió esta pregunta en el turno previo, no la repitas; produce una transición breve y continúa dentro del paso sin avanzar al siguiente hasta cumplir el criterio de cierre. No re-narres el caso ni repitas la historia.');
      break;
    }

    case 'hint': {
      if (!ctx.questionText) lines.push('Falta la pregunta para la pista.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      pushIf(contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
      pushIf(safeAnswer, `Respuesta del estudiante: ${safeAnswer}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      const limit = ctx.hintWordLimit || 18;
      lines.push(
        `Tarea: primero escribe UNA pista (${limit} palabras aprox., sin signos de interrogación) orientada al OBJETIVO (no listar soluciones ni definiciones generales). ` +
        `Luego, en una línea aparte, UNA sola micro‑pregunta (≤8 palabras) centrada en el objetivo o el primer faltante. Nunca devuelvas solo preguntas.`
      );
      lines.push('Reglas: evita repetir la misma micro‑pregunta usada en el turno previo (usa Historial reciente). No re‑narrar el caso.');
      break;
    }

    case 'ask_simple': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const opts = Array.from(new Set(ctx.simpleOptions || [])).filter(Boolean).slice(0, 5);
      if (opts.length) {
        lines.push(`Opciones (elige una): ${opts.join(' / ')}`);
      }
      lines.push('Tarea: formula la elección de forma clara y breve. No re‑narrar el caso.');
      break;
    }

    case 'ask_options': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const items = Array.from(new Set(ctx.optionItems || [])).filter(Boolean).slice(0, 5);
      if (items.length) {
        const labeled = items.map((s, i) => `${String.fromCharCode(65 + i)}) ${s}`);
        lines.push(`Opciones: ${labeled.join(' | ')}`);
      }
      lines.push('Tarea: pide que elija una opción (A, B, C, …) y espera su selección. No re‑narrar el caso.');
      break;
    }

    case 'ok': {
      if (!ctx.questionText) lines.push('Falta la pregunta que se está validando.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      lines.push('Tarea: en 1–2 frases, reconoce lo correcto citando los aciertos y, si aplica, orienta brevemente lo que falta, sin preguntas. No introduzcas contenido nuevo.');
      break;
    }

    case 'advance': {
      lines.push('Tarea: micro‑resumen de cierre (1–2 frases) y puente corto al siguiente foco.');
      break;
    }

    case 'end': {
      lines.push('Tarea: cierre final breve.');
      break;
    }

    case 'feedback': {
      const limit = ctx.hintWordLimit || 3; // número de frases esperado, controlable por policies.feedback.maxSentences via caller
      const allowQ = ctx.allowQuestions !== false; // default: true
      pushIf(true, `Momento: ${ctx.momentTitle || ''}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.userAnswer, `Respuesta del estudiante: ${safeAnswer}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      pushIf(contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
      // Semántica para reencuadre sin hardcodeos
      const sem = [
        Array.isArray(ctx.acceptable) && ctx.acceptable.length ? `Aceptables: ${ctx.acceptable.join(' | ')}` : '',
        matched.length ? `Señales presentes: ${matched.join(' | ')}` : '',
        missing.length ? `Señales faltantes: ${missing.join(' | ')}` : ''
      ].filter(Boolean).join('\n');
      pushIf(sem, sem);
      const kind = (ctx.kind || 'HINT').toUpperCase();
      if (kind === 'ACCEPT') {
        lines.push(
          `Tarea (feedback: ACCEPT): escribe hasta ${limit} frases: ` +
          `1) empieza con una frase de refuerzo específica citando 1–2 aciertos (usa Aciertos); ` +
          `2) si procede, orienta brevemente el siguiente foco` + (allowQ ? '' : `, sin preguntas`) + `, sin revelar respuestas. No re‑narrar el caso.`
        );
      } else if (kind === 'PARTIAL') {
        lines.push(
          `Tarea (feedback: PARTIAL): escribe ${limit} frases: ` +
          `1) valida el esfuerzo y nombra lo correcto (usa Aciertos) sin repetir fórmulas de ánimo ya usadas; ` +
          `2) si el término del estudiante es extremo/coloquial (p. ej., "se muere"), infiere su categoría semántica próxima (p. ej., lesión grave por caída) y reencuadra con lenguaje profesional; ` +
          `orienta 1 faltante con una pista concreta alineada al objetivo/contenido (usa Faltantes y Pistas de contenido). ` +
          (allowQ ? '' : `No incluyas preguntas. `) + `Evita definiciones generales y no reveles soluciones completas.`
        );
      } else if (kind === 'REFOCUS') {
        lines.push(
          `Tarea (feedback: REFOCUS): escribe hasta ${limit} frases: ` +
          `1) ofrece ánimo (sin repetirlo si ya fue expresado) y señala con amabilidad el desvío; ` +
          `2) redirige al criterio/objetivo central en forma concreta` + (allowQ ? '' : `, sin preguntas`) + `. No re‑narrar el caso.`
        );
      } else {
        // HINT o evasiva
        lines.push(
          `Tarea (feedback: HINT): escribe ${limit} frases: ` +
          `1) normaliza la duda y anima a continuar (evita repetir empatía si ya fue usada en el turno previo); ` +
          `2) da una pista concreta alineada al objetivo (usa Pistas de contenido o el primer Faltante); si el término es extremo/coloquial, reencuadra con lenguaje profesional. No re‑narrar el caso.` + (allowQ ? '' : ` No incluyas preguntas.`)
        );
      }
      break;
    }

    default: {
      lines.push(`Acción desconocida: ${String((ctx as any).action)}`);
      break;
    }
  }

  // Limpieza final: sin líneas vacías y con espacios normalizados
  return lines
    .map(s => s.trim())
    .filter(Boolean)
    .join('\n');
}


```
=== EOF: src\ai\prompt.ts

===  src\ai\orchestrator.ts
```typescript
import OpenAI from 'openai';
import { buildSystemPrompt, buildUserPrompt, DocentePromptContext } from './prompt';

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

function stripQuestions(text?: string): string {
  const raw = (text || '').trim();
  if (!raw) return '';
  // Quita oraciones que terminen en ? o ¿ a nivel de frase, manteniendo el resto
  const sentences = raw.split(/(?<=[\.!?¿])\s+/).filter(Boolean);
  return sentences.filter(s => !/[?¿]\s*$/.test(s.trim())).join(' ');
}

function lastQuestion(text?: string): string {
  const lines = (text || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
  const qs = lines.filter(l => /[?¿]\s*$/.test(l));
  return qs[qs.length - 1] || '';
}

function normalizeForMatch(s: string): string {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/\s+/g, ' ')
    .trim();
}

// Anti re‑narración: elimina párrafos exactos presentes en el historial reciente
function stripRepeatedFromHistory(text: string, ctx: DocentePromptContext): string {
  const raw = (text || '').trim();
  if (!raw || !Array.isArray(ctx.recentHistory) || ctx.recentHistory.length === 0) return raw;
  const historyBlob = normalizeForMatch(ctx.recentHistory.join(' \n '));
  const paras = raw.split(/\n\n+/).map(s => s.trim()).filter(Boolean);
  const kept: string[] = [];
  for (const p of paras) {
    const pNorm = normalizeForMatch(p);
    const isRepeated = pNorm.length >= 60 && historyBlob.includes(pNorm);
    if (!isRepeated) kept.push(p);
  }
  return kept.join('\n\n').trim();
}

export async function runDocenteLLM(ctx: DocentePromptContext): Promise<{ message: string; followUp?: string }> {
  const system = buildSystemPrompt(ctx);
  const user = buildUserPrompt(ctx);
  const r = await client.responses.create({
    model: 'gpt-4o-mini',
    input: [
      { role: 'system', content: system },
      { role: 'user', content: user },
    ],
    temperature: 0.30,
  });
  const out = ((r as any).output_text || '').trim();
  if (ctx.action === 'explain') {
    return { message: stripQuestions(out) };
  }
  if (ctx.action === 'ask') {
    // Garantizar que la pregunta final sea la del JSON
    const q = (ctx.questionText || '').trim();
    let msg = stripQuestions(out);
    msg = stripRepeatedFromHistory(msg, ctx);
    const norm = (s: string) => s.replace(/\s+/g, ' ').toLowerCase();
    const already = norm(msg).includes(norm(q));
    return { message: already ? msg : [msg, q].filter(Boolean).join('\n\n') };
  }
  if (ctx.action === 'ok' || ctx.action === 'advance') {
    // Evitar que el reconocimiento o el puente incluyan preguntas
    let msg = stripQuestions(out);
    msg = stripRepeatedFromHistory(msg, ctx);
    return { message: msg };
  }
  if (ctx.action === 'hint') {
    let msg = stripQuestions(out);
    msg = stripRepeatedFromHistory(msg, ctx);
    const follow = lastQuestion(out);
    return { message: msg, followUp: follow };
  }
  if (ctx.action === 'ask_simple' || ctx.action === 'ask_options') {
    const msg = stripRepeatedFromHistory(out, ctx);
    return { message: msg };
  }
  if (ctx.action === 'feedback') {
    // No eliminar preguntas en feedback; solo evitar re‑narración repetida
    const msg = stripRepeatedFromHistory(out, ctx);
    return { message: msg };
  }
  return { message: out };
}


```
=== EOF: src\ai\orchestrator.ts

===  app\engine-chat\page.tsx
```tsx
"use client";
import EngineChatLayout from '@/components/EngineChatLayout';
import { usePlanChat } from '@/hooks/usePlanChat';
import { useEffect, useMemo, useState } from 'react';

type LessonRef = { id: string; name?: string; planUrl: string };
type CourseRef = { id: string; name?: string; lessons: LessonRef[] };
type Registry = { courses: CourseRef[] };

export default function EngineChatPage() {
  const [registry, setRegistry] = useState<Registry | null>(null);
  const [selectedCourseId, setSelectedCourseId] = useState<string>('');
  const [selectedLessonId, setSelectedLessonId] = useState<string>('');

  // derive current planUrl from selection
  const planUrl: string | null = useMemo(() => {
    if (!registry || !selectedCourseId || !selectedLessonId) return null;
    const course = registry.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return lesson?.planUrl || null;
  }, [registry, selectedCourseId, selectedLessonId]);

  const { messages, isTyping, done, sendMessage, clearMessages } = usePlanChat(planUrl || '/courses/SSO001/lessons/lesson02.json');

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        const res = await fetch('/courses/registry.json');
        if (!res.ok) return;
        const json = (await res.json()) as Registry;
        if (!alive) return;
        setRegistry(json);
        // default selection: first course/lesson
        const c = json.courses?.[0];
        if (c) {
          setSelectedCourseId(prev => prev || c.id);
          const l = c.lessons?.[0];
          if (l) setSelectedLessonId(prev => prev || l.id);
        }
      } catch {}
    })();
    return () => { alive = false; };
  }, []);

  // Simple VM/state placeholders for EngineChatLayout
  const vm = useMemo(() => {
    const course = registry?.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return {
      title: [course?.name || course?.id, lesson?.name || lesson?.id].filter(Boolean).join(' · ') || 'DocenteIA',
      version: 'plan',
      locale: 'es-CL',
      moments: [],
      keyPoints: []
    } as any;
  }, [registry, selectedCourseId, selectedLessonId]);

  const state = useMemo(() => ({ momentIdx: 0 }), []);

  return (
    <div className="min-h-screen bg-slate-100">
      <div className="w-full px-2 md:px-4 py-4">
        <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4 mb-4 flex flex-col md:flex-row gap-3">
          <div className="flex-1 grid grid-cols-1 md:grid-cols-3 gap-3">
            <select
              className="border rounded-lg px-3 py-2"
              value={selectedCourseId}
              onChange={(e) => { setSelectedCourseId(e.target.value); setSelectedLessonId(''); clearMessages(); }}
            >
              <option value="">Selecciona curso…</option>
              {registry?.courses.map(c => (
                <option key={c.id} value={c.id}>{c.name || c.id}</option>
              ))}
            </select>
            <select
              className="border rounded-lg px-3 py-2"
              value={selectedLessonId}
              onChange={(e) => { setSelectedLessonId(e.target.value); clearMessages(); }}
              disabled={!selectedCourseId}
            >
              <option value="">Selecciona lección…</option>
              {registry?.courses.find(c => c.id === selectedCourseId)?.lessons.map(l => (
                <option key={l.id} value={l.id}>{l.name || l.id}</option>
              ))}
            </select>
            <div className="flex items-center gap-2">
              <button onClick={() => clearMessages()} className="border rounded-lg px-3 py-2">Nueva sesión</button>
              {done && <span className="text-green-600 text-sm">Fin de la lección</span>}
            </div>
          </div>
        </div>

        <EngineChatLayout
          messages={messages as any}
          isTyping={isTyping}
          onSend={(t) => sendMessage(t)}
          vm={vm}
          state={state as any}
        />
      </div>
    </div>
  );
}


```
=== EOF: app\engine-chat\page.tsx

===  .data\history\plan-1755385171765-9zn2rxmp.jsonl
```
{"ts":1755400734470,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Hola, bienvenido. En esta sesión, vamos a hablar sobre los procedimientos de seguridad, que son las normas y acciones que se deben seguir para garantizar un entorno laboral seguro. Es fundamental entender su importancia para prevenir accidentes y proteger la salud de todos en el trabajo.","followUp":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?"}
{"ts":1755400743313,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Intenta precisar un poco más. Menciona: partes del procedimiento, cómo se aplica, importancia de seguirlos.\n\nEs normal no tener claridad en este momento, y está bien seguir explorando. Podrías pensar en las diferentes partes de un procedimiento de seguridad y cómo se aplican en el entorno laboral. Esto nos ayudará a entender su importancia y cómo contribuyen a un ambiente de trabajo seguro.\n\nLos procedimientos de seguridad son un conjunto de normas y acciones diseñadas para mantener un ambiente laboral seguro. Su comprensión es esencial, ya que ayudan a prevenir accidentes y garantizan la salud de todos los trabajadores. En esta sesión, exploraremos cómo aplicar estas normas en situaciones prácticas.","followUp":""}
{"ts":1755400759033,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Intenta precisar un poco más. Menciona: partes del procedimiento, cómo se aplica, importancia de seguirlos.\n\nEs completamente normal no tener claridad en este momento, y es un buen punto de partida para seguir explorando. Piensa en las diferentes partes que componen un procedimiento de seguridad, como las normas específicas y las acciones a seguir. Esto te ayudará a comprender mejor cómo se aplican en el entorno laboral y por qué es crucial seguirlas.\n\nLos procedimientos de seguridad son directrices que establecen cómo actuar en diversas situaciones para evitar riesgos en el trabajo. Comprender cada parte de estos procedimientos es clave, ya que nos ayuda a aplicar las normas adecuadamente y a reconocer su relevancia en la prevención de accidentes. Al seguir estas pautas, se protege la salud de todos los colaboradores en el entorno laboral.","followUp":""}
{"ts":1755400772737,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Intenta precisar un poco más. Menciona: partes del procedimiento, cómo se aplica, importancia de seguirlos.\n\nEs natural tener dudas al inicio, y eso es parte del proceso de aprendizaje. Te animo a que sigas explorando este tema. Piensa en las diferentes partes de un procedimiento de seguridad, como las normas específicas que se deben seguir y cómo se aplican en el día a día laboral. Esto te ayudará a entender mejor su importancia en la prevención de accidentes y en la protección de la salud de todos.\n\nLos procedimientos de seguridad son un conjunto de directrices que indican cómo actuar para minimizar riesgos en el trabajo. Cada parte de estos procedimientos, como las normas y las acciones específicas, es fundamental para garantizar un ambiente seguro. Al seguir estas pautas, se protege la salud de todos los trabajadores y se previenen accidentes.","followUp":""}
```
=== EOF: .data\history\plan-1755385171765-9zn2rxmp.jsonl

===  .data\history\plan-1755314867175-r5b9uhf3.jsonl
```
{"ts":1755319645358,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Hola, bienvenido. En esta sesión, vamos a hablar sobre los procedimientos de seguridad, que son esenciales para mantener un ambiente laboral seguro. Veremos por qué son importantes y cómo pueden ayudarnos a prevenir accidentes y proteger a todos en el trabajo.","followUp":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?"}
{"ts":1755319659226,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"Bien: mencionaste partes del procedimiento.\n\nEs genial que estés interesado en las partes del procedimiento de seguridad, ya que son fundamentales para entender cómo funcionan. En esta sesión, también exploraremos cómo se aplican estos procedimientos y por qué es crucial seguirlos, además de la selección de equipos de protección personal. Esto te ayudará a tener una visión más completa sobre la seguridad en el trabajo.\n\nEspero que en esta sesión puedas comprender la importancia de los procedimientos de seguridad y cómo su correcta implementación puede prevenir accidentes en el entorno laboral. Ahora, pasemos a explorar algunos ejemplos específicos de estos procedimientos y su aplicación práctica.\n\nEn una obra, un operario que debe colocar ventanas en un tercer piso recibe un arnés de seguridad, aunque no tiene experiencia trabajando en alturas. Es fundamental que aprenda a usar este equipo correctamente para evitar accidentes y garantizar su seguridad. La capacitación en procedimientos de seguridad es clave para prevenir riesgos laborales en situaciones como esta.","followUp":"¿Qué elementos de seguridad identificas en esta situación?"}
{"ts":1755319676580,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":6,"momentIdx":1,"message":"Bien: mencionaste arnés, arnés de seguridad.\n\nHas identificado correctamente el arnés y el arnés de seguridad, lo cual es un gran comienzo. Sin embargo, también es importante considerar otros elementos como la línea de vida y el casco, que son esenciales para garantizar la seguridad en trabajos en altura. Ahora, piensa en cómo estos elementos trabajan juntos para proteger al trabajador en esa situación.","followUp":"¿Qué podría pasar si no se siguen los procedimientos correctos?"}
{"ts":1755319705768,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":8,"momentIdx":2,"message":"Bien: mencionaste lesiones, accidentes, sanciones.\n\nHas hecho un buen trabajo al identificar que no seguir los procedimientos correctos puede llevar a accidentes y lesiones. Además, es importante considerar que también podrían haber sanciones para la empresa. Ahora, reflexiona sobre otros posibles riesgos, como las caídas y las multas, que pueden surgir si no se cumplen las normas de seguridad.\n\nSi no se siguen los procedimientos correctos, el trabajador podría sufrir accidentes graves, lo que pone en riesgo su vida y la de sus compañeros. Es crucial entender que cada elemento de seguridad tiene un propósito específico para prevenir estos incidentes. Ahora, vamos a profundizar en la selección y uso adecuado de los equipos de protección personal.\n\nUn procedimiento de seguridad es una serie de pasos bien definidos que se deben seguir para realizar una tarea de manera segura, con el objetivo de reducir al mínimo los riesgos en el trabajo. Estos procedimientos están documentados para asegurar que todos los trabajadores conozcan y apliquen las medidas necesarias para protegerse y evitar accidentes. Así, se busca crear un ambiente laboral más seguro y eficiente.","followUp":"¿Cómo definirías un procedimiento de seguridad con tus palabras?"}
{"ts":1755319781015,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":8,"momentIdx":2,"message":"Aún no es claro. Intenta mencionar: secuencia documentada de pasos, realizar una tarea de forma segura, minimizar riesgos laborales.\n\nEs normal tener dudas al definir conceptos, así que sigue adelante, ¡estás haciendo un buen trabajo! Piensa en que un procedimiento de seguridad no solo es un documento, sino que también implica una secuencia ordenada de pasos que se deben seguir para realizar una tarea de manera segura. Esto ayuda a minimizar los riesgos laborales y a proteger a todos en el entorno de trabajo.\n\nUn procedimiento de seguridad es una secuencia documentada de pasos que se deben seguir para realizar una tarea de manera segura, minimizando los riesgos laborales.","followUp":"¿Qué pasos específicos incluirías en tu definición?"}
```
=== EOF: .data\history\plan-1755314867175-r5b9uhf3.jsonl

===  .data\history\plan-1755304529774-nofsde57.jsonl
```
{"ts":1755311667101,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Hola, bienvenido. En esta sesión, vamos a hablar sobre los procedimientos de seguridad, que son normas y prácticas esenciales para garantizar un ambiente laboral seguro. Comprenderemos por qué son tan importantes y cómo pueden protegernos a todos en el trabajo.","followUp":"¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?"}
{"ts":1755311686480,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":4,"momentIdx":1,"message":"Es genial que ya tengas claro que quieres aprender sobre las partes del procedimiento de seguridad. Esto es fundamental, ya que cada elemento juega un papel clave en la protección de todos en el entorno laboral. A lo largo de la sesión, también exploraremos cómo se aplican estos procedimientos y la importancia de seguirlos, así como la selección adecuada de equipos de protección personal.\n\nEspero aprender sobre las normas específicas que debo seguir para mantenerme seguro en el trabajo y cómo identificar posibles riesgos. Al final de esta sesión, veremos cómo aplicar estos procedimientos en situaciones reales.\n\nEn una obra, un trabajador que debe colocar ventanas en el tercer piso recibe un arnés de seguridad, aunque no tiene experiencia en trabajos en altura. Es fundamental que comprenda cómo usar el arnés correctamente para evitar accidentes y garantizar su seguridad. La capacitación en procedimientos de seguridad es clave para proteger a todos en el entorno laboral.","followUp":"¿Qué elementos de seguridad identificas en esta situación?"}
{"ts":1755311817747,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":5,"momentIdx":1,"message":"En una obra, un trabajador que debe instalar ventanas en el tercer piso recibe un arnés de seguridad, pero carece de experiencia en trabajos en altura. Es crucial que aprenda a utilizar correctamente el arnés para prevenir accidentes y asegurar su bienestar. La capacitación en procedimientos de seguridad es esencial para proteger a todos en el lugar de trabajo.","followUp":"¿Qué elementos de seguridad identificas en esta situación?"}
```
=== EOF: .data\history\plan-1755304529774-nofsde57.jsonl

===  src\engine\flow\transition.ts
```typescript
export type TransitionAction = 'ask' | 'hint' | 'ask_simple' | 'ask_options' | 'explain' | 'ok';

export type EscalationConfig = {
  noSeToHint?: number;
  hintToAskSimple?: number;
  askSimpleToOptions?: number;
  hardStopToExplain?: number;
};

export function decideNextAction(params: {
  lastAction?: TransitionAction;
  classKind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  attempts: number;
  noSeCount: number;
  cfg?: EscalationConfig;
}): { nextAction: TransitionAction; resetNoSe?: boolean } {
  const { lastAction, classKind, attempts, noSeCount, cfg } = params;

  // Acierto explícito del clasificador
  if (classKind === 'ACCEPT') {
    return { nextAction: 'ok', resetNoSe: true };
  }

  // Si hay configuración explícita, respétala
  if (cfg) {
    const toHint = cfg.noSeToHint ?? Number.POSITIVE_INFINITY;
    const toSimple = cfg.hintToAskSimple ?? Number.POSITIVE_INFINITY;
    const toOptions = cfg.askSimpleToOptions ?? Number.POSITIVE_INFINITY;
    const toExplain = cfg.hardStopToExplain ?? Number.POSITIVE_INFINITY;

    if (lastAction === 'ask') {
      if (noSeCount >= toHint) return { nextAction: 'hint' };
      return { nextAction: 'ask' };
    }
    if (lastAction === 'hint') {
      if (noSeCount >= toSimple) return { nextAction: 'ask_simple' };
      return { nextAction: 'hint' };
    }
    if (lastAction === 'ask_simple') {
      if (noSeCount >= toOptions) return { nextAction: 'ask_options' };
      return { nextAction: 'ask_simple' };
    }
    if (lastAction === 'ask_options') {
      if (noSeCount >= toExplain) return { nextAction: 'explain' };
      return { nextAction: 'ask_options' };
    }
    // Fallback config-driven: empezar por ask
    return { nextAction: 'ask' };
  }

  // Sin configuración: preferir feedback primero cuando hay señales parciales
  if (classKind === 'PARTIAL') {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  } else {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  }
  return { nextAction: 'ask' };
}


```
=== EOF: src\engine\flow\transition.ts

===  public\courses\SSO001\policies.json
```json
{
  "language": {
    "stopwords": ["el","la","los","las","un","una","unos","unas","de","en","y","o","a","para","con","sobre","que","es","son","del","al","por","se","como","mas","más","menos","no","si","sí","qué","cuales","cuáles"]
  },
  "thresholds": {
    "conceptual": { "min": 1 },
    "identificacion": { "min": 1 },
    "listado": { "kDefault": 2 },
    "aplicacion": { "requiresJustification": true },
    "metacognitiva": { "min": 1 },
    "experiencial": { "min": 1 },
    "reflexiva": { "min": 1 }
  },
  "hints": {
    "wordLimits": [18, 35, 60],
    "escalateAfterAttempts": [1, 2, 3]
  },
  "advance": {
    "allowForcedOn": [],
    "maxAttemptsBeforeForce": 999
  },
  "vague": {
    "minUsefulTokens": 3,
    "maxStopwordRatio": 0.6,
    "echoOverlap": 0.7,
    "repeatSimilarity": 0.8,
    "vagueAttemptsBeforeAB": 2,
    "vagueAttemptsBeforeExplain": 3,
    "simplifiedAskMaxWords": 10
  },
  "typeMap": {
    "abierta": "metacognitiva",
    "diagnostica": "identificacion",
    "diagnóstica": "identificacion",
    "aplicacion_practica": "aplicacion",
    "aplicacion": "aplicacion",
    "analisis": "conceptual",
    "analisis_comparativo": "conceptual",
    "analisis_critico": "conceptual",
    "seleccion_justificada": "aplicacion",
    "planificacion_aplicacion": "aplicacion",
    "autoevaluacion": "reflexiva",
    "identificacion": "identificacion",
    "conceptual": "conceptual",
    "listado": "listado",
    "reflexiva": "reflexiva",
    "experiencial": "experiencial"
  }
}


```
=== EOF: public\courses\SSO001\policies.json

===  public\courses\SSO001\overrides.json
```json
{
  "steps": {
    "M3-Q02": { "type": "listado", "k": 4 },
    "M4-Q01": { "type": "aplicacion", "requiresJustification": true }
  }
}



```
=== EOF: public\courses\SSO001\overrides.json

===  public\courses\SSO001\course.json
```json
{
  "id": "SSO001",
  "name": "Seguridad y Salud Ocupacional",
  "version": "1.0.0",
  "language": "es",
  "objectives": [
    "Identificar riesgos",
    "Aplicar procedimientos"
  ],
  "specialist": {},
  "lessons": [
    {
      "id": "lesson02",
      "title": "Procedimientos de Seguridad",
      "order": 2,
      "path": "/courses/SSO001/lessons/lesson02.json"
    }
  ]
}


```
=== EOF: public\courses\SSO001\course.json

===  public\courses\SSO001\lessons\lesson02.json
```json
{
  "meta": {
    "lesson_id": "SSO001_lesson02",
    "lesson_name": "Procedimientos de Seguridad",
    "version": "1.0.0",
    "language": "es",
    "ordered": true,
    "generated_at": "2025-08-14T00:00:00Z"
  },
  "moments": [
    {
      "code": "M1",
      "order": 1,
      "title": "Saludo",
      "steps": [
        { "code": "M1-EL01", "order": 1, "type": "EXPECTED_LEARNING", "items": [
          "Comprender qué es un procedimiento de seguridad",
          "Identificar sus componentes principales",
          "Aplicar criterios básicos de selección de EPP"
        ]},
        { "code": "M1-KP01", "order": 2, "type": "KEY_POINTS", "items": [
          "Qué es un procedimiento", "Por qué es importante", "Cómo se aplica"
        ]},
        { "code": "M1-N01", "order": 3, "type": "NARRATION", "text": "Bienvenida y objetivo de la sesión. Exploraremos qué son los procedimientos de seguridad y su relevancia en el trabajo." },
        { "code": "M1-Q01", "order": 4, "type": "ASK",
          "question": "¿Qué esperas aprender sobre procedimientos de seguridad en esta sesión?",
          "objective": "Elicitar expectativas del estudiante",
          "acceptable_answers": ["partes del procedimiento", "cómo se aplica", "importancia de seguirlos", "selección de EPP"],
          "question_type": "metacognitiva"
        }
      ]
    },
    {
      "code": "M2",
      "order": 2,
      "title": "Conexión",
      "steps": [
        { "code": "M2-N01", "order": 1, "type": "NARRATION",
          "text": "Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arnés, pero no ha trabajado en altura antes." },
        { "code": "M2-Q01", "order": 2, "type": "ASK",
          "question": "¿Qué elementos de seguridad identificas en esta situación?",
          "objective": "Activar conocimientos previos",
          "acceptable_answers": ["arnés", "arnés de seguridad", "línea", "línea de vida", "casco", "guantes", "inspección previa", "supervisión"],
          "question_type": "diagnóstica"
        },
        { "code": "M2-Q02", "order": 3, "type": "ASK",
          "question": "¿Qué podría pasar si no se siguen los procedimientos correctos?",
          "objective": "Conciencia de riesgos",
          "acceptable_answers": ["caídas", "lesiones", "accidentes", "sanciones", "multas"],
          "question_type": "reflexiva"
        }
      ]
    },
    {
      "code": "M3",
      "order": 3,
      "title": "Adquisición",
      "steps": [
        { "code": "M3-C01", "order": 1, "type": "CONTENT",
          "title": "Definición de procedimiento de seguridad",
          "body": [
            "PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos específicos para realizar una tarea de forma segura, minimizando riesgos laborales"
          ]
        },
        { "code": "M3-Q01", "order": 2, "type": "ASK",
          "question": "¿Cómo definirías un procedimiento de seguridad con tus palabras?",
          "objective": "Comprender la definición",
          "acceptable_answers": ["secuencia documentada de pasos", "realizar una tarea de forma segura", "minimizar riesgos laborales"],
          "question_type": "conceptual"
        },
        { "code": "M3-C02", "order": 3, "type": "CONTENT",
          "title": "Partes de un procedimiento",
          "body": [
            "Objetivo", "Alcance", "Responsabilidades", "Pasos específicos", "EPP requerido", "Medidas de emergencia", "Registros"
          ]
        },
        { "code": "M3-Q02", "order": 4, "type": "ASK",
          "question": "¿Qué partes debe incluir un procedimiento de seguridad completo?",
          "objective": "Identificar componentes",
          "acceptable_answers": ["objetivo", "alcance", "responsabilidades", "pasos específicos", "epp requerido", "medidas de emergencia", "registros"],
          "question_type": "listado"
        },
        { "code": "M3-C03", "order": 5, "type": "CONTENT",
          "title": "Criterios para seleccionar EPP",
          "body": [
            "Evaluar tipo de riesgo y nivel de exposición",
            "Compatibilidad, ajuste y comodidad",
            "Cumplimiento normativo y certificaciones"
          ]
        },
        { "code": "M3-Q03", "order": 6, "type": "ASK",
          "question": "Menciona dos criterios para seleccionar EPP adecuadamente.",
          "objective": "Dominar criterios de selección de EPP",
          "acceptable_answers": ["tipo de riesgo", "nivel de exposición", "compatibilidad", "ajuste", "normativa", "certificaciones"],
          "question_type": "aplicación"
        }
      ]
    },
    {
      "code": "M4",
      "order": 4,
      "title": "Aplicación",
      "steps": [
        { "code": "M4-CASE01", "order": 1, "type": "CASE",
          "title": "Trabajo en altura en fachada",
          "description": "Instalación de ventanas en tercer piso con uso de arnés y línea de vida.",
          "variables": ["altura > 2 m", "arnés", "línea de vida", "supervisión", "verificación de anclajes"]
        },
        { "code": "M4-Q01", "order": 2, "type": "ASK",
          "question": "¿Qué EPP mínimo usarías y por qué?",
          "objective": "Justificar selección de EPP",
          "acceptable_answers": ["arnés con línea de vida", "casco", "guantes", "calzado antideslizante"],
          "question_type": "aplicación"
        }
      ]
    },
    {
      "code": "M5",
      "order": 5,
      "title": "Discusión",
      "steps": [
        { "code": "M5-TOP01", "order": 1, "type": "TOPICS",
          "items": ["Protocolizar vs. improvisar", "Cultura de seguridad"]
        },
        { "code": "M5-Q01", "order": 2, "type": "ASK",
          "question": "¿Qué ventajas tiene documentar procedimientos frente a improvisar?",
          "objective": "Comparar enfoques",
          "acceptable_answers": ["estandariza", "reduce errores", "trazabilidad", "cumplimiento"],
          "question_type": "argumentativa"
        }
      ]
    },
    {
      "code": "M6",
      "order": 6,
      "title": "Reflexión",
      "steps": [
        { "code": "M6-REF01", "order": 1, "type": "REFLECTION_AREAS",
          "items": ["Hábitos personales de seguridad", "Compromisos inmediatos"]
        },
        { "code": "M6-Q01", "order": 2, "type": "ASK",
          "question": "¿Qué cambio aplicarás esta semana para mejorar tu seguridad?",
          "objective": "Plan de mejora personal",
          "acceptable_answers": ["ejemplo personal", "compromiso concreto"],
          "question_type": "reflexiva"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\SSO001\lessons\lesson02.json

===  app\api\audio\transcribe\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';

export async function POST(request: NextRequest) {
  try {
    const form = await request.formData();
    const file = form.get('audio') as File | null;
    const language = (form.get('language') as string) || 'es';

    if (!file) return NextResponse.json({ error: 'Archivo de audio requerido (field: audio)' }, { status: 400 });

    const ai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const aiFile = new File([buffer], file.name || 'audio.webm', { type: file.type || 'audio/webm' });

    const result = await ai.audio.transcriptions.create({ file: aiFile, model: 'whisper-1', language });
    return NextResponse.json({ text: (result as any)?.text || '' });
  } catch (error) {
    console.error('Transcribe error:', error);
    return NextResponse.json({ error: 'Error transcribiendo audio' }, { status: 500 });
  }
}


```
=== EOF: app\api\audio\transcribe\route.ts

===  app\api\engine\turn\route.ts
```typescript
import { runDocenteLLM } from '@/ai/orchestrator';
import { evaluateHybrid, type AskPolicy } from '@/engine/eval';
import { decideNextAction } from '@/engine/flow/transition';
import { extractKeywords } from '@/engine/hints';
import { advanceTo, currentStep, decideAction, next } from '@/engine/runner';
import { loadAndCompile } from '@/plan/compilePlan';
import { appendHistory, clearHistory, getRecentHistory } from '@/session/history';
import { SessionState, initSession } from '@/session/state';
import { getSessionStore } from '@/session/store';
import { NextResponse } from 'next/server';

type ClientState = {
  momentIdx?: number;
  stepIdx?: number;
  attemptsByAskCode?: Record<string, number>;
  noSeCountByAskCode?: Record<string, number>;
  lastActionByAskCode?: Record<string, string>;
  lastAnswerByAskCode?: Record<string, string>;
  done?: boolean;
};

type Body = { sessionKey: string; userInput?: string; planUrl?: string; reset?: boolean; clientState?: ClientState };

const SESSIONS = new Map<string, SessionState>();
const COURSE_POLICIES_CACHE = new Map<string, any>();

function mapMomentKind(title?: string): 'SALUDO'|'CONEXION'|'ADQUISICION'|'APLICACION'|'DISCUSION'|'REFLEXION'|'OTRO' {
  const t = (title || '').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
  if (t.includes('saludo')) return 'SALUDO';
  if (t.includes('conexion')) return 'CONEXION';
  if (t.includes('adquisicion')) return 'ADQUISICION';
  if (t.includes('aplicacion')) return 'APLICACION';
  if (t.includes('discusion')) return 'DISCUSION';
  if (t.includes('reflexion')) return 'REFLEXION';
  return 'OTRO';
}

function deriveCourseId(planUrl: string): string | undefined {
  const m = planUrl.match(/\/courses\/(.*?)\//);
  return m?.[1];
}

async function loadCoursePolicies(courseId?: string) {
  if (!courseId) return undefined;
  if (COURSE_POLICIES_CACHE.has(courseId)) return COURSE_POLICIES_CACHE.get(courseId);
  try {
    const res = await fetch(`/courses/${courseId}/policies.json`);
    if (!res.ok) return undefined;
    const json = await res.json();
    COURSE_POLICIES_CACHE.set(courseId, json);
    return json;
  } catch {
    return undefined;
  }
}

function buildStudentFacingBase(questionText: string, objective: string, expected: string[]): string {
  const q = (questionText || '').toLowerCase();
  const idx = q.indexOf('sobre ');
  if (idx !== -1) {
    const topic = questionText.slice(idx + 'sobre '.length).replace(/[?¿.]/g, '').trim();
    if (topic) return `lo que esperas aprender sobre ${topic}`;
  }
  const fallback = (expected || []).filter(Boolean)[0] || objective || '';
  if (fallback) return `aspectos clave de ${fallback}`;
  return 'el tema actual';
}

export async function POST(req: Request) {
	try {
		const body = (await req.json()) as Body;
		const { sessionKey, userInput = '', planUrl = '/courses/SSO001/lessons/lesson02.json', reset = false, clientState } = body;
		let pendingInput = (userInput || '').toString();
		if (reset) {
			SESSIONS.delete(sessionKey);
			try { await getSessionStore().delete(sessionKey); } catch {}
			try { await clearHistory(sessionKey); } catch {}
		}
		let state = (await getSessionStore().get(sessionKey)) || SESSIONS.get(sessionKey);
    if (!state) {
			const plan = await loadAndCompile(planUrl);
			state = initSession(planUrl, plan);
			SESSIONS.set(sessionKey, state);
			try { await getSessionStore().set(sessionKey, state); } catch {}
		}
    if (!state) {
      throw new Error('No se pudo inicializar la sesión');
    }
    // Rehidratar desde clientState si viene en el request (persistencia sin servidor)
    if (clientState) {
      // No sobrescribir con índices más antiguos del cliente
      if (typeof clientState.momentIdx === 'number') {
        const m = Number(clientState.momentIdx);
        if (typeof state.momentIdx !== 'number' || m > (state.momentIdx as number)) {
          state.momentIdx = m;
        }
      }
      if (typeof clientState.stepIdx === 'number') {
        const sIdx = Number(clientState.stepIdx);
        if (typeof state.stepIdx !== 'number' || sIdx > (state.stepIdx as number)) {
          state.stepIdx = sIdx;
        }
      }
      state.attemptsByAskCode = { ...state.attemptsByAskCode, ...(clientState.attemptsByAskCode || {}) };
      state.noSeCountByAskCode = { ...(state.noSeCountByAskCode || {}), ...(clientState.noSeCountByAskCode || {}) };
      state.lastActionByAskCode = { ...(state.lastActionByAskCode || {}), ...(clientState.lastActionByAskCode || {}) };
      state.lastAnswerByAskCode = { ...(state.lastAnswerByAskCode || {}), ...(clientState.lastAnswerByAskCode || {}) };
      // Flag opcional
      if (typeof (clientState as any).justAskedFollowUp === 'boolean') {
        state.justAskedFollowUp = Boolean((clientState as any).justAskedFollowUp);
      }
    }
    const coursePolicies = await loadCoursePolicies(deriveCourseId(state.planUrl));
		const step = currentStep(state);
		// Debug inicio de turno
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st0 = currentStep(state);
				const payload0 = {
					tag: 'engine.turn.start',
					sessionKey,
					momentTitle: state.plan?.moments?.[st0?.momentIndex || 0]?.title,
					stepType: st0?.type,
					stepIdx: state.stepIdx,
					userInputLen: (pendingInput || '').length
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload0));
			}
		} catch {}
		// Bucle: saltar SKIP consecutivos y construir salida adecuada
		let message = '';
		let followUp = '';
		// Debug vars
		let dbg: any = null;
		let safety = 0;
    let skipGuarantee = false;
		while (safety++ < 20) {
			const act = decideAction(currentStep(state));
			if (act.kind === 'skip') {
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				continue;
			}
			if (act.kind === 'explain') {
				const data = act.step.data;
				const parts = [data.title, ...(data.body || []), data.text, ...(data.items || [])].filter(Boolean) as string[];
				const bodyArr: string[] = parts as string[];
				try {
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({
						language: 'es',
						action: 'explain',
						stepType: act.step.type,
						momentTitle: state.plan?.moments[act.step.momentIndex]?.title,
						objective: state.plan?.meta?.lesson_name || '',
						contentBody: bodyArr,
						recentHistory: recent
					});
					message = llm.message;
				} catch {
					message = bodyArr.join(' — ') || 'Continuemos con el contenido.';
				}
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				// Buscar la siguiente ASK saltando pasos de metadatos y avanzar el puntero a ella
				const steps = state.plan?.allSteps || [];
				let targetIdx: number | undefined;
				for (let i = state.stepIdx; i < steps.length; i++) {
					const s = steps[i];
					const t = s.type;
					if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'EXPECTED_LEARNING') continue;
					if (t === 'ASK') { followUp = s.data.question || ''; targetIdx = i; }
					break;
				}
				// marcar flag para evitar eco y adelantar estado a la ASK
				state.justAskedFollowUp = Boolean(followUp);
				if (typeof targetIdx === 'number') { state = advanceTo(state, targetIdx); }
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				break;
			}
        if (act.kind === 'ask') {
				const q = act.step.data.question || '';
				const acceptable = act.step.data.acceptable_answers || [];
				// Política por tipo con K dinámico para LISTADO
				const qtype = String(act.step.data.question_type || '').toLowerCase();
				// Identificador del paso para contar intentos/acciones previas
				const stepCodeDyn = act.step.code || `Q:${q.substring(0,50)}`;
				const attemptsSoFar = Number(state.attemptsByAskCode?.[stepCodeDyn] || 0);
				const lastActionForStep = String(state.lastActionByAskCode?.[stepCodeDyn] || 'ask');
				const firstAttempt = attemptsSoFar === 0;
				const afterHint = lastActionForStep === 'hint';
				const dynamicK = qtype.includes('lista') ? (firstAttempt ? 1 : (afterHint ? 2 : 2)) : undefined;
				const policy: AskPolicy = qtype.includes('lista') ? { type: 'listado', thresholdK: dynamicK }
					: qtype.includes('aplica') ? { type: 'aplicacion', requiresJustification: true }
					: (qtype.includes('abierta') ? { type: 'metacognitiva' } : { type: (qtype as any) || 'conceptual' });
				// Derivar expected desde pasos previos (CONTENT/KEY_*) del mismo momento
				let expected: string[] = [];
				try {
					const moment = state.plan?.moments?.[act.step.momentIndex];
					const prior = (moment?.steps || []).slice(0, act.step.stepIndex);
					const texts: string[] = [];
					for (const ps of prior) {
						const t = ps.type;
						const d: any = ps.data;
						if (t === 'CONTENT') {
							if (d.title) texts.push(String(d.title));
							if (Array.isArray(d.body)) texts.push(...d.body.map((x: any)=>String(x)));
						} else if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'KEY_ELEMENTS' || t === 'TOPICS') {
							if (Array.isArray(d.items)) texts.push(...d.items.map((x: any)=>String(x)));
						} else if (t === 'NARRATION' && d.text) {
							texts.push(String(d.text));
						}
					}
					expected = extractKeywords(texts);
				} catch {}
          const momentKind = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
          const maxAttempts = Number(coursePolicies?.advance?.maxAttemptsBeforeForce ?? 2);
          const allowForcedOn: string[] = Array.isArray(coursePolicies?.advance?.allowForcedOn) ? coursePolicies.advance.allowForcedOn : ['SALUDO','CONEXION'];
          const stepCode = act.step.code || `Q:${q.substring(0,50)}`;
          if (!pendingInput.trim()) {
            // evitar eco si acabamos de adjuntar followUp
            if (state.justAskedFollowUp) {
              message = '';
              followUp = '';
              state.justAskedFollowUp = false;
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
              skipGuarantee = true;
              break;
            }
            try {
              const recent = await getRecentHistory(sessionKey, 4);
              const llm = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: String(act.step.data.objective || ''), recentHistory: recent });
              message = llm.message;
            } catch { message = q; }
            break;
          }
          // Evaluación híbrida: vaguedad → rápido → semántica (embeddings bajo demanda)
          const hintsUsed = Number(state.hintsByAskCode?.[stepCode] || 0);
          const hybrid = await evaluateHybrid(
            pendingInput,
            acceptable,
            expected,
            policy,
            { fuzzy: { maxEditDistance: 1, similarityMin: 0.35 }, semThresh: 0.78, semBestThresh: 0.65, maxHints: 2 },
            { lastAnswer: state.lastAnswerByAskCode?.[stepCode], hintsUsed }
          );
          const cls = { kind: hybrid.kind, matched: hybrid.matched, missing: hybrid.missing } as const;
          const vague = hybrid.reason === 'VAGUE';
                // En metacognitiva (Saludo) NO aceptar respuestas DONT_KNOW/VAGUE ni por longitud.
                // La aceptación debe basarse en señales reales del objetivo/expected o acceptable.
          // Feedback determinista breve basado en matched/missing
          const buildDeterministicFeedback = () => {
            const has = (arr?: string[]) => Array.isArray(arr) && arr.length > 0;
            if (cls.kind === 'ACCEPT' && has(cls.matched)) return `Bien: mencionaste ${cls.matched.join(', ')}.`;
            if (cls.kind === 'PARTIAL') {
              const a = has(cls.matched) ? `acertaste ${cls.matched.join(', ')}` : 'ya estás cerca';
              const b = has(cls.missing) ? `Te falta incluir ${cls.missing.join(', ')}.` : '';
              return `Vas bien: ${a}. ${b}`.trim();
            }
            // Abridores configurables para variar el feedback (evita repetición)
            const openers: string[] = (coursePolicies?.feedback?.openers?.hint || []) as string[];
            const idx = Math.max(0, (attempts % Math.max(1, openers.length)) - 1);
            const opener = openers[idx] || 'Intenta precisar un poco más.';
            if (has(cls.missing)) return `${opener} Menciona: ${cls.missing.join(', ')}.`;
            return `${opener} Da un ejemplo o una idea concreta.`;
          };
          if (!vague && cls.kind === 'ACCEPT') {
            let fb = '';
            try {
              const fbCfg: any = (coursePolicies as any)?.feedback || {};
              const recent = await getRecentHistory(sessionKey, 4);
              const deterministic = buildDeterministicFeedback();
              const llm = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: fbCfg.allowQuestions !== false, kind: 'ACCEPT' as any, recentHistory: recent });
              fb = [deterministic, llm.message || ''].filter(Boolean).join('\n\n');
            } catch {}
            // Avanzar al siguiente paso y componer salida (evaluación + siguiente acción)
            state = next(state);
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            let nextMsg = '';
            const nxt = decideAction(currentStep(state));
            if (nxt.kind === 'ask' && nxt.step) {
              // Preparar la siguiente pregunta como followUp (se muestra en burbuja aparte)
              const qNext = (nxt.step as any).data?.question || '';
              followUp = qNext;
              // no avanzamos más el estado aquí; ya estamos en la ASK correcta
              dbg = { ...(dbg || {}), messageType: 'ask', nextAction: 'ask' };
            } else if (nxt.kind === 'explain' && nxt.step) {
              const d: any = nxt.step.data || {};
              const parts = [d.title, ...(d.body || []), d.text, ...(d.items || [])].filter(Boolean) as string[];
              const bodyArr: string[] = parts as string[];
              try {
                // Puente breve al siguiente foco (ej. conexión)
                const recent = await getRecentHistory(sessionKey, 4);
                const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: nxt.step.type, momentTitle: state.plan?.moments[nxt.step.momentIndex]?.title, objective: state.plan?.meta?.lesson_name || '', recentHistory: recent });
                // Evitar re‑narrar: no insertar historia aquí, sólo puente
                nextMsg = bridge.message || '';
              } catch {
                nextMsg = bodyArr.join(' — ');
              }
              // No mezclar: prepara sólo followUp y ADELANTA estado a la siguiente ASK
              {
                const stepsAfter = state.plan?.allSteps || [];
                let targetIdx: number | undefined;
                for (let i = state.stepIdx + 1; i < stepsAfter.length; i++) {
                  const s = stepsAfter[i];
                  const t = s.type;
                  if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'EXPECTED_LEARNING') continue;
                  if (t === 'ASK') { followUp = s.data.question || ''; targetIdx = i; break; }
                }
                state.justAskedFollowUp = Boolean(followUp);
                if (typeof targetIdx === 'number') {
                  state = advanceTo(state, targetIdx);
                }
                SESSIONS.set(sessionKey, state);
                try { await getSessionStore().set(sessionKey, state); } catch {}
              }
            } else if (nxt.kind === 'end') {
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const adv = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'END', objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
                nextMsg = adv.message || '';
              } catch { nextMsg = ''; }
            }
            message = [fb, nextMsg].filter(Boolean).join('\n\n');
            dbg = { ...(dbg || {}), kind: 'ACCEPT', feedbackKind: 'ACCEPT', matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], stepCode };
            pendingInput = '';
            break;
          }
          // Contabilizar respuesta previa y contadores separados para 'no sé'
          state.lastAnswerByAskCode![stepCode] = pendingInput;
          const noSeMap = state.noSeCountByAskCode || (state.noSeCountByAskCode = {});
          const isNo = false; // detección por prompt
          if (isNo) {
            noSeMap[stepCode] = (noSeMap[stepCode] || 0) + 1;
          } else {
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          }
          const attempts = state.attemptsByAskCode[stepCode] || 0;
          const vagueCfg = coursePolicies?.vague || {};
          if (vague || cls.kind === 'PARTIAL' || cls.kind === 'HINT' || isNo || hybrid.reason === 'MAX_HINTS' || hybrid.reason === 'SEM_LOW') {
            // Mensaje alentador
            let fb = '';
            try {
              const fbCfg: any = (coursePolicies as any)?.feedback || {};
              const recent = await getRecentHistory(sessionKey, 4);
              const deterministic = buildDeterministicFeedback();
              const llmFb = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: fbCfg.allowQuestions !== false, kind: cls.kind as any, recentHistory: recent });
              fb = [deterministic, llmFb.message || ''].filter(Boolean).join('\n\n');
            } catch {}
            const pool = (cls.missing && cls.missing.length ? cls.missing : expected).filter(Boolean).map(String);
            // Decidir acción de apoyo
            // Limitar bucle de pistas: máx 2 antes de ask_options
            const lastActionMap = state.lastActionByAskCode || (state.lastActionByAskCode = {});
            const hintsMap = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
            const lastAction = (lastActionMap[stepCode] as any) || 'ask';
            if (lastAction === 'hint') hintsMap[stepCode] = (hintsMap[stepCode] || 0) + 1;
            const forcedCfg = { ...(coursePolicies?.advance || {}), hintToAskSimple: 1, askSimpleToOptions: 2 };
            if ((hintsMap[stepCode] || 0) >= 2) {
              // fuerza opciones
              lastActionMap[stepCode] = 'ask_options';
            }
            const { nextAction } = decideNextAction({ lastAction, classKind: (vague ? 'HINT' : cls.kind) as any, attempts, noSeCount: noSeMap[stepCode] || 0, cfg: forcedCfg });
            lastActionMap[stepCode] = nextAction;
            if (nextAction === 'hint') {
              try {
                const wordLimits = coursePolicies?.hints?.wordLimits || [18,35,60];
                const limit = wordLimits[0] ?? 18;
                // Hints con keywords del curso (objetivos + contenido del momento)
                const moment = state.plan?.moments?.[act.step.momentIndex];
                const objText = String(state.plan?.meta?.lesson_name || act.step.data.objective || '');
                const priorTexts: string[] = [];
                for (const ps of (moment?.steps || []).slice(0, act.step.stepIndex)) {
                  const d: any = ps.data;
                  if (Array.isArray(d?.body)) priorTexts.push(...d.body.map((x:any)=>String(x)));
                  if (Array.isArray(d?.items)) priorTexts.push(...d.items.map((x:any)=>String(x)));
                  if (d?.text) priorTexts.push(String(d.text));
                  if (d?.title) priorTexts.push(String(d.title));
                }
                const expectedPlus = extractKeywords([objText, ...priorTexts]);
                const recent = await getRecentHistory(sessionKey, 4);
                const llm = await runDocenteLLM({ language: 'es', action: 'hint', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expectedPlus, hintWordLimit: limit, recentHistory: recent });
                message = [fb, llm.message].filter(Boolean).join('\n\n');
                followUp = llm.followUp || '';
              } catch { message = ''; followUp = ''; }
              dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              pendingInput = '';
              break;
            }
            if (nextAction === 'ask_simple') {
              try {
                const simpleOptions = (pool.length ? pool : expected).slice(0, 3);
                const recent = await getRecentHistory(sessionKey, 4);
                const llm = await runDocenteLLM({ language: 'es', action: 'ask_simple', stepType: 'ASK', questionText: q, objective: String(act.step.data.objective || ''), simpleOptions, recentHistory: recent });
                message = [fb, llm.message].filter(Boolean).join('\n\n');
                followUp = '';
              } catch { message = ''; followUp = ''; }
              dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'ask_simple', stepCode };
              pendingInput = '';
              break;
            }
            // attempts >= 3
            try {
              const optionItems = (pool.length ? pool : expected).slice(0, 3);
              const recent = await getRecentHistory(sessionKey, 4);
              const llm = await runDocenteLLM({ language: 'es', action: (nextAction === 'ask_options' ? 'ask_options' : 'explain') as any, stepType: 'ASK', questionText: q, objective: String(act.step.data.objective || ''), optionItems, recentHistory: recent });
              message = [fb, llm.message].filter(Boolean).join('\n\n');
              followUp = '';
            } catch { message = ''; followUp = ''; }
            dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: nextAction, stepCode };
            pendingInput = '';
            break;
          }
			}
			if (act.kind === 'end') {
				try {
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({ language: 'es', action: 'end', stepType: 'END', objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm.message || '';
				} catch {
					message = '';
				}
				break;
			}
		}
		// Garantía final: siempre devolver un mensaje del docente usando datos del plan
		if (!skipGuarantee && (!message || !String(message).trim()) && (!followUp || !String(followUp).trim())) {
			try {
				const st = currentStep(state);
				const recent = await getRecentHistory(sessionKey, 4);
				if (st?.type === 'ASK') {
					const q2 = (st as any).data?.question || '';
					const llm2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q2, objective: String(((st as any).data?.objective) || state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm2.message || q2;
					followUp = llm2.followUp || followUp;
				} else {
					const d: any = (st as any)?.data || {};
					const parts = [d.title, ...(d.body || []), d.text, ...(d.items || [])].filter(Boolean) as string[];
					const bodyArr: string[] = parts as string[];
					const llm2 = await runDocenteLLM({ language: 'es', action: 'explain', stepType: (st?.type as any) || 'CONTENT', momentTitle: state.plan?.moments[(st as any)?.momentIndex || 0]?.title, objective: state.plan?.meta?.lesson_name || '', contentBody: bodyArr, recentHistory: recent });
					message = llm2.message || bodyArr.join(' — ');
				}
			} catch {
				const st: any = currentStep(state);
				const q2 = st?.data?.question || '';
				message = q2 || message || '';
			}
		}
		// Persist history (JSONL estilo MongoDB-like)
		try {
			await appendHistory(sessionKey, {
				planUrl: state.planUrl,
				stepIdx: state.stepIdx,
				momentIdx: state.momentIdx,
				message,
				followUp
			});
		} catch {}

		// Debug logging opcional
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st = currentStep(state);
				const messageType = (dbg && dbg.messageType) || (dbg && dbg.nextAction) || (st?.type === 'ASK' ? 'ask' : String(st?.type || '').toLowerCase());
				const payload = {
					tag: 'engine.turn',
					sessionKey,
					momentTitle: state.plan?.moments?.[st?.momentIndex || 0]?.title,
					momentKind: mapMomentKind(state.plan?.moments?.[st?.momentIndex || 0]?.title),
					stepType: st?.type,
					stepIdx: state.stepIdx,
					stepCode: (st as any)?.code || dbg?.stepCode,
					classification: dbg?.kind,
					feedbackKind: dbg?.feedbackKind || dbg?.kind,
					messageType,
					matched: dbg?.matched,
					missing: dbg?.missing,
					nextAction: dbg?.nextAction,
					messageChars: (message || '').length,
					followUpChars: (followUp || '').length,
					hasFollowUp: Boolean(followUp && String(followUp).trim()),
					userInputLen: (pendingInput || '').length,
					thresholds: { jaccardMin: 0.35, semThresh: 0.78, semBest: 0.72 },
					hintsUsed: Number(state.hintsByAskCode?.[(st as any)?.code || dbg?.stepCode] || 0)
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload));
			}
		} catch {}
		return NextResponse.json({ message, followUp, state: { stepIdx: state.stepIdx, done: state.done } });
	} catch (err: any) {
		return NextResponse.json({ error: String(err?.message || err) }, { status: 500 });
	}
}


```
=== EOF: app\api\engine\turn\route.ts

