---
repository:
  name: docenteia-v2-monolith
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-18T20:27:01.181Z
  tool: FlatRepo
statistics:
  totalFiles: 52
  totalLines: 5022
  languages:
    json: 11
    javascript: 3
    markdown: 3
    typescript: 25
    tsx: 4
    css: 1
  fileTypes:
    .json: 11
    .js: 3
    .md: 3
    .ts: 25
    "": 1
    .tsx: 4
    .css: 1
    .jsonl: 4
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "archive"]
}
```
=== EOF: tsconfig.json

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```
=== EOF: tailwind.config.js

===  REPORTE_ROUTING_MODELOS.md
```markdown
# Reporte: Implementaci√≥n de Routing de Modelos OpenAI

## üéØ **Objetivo**

Implementar un sistema de routing inteligente de modelos OpenAI para optimizar costos y rendimiento seg√∫n el tipo de tarea.

## üìä **Arquitectura Implementada**

### **1. Router de Modelos (`src/lib/ai.ts`)**

```typescript
export function pickModel(
  tier: "cheap" | "thinker" | "embed" = "cheap"
): string {
  if (tier === "thinker") return process.env.THINKER_MODEL || "o3-mini";
  if (tier === "embed")
    return process.env.EMBED_MODEL || "text-embedding-3-small";
  return process.env.CHEAP_MODEL || "gpt-4o-mini";
}
```

**Tiers implementados:**

- **`cheap`**: `gpt-4o-mini` - Para redacci√≥n docente, hints, reformulaciones
- **`thinker`**: `o3-mini` - Para decisiones dif√≠ciles de evaluaci√≥n
- **`embed`**: `text-embedding-3-small` - Para embeddings sem√°nticos

### **2. Escalamiento Inteligente (`src/engine/eval-escalation.ts`)**

```typescript
export async function escalateReasoning(input: {
  student: string;
  objective: string;
  acceptable: string[];
  expected: string[];
  matched: string[];
  missing: string[];
  hintsUsed: number;
}) {
  // Usa o3-mini con reasoning para decisiones complejas
  const res = await ai.responses.create({
    model: pickModel("thinker"),
    reasoning: { effort: "medium" },
    response_format: { type: "json_object" },
  });
}
```

**Caracter√≠sticas:**

- **JSON estricto** para decisiones
- **Reasoning con esfuerzo medio** para an√°lisis profundo
- **Fallback robusto** si falla el escalamiento

### **3. Integraci√≥n en Pipeline H√≠brido**

```typescript
// Escalamiento a thinker para casos borderline/ambiguos
if (cos >= 0.4 && cos < semThresh && (best?.cos || 0) >= 0.35) {
  const escalation = await escalateReasoning({...});

  if (escalation.decision === 'ACCEPT') {
    return { kind: 'ACCEPT', reason: 'THINKER_ESCALATION' };
  } else if (escalation.decision === 'HINT') {
    return { kind: 'HINT', reason: 'THINKER_ESCALATION' };
  }
}
```

**Criterios de escalamiento:**

- **Similitud sem√°ntica borderline** (0.4 ‚â§ cos < umbral)
- **Mejor match aceptable** (‚â• 0.35)
- **Solo cuando es necesario** para evitar costos innecesarios

## üîß **Cambios Implementados**

### **1. Orquestador (`src/ai/orchestrator.ts`)**

```typescript
// Antes
model: "gpt-4o-mini";

// Despu√©s
const model = pickModel("cheap"); // Usar modelo barato para redacci√≥n docente
```

### **2. Embeddings (`src/engine/semvec.ts`)**

```typescript
// Antes
const MODEL = process.env.EMBED_MODEL || "text-embedding-3-small";

// Despu√©s
const MODEL = pickModel("embed");
```

### **3. Evaluaci√≥n H√≠brida (`src/engine/eval.ts`)**

- **Agregado escalamiento** para casos borderline
- **Integraci√≥n con thinker** para decisiones complejas
- **Fallback robusto** en caso de errores

## üìà **Optimizaci√≥n de Costos**

### **Distribuci√≥n de Uso:**

- **80% cheap** (`gpt-4o-mini`) - Redacci√≥n docente, hints
- **15% embed** (`text-embedding-3-small`) - Similitud sem√°ntica
- **5% thinker** (`o3-mini`) - Decisiones complejas

### **Estimaci√≥n de Costos (por 1000 turnos):**

- **Cheap**: ~$0.50 (redacci√≥n docente)
- **Embed**: ~$0.10 (embeddings)
- **Thinker**: ~$0.25 (decisiones complejas)
- **Total**: ~$0.85 (vs $2.00+ con solo gpt-4o)

**Ahorro estimado: 57%**

## üß™ **Casos de Uso**

### **Caso 1: Redacci√≥n Docente**

```
Input: Sin input del estudiante
Model: cheap (gpt-4o-mini)
Output: Pregunta docente breve
Costo: M√≠nimo
```

### **Caso 2: Evaluaci√≥n Clara**

```
Input: "las partes del procedimiento"
Model: cheap + embed
Output: ACCEPT directo
Costo: Bajo
```

### **Caso 3: Evaluaci√≥n Borderline**

```
Input: "los peligros y los riesgos" (cos: 0.535)
Model: cheap + embed + thinker (o3-mini)
Output: Decisi√≥n basada en reasoning
Costo: Medio (solo cuando necesario)
```

## üîß **Configuraci√≥n de Variables de Entorno**

Agregar en `.env.local`:

```bash
CHEAP_MODEL=gpt-4o-mini
THINKER_MODEL=o3-mini
EMBED_MODEL=text-embedding-3-small
```

## üéØ **Beneficios Implementados**

### **1. Optimizaci√≥n de Costos:**

- **57% de ahorro** estimado en costos de API
- **Uso inteligente** de modelos seg√∫n complejidad
- **Escalamiento condicional** solo cuando es necesario

### **2. Mejor Calidad:**

- **o3-mini** para decisiones complejas con reasoning
- **gpt-4o-mini** para redacci√≥n r√°pida y eficiente
- **text-embedding-3-small** para similitud sem√°ntica

### **3. Robustez:**

- **Fallback autom√°tico** si falla el escalamiento
- **Logs de debug** para monitoreo
- **Configuraci√≥n flexible** por variables de entorno

## üìä **M√©tricas a Monitorear**

### **Uso de Modelos:**

- **Porcentaje de uso** de cada tier
- **Tasa de escalamiento** a thinker
- **Costos por turno** promedio

### **Calidad:**

- **Precisi√≥n de decisiones** con thinker
- **Tiempo de respuesta** por modelo
- **Satisfacci√≥n del usuario**

## üéØ **Estado Final**

**‚úÖ SISTEMA DE ROUTING IMPLEMENTADO**

El sistema ahora:

1. **Usa modelos apropiados** seg√∫n la complejidad de la tarea
2. **Optimiza costos** con escalamiento inteligente
3. **Mantiene calidad** con reasoning para decisiones complejas
4. **Es configurable** por variables de entorno

**Pr√≥ximo paso:** Monitorear m√©tricas de uso y costos para validar la optimizaci√≥n.
```
=== EOF: REPORTE_ROUTING_MODELOS.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia-v2-monolith",
  "version": "2.0.0",
  "description": "DocenteIA V2 - Sistema educativo monol√≠tico con Next.js",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "next lint",
    "test": "vitest",
    "chat-demo": "tsx src/index.ts",
    "clean": "rm -rf .next node_modules package-lock.json && npm install",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@types/dompurify": "^3.2.0",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.6",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.536.0",
    "next": "^15.0.0",
    "openai": "^5.10.2",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/node": "^20.19.9",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^15.0.0",
    "flatrepo": "^1.2.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.7.0",
    "typescript": "^5.0.0",
    "vitest": "^3.2.4"
  },
  "keywords": [
    "education",
    "ai",
    "chatbot",
    "typescript",
    "nextjs",
    "openai"
  ],
  "author": "KIKE (Backend) + JANKARLO (Frontend)",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```
=== EOF: package.json

===  obejtivodocenteia.md
```markdown
1) Capa de textualizaci√≥n docente (LLM-orchestrator)
Explica y pregunta ‚Äúcomo docente‚Äù a partir de cada step (NARRATION/CONTENT/ASK), con persona, tono y estilo.
El motor determinista decide el paso; el LLM solo redacta con variedad, ejemplos y analog√≠as. ok
2) Persona y estilo por curso
Inyectar course.specialist (rol, tono, gu√≠as de estilo).
Variar frases gu√≠a: ‚ÄúAhora te explico‚Ä¶‚Äù, ‚ÄúBuen intento‚Ä¶‚Äù, ‚ÄúEstamos por buen camino‚Ä¶‚Äù, evitando repeticiones.
3) Pol√≠tica de turnos por tipo de step
NARRATION/CONTENT: 2‚Äì3 frases m√°ximas sin listas ni copiar literal; no pregunta en ese turno.
ASK: formular la pregunta exacta del JSON; validar; si no alcanza, re‚Äëpreguntar con micro-variaci√≥n.
4) Guardarra√≠les de avance
Umbrales claros (evidencia m√≠nima: par√°frasis, ejemplo, justificaci√≥n breve).
No avanzar si faltan preguntas del momento o la evidencia no cumple.
5) Evaluaci√≥n sem√°ntica con r√∫brica ligera
Matching contra acceptable_answers, y respaldo con objective/expected.
Parcialidades (matched/missing), y decisi√≥n ok/hint/refocus/advance.
6) Pistas escalonadas integradas al plan
Pista 1 (‚âà10 palabras), Pista 2 (‚âà20), Pista 3 (casi explicativa), derivadas de acceptable_answers y contentBody, sin spoilers.
7) Manejo de atascos y fuera de foco
Detecci√≥n de DONT_KNOW/IRRELEVANT reiterado; reconduce al objetivo o micro-contenido.
Anti‚Äëbucle y anti‚Äërepetici√≥n de la misma pregunta.
8) Se√±alizaci√≥n y transiciones pedag√≥gicas
Micro‚Äëresumen de cierre + puente al siguiente objetivo/paso.
‚ÄúTe adelanto qu√© veremos ahora‚Ä¶‚Äù sin spoilear respuestas.
9) Memoria de sesi√≥n docente
Intentos por pregunta, pistas usadas, matched/missing.
Referencias a aportes previos del estudiante para personalizar.
10) Biblioteca de preguntas socr√°ticas y reformulaciones
Micro‚Äëpreguntas de descomposici√≥n (‚â§8 palabras), alternativas A/B, enfoques por taxonom√≠a (recuerdo, comprensi√≥n, aplicaci√≥n‚Ä¶).
11) Anti‚Äërepetici√≥n y deduplicaci√≥n
Normalizaci√≥n y filtros para no repetir la misma pregunta o frase en turnos consecutivos.
12) Narrativa con ‚Äúvoz docente‚Äù
Reescritura del body en texto corrido, ejemplos laborales breves, lenguaje sencillo, evitando bullets y copia literal.
13) Cierre de momento y metacognici√≥n
Checklist de objetivos alcanzados y ‚Äúqu√© te llevas‚Äù, mini‚Äëreflexi√≥n o plan de acci√≥n.
14) Adaptaci√≥n de dificultad
Si responde con solvencia, ir a preguntas de mayor nivel; si no, simplificar y ejemplificar.
15) M√©tricas y trazabilidad
contentShown/Total, asksAsked/Total, attempts/hints per ask.
Logs de decisiones (acci√≥n, raz√≥n, paso).
16) Validaci√≥n y saneo del JSON
Asegurar steps completos y ordenados; sin preguntas en NARRATION.
Contenido en CONTENT.body; pregunta solo en ASK.
17) Internacionalizaci√≥n y normas de estilo
Longitudes m√°ximas por bloque, tono consistente, emojis/√©nfasis opcionales seg√∫n curso.
18) UI docente
Marcar visualmente: ‚ÄúExplicaci√≥n‚Äù, ‚ÄúPregunta‚Äù, ‚ÄúPista‚Äù.
Mostrar progreso por momento y paso sin distraer.
19) Pruebas de flujo end‚Äëto‚Äëend
Casos t√≠picos: correcto a la primera, parcial, ‚Äúno lo s√©‚Äù, offtopic, reiteraci√≥n.
Tests de anti‚Äërepetici√≥n y de avance.
20) Fallbacks robustos
Si falta ASK, generar una de verificaci√≥n coherente; si falta CONTENT, sintetizar a partir de KEY_*.
```
=== EOF: obejtivodocenteia.md

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    ignoreBuildErrors: false,
  },
  eslint: {
    ignoreDuringBuilds: false,
  },
}

module.exports = nextConfig
```
=== EOF: next.config.js

===  next-env.d.ts
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```
=== EOF: next-env.d.ts

===  docs\ADAPTIVE_ENGINE.md
```markdown
# Motor Adaptativo con Control de Presupuesto

## Resumen

Este documento describe la implementaci√≥n del modelo-planificador acotado que permite adaptaci√≥n en tiempo real dentro de l√≠mites estrictos, manteniendo el JSON de la lecci√≥n como fuente de verdad.

## Arquitectura

### Componentes Principales

1. **Planificador Acotado** (`src/engine/planner.ts`)

   - Define comandos de adaptaci√≥n con Zod
   - Opera solo dentro del ciclo actual
   - Detecta desv√≠os de tema
   - Valida comandos antes de ejecutar

2. **Gestor de Presupuesto** (`src/engine/costs.ts`)

   - Controla uso de modelos por tiers
   - Limita escalaciones por sesi√≥n
   - Degrada autom√°ticamente cuando se agota presupuesto

3. **Evaluaci√≥n H√≠brida** (`src/engine/eval-escalation.ts`)

   - Validaci√≥n estricta con Zod
   - Escalaci√≥n inteligente solo cuando es necesaria
   - Fallback seguro en caso de errores

4. **Logger de Telemetr√≠a** (`src/engine/logger.ts`)
   - Registra todas las decisiones del motor
   - Exporta en formato JSONL para auditor√≠a
   - M√©tricas de uso por tier

## Comandos de Adaptaci√≥n

### AdaptCommand Schema

```typescript
{
  op: 'reask' | 'hint' | 'goto' | 'repeat' | 'insert_micro',
  targetAskCode?: string,
  note?: string,
  reason?: 'SEM_LOW' | 'THINKER_ESCALATION' | 'OFF_TOPIC' | 'BUDGET_LIMIT'
}
```

### Operaciones Permitidas

- **reask**: Solicitar reformulaci√≥n de respuesta vaga
- **hint**: Proporcionar pista determinista
- **goto**: Saltar a ASK espec√≠fica del cat√°logo
- **repeat**: Repetir paso actual sin avanzar
- **insert_micro**: Insertar micro-paso temporal (limitado)

## Control de Presupuesto

### Tiers de Modelos

| Tier    | Modelo                 | Costo/1K tokens | Uso                   |
| ------- | ---------------------- | --------------- | --------------------- |
| cheap   | gpt-4o-mini            | $0.005          | Docencia/redacci√≥n    |
| embed   | text-embedding-3-small | $0.001          | Similitud sem√°ntica   |
| thinker | o3-mini                | $0.025          | Razonamiento complejo |

### L√≠mites por Sesi√≥n

- **Presupuesto inicial**: $1.00 (100 centavos)
- **Escalaciones m√°ximas**: 5 por sesi√≥n
- **Umbral de degradaci√≥n**: 10 centavos restantes
- **Modo econ√≥mico**: < 5 centavos restantes

### Pol√≠tica de Uso

- **80% cheap**: Operaciones normales
- **15% embed**: Evaluaci√≥n sem√°ntica
- **5% thinker**: Escalaci√≥n solo cuando es necesaria

## Detecci√≥n de Desv√≠os

### Algoritmo de Clasificaci√≥n

```typescript
function detectTopicDeviation(
  response: string,
  step: any,
  objective: string
): TopicDeviation {
  const objectiveWords = objective
    .toLowerCase()
    .split(/\s+/)
    .filter((w) => w.length > 3);
  const objectiveMatches = objectiveWords.filter((word) =>
    response.includes(word)
  );
  const matchRatio =
    objectiveMatches.length / Math.max(1, objectiveWords.length);

  if (matchRatio >= 0.3) return "ON_TOPIC";
  if (matchRatio >= 0.1) return "VAGUE";
  return "OFF_TOPIC";
}
```

### Respuestas Autom√°ticas

- **ON_TOPIC**: Evaluaci√≥n normal
- **VAGUE**: REASK con solicitud de reformulaci√≥n
- **OFF_TOPIC**: GOTO a siguiente ASK del ciclo

## Integraci√≥n con el Frontend

### Toggle de Modo

```typescript
<select
  value={adaptiveMode ? "adaptive" : "deterministic"}
  onChange={(e) => setAdaptiveMode(e.target.value === "adaptive")}
>
  <option value="deterministic">Determinista</option>
  <option value="adaptive">Adaptativo</option>
</select>
```

### Barra de Presupuesto

```typescript
<div className="w-32 bg-gray-200 rounded-full h-2">
  <div
    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
    style={{ width: `${(budgetMetrics.budgetCentsLeft / 100) * 100}%` }}
  ></div>
</div>
```

## Variables de Entorno

```bash
# Modelos por tier
CHEAP_MODEL=gpt-4o-mini
THINKER_MODEL=o3-mini
EMBED_MODEL=text-embedding-3-small

# Debug
ENGINE_DEBUG=false
NEXT_PUBLIC_ENGINE_DEBUG=false

# Presupuesto
SESSION_BUDGET_CENTS=100
MAX_ESCALATIONS_PER_SESSION=5
ESCALATION_THRESHOLD_CENTS=10
```

## Telemetr√≠a

### Eventos Registrados

- `engine.turn.start`: Inicio de turno
- `evaluation.result`: Resultado de evaluaci√≥n
- `escalation.triggered`: Escalaci√≥n iniciada
- `adaptation.planned`: Adaptaci√≥n planificada
- `budget.usage`: Uso de presupuesto
- `advancement.accept/reject`: Avance del plan

### Formato JSONL

```json
{
  "timestamp": "2024-01-01T12:00:00Z",
  "level": "info",
  "event": "evaluation.result",
  "sessionId": "plan-123",
  "data": { "askCode": "ASK_001", "result": "ACCEPT", "reason": "SEM_LOW" }
}
```

## Riesgos y Mitigaciones

### Deriva del Tema

- **Riesgo**: El planificador inventa pasos persistentes
- **Mitigaci√≥n**: Solo opera dentro del ciclo actual con goto a ASK conocidas

### Costos Desbordados

- **Riesgo**: Presupuesto excedido
- **Mitigaci√≥n**: Hard cap con degradaci√≥n autom√°tica a modo determinista

### JSON Fr√°gil

- **Riesgo**: Respuestas malformadas del LLM
- **Mitigaci√≥n**: Validaci√≥n estricta con Zod antes de actuar

## Pruebas

### Ejecutar Tests

```bash
npm test src/engine/planner.test.ts
```

### Cobertura de Pruebas

- Detecci√≥n de desv√≠os de tema
- Validaci√≥n de comandos de adaptaci√≥n
- Aplicaci√≥n segura de comandos
- Control de presupuesto

## Uso en Producci√≥n

### Activaci√≥n

1. Configurar variables de entorno
2. Activar modo adaptativo en el frontend
3. Monitorear m√©tricas de presupuesto
4. Revisar logs de telemetr√≠a

### Monitoreo

- **M√©tricas clave**: Uso por tier, tasa de escalaci√≥n, costo por sesi√≥n
- **Alertas**: Presupuesto < 20%, escalaciones > 3 por sesi√≥n
- **Logs**: Revisar JSONL para auditor√≠a de decisiones

## Roadmap

### Pr√≥ximas Mejoras

1. **Historial corto**: Implementar contexto de conversaci√≥n reciente
2. **Micro-pasos**: Permitir inserci√≥n temporal de contenido
3. **Pol√≠ticas por curso**: Configuraci√≥n espec√≠fica de adaptaci√≥n
4. **Panel de m√©tricas**: Dashboard para monitoreo en tiempo real

### Optimizaciones

1. **Cache de embeddings**: Reutilizar embeddings calculados
2. **Batch processing**: Procesar m√∫ltiples evaluaciones juntas
3. **Predictive scaling**: Anticipar necesidad de escalaci√≥n
```
=== EOF: docs\ADAPTIVE_ENGINE.md

===  archive\.gitkeep
```


```
=== EOF: archive\.gitkeep

===  app\layout.tsx
```tsx
import './globals.css';
export const metadata = { title: 'DocenteIA', description: 'Lecci√≥n guiada por JSON' };

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="es">
      <body className="min-h-screen">{children}</body>
    </html>
  )
}
```
=== EOF: app\layout.tsx

===  app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }
}

@layer base {
  * { @apply border-border; }
  body { @apply bg-background text-foreground; font-feature-settings: "rlig" 1, "calt" 1; }
}


```
=== EOF: app\globals.css

===  .vscode\settings.json
```json
{
    "files.autoSave": "afterDelay",
    "files.autoSaveDelay": 1000,
    "files.autoSaveWorkspaceFilesOnly": false,
    "files.autoSaveDelay": 1000,
    "editor.formatOnSave": true,
    "editor.formatOnPaste": true,
    "editor.formatOnType": true,
    "typescript.preferences.includePackageJsonAutoImports": "on",
    "typescript.suggest.autoImports": true,
    "typescript.updateImportsOnFileMove.enabled": "always",
    "editor.codeActionsOnSave": {
        "source.fixAll.eslint": "explicit",
        "source.organizeImports": "explicit"
    },
    "files.exclude": {
        "**/.git": true,
        "**/.svn": true,
        "**/.hg": true,
        "**/CVS": true,
        "**/.DS_Store": true,
        "**/Thumbs.db": true,
        "**/node_modules": true,
        "**/.next": true,
        "**/dist": true,
        "**/build": true
    },
    "search.exclude": {
        "**/node_modules": true,
        "**/.next": true,
        "**/dist": true,
        "**/build": true,
        "**/package-lock.json": true
    },
    "files.watcherExclude": {
        "**/.git/objects/**": true,
        "**/.git/subtree-cache/**": true,
        "**/node_modules/**": true,
        "**/.next/**": true,
        "**/dist/**": true,
        "**/build/**": true
    }
}
```
=== EOF: .vscode\settings.json

===  .vscode\launch.json
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Next.js: debug server-side",
            "type": "node",
            "request": "launch",
            "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
            "args": [
                "dev"
            ],
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal",
            "skipFiles": [
                "<node_internals>/**"
            ]
        },
        {
            "name": "Next.js: debug client-side",
            "type": "chrome",
            "request": "launch",
            "url": "http://localhost:3000"
        },
        {
            "name": "Next.js: debug full stack",
            "type": "node",
            "request": "launch",
            "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
            "args": [
                "dev"
            ],
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "serverReadyAction": {
                "pattern": "started server on .+, url: (https?://.+)",
                "uriFormat": "%s",
                "action": "debugWithChrome"
            }
        }
    ]
}
```
=== EOF: .vscode\launch.json

===  .vscode\extensions.json
```json
{
    "recommendations": [
        "bradlc.vscode-tailwindcss",
        "esbenp.prettier-vscode",
        "dbaeumer.vscode-eslint",
        "ms-vscode.vscode-typescript-next",
        "formulahendry.auto-rename-tag",
        "christian-kohler.path-intellisense",
        "ms-vscode.vscode-json"
    ]
}
```
=== EOF: .vscode\extensions.json

===  .claude\settings.local.json
```json
{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(rm:*)",
      "Bash(npm run dev:*)",
      "Bash(kill:*)"
    ],
    "deny": []
  }
}
```
=== EOF: .claude\settings.local.json

===  public\courses\registry.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "SSO001",
      "lessons": [
        {
          "id": "lesson02",
          "name": "Lecci√≥n 02",
          "planUrl": "/courses/SSO001/lessons/lesson02.json"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\registry.json

===  src\schema\timeline.ts
```typescript
import { z } from 'zod';

export const TimelineStepSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	type: z.string(),
	// ASK
	question: z.string().optional(),
	objective: z.string().optional(),
	expected: z.array(z.string()).optional(),
	acceptable_answers: z.array(z.string()).optional(),
	question_type: z.string().optional(),
	answer_type: z.enum(['open', 'list', 'definition', 'procedure', 'choice']).optional(),
	// CONTENT / CASE / NARRATION / KEY_* / TOPICS / REFLECTION_AREAS
	title: z.string().optional(),
	body: z.array(z.string()).optional(),
	text: z.string().optional(),
	description: z.string().optional(),
	items: z.array(z.string()).optional(),
	variables: z.array(z.string()).optional()
});

export const TimelineMomentSchema = z.object({
	code: z.string().optional(),
	order: z.number().int().optional(),
	title: z.string(),
	steps: z.array(TimelineStepSchema)
});

export const TimelineFileSchema = z.object({
	meta: z.object({
		lesson_id: z.string().optional(),
		lesson_name: z.string().optional(),
		version: z.string().optional(),
		language: z.string().optional(),
		ordered: z.boolean().optional(),
		generated_at: z.string().optional()
	}),
	moments: z.array(TimelineMomentSchema)
});

export type TimelineStep = z.infer<typeof TimelineStepSchema>;
export type TimelineMoment = z.infer<typeof TimelineMomentSchema>;
export type TimelineFile = z.infer<typeof TimelineFileSchema>;

export function assertTimeline(obj: unknown): TimelineFile {
	return TimelineFileSchema.parse(obj);
}


```
=== EOF: src\schema\timeline.ts

===  src\session\store.ts
```typescript
import type { SessionState } from '@/session/state';
import fs from 'fs/promises';
import path from 'path';

export interface SessionStore {
  get(sessionKey: string): Promise<SessionState | undefined>;
  set(sessionKey: string, state: SessionState): Promise<void>;
  delete(sessionKey: string): Promise<void>;
}

class MemoryStore implements SessionStore {
  private map = new Map<string, SessionState>();
  async get(k: string) { return this.map.get(k); }
  async set(k: string, v: SessionState) { this.map.set(k, v); }
  async delete(k: string) { this.map.delete(k); }
}

type FileShape = { sessions: Record<string, { state: SessionState; lastActivity: number }> };

class JsonFileStore implements SessionStore {
  private filePath: string;
  private data: FileShape = { sessions: {} };
  private writing = Promise.resolve();
  constructor(filePath?: string) {
    this.filePath = filePath || path.join(process.cwd(), '.data', 'sessions.json');
  }
  private async ensureLoaded() {
    if (Object.keys(this.data.sessions).length) return;
    try {
      await fs.mkdir(path.dirname(this.filePath), { recursive: true });
      const raw = await fs.readFile(this.filePath, 'utf-8');
      this.data = JSON.parse(raw) as FileShape;
    } catch {
      this.data = { sessions: {} };
    }
  }
  private async flush() {
    const payload = JSON.stringify(this.data);
    const tmp = this.filePath + '.tmp';
    await fs.writeFile(tmp, payload, 'utf-8');
    await fs.rename(tmp, this.filePath);
  }
  async get(k: string) {
    await this.ensureLoaded();
    return this.data.sessions[k]?.state;
  }
  async set(k: string, v: SessionState) {
    await this.ensureLoaded();
    this.data.sessions[k] = { state: v, lastActivity: Date.now() };
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
  async delete(k: string) {
    await this.ensureLoaded();
    delete this.data.sessions[k];
    this.writing = this.writing.then(() => this.flush());
    await this.writing;
  }
}

let storeInstance: SessionStore | null = null;
export function getSessionStore(): SessionStore {
  if (storeInstance) return storeInstance;
  const useFile = process.env.SESSION_STORE === 'file';
  storeInstance = useFile ? new JsonFileStore() : new MemoryStore();
  return storeInstance;
}


```
=== EOF: src\session\store.ts

===  src\session\state.ts
```typescript
import type { LessonPlan } from '@/plan/types';

export type SessionState = {
	planUrl: string;
	plan?: LessonPlan;
	momentIdx: number;
	stepIdx: number;
	attemptsByAskCode: Record<string, number>;
	hintsByAskCode?: Record<string, number>;
	lastAnswerByAskCode?: Record<string, string>;
	noSeCountByAskCode?: Record<string, number>;
	lastActionByAskCode?: Record<string, string>;
	justAskedFollowUp?: boolean;
	// Anti-repetici√≥n de narrativa por momento
	narrativesShownByMoment?: Record<number, boolean>;
	lastNarrativeHashByMoment?: Record<number, string>;
	// Blindaje anti-repetici√≥n de historias/contenidos
	shownByStepIndex?: Record<number, boolean>;
	shownByMomentIndex?: Record<number, boolean>;
	askedAskCodes: string[];
	answeredAskCodes: string[];
	done: boolean;
	// Nuevos campos para adaptaci√≥n y presupuesto
	dynamicQueue: Array<{
		op: 'reask' | 'hint' | 'goto' | 'repeat' | 'insert_micro';
		targetAskCode?: string;
		note?: string;
		reason?: 'SEM_LOW' | 'THINKER_ESCALATION' | 'OFF_TOPIC' | 'BUDGET_LIMIT';
	}>;
	budgetCentsLeft: number;
	escalationsUsed: number;
	// Modo de operaci√≥n
	adaptiveMode: boolean;
	// Contexto de consultas para pausar/retomar
	consultCtx?: {
		pausedAt?: { momentIndex: number; stepIndex: number };
	};
	lastFollowUpText?: string;
};

export function initSession(planUrl: string, plan: LessonPlan): SessionState {
	return {
		planUrl,
		plan,
		momentIdx: 0,
		stepIdx: 0,
		attemptsByAskCode: {},
		hintsByAskCode: {},
		lastAnswerByAskCode: {},
		noSeCountByAskCode: {},
		lastActionByAskCode: {},
		justAskedFollowUp: false,
		narrativesShownByMoment: {},
		lastNarrativeHashByMoment: {},
		shownByStepIndex: {},
		shownByMomentIndex: {},
		askedAskCodes: [],
		answeredAskCodes: [],
		done: false,
		// Inicializar nuevos campos
		dynamicQueue: [],
		budgetCentsLeft: 100, // 100 centavos = $1.00 por sesi√≥n
		escalationsUsed: 0,
		adaptiveMode: false, // Por defecto modo determinista
		consultCtx: {} // Contexto de consultas
	};
}


```
=== EOF: src\session\state.ts

===  src\session\history.ts
```typescript
import fs from 'fs/promises';
import path from 'path';

function historyPath(sessionKey: string) {
  const dir = path.join(process.cwd(), '.data', 'history');
  const file = path.join(dir, `${sessionKey}.jsonl`);
  return { dir, file };
}

export async function appendHistory(sessionKey: string, record: unknown): Promise<void> {
  const { dir, file } = historyPath(sessionKey);
  try { await fs.mkdir(dir, { recursive: true }); } catch {}
  const line = JSON.stringify({ ts: Date.now(), ...((record as object) || {}) }) + '\n';
  await fs.appendFile(file, line, 'utf-8');
}

export async function clearHistory(sessionKey: string): Promise<void> {
  const { file } = historyPath(sessionKey);
  try { await fs.unlink(file); } catch {}
}

export async function getRecentHistory(sessionKey: string, limit: number = 6): Promise<string[]> {
  const { file } = historyPath(sessionKey);
  try {
    const raw = await fs.readFile(file, 'utf-8');
    const lines = raw.trim().split(/\n+/).filter(Boolean);
    const tail = lines.slice(-limit);
    const out: string[] = [];
    for (const ln of tail) {
      try {
        const rec: any = JSON.parse(ln);
        if (typeof rec?.content === 'string') { out.push(rec.content); continue; }
        if (typeof rec?.message === 'string' || typeof rec?.followUp === 'string') {
          const combined = [rec.message, rec.followUp].filter(Boolean).join('\n\n');
          if (combined) out.push(combined);
          continue;
        }
      } catch {}
    }
    return out;
  } catch {
    return [];
  }
}


```
=== EOF: src\session\history.ts

===  src\plan\types.ts
```typescript
import type { TimelineFile, TimelineStep } from '@/schema/timeline';

export type StepType = 'NARRATION'|'CONTENT'|'ASK'|'CASE'|'KEY_CONTENT'|'KEY_POINTS'|'KEY_ELEMENTS'|'TOPICS'|'EXPECTED_LEARNING'|'REFLECTION_AREAS';

export type PlanStep = {
	momentIndex: number;
	stepIndex: number;
	code?: string;
	order?: number;
	type: StepType;
	data: TimelineStep;
};

export type LessonPlan = {
	meta: TimelineFile['meta'];
	moments: Array<{ title: string; code?: string; order?: number; steps: PlanStep[] }>;
	allSteps: PlanStep[];
	contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }>;
	askCatalog: Array<{ globalIndex: number; momentIndex: number; stepIndex: number; code?: string; question: string; acceptable: string[] }>;
};



```
=== EOF: src\plan\types.ts

===  src\plan\compilePlan.ts
```typescript
import { assertTimeline, TimelineFile } from '@/schema/timeline';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { LessonPlan, PlanStep, StepType } from './types';

function toStepType(t?: string): StepType {
	const u = String(t || '').toUpperCase();
	return (['NARRATION','CONTENT','ASK','CASE','KEY_CONTENT','KEY_POINTS','KEY_ELEMENTS','TOPICS','EXPECTED_LEARNING','REFLECTION_AREAS'] as StepType[])
		.find(x => x === u) || 'CONTENT';
}

export function compilePlan(tl: TimelineFile): LessonPlan {
	const moments = (tl.moments || []).map((m, mi) => {
		const steps: PlanStep[] = (m.steps || [])
			.sort((a, b) => (a.order || 0) - (b.order || 0))
			.map((s, si) => ({ momentIndex: mi, stepIndex: si, code: s.code, order: s.order, type: toStepType(s.type), data: s }));
		return { title: m.title, code: m.code, order: m.order, steps };
	});
	const allSteps = moments.flatMap(m => m.steps);
	// Construir ciclos CONTENT->ASK por proximidad
	const contentCycles: Array<{ contentStepIndex: number; askStepIndices: number[] }> = [];
	let current: { contentStepIndex: number; askStepIndices: number[] } | null = null;
	for (let i = 0; i < allSteps.length; i++) {
		const s = allSteps[i];
		if (s.type === 'CONTENT') {
			if (current) contentCycles.push(current);
			current = { contentStepIndex: i, askStepIndices: [] };
		} else if (s.type === 'ASK') {
			if (!current) current = { contentStepIndex: -1, askStepIndices: [] };
			current.askStepIndices.push(i);
		}
	}
	if (current) contentCycles.push(current);
	// Cat√°logo de preguntas
	const askCatalog = allSteps
		.map((s, idx) => ({
			globalIndex: idx,
			momentIndex: s.momentIndex,
			stepIndex: s.stepIndex,
			code: s.code,
			question: s.data.question || '',
			acceptable: s.data.acceptable_answers || []
		}))
		.filter(x => !!x.question);
	return { meta: tl.meta, moments, allSteps, contentCycles, askCatalog };
}

export async function loadAndCompile(url: string): Promise<LessonPlan> {
	let obj: any;
	// Soporte server-side: si es ruta absoluta del sitio (/courses/..), leer desde /public
	if (/^https?:/i.test(url)) {
		const res = await fetch(url);
		obj = await res.json();
	} else if (url.startsWith('/')) {
		const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	} else {
		const filePath = path.isAbsolute(url) ? url : path.join(process.cwd(), url);
		const raw = await fs.readFile(filePath, 'utf-8');
		obj = JSON.parse(raw);
	}
	const tl = assertTimeline(obj);
	return compilePlan(tl);
}


```
=== EOF: src\plan\compilePlan.ts

===  src\hooks\usePlanChat.ts
```typescript
import { useEffect, useRef, useState } from 'react';

export type PlanChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

function generateSessionKey(): string {
	return `plan-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
}

export function usePlanChat(planUrl: string = '/courses/SSO001/lessons/lesson02.json') {
	const [messages, setMessages] = useState<PlanChatMessage[]>([]);
	const [isTyping, setIsTyping] = useState<boolean>(false);
	const [done, setDone] = useState<boolean>(false);
	const [adaptiveMode, setAdaptiveMode] = useState<boolean>(false);
	const [budgetMetrics, setBudgetMetrics] = useState<any>(null);
	const sessionKeyRef = useRef<string>('');
	const idSeq = useRef<number>(1);
  const bootedRef = useRef<boolean>(false);

	useEffect(() => {
		if (!sessionKeyRef.current) {
			// Persistir la sesi√≥n para recargas superficiales
			try {
				const stored = typeof window !== 'undefined' ? window.sessionStorage.getItem('planSessionKey') : '';
				if (stored) sessionKeyRef.current = stored;
				else {
					sessionKeyRef.current = generateSessionKey();
					if (typeof window !== 'undefined') window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
				}
			} catch {
				sessionKeyRef.current = generateSessionKey();
			}
		}
		// Primer turno para obtener el primer paso del plan (evitar doble invocaci√≥n en StrictMode)
		if (!bootedRef.current) {
			bootedRef.current = true;
			void turn('');
		}
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [planUrl]);

  async function turn(userInput: string) {
		if (done) return;
		setIsTyping(true);
		try {
			const res = await fetch('/api/engine/turn', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ 
					sessionKey: sessionKeyRef.current, 
					userInput, 
					planUrl, 
					reset: !messages.length,
					adaptiveMode 
				})
			});
			if (!res.ok) throw new Error('engine turn failed');
			const { message, followUp, state, budgetMetrics: newBudgetMetrics } = await res.json();
			
			// Agregar mensaje del estudiante si hay input
			if (userInput && userInput.trim()) {
				setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'student', content: userInput, timestamp: new Date() }]);
			}
			
			// Crear UNA sola burbuja del asistente (message + followUp)
			if (message || followUp) {
				const norm = (s: string) => s.replace(/\s+/g, ' ').trim().toLowerCase();
				const hasQ = followUp && norm(message || '').includes(norm(followUp));
				const combined = [message, (!hasQ && followUp) ? followUp : '']
					.map(s => (s || '').trim())
					.filter(Boolean)
					.join('\n\n');
				
				// Evitar repetir exactamente el mismo texto que la √∫ltima burbuja del assistant
				setMessages(prev => {
					const last = prev.slice().reverse().find(m => m.sender === 'ai');
					if (last && norm(last.content) === norm(combined)) return prev;
					return [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: combined, timestamp: new Date() }];
				});
			}
			setDone(Boolean(state?.done));
			if (newBudgetMetrics) {
				setBudgetMetrics(newBudgetMetrics);
			}
		} catch (_err) {
			// Emitir mensaje de error simple
			setMessages(prev => [...prev, { id: `${idSeq.current++}`, sender: 'ai', content: 'Ocurri√≥ un error al avanzar el plan.', timestamp: new Date() }]);
		} finally {
			setIsTyping(false);
		}
	}

	function sendMessage(content: string) {
		if (!content || !content.trim()) return;
		void turn(content);
	}

	function clearMessages() {
		setMessages([]);
	}

	function resetSession() {
		// Limpiar sessionStorage y regenerar sessionKey
		if (typeof window !== 'undefined') {
			window.sessionStorage.removeItem('planSessionKey');
		}
		sessionKeyRef.current = generateSessionKey();
		if (typeof window !== 'undefined') {
			window.sessionStorage.setItem('planSessionKey', sessionKeyRef.current);
		}
		// Resetear estado
		setMessages([]);
		setDone(false);
		setIsTyping(false);
		setBudgetMetrics(null);
		bootedRef.current = false;
		// Reiniciar con nuevo plan
		void turn('');
	}

	return { messages, isTyping, done, sendMessage, clearMessages, resetSession, adaptiveMode, setAdaptiveMode, budgetMetrics };
}


```
=== EOF: src\hooks\usePlanChat.ts

===  src\engine\semvec.ts
```typescript
import { getClient } from '@/lib/ai';
import { getBudgetManager, pickModelWithBudget } from './costs';

const client = getClient();

export type AskVectorIndex = {
	acceptables: string[];
	expected: string[];
	centroid: number[];
	byItem: { text: string; vec: number[] }[];
};

function cosine(a: number[], b: number[]): number {
	let dot = 0;
	let na = 0;
	let nb = 0;
	const len = Math.min(a.length, b.length);
	for (let i = 0; i < len; i++) { dot += a[i] * b[i]; na += a[i] * a[i]; nb += b[i] * b[i]; }
	if (!na || !nb) return 0;
	return dot / (Math.sqrt(na) * Math.sqrt(nb));
}

export async function embedTexts(texts: string[]): Promise<number[][]> {
	if (!texts || texts.length === 0) return [];
	const model = pickModelWithBudget('embed');
	const res = await client.embeddings.create({ model: model as any, input: texts });
	
	// Registrar uso de embeddings para costeo
	const budgetManager = getBudgetManager();
	const approxTokens = texts.reduce((total, text) => total + Math.ceil(text.length / 4), 0);
	budgetManager.recordUsage('embed', approxTokens);
	
	return res.data.map(x => (x as any).embedding as number[]);
}

export async function buildAskIndex(acceptables: string[] = [], expected: string[] = []): Promise<AskVectorIndex> {
	const items = Array.from(new Set([...(acceptables || []), ...(expected || [])].map(s => String(s || '').trim()).filter(Boolean)));
	if (items.length === 0) return { acceptables, expected, centroid: [], byItem: [] };
	const vecs = await embedTexts(items);
	const dim = vecs[0]?.length || 0;
	const centroid = dim ? Array.from({ length: dim }, (_, j) => vecs.reduce((acc, v) => acc + (v[j] || 0), 0) / vecs.length) : [];
	return {
		acceptables,
		expected,
		centroid,
		byItem: items.map((t, i) => ({ text: t, vec: vecs[i] || [] }))
	};
}

export async function semanticScore(answer: string, index: AskVectorIndex): Promise<{ cos: number; best?: { text: string; cos: number } }> {
	const text = String(answer || '').trim();
	if (!text || !index || !index.centroid || index.centroid.length === 0) return { cos: 0 };
	const [u] = await embedTexts([text]);
	const cosC = cosine(u || [], index.centroid || []);
	let best = { text: '', cos: 0 };
	for (const it of index.byItem || []) {
		const c = cosine(u || [], it.vec || []);
		if (c > best.cos) best = { text: it.text, cos: c };
	}
	return { cos: cosC, best };
}


```
=== EOF: src\engine\semvec.ts

===  src\engine\runner.ts
```typescript
import type { PlanStep } from '@/plan/types';
import type { SessionState } from '@/session/state';
import { getBudgetManager } from './costs';
import { log } from './logger';
import { applyAdaptCommand, planAdaptation, type PlanningContext } from './planner';

export type SkipAction = { kind: 'skip'; step?: PlanStep };
export type ExplainAction = { kind: 'explain'; step: PlanStep };
export type AskAction = { kind: 'ask'; step: PlanStep };
export type EndAction = { kind: 'end' };
export type EngineAction = SkipAction | ExplainAction | AskAction | EndAction;

export function currentStep(state?: SessionState): PlanStep | undefined {
	const steps = state?.plan?.allSteps || [];
	if (typeof state?.stepIdx !== 'number') return undefined;
	if (state.stepIdx < 0 || state.stepIdx >= steps.length) return undefined;
	return steps[state.stepIdx];
}

export function decideAction(step?: PlanStep, state?: SessionState): EngineAction {
	if (!step) return { kind: 'end' };
	
			// Si el modo adaptativo est√° activado y es un paso ASK, consultar al planificador
		if (state?.adaptiveMode && step.type === 'ASK') {
			const budgetManager = getBudgetManager();
			const metrics = budgetManager.getUsageMetrics();
			
			// Obtener historial corto para el contexto
			const shortHistory: Array<{
				stepIdx: number;
				action: string;
				response?: string;
			}> = []; // TODO: Implementar historial real cuando se necesite
			
			const context: PlanningContext = {
				state: state,
				shortHistory,
				budgetCentsLeft: metrics.budgetCentsLeft,
				escalationsUsed: state.escalationsUsed || 0
			};
			
			const adaptation = planAdaptation(context);
			if (adaptation) {
				// Aplicar la adaptaci√≥n al estado
				const adaptedState = applyAdaptCommand(adaptation, state);
				// Actualizar el estado global con la adaptaci√≥n
				Object.assign(state, adaptedState);
				// Log de adaptaci√≥n aplicada
				log.adaptation('session-' + Date.now(), adaptation);
			}
		}
	
	switch (step.type) {
		case 'ASK':
			return { kind: 'ask', step };
		case 'CONTENT':
		case 'NARRATION':
		case 'CASE':
		case 'REFLECTION_AREAS':
			return { kind: 'explain', step };
		case 'KEY_CONTENT':
		case 'KEY_POINTS':
		case 'KEY_ELEMENTS':
		case 'TOPICS':
		case 'EXPECTED_LEARNING':
		default:
			return { kind: 'skip', step } as SkipAction;
	}
}

export function next(state?: SessionState): SessionState {
	if (!state) {
		throw new Error('Session state not initialized');
	}
	const steps = state.plan?.allSteps || [];
	const nextIdx = (state.stepIdx ?? 0) + 1;
	if (nextIdx >= steps.length) {
		const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
		return { ...state, stepIdx: steps.length, momentIdx: lastMomentIdx, done: true };
	}
	const newStep = steps[nextIdx];
	const newMomentIdx = typeof newStep?.momentIndex === 'number' ? newStep.momentIndex : state.momentIdx;
	return { ...state, stepIdx: nextIdx, momentIdx: newMomentIdx, done: false };
}

export function advanceTo(state: SessionState, targetStepIndex?: number): SessionState {
  if (targetStepIndex === undefined || targetStepIndex === null) {
    const steps = state.plan?.allSteps || [];
    const lastMomentIdx = steps.length ? steps[steps.length - 1].momentIndex : state.momentIdx;
    return { ...state, done: true, stepIdx: steps.length, momentIdx: lastMomentIdx };
  }
  const steps = state.plan?.allSteps || [];
  const boundedIndex = Math.max(0, Math.min(targetStepIndex, Math.max(0, steps.length)));
  const step = steps[boundedIndex];
  const newMomentIdx = typeof step?.momentIndex === 'number' ? step.momentIndex : state.momentIdx;
  return { ...state, stepIdx: boundedIndex, momentIdx: newMomentIdx, done: false };
}

export function getCycleIndexForStep(state: SessionState, stepIdx: number): number | undefined {
  const cycles = state.plan?.contentCycles || [];
  for (let i = 0; i < cycles.length; i++) {
    const c = cycles[i];
    if (c.contentStepIndex === stepIdx) return i;
    if (c.askStepIndices.includes(stepIdx)) return i;
  }
  return undefined;
}

export function getNextAskInSameCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const cycleIdx = getCycleIndexForStep(state, stepIdx);
  if (cycleIdx === undefined) return undefined;
  const cycle = cycles[cycleIdx];
  const askList = cycle.askStepIndices || [];
  const pos = askList.indexOf(stepIdx);
  if (pos === -1) return askList.length ? askList[0] : undefined; // si estamos en CONTENT, volver a la primera ASK
  return askList[pos + 1];
}

export function getFirstAskOfNextCycle(state: SessionState, stepIdx: number): number | undefined {
  const plan = state.plan;
  if (!plan) return undefined;
  const cycles = plan.contentCycles || [];
  const currentCycleIdx = getCycleIndexForStep(state, stepIdx);
  const startIdx = currentCycleIdx === undefined ? 0 : currentCycleIdx + 1;
  for (let i = startIdx; i < cycles.length; i++) {
    const askList = cycles[i].askStepIndices || [];
    if (askList.length > 0) return askList[0];
  }
  return undefined;
}

export function decideNextAction(context: {
  lastAction: string;
  noSeCount: number;
  attempts: number;
  momentKind?: string;
}): 'reask' | 'hint' | 'explain' | 'options' | 'force_advance' {
  const { lastAction, noSeCount, attempts, momentKind } = context;
  
  // Solo permitir avance forzado en CONEXI√ìN (no SALUDO)
  const policyAllowsForce = ['CONEXION'].includes(momentKind || '');
  
  // Si no permite forzar y hay muchos intentos, usar transici√≥n pedag√≥gica
  if (!policyAllowsForce && attempts >= 2) {
    if (lastAction === 'hint') return 'explain';
    if (lastAction === 'explain') return 'options';
    if (lastAction === 'options') return 'reask';
    return 'hint';
  }
  
  // Si permite forzar, solo despu√©s de agotar opciones (umbral m√°s alto)
  if (policyAllowsForce && attempts >= 4) {
    return 'force_advance';
  }
  
  // L√≥gica normal de transici√≥n
  if (noSeCount > 0) return 'hint';
  if (lastAction === 'hint') return 'explain';
  if (lastAction === 'explain') return 'options';
  
  return 'reask';
}



```
=== EOF: src\engine\runner.ts

===  src\engine\questions.ts
```typescript
export function isStudentAskingQuestion(input: string): boolean {
  const normalized = (input || '').toLowerCase().trim();

  // signos de pregunta
  if (/\?\s*$/.test(input || '')) return true;

  // intenci√≥n de "pedir permiso para preguntar"
  const askIntent = [
    'te puedo hacer una pregunta', 'puedo hacer una pregunta', 'tengo una pregunta',
    'tengo una duda', 'una consulta', 'puedo consultar', 'quiero preguntar'
  ];
  if (askIntent.some(p => normalized.includes(p))) return true;

  // aclaraciones expl√≠citas
  const clarification = [
    'no entiendo', 'no comprendo', 'puedes aclarar', '¬øpuedes aclarar',
    'puedes explicar', 'qu√© significa', 'c√≥mo es que', 'por qu√©', 'cu√°l es',
    'd√≥nde est√°', 'cu√°ndo', 'qui√©n', 'qu√© es'
  ];
  return clarification.some(p => normalized.includes(p));
}

export function isAffirmativeToResume(input: string): boolean {
  const n = (input || '').toLowerCase().trim();
  return ['s√≠','si','ok','listo','entendido','claro','ya'].includes(n) || /^si[,\.!\s]?/i.test(input||'');
}
```
=== EOF: src\engine\questions.ts

===  src\engine\planner.ts
```typescript
import type { SessionState } from '@/session/state';
import { z } from 'zod';
import { getCycleIndexForStep, getNextAskInSameCycle } from './runner';

// Esquema Zod para comandos de adaptaci√≥n acotados
export const AdaptCommandSchema = z.object({
  op: z.enum(['reask', 'hint', 'goto', 'repeat', 'insert_micro']),
  targetAskCode: z.string().optional(),
  note: z.string().optional(),
  reason: z.enum(['SEM_LOW', 'THINKER_ESCALATION', 'OFF_TOPIC', 'BUDGET_LIMIT']).optional()
});

export type AdaptCommand = z.infer<typeof AdaptCommandSchema>;

// Tipos para el contexto de planificaci√≥n
export type PlanningContext = {
  state: SessionState;
  currentCycleIndex?: number;
  shortHistory: Array<{
    stepIdx: number;
    action: string;
    response?: string;
  }>;
  budgetCentsLeft: number;
  escalationsUsed: number;
};

// Evaluaci√≥n de desv√≠o de tema
export type TopicDeviation = 'ON_TOPIC' | 'VAGUE' | 'OFF_TOPIC';

export function detectTopicDeviation(
  studentResponse: string,
  currentStep: any,
  objective: string
): TopicDeviation {
  const response = studentResponse.toLowerCase().trim();
  const objectiveWords = objective.toLowerCase().split(/\s+/).filter(w => w.length > 3);
  
  // Palabras clave del objetivo presentes
  const objectiveMatches = objectiveWords.filter(word => response.includes(word));
  const matchRatio = objectiveMatches.length / Math.max(1, objectiveWords.length);
  
  if (matchRatio >= 0.3) return 'ON_TOPIC';
  if (matchRatio >= 0.1) return 'VAGUE';
  return 'OFF_TOPIC';
}

// Planificador principal acotado
export function planAdaptation(context: PlanningContext): AdaptCommand | null {
  const { state, budgetCentsLeft, escalationsUsed } = context;
  const currentStep = state.plan?.allSteps?.[state.stepIdx];
  
  if (!currentStep || currentStep.type !== 'ASK') {
    return null; // Solo adaptamos en pasos ASK
  }

  // Verificar presupuesto antes de escalar
  const canEscalate = budgetCentsLeft > 10 && escalationsUsed < 5;
  
  // Si no hay presupuesto, forzar HINT determinista
  if (!canEscalate) {
    return {
      op: 'hint',
      reason: 'BUDGET_LIMIT',
      note: 'Presupuesto agotado, usando hint determinista'
    };
  }

  // Detectar desv√≠o de tema
  const deviation = detectTopicDeviation(
    context.shortHistory[context.shortHistory.length - 1]?.response || '',
    currentStep,
    currentStep.data?.objective ?? ''
  );

  if (deviation === 'OFF_TOPIC') {
    // Proponer bridge corto y volver al ciclo actual
    const nextAskInCycle = getNextAskInSameCycle(state, state.stepIdx);
    if (nextAskInCycle !== undefined) {
      return {
        op: 'goto',
        targetAskCode: state.plan?.allSteps?.[nextAskInCycle]?.code,
        reason: 'OFF_TOPIC',
        note: 'Desv√≠o detectado, redirigiendo a siguiente pregunta del ciclo'
      };
    }
  }

  if (deviation === 'VAGUE') {
    return {
      op: 'reask',
      reason: 'SEM_LOW',
      note: 'Respuesta vaga, solicitando reformulaci√≥n'
    };
  }

  // Si est√° on-topic pero necesita escalaci√≥n, el evaluador decidir√°
  return null;
}

// Validar comando antes de ejecutar
export function validateAdaptCommand(command: AdaptCommand, state: SessionState): boolean {
  try {
    AdaptCommandSchema.parse(command);
    
    // Validaciones adicionales de contexto
    if (command.op === 'goto' && command.targetAskCode) {
      const targetStep = state.plan?.allSteps?.find(s => s.code === command.targetAskCode);
      if (!targetStep) return false;
    }
    
    return true;
  } catch {
    return false;
  }
}

// Aplicar comando al estado (sin modificar el plan)
export function applyAdaptCommand(command: AdaptCommand, state: SessionState): SessionState {
  if (!validateAdaptCommand(command, state)) {
    return state; // No aplicar si no es v√°lido
  }

  switch (command.op) {
    case 'repeat':
      // Repetir el paso actual sin avanzar
      return { ...state };
      
    case 'goto':
      if (command.targetAskCode) {
        const targetIdx = state.plan?.allSteps?.findIndex(s => s.code === command.targetAskCode);
        if (targetIdx !== undefined && targetIdx >= 0) {
          return { ...state, stepIdx: targetIdx };
        }
      }
      return state;
      
    case 'reask':
    case 'hint':
      // No avanzar, mantener en el paso actual
      return { ...state };
      
    case 'insert_micro':
      // Solo permitir micro-pasos dentro del ciclo actual
      const currentCycle = getCycleIndexForStep(state, state.stepIdx);
      if (currentCycle !== undefined) {
        // Aqu√≠ se podr√≠a insertar un paso temporal, pero por ahora solo mantenemos posici√≥n
        return { ...state };
      }
      return state;
      
    default:
      return state;
  }
}
```
=== EOF: src\engine\planner.ts

===  src\engine\planner.test.ts
```typescript
import type { SessionState } from '@/session/state';
import { describe, expect, it } from 'vitest';
import {
    applyAdaptCommand,
    detectTopicDeviation,
    planAdaptation,
    validateAdaptCommand,
    type AdaptCommand,
    type PlanningContext
} from './planner';

// Mock de estado de sesi√≥n para pruebas
const createMockState = (overrides: Partial<SessionState> = {}): SessionState => ({
  planUrl: '/test/lesson.json',
  momentIdx: 0,
  stepIdx: 0,
  attemptsByAskCode: {},
  askedAskCodes: [],
  answeredAskCodes: [],
  done: false,
  dynamicQueue: [],
  budgetCentsLeft: 100,
  escalationsUsed: 0,
  adaptiveMode: true,
  ...overrides
});

// Mock de plan para pruebas
const createMockPlan = () => ({
  allSteps: [
    {
      type: 'ASK',
      code: 'ASK_001',
      objective: 'Identificar elementos de seguridad en trabajo en altura',
      data: {
        question: '¬øQu√© elementos de seguridad son necesarios para trabajo en altura?',
        acceptable_answers: ['arn√©s', 'cuerda', 'casco'],
        expected: ['arn√©s de seguridad', 'l√≠nea de vida', 'protecci√≥n contra ca√≠das']
      }
    },
    {
      type: 'ASK',
      code: 'ASK_002', 
      objective: 'Reconocer procedimientos de seguridad',
      data: {
        question: '¬øCu√°les son los pasos del procedimiento de seguridad?',
        acceptable_answers: ['inspecci√≥n', 'colocaci√≥n', 'verificaci√≥n'],
        expected: ['inspecci√≥n previa', 'colocaci√≥n correcta', 'verificaci√≥n continua']
      }
    }
  ],
  contentCycles: [
    {
      contentStepIndex: 0,
      askStepIndices: [0, 1]
    }
  ]
});

describe('Planner', () => {
  describe('detectTopicDeviation', () => {
    it('deber√≠a detectar respuesta on-topic', () => {
      const step = { objective: 'Identificar elementos de seguridad en trabajo en altura' };
      const response = 'El arn√©s de seguridad es fundamental para el trabajo en altura';
      
      const result = detectTopicDeviation(response, step, step.objective);
      expect(result).toBe('ON_TOPIC');
    });

    it('deber√≠a detectar respuesta vaga', () => {
      const step = { objective: 'Identificar elementos de seguridad en trabajo en altura' };
      const response = 'Hay que tener cuidado con la seguridad';
      
      const result = detectTopicDeviation(response, step, step.objective);
      expect(result).toBe('VAGUE');
    });

    it('deber√≠a detectar respuesta off-topic', () => {
      const step = { objective: 'Identificar elementos de seguridad en trabajo en altura' };
      const response = 'El clima est√° muy bonito hoy';
      
      const result = detectTopicDeviation(response, step, step.objective);
      expect(result).toBe('OFF_TOPIC');
    });
  });

  describe('planAdaptation', () => {
    it('deber√≠a retornar null para pasos que no son ASK', () => {
      const state = createMockState();
      state.plan = createMockPlan();
      state.plan.allSteps[0].type = 'CONTENT';
      
      const context: PlanningContext = {
        state,
        shortHistory: [],
        budgetCentsLeft: 100,
        escalationsUsed: 0
      };
      
      const result = planAdaptation(context);
      expect(result).toBeNull();
    });

    it('deber√≠a sugerir hint cuando el presupuesto est√° agotado', () => {
      const state = createMockState();
      state.plan = createMockPlan();
      state.budgetCentsLeft = 5;
      
      const context: PlanningContext = {
        state,
        shortHistory: [],
        budgetCentsLeft: 5,
        escalationsUsed: 0
      };
      
      const result = planAdaptation(context);
      expect(result).toEqual({
        op: 'hint',
        reason: 'BUDGET_LIMIT',
        note: 'Presupuesto agotado, usando hint determinista'
      });
    });

    it('deber√≠a sugerir goto para respuestas off-topic', () => {
      const state = createMockState();
      state.plan = createMockPlan();
      
      const context: PlanningContext = {
        state,
        shortHistory: [{
          stepIdx: 0,
          action: 'ask',
          response: 'Hay que tener cuidado'
        }],
        budgetCentsLeft: 100,
        escalationsUsed: 0
      };
      
      const result = planAdaptation(context);
      expect(result?.op).toBe('goto');
      expect(result?.reason).toBe('OFF_TOPIC');
    });
  });

  describe('validateAdaptCommand', () => {
    it('deber√≠a validar comandos v√°lidos', () => {
      const state = createMockState();
      const command: AdaptCommand = {
        op: 'hint',
        reason: 'SEM_LOW'
      };
      
      const result = validateAdaptCommand(command, state);
      expect(result).toBe(true);
    });

    it('deber√≠a rechazar comandos con targetAskCode inv√°lido', () => {
      const state = createMockState();
      const command: AdaptCommand = {
        op: 'goto',
        targetAskCode: 'INVALID_CODE'
      };
      
      const result = validateAdaptCommand(command, state);
      expect(result).toBe(false);
    });
  });

  describe('applyAdaptCommand', () => {
    it('deber√≠a aplicar comando goto correctamente', () => {
      const state = createMockState();
      state.plan = createMockPlan();
      
      const command: AdaptCommand = {
        op: 'goto',
        targetAskCode: 'ASK_002'
      };
      
      const result = applyAdaptCommand(command, state);
      expect(result.stepIdx).toBe(1);
    });

    it('deber√≠a mantener estado para comandos que no modifican posici√≥n', () => {
      const state = createMockState();
      const command: AdaptCommand = {
        op: 'hint'
      };
      
      const result = applyAdaptCommand(command, state);
      expect(result.stepIdx).toBe(state.stepIdx);
    });

    it('deber√≠a rechazar comandos inv√°lidos', () => {
      const state = createMockState();
      const command: AdaptCommand = {
        op: 'goto',
        targetAskCode: 'INVALID_CODE'
      };
      
      const result = applyAdaptCommand(command, state);
      expect(result).toEqual(state); // No deber√≠a cambiar el estado
    });
  });
});
```
=== EOF: src\engine\planner.test.ts

===  src\engine\logger.ts
```typescript
import type { SessionState } from '@/session/state';
import type { EscalationResponse } from './eval-escalation';
import type { AdaptCommand } from './planner';

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export type LogEvent = {
  timestamp: string;
  level: LogLevel;
  event: string;
  sessionId?: string;
  data: Record<string, any>;
};

class EngineLogger {
  private logs: LogEvent[] = [];
  private debugMode: boolean;

  constructor() {
    this.debugMode = process.env.ENGINE_DEBUG === 'true' || 
                    process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true';
  }

  private log(level: LogLevel, event: string, data: Record<string, any> = {}, sessionId?: string) {
    const logEvent: LogEvent = {
      timestamp: new Date().toISOString(),
      level,
      event,
      sessionId,
      data
    };

    this.logs.push(logEvent);

    // Log a consola si est√° en modo debug
    if (this.debugMode) {
      console.log(`[${level.toUpperCase()}] ${event}:`, data);
    }
  }

  // Eventos del motor
  engineTurnStart(sessionId: string, stepIdx: number, stepType: string) {
    this.log('info', 'engine.turn.start', { stepIdx, stepType }, sessionId);
  }

  engineTurnEnd(sessionId: string, stepIdx: number, action: string) {
    this.log('info', 'engine.turn.end', { stepIdx, action }, sessionId);
  }

  // Eventos de evaluaci√≥n
  evaluationStart(sessionId: string, askCode: string, studentResponse: string) {
    this.log('info', 'evaluation.start', { askCode, responseLength: studentResponse.length }, sessionId);
  }

  evaluationResult(sessionId: string, askCode: string, result: 'ACCEPT' | 'HINT' | 'REASK', reason?: string) {
    this.log('info', 'evaluation.result', { askCode, result, reason }, sessionId);
  }

  escalationTriggered(sessionId: string, askCode: string, reason: string) {
    this.log('info', 'escalation.triggered', { askCode, reason }, sessionId);
  }

  escalationResult(sessionId: string, askCode: string, result: EscalationResponse) {
    this.log('info', 'escalation.result', { askCode, decision: result.decision, reason: result.reason }, sessionId);
  }

  // Eventos de planificaci√≥n adaptativa
  adaptationPlanned(sessionId: string, command: AdaptCommand) {
    this.log('info', 'adaptation.planned', { 
      op: command.op, 
      targetAskCode: command.targetAskCode,
      reason: command.reason 
    }, sessionId);
  }

  adaptationApplied(sessionId: string, command: AdaptCommand, success: boolean) {
    this.log('info', 'adaptation.applied', { 
      op: command.op, 
      success,
      reason: command.reason 
    }, sessionId);
  }

  // Eventos de presupuesto
  budgetCheck(sessionId: string, tier: string, allowed: boolean, budgetLeft: number) {
    this.log('info', 'budget.check', { tier, allowed, budgetLeft }, sessionId);
  }

  budgetUsage(sessionId: string, tier: string, cost: number, tokens: number) {
    this.log('info', 'budget.usage', { tier, cost, tokens }, sessionId);
  }

  budgetLimit(sessionId: string, tier: string) {
    this.log('warn', 'budget.limit', { tier }, sessionId);
  }

  // Eventos de avance
  advancementAccept(sessionId: string, stepIdx: number, askCode: string) {
    this.log('info', 'advancement.accept', { stepIdx, askCode }, sessionId);
  }

  advancementReject(sessionId: string, stepIdx: number, askCode: string, reason: string) {
    this.log('info', 'advancement.reject', { stepIdx, askCode, reason }, sessionId);
  }

  // Eventos de error
  error(sessionId: string, error: string, context?: Record<string, any>) {
    this.log('error', 'engine.error', { error, context }, sessionId);
  }

  // M√©tricas de sesi√≥n
  sessionMetrics(sessionId: string, state: SessionState, budgetMetrics: any) {
    this.log('info', 'session.metrics', {
      stepIdx: state.stepIdx,
      momentIdx: state.momentIdx,
      attemptsByAskCode: state.attemptsByAskCode,
      escalationsUsed: state.escalationsUsed,
      budgetCentsLeft: state.budgetCentsLeft,
      adaptiveMode: state.adaptiveMode,
      budgetMetrics
    }, sessionId);
  }

  // Obtener logs para auditor√≠a
  getLogs(): LogEvent[] {
    return [...this.logs];
  }

  // Exportar logs en formato JSONL
  exportJSONL(): string {
    return this.logs.map(log => JSON.stringify(log)).join('\n');
  }

  // Limpiar logs (√∫til para sesiones largas)
  clear() {
    this.logs = [];
  }
}

// Instancia global del logger
export const engineLogger = new EngineLogger();

// Funciones de conveniencia para uso directo
export const log = {
  turnStart: (sessionId: string, stepIdx: number, stepType: string) => 
    engineLogger.engineTurnStart(sessionId, stepIdx, stepType),
  
  turnEnd: (sessionId: string, stepIdx: number, action: string) => 
    engineLogger.engineTurnEnd(sessionId, stepIdx, action),
  
  evalStart: (sessionId: string, askCode: string, response: string) => 
    engineLogger.evaluationStart(sessionId, askCode, response),
  
  evalResult: (sessionId: string, askCode: string, result: 'ACCEPT' | 'HINT' | 'REASK', reason?: string) => 
    engineLogger.evaluationResult(sessionId, askCode, result, reason),
  
  escalation: (sessionId: string, askCode: string, result: EscalationResponse) => 
    engineLogger.escalationResult(sessionId, askCode, result),
  
  adaptation: (sessionId: string, command: AdaptCommand) => 
    engineLogger.adaptationPlanned(sessionId, command),
  
  budget: (sessionId: string, tier: string, cost: number, tokens: number) => 
    engineLogger.budgetUsage(sessionId, tier, cost, tokens),
  
  error: (sessionId: string, error: string, context?: Record<string, any>) => 
    engineLogger.error(sessionId, error, context),
  
  metrics: (sessionId: string, state: SessionState, budgetMetrics: any) => 
    engineLogger.sessionMetrics(sessionId, state, budgetMetrics)
};
```
=== EOF: src\engine\logger.ts

===  src\engine\hints.ts
```typescript
type HintPolicies = {
  mentionCount?: number;
  wordLimits?: number[]; // [S1, S2, S3]
  variants?: string[];
  templates?: {
    objective?: string;
    reask?: Record<'list'|'definition'|'procedure'|'choice', string>;
    open?: { hint: string; reask: string };
  };
};

type LangPolicies = { stopwords?: string[] };

export function makeTokenizer(stop: string[] = []) {
  const STOP = new Set(stop);
  return (s: string) =>
    (s || '')
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/["'()\[\]{}]/g, '')
      .split(/[^a-z√°√©√≠√≥√∫√±0-9]+/)
      .filter(Boolean)
      .filter(w => w.length > 2 && !STOP.has(w));
}

export function extractKeywords(from: string[], stop: string[] = []): string[] {
  const tok = makeTokenizer(stop);
  const uniq: string[] = [];
  for (const item of from) for (const w of tok(item)) if (!uniq.includes(w)) uniq.push(w);
  return uniq.slice(0, 40);
}

export function buildStudentFacingBase(questionText: string, objective: string, expected: string[]): string {
  return (questionText && questionText.toLowerCase().includes('sobre '))
    ? `lo que esperas aprender sobre ${questionText.split('sobre ')[1].replace(/[?¬ø.]/g,'').trim()}`
    : (expected?.[0] || objective || 'el tema actual');
}

// Nivel de severidad seg√∫n intentos/pistas
function severity(attempts: number, hintsUsed: number): 0|1|2 {
  if (attempts <= 1 && hintsUsed === 0) return 0; // S1
  if (hintsUsed <= 1) return 1;                    // S2
  return 2;                                        // S3
}

export function makeHintMessage(opts: {
  questionText: string;
  objective: string;
  expected: string[];
  missing: string[];
  answerType?: 'open'|'list'|'definition'|'procedure'|'choice';
  hintsUsed: number;
  attempts: number;
  coursePolicies?: { hints?: HintPolicies; language?: LangPolicies; feedback?: any };
}) {
  const { questionText, objective, expected, missing, answerType = 'list', hintsUsed, attempts, coursePolicies } = opts;
  const hp = coursePolicies?.hints || {};
  const lp = coursePolicies?.language || {};
  const wordLimits = hp.wordLimits || [16, 22, 28];
  const mentionCount = hp.mentionCount ?? 2;
  const sev = severity(attempts, hintsUsed);
  const maxMsgChars = wordLimits[Math.min(sev, wordLimits.length-1)] * 5;

  const stop = lp.stopwords || [];
  const kws = extractKeywords([objective, ...(expected||[])], stop).slice(0, 6);

  // cues: prioriza missing; si no hay, usa expected
  const cuesArr = (missing?.length ? missing : expected || []).slice(0, mentionCount);
  const cueLine = cuesArr.length ? `Menciona: ${cuesArr.join(', ')}.` : '';

  const variants = hp.variants || [];
  const opener = variants.length ? variants[hintsUsed % variants.length] : '';

  if (answerType === 'open') {
    const tmpl = hp.templates?.open?.hint || `Comparte tus ideas en al menos {minWords} palabras. {cuesLine}`;
    const fallbackAspects: string[] = (hp.templates as any)?.open?.fallbackAspects || [];
    const aspects = cuesArr.length ? cuesArr : fallbackAspects;
    const cuesLine = aspects.length ? `Gu√≠ate por: ${aspects.join(', ')}.` : '';
    const msg = tmpl
      .replace('{minWords}', String(wordLimits[0]))
      .replace('{cuesLine}', cuesLine);
    // Para preguntas abiertas, evitar cortar el mensaje por caracteres para no truncar frases
    return msg.trim();
  }

  const base = hp.templates?.objective || '{opener} Enf√≥cate en {keywords}. {cueLine}';
  const msg = base
    .replace('{opener}', opener)
    .replace('{keywords}', kws.join(', '))
    .replace('{cueLine}', cueLine);

  return msg.trim().slice(0, maxMsgChars);
}

export function makeReaskMessage(opts: {
  questionText: string;
  objective: string;
  expected: string[];
  answerType?: 'open'|'list'|'definition'|'procedure'|'choice';
  coursePolicies?: { hints?: HintPolicies };
}) {
  const { questionText, objective, expected, answerType = 'list', coursePolicies } = opts;
  const hp = coursePolicies?.hints || {};
  const baseStr = buildStudentFacingBase(questionText, objective, expected);
  if (answerType === 'open') {
    const tmpl = hp.templates?.open?.reask || 'En {minWords}-{maxWords} palabras, cu√©ntame {aspects} sobre "{objective}".';
    const minw = (hp.wordLimits || [16])[0];
    const base = buildStudentFacingBase(questionText, objective, expected);
    const aspectsLabel = (hp.templates as any)?.open?.aspectsLabel || 'tus ideas principales';
    return tmpl
      .replace('{minWords}', String(minw))
      .replace('{maxWords}', String(minw + 8))
      .replace('{aspects}', aspectsLabel)
      .replace('{objective}', base);
  }
  const reaskTmpls = (hp.templates?.reask || {}) as Record<'list'|'definition'|'procedure'|'choice', string>;
  const maxWords = (hp.wordLimits || [16])[0];
  const map: Record<string, string> = {
    list: reaskTmpls.list || '',
    definition: reaskTmpls.definition || '',
    procedure: reaskTmpls.procedure || '',
    choice: reaskTmpls.choice || ''
  };
  const fallback = `Menciona en ${maxWords} palabras 2 elementos de ${baseStr}.`;
  return (map[answerType] || '')
    .replace('{maxWords}', String(maxWords))
    .replace('{base}', baseStr) || fallback;
}

// Funciones legacy para compatibilidad - eliminar despu√©s de migraci√≥n
export function makeObjectiveHint(args: {
  objective: string;
  expected: string[];
  missing: string[];
  variants?: string[];
  wordLimit?: number;
}) {
  return makeHintMessage({
    questionText: '',
    objective: args.objective,
    expected: args.expected,
    missing: args.missing,
    hintsUsed: 0,
    attempts: 1,
    coursePolicies: {
      hints: {
        variants: args.variants,
        wordLimits: [args.wordLimit || 16]
      }
    }
  });
}

export function makeObjectiveReask(args: {
  questionText: string;
  objective: string;
  expected: string[];
  answerType?: 'list' | 'definition' | 'procedure' | 'choice';
  maxWords?: number;
}) {
  return makeReaskMessage({
    questionText: args.questionText,
    objective: args.objective,
    expected: args.expected,
    answerType: args.answerType,
    coursePolicies: {
      hints: {
        wordLimits: [args.maxWords || 16]
      }
    }
  });
}

export function makeOpenHint({ objective, aspects = [], minWords = 12 }: {
  objective: string; aspects?: string[]; minWords?: number;
}) {
  return makeHintMessage({
    questionText: '',
    objective,
    expected: aspects,
    missing: [],
    answerType: 'open',
    hintsUsed: 0,
    attempts: 1,
    coursePolicies: {
      hints: {
        wordLimits: [minWords]
      }
    }
  });
}

export function makeOpenReask({ objective, aspects = [], minWords = 12 }: {
  objective: string; aspects?: string[]; minWords?: number;
}) {
  return makeReaskMessage({
    questionText: '',
    objective,
    expected: aspects,
    answerType: 'open',
    coursePolicies: {
      hints: {
        wordLimits: [minWords]
      }
    }
  });
}








```
=== EOF: src\engine\hints.ts

===  src\engine\feedback.ts
```typescript
export type FeedbackClass = {
  kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS';
  matched?: string[];
  missing?: string[];
};

export function buildDeterministicFeedback(
  cls: FeedbackClass,
  opts: {
    attempts: number;            // intentos de respuesta del alumno
    hintsUsed: number;           // pistas ya usadas en ESTA pregunta
    coursePolicies?: any;        // policies.json ya cargadas
  }
): string {
  const has = (arr?: string[]) => Array.isArray(arr) && arr.length > 0;

  // 1) Mensajes cortos por estado (evita muletillas)
  if (cls.kind === 'ACCEPT' && has(cls.matched)) {
    return `Bien: mencionaste ${cls.matched!.join(', ')}.`;
  }
  if (cls.kind === 'PARTIAL') {
    const a = has(cls.matched) ? `acertaste ${cls.matched!.join(', ')}` : 'ya est√°s cerca';
    const missTop = has(cls.missing) ? `Te falta incluir ${cls.missing!.slice(0,2).join(', ')}.` : '';
    return `Vas bien: ${a}. ${missTop}`.trim();
  }

  // 2) Abridores configurables (rotar por n√∫mero de pistas, no por attempts)
  const openers: string[] = (opts.coursePolicies?.feedback?.openers?.hint || []) as string[];
  const idx = (opts.hintsUsed % Math.max(1, openers.length || 1)); // <‚Äî ROTA DE VERDAD
  const opener = openers[idx] || 'Intenta precisar un poco m√°s.';
  
  // 3) En HINT/REFOCUS devolver solo el opener.
  // La pista concreta se compone en hints.ts y se integra en route.ts
  return opener;
}
```
=== EOF: src\engine\feedback.ts

===  src\engine\eval.ts
```typescript
export function normalize(input: string): string {
	return (input || '')
		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		// Colapsa repeticiones largas de caracteres: accidenteee -> accidentee
		.replace(/([a-z√±])\1{2,}/g, '$1$1')
		.replace(/[^\w\s]/g, ' ')
		.replace(/\s+/g, ' ')
		.trim();
}

export function matchesAcceptable(user: string, acceptable: string[]): boolean {
	const u = normalize(user);
	return acceptable.some(a => {
		const n = normalize(a);
		return n.length > 0 && (u === n || u.includes(n) || n.includes(u));
	});
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
}

function tokenSet(s: string): Set<string> {
  return new Set(normalize(s).split(' ').filter(Boolean));
}

function jaccard(a: string, b: string): number {
  const A = tokenSet(a), B = tokenSet(b);
  const interArr: string[] = [];
  A.forEach(v => { if (B.has(v)) interArr.push(v); });
  const inter = interArr.length;
  const unionSet = new Set<string>();
  A.forEach(v => unionSet.add(v));
  B.forEach(v => unionSet.add(v));
  const union = unionSet.size || 1;
  return inter / union;
}

export function computeMatchedMissing(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const u = normalize(user);
	const essentials = acceptable;
	const matched: string[] = [];
	const uTokens = u.split(' ').filter(Boolean);
	for (const a of essentials) {
		const n = normalize(a);
		if (!n) continue;
		// Coincidencia estricta por frase completa
		if (u === n || u.includes(n) || n.includes(u)) { matched.push(a); continue; }
		if (fuzzy) {
			const dist = levenshtein(u, n);
			const sim = jaccard(u, n);
			if ((fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin)) { matched.push(a); continue; }
			// Fuzzy a nivel de tokens: si alg√∫n token del usuario se parece a un token del aceptable
			const nTokens = n.split(/\s+/).filter(t => t.length >= 4);
			const uStrong = uTokens.filter(t => t.length >= 4);
			const tokenHit = uStrong.some(ut => nTokens.some(nt => {
				if (!ut || !nt) return false;
				if (ut === nt || ut.includes(nt) || nt.includes(ut)) return true;
				const d = levenshtein(ut, nt);
				return typeof fuzzy.maxEditDistance === 'number' ? d <= fuzzy.maxEditDistance : d <= 1;
			}));
			if (tokenHit) { matched.push(a); continue; }
			// Soft token match conservador por inclusi√≥n directa
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) { matched.push(a); }
			continue;
		}
		// Sin fuzzy: aplicar soft token match m√≠nimo
		const tokens = n.split(/\s+/).filter(t => t.length >= 4);
		if (tokens.some(t => u.includes(t))) { matched.push(a); continue; }
	}
	if (matched.length === 0 && expected?.length) {
		const extras = expected.filter(e => {
			const n = normalize(e);
			if (!n) return false;
			if (u.includes(n)) return true;
			if (fuzzy) {
				const dist = levenshtein(u, n);
				const sim = jaccard(u, n);
				return (fuzzy.maxEditDistance && dist <= fuzzy.maxEditDistance) || (fuzzy.similarityMin && sim >= fuzzy.similarityMin);
			}
			// Soft token para expected
			const tokens = n.split(/\s+/).filter(t => t.length >= 4);
			if (tokens.some(t => u.includes(t))) return true;
			return false;
		}).slice(0, 2);
		matched.push(...extras);
	}
	const missing = essentials.filter(a => !matched.includes(a)).slice(0, 3);
	return { matched, missing };
}

export function evaluateAnswer(user: string, acceptable: string[] = [], expected: string[] = [], fuzzy?: { maxEditDistance?: number; similarityMin?: number }) {
	const { matched, missing } = computeMatchedMissing(user, acceptable, expected, fuzzy);
	return { ok: matched.length > 0, matched, missing };
}

export type AskPolicy = {
	type: 'conceptual'|'listado'|'aplicacion'|'identificacion'|'experiencial'|'metacognitiva'|'reflexiva'|string;
	thresholdK?: number; // para listado
	requiresJustification?: boolean; // para aplicacion
};

export function classifyTurn(
	user: string,
	policy: AskPolicy,
	acceptable: string[] = [],
	expected: string[] = [],
	fuzzy?: { maxEditDistance?: number; similarityMin?: number }
): { kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; matched: string[]; missing: string[]; reason: string } {
	const u = normalize(user);
	if (!u) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	// Gate duro: si el alumno dice "no s√©" o equivalente, no intentamos ACCEPT/PARTIAL
	if (isNoSe(user)) {
		return { kind: 'HINT', matched: [], missing: acceptable.slice(0, 3), reason: 'DONT_KNOW' };
	}
	const { matched, missing } = computeMatchedMissing(u, acceptable, expected, fuzzy);
	const hasAny = matched.length > 0;
	if (policy.type === 'listado') {
		const k = Math.max(1, policy.thresholdK || 2);
		if (matched.length >= k) return { kind: 'ACCEPT', matched, missing, reason: 'K_OF_N' };
		if (matched.length > 0 || expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'PARTIAL_LISTADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	if (policy.type === 'aplicacion') {
		if (hasAny && (!policy.requiresJustification || /porque|para|ya que/i.test(user))) return { kind: 'ACCEPT', matched, missing, reason: 'APLICACION_OK' };
		if (hasAny) return { kind: 'PARTIAL', matched, missing, reason: 'FALTA_JUSTIFICACION' };
		if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
		return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
	}
	// conceptual, identificacion, etc.
	if (hasAny) return { kind: 'ACCEPT', matched, missing, reason: 'MATCH_ACCEPTABLE' };
	if (expected.some(e => u.includes(normalize(e)))) return { kind: 'PARTIAL', matched, missing, reason: 'OBJETIVO_ALINEADO' };
	return { kind: 'HINT', matched, missing, reason: 'INSUFFICIENT' };
}

export function isVagueAnswer(
	user: string,
	question?: string,
	opts?: { stopwords?: string[]; minUsefulTokens?: number; maxStopwordRatio?: number; echoOverlap?: number; repeatSimilarity?: number; lastAnswer?: string }
): boolean {
	const u = normalize(user);
	if (!u) return true;
	const tokens = u.split(' ').filter(Boolean);
	const stop = new Set((opts?.stopwords || []).map(s => normalize(s)));
	const useful = tokens.filter(t => !stop.has(t));
	const stopRatio = tokens.length ? (tokens.length - useful.length) / tokens.length : 1;
	if (useful.length < (opts?.minUsefulTokens ?? 3)) return true;
	if (stopRatio > (opts?.maxStopwordRatio ?? 0.6)) return true;
	const q = question ? normalize(question) : '';
	if (q) {
		const overlap = jaccard(u, q);
		if (overlap >= (opts?.echoOverlap ?? 0.7)) return true;
	}
	const last = normalize(opts?.lastAnswer || '');
	if (last) {
		const sim = jaccard(u, last);
		if (sim >= (opts?.repeatSimilarity ?? 0.8)) return true;
	}
	return false;
}

export function isNoSe(answer?: string): boolean {
	const a = (answer || '').trim().toLowerCase();
	if (!a) return true;
	const patterns = [
		/^no\s*se$/, /^no\s*lo\s*se$/, /^no\s*s√©$/, /^no\s*lo\s*s√©$/,
		/^ns$/, /^n\/a$/, /^no\s*sab[o√≥]$/, /^no\s*est[o√≥]\s*seguro$/,
		/^no$/, /^mmm$/, /^mm$/,
		/^[\.\!\?‚Ä¶]+$/
	];
	if (patterns.some(rx => rx.test(a))) return true;
	const words = a.split(/\s+/).filter(Boolean);
	return false; // deja solo patrones expl√≠citos (no, no s√©, n/a, mmm‚Ä¶)
}

export function detectTopicDeviation(
	studentResponse: string,
	currentStep: any,
	objective: string
): 'ON_TOPIC' | 'VAGUE' | 'OFF_TOPIC' {
	const response = studentResponse.toLowerCase().trim();
	const objectiveWords = objective.toLowerCase().split(/\s+/).filter(w => w.length > 3);
	
	// Palabras clave del objetivo presentes
	const objectiveMatches = objectiveWords.filter(word => response.includes(word));
	const matchRatio = objectiveMatches.length / Math.max(1, objectiveWords.length);
	
	if (matchRatio >= 0.3) return 'ON_TOPIC';
	if (matchRatio >= 0.1) return 'VAGUE';
	return 'OFF_TOPIC';
}



// Evaluaci√≥n h√≠brida (vaguedad ‚Üí r√°pido ‚Üí sem√°ntico)
import { escalateReasoning } from '@/engine/eval-escalation';
import { buildAskIndex, semanticScore, type AskVectorIndex } from '@/engine/semvec';

export type HybridOpts = {
  fuzzy?: { maxEditDistance?: number; similarityMin?: number };
  semThresh?: number;
  semBestThresh?: number;
  maxHints?: number;
  vague?: { stopwords?: string[]; minUsefulTokens?: number; maxStopwordRatio?: number; echoOverlap?: number; repeatSimilarity?: number };
};

export async function evaluateHybrid(
  user: string,
  acceptable: string[] = [],
  expected: string[] = [],
  policy: AskPolicy = { type: 'conceptual' },
  opts: HybridOpts = { fuzzy: { maxEditDistance: 1, similarityMin: 0.35 }, semThresh: 0.78, semBestThresh: 0.65, maxHints: 2 },
  context?: { lastAnswer?: string; hintsUsed?: number }
): Promise<{ kind: 'ACCEPT'|'PARTIAL'|'HINT'|'REFOCUS'; reason: string; matched: string[]; missing: string[]; sem?: { cos: number; best?: { text: string; cos: number } } }> {
  // Umbrales de embeddings por tipo de pregunta (MUY PERMISIVOS)
  const getThresholdsByType = (type: string) => {
    switch (type) {
      case 'diagn√≥stica':
        return { semThresh: 0.45, semBestThresh: 0.35 };
      case 'conceptual':
        return { semThresh: 0.50, semBestThresh: 0.40 };
      case 'aplicaci√≥n':
        return { semThresh: 0.48, semBestThresh: 0.38 };
      case 'listado':
        return { semThresh: 0.46, semBestThresh: 0.36 };
      default:
        	return { semThresh: opts.semThresh ?? 0.48, semBestThresh: opts.semBestThresh ?? 0.40 };
    }
  };
  
  const thresholds = getThresholdsByType(policy.type);
  const semThresh = thresholds.semThresh;
  const semBestThresh = thresholds.semBestThresh;
  const u = normalize(user);
  if (!u) return { kind: 'HINT', reason: 'EMPTY', matched: [], missing: acceptable.slice(0,3) };
  if (isNoSe(user)) return { kind: 'HINT', reason: 'DONT_KNOW', matched: [], missing: acceptable.slice(0,3) };

  // 1) Gate de vaguedad (barato) - M√ÅS PERMISIVO
  const vague = isVagueAnswer(u, undefined, { 
    stopwords: opts.vague?.stopwords,
    minUsefulTokens: opts.vague?.minUsefulTokens ?? 2,
    maxStopwordRatio: opts.vague?.maxStopwordRatio ?? 0.6,
    echoOverlap: opts.vague?.echoOverlap ?? 0.8,
    repeatSimilarity: opts.vague?.repeatSimilarity ?? 0.8,
    lastAnswer: context?.lastAnswer 
  });
  if (vague) return { kind: 'HINT', reason: 'VAGUE', matched: [], missing: acceptable.slice(0,3) };
  
  // 2) Detecci√≥n de "eco" (repetici√≥n de pregunta/respuesta anterior) - M√ÅS PERMISIVO
  if (context?.lastAnswer) {
    const overlap = jaccard(u, normalize(context.lastAnswer));
    if (overlap >= 0.8) return { kind: 'HINT', reason: 'ECHO', matched: [], missing: acceptable.slice(0,3) };
  }

  // 2) Match r√°pido (barato)
  const fast = classifyTurn(u, policy, acceptable, expected, opts.fuzzy);
  if (fast.kind === 'ACCEPT' || fast.kind === 'PARTIAL') return { ...fast, reason: fast.reason, sem: undefined } as any;

  // 3) Sem√°ntico (costoso): embeddings
  let idx: AskVectorIndex | null = null;
  try { idx = await buildAskIndex(acceptable, expected); } catch { idx = null; }
  if (!idx || !idx.centroid?.length) return { kind: 'HINT', reason: 'NO_SEM_MODEL', matched: [], missing: acceptable.slice(0,3) };
  const { cos, best } = await semanticScore(u, idx);
  
  // Debug: embeddings activos
  if (process.env.ENGINE_DEBUG === 'true') {
    console.log('[EMBEDDINGS]', { 
      user: u.slice(0, 50), 
      cos, 
      best: best?.text?.slice(0, 30), 
      semThresh: opts.semThresh,
      semBestThresh: opts.semBestThresh 
    });
  }
  // Usar umbrales calculados por tipo de pregunta
  if (cos >= semThresh) {
    if (policy.type === 'aplicacion') {
      const justifica = /porque|para|ya que/i.test(user);
      return { kind: (justifica ? 'ACCEPT' : 'PARTIAL'), reason: (justifica ? 'SEM_APLICACION_OK' : 'SEM_FALTA_JUSTIFICACION'), matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } } as any;
    }
    return { kind: 'PARTIAL', reason: 'SEM_SIMILAR', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((best?.cos || 0) >= semBestThresh) {
    return { kind: 'PARTIAL', reason: 'SEM_BEST', matched: best?.text ? [best.text] : [], missing: acceptable.filter(a => a !== best?.text).slice(0,2), sem: { cos, best } };
  }
  if ((context?.hintsUsed || 0) >= (opts.maxHints ?? 2)) {
    return { kind: 'REFOCUS', reason: 'MAX_HINTS', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
  }
  
  // Escalamiento a thinker para casos borderline/ambiguos
  if (cos >= 0.4 && cos < semThresh && (best?.cos || 0) >= 0.35) {
    try {
      const escalation = await escalateReasoning({
        student: user,
        objective: policy.type,
        acceptable,
        expected,
        matched: best?.text ? [best.text] : [],
        missing: acceptable.filter(a => a !== best?.text).slice(0,2),
        hintsUsed: context?.hintsUsed || 0
      });
      
      if (escalation.decision === 'ACCEPT') {
        return { kind: 'ACCEPT', reason: 'THINKER_ESCALATION', matched: best?.text ? [best.text] : [], missing: [], sem: { cos, best } };
      } else if (escalation.decision === 'HINT') {
        return { kind: 'HINT', reason: 'THINKER_ESCALATION', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
      }
    } catch (error) {
      // Si falla el escalamiento, continuar con la l√≥gica normal
      console.warn('[ESCALATION_ERROR]', error);
    }
  }
  
  return { kind: 'HINT', reason: 'SEM_LOW', matched: [], missing: acceptable.slice(0,3), sem: { cos, best } };
}
```
=== EOF: src\engine\eval.ts

===  src\engine\eval-escalation.ts
```typescript
import { getClient } from '@/lib/ai';
import { z } from 'zod';
import { getBudgetManager, pickModelWithBudget } from './costs';

// Esquema Zod para validaci√≥n estricta del JSON
const EscalationResponseSchema = z.object({
  decision: z.enum(['ACCEPT', 'HINT', 'REASK']),
  short: z.string().min(1).max(200),
  reason: z.enum(['SEM_LOW', 'THINKER_ESCALATION', 'OFF_TOPIC', 'BUDGET_LIMIT']).optional()
});

export type EscalationResponse = z.infer<typeof EscalationResponseSchema>;

export async function escalateReasoning(input: {
  student: string;
  objective: string;
  acceptable: string[];
  expected: string[];
  matched: string[];
  missing: string[];
  hintsUsed: number;
}): Promise<EscalationResponse> {
  const budgetManager = getBudgetManager();
  
  // Verificar presupuesto antes de escalar
  if (!budgetManager.canEscalate()) {
    return {
      decision: 'HINT',
      short: 'Considera revisar los conceptos clave mencionados.',
      reason: 'BUDGET_LIMIT'
    };
  }

  const ai = getClient();
  const model = pickModelWithBudget('thinker');
  
  const sys = [
    'Eres un evaluador estricto.',
    'Devuelve SOLO JSON con: { "decision": "ACCEPT|HINT|REASK", "short": "texto breve", "reason": "SEM_LOW|THINKER_ESCALATION|OFF_TOPIC" }. Sin comentarios.'
  ].join('\n');

  const user = `
Objetivo: ${input.objective}
Respuesta del alumno: ${input.student}
Acceptable: ${input.acceptable.join(', ')}
Expected: ${input.expected.join(', ')}
Matched: ${input.matched.join(', ')}
Missing: ${input.missing.join(', ')}
Hints usadas: ${input.hintsUsed}
Regla: si faltan conceptos cr√≠ticos -> HINT con pista breve; si es off-topic/vago -> REASK; si cumple -> ACCEPT.
`;

  try {
    const res = await ai.responses.create({
      model,
      reasoning: { effort: 'medium' },
      input: [
        { role: 'system', content: sys },
        { role: 'user',   content: user }
      ],
      max_output_tokens: 120
    });

    const raw = res.output_text || '{}';
    
    // Validar con Zod antes de usar
    const parsed = JSON.parse(raw);
    const validated = EscalationResponseSchema.parse(parsed);
    
    // Registrar uso en el presupuesto
    budgetManager.recordUsage('thinker', 200);
    
    return validated;
  } catch (error) {
    // Fallback seguro si falla la validaci√≥n o la llamada
    return {
      decision: 'REASK',
      short: 'Reformula tu respuesta con m√°s precisi√≥n.',
      reason: 'THINKER_ESCALATION'
    };
  }
}
```
=== EOF: src\engine\eval-escalation.ts

===  src\engine\costs.ts
```typescript
// Configuraci√≥n de costos por modelo (en centavos por 1K tokens)
const COST_CONFIG = {
  cheap: 0.5,    // gpt-4o-mini
  embed: 0.1,    // text-embedding-3-small  
  thinker: 2.5   // o3-mini
};

// Estimaci√≥n de tokens por tipo de operaci√≥n
const TOKEN_ESTIMATES = {
  response: 150,    // Respuesta t√≠pica
  embedding: 50,    // Embedding de texto
  escalation: 200   // Escalaci√≥n con razonamiento
};

export type CostTier = 'cheap' | 'embed' | 'thinker';

export class BudgetManager {
  private budgetCentsLeft: number;
  private usageByTier: Record<CostTier, number> = {
    cheap: 0,
    embed: 0,
    thinker: 0
  };

  constructor(initialBudgetCents: number = 100) {
    this.budgetCentsLeft = initialBudgetCents;
  }

  // Verificar si se puede usar un tier espec√≠fico
  canUseTier(tier: CostTier): boolean {
    const estimatedCost = this.estimateCost(tier);
    return this.budgetCentsLeft >= estimatedCost;
  }

  // Registrar uso y actualizar presupuesto
  recordUsage(tier: CostTier, actualTokens?: number): number {
    const tokens = actualTokens || TOKEN_ESTIMATES[tier === 'embed' ? 'embedding' : 'response'];
    const cost = (tokens / 1000) * COST_CONFIG[tier];
    
    this.usageByTier[tier] += tokens;
    this.budgetCentsLeft = Math.max(0, this.budgetCentsLeft - cost);
    
    return cost;
  }

  // Estimaci√≥n de costo para una operaci√≥n
  private estimateCost(tier: CostTier): number {
    const tokens = TOKEN_ESTIMATES[tier === 'embed' ? 'embedding' : 'response'];
    return (tokens / 1000) * COST_CONFIG[tier];
  }

  // Obtener m√©tricas de uso
  getUsageMetrics() {
    return {
      budgetCentsLeft: this.budgetCentsLeft,
      usageByTier: { ...this.usageByTier },
      totalCost: 100 - this.budgetCentsLeft,
      canEscalate: this.canUseTier('thinker')
    };
  }

  // Verificar si se puede escalar (thinker)
  canEscalate(): boolean {
    return this.canUseTier('thinker') && this.budgetCentsLeft > 10;
  }

  // Forzar modo econ√≥mico (solo cheap)
  forceCheapMode(): boolean {
    return this.budgetCentsLeft < 5;
  }
}

// Instancia global del gestor de presupuesto
let globalBudgetManager: BudgetManager | null = null;

export function getBudgetManager(): BudgetManager {
  if (!globalBudgetManager) {
    globalBudgetManager = new BudgetManager();
  }
  return globalBudgetManager;
}

export function resetBudgetManager(budgetCents: number = 100): BudgetManager {
  globalBudgetManager = new BudgetManager(budgetCents);
  return globalBudgetManager;
}

// Wrapper para pickModel que respeta el presupuesto
export function pickModelWithBudget(tier: CostTier): string {
  const budgetManager = getBudgetManager();
  
  // Si no hay presupuesto para el tier solicitado, degradar
  if (!budgetManager.canUseTier(tier)) {
    if (tier === 'thinker') return process.env.CHEAP_MODEL || 'gpt-4o-mini';
    if (tier === 'embed') return process.env.CHEAP_MODEL || 'gpt-4o-mini';
    return process.env.CHEAP_MODEL || 'gpt-4o-mini';
  }
  
  // Usar el modelo original
  if (tier === 'thinker') return process.env.THINKER_MODEL || 'o3-mini';
  if (tier === 'embed') return process.env.EMBED_MODEL || 'text-embedding-3-small';
  return process.env.CHEAP_MODEL || 'gpt-4o-mini';
}
```
=== EOF: src\engine\costs.ts

===  src\lib\ai.ts
```typescript
import OpenAI from 'openai';

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export function pickModel(tier: 'cheap'|'thinker'|'embed'='cheap'): string {
  if (tier === 'thinker') return process.env.THINKER_MODEL || 'o3-mini';
  if (tier === 'embed')  return process.env.EMBED_MODEL  || 'text-embedding-3-small';
  return process.env.CHEAP_MODEL || 'gpt-4o-mini';
}

export function getClient() { return client; }
```
=== EOF: src\lib\ai.ts

===  src\components\VoiceRecorder.tsx
```tsx
'use client';
import { Mic } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

export default function VoiceRecorder({ onResult, language = 'es' }: { onResult: (text: string) => void; language?: string }) {
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const [recording, setRecording] = useState(false);
  const [supported, setSupported] = useState(true);

  useEffect(() => {
    if (!navigator.mediaDevices || typeof window === 'undefined' || !(window as any).MediaRecorder) {
      setSupported(false);
    }
  }, []);

  const start = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mr = new MediaRecorder(stream);
      mediaRecorderRef.current = mr;
      chunksRef.current = [];
      mr.ondataavailable = e => { if (e.data && e.data.size > 0) chunksRef.current.push(e.data); };
      mr.onstop = async () => {
        try {
          const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
          const form = new FormData();
          form.append('audio', blob, 'audio.webm');
          form.append('language', language);
          const res = await fetch('/api/audio/transcribe', { method: 'POST', body: form });
          const data = await res.json();
          if (data?.text) onResult(data.text);
        } catch {}
      };
      mr.start();
      setRecording(true);
    } catch {
      setSupported(false);
    }
  };

  const stop = () => {
    const mr = mediaRecorderRef.current;
    if (mr && mr.state !== 'inactive') {
      mr.stop();
      setRecording(false);
    }
  };

  if (!supported) return null;

  return (
    <button
      onClick={() => (recording ? stop() : start())}
      className={`rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg ${
        recording ? 'bg-gradient-to-r from-rose-600 to-red-600 text-white p-3' : 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white p-3'
      }`}
      title={recording ? 'Detener dictado' : 'Dictar con voz'}
      aria-label={recording ? 'Detener dictado' : 'Dictar con voz'}
      type="button"
    >
      <Mic className="w-5 h-5" />
    </button>
  );
}


```
=== EOF: src\components\VoiceRecorder.tsx

===  src\components\EngineChatLayout.tsx
```tsx
'use client';
// Legacy layout: remove tight coupling with legacy core types
type LessonVM = any;
type EngineState = any;
import { Clock, Menu, Send, User, X } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import VoiceRecorder from './VoiceRecorder';

export type EngineChatMessage = { id: string; sender: 'ai'|'student'; content: string; timestamp: Date };

export default function EngineChatLayout({
  messages,
  isTyping,
  onSend,
  vm,
  state
}: {
  messages: EngineChatMessage[];
  isTyping: boolean;
  onSend: (text: string) => void;
  vm: LessonVM | null;
  state: EngineState | null;
}) {
  const [inputValue, setInputValue] = useState('');
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages, isTyping]);

  const handleSend = () => {
    if (!inputValue.trim()) return;
    onSend(inputValue);
    setInputValue('');
  };

  const handleKey = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }
  };

  return (
    <div className="min-h-screen bg-slate-100">
      {/* Header */}
      <header className="bg-white border-b border-slate-200 px-4 md:px-6 py-3 md:py-4 sticky top-0 z-40">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="bg-gradient-to-br from-blue-600 to-indigo-600 p-2.5 rounded-xl shadow-lg" />
            <div>
              <h1 className="text-lg md:text-xl font-bold text-slate-900">{vm?.title || 'DocenteIA'}</h1>
              <p className="text-xs md:text-sm text-slate-600">Versi√≥n {vm?.version} ¬∑ {vm?.locale}</p>
            </div>
          </div>
          <button onClick={() => setSidebarOpen(!sidebarOpen)} className="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 transition-colors">
            {sidebarOpen ? <X className="w-5 h-5" /> : <Menu className="w-5 h-5" />}
          </button>
        </div>
      </header>

      <div className="flex h-[calc(100vh-72px)]">
        {/* Main chat (m√°s ancho que multimedia) */}
        <div className={`transition-all duration-300 w-full ${sidebarOpen ? 'lg:basis-[60%] xl:basis-[65%]' : 'lg:basis-[70%] xl:basis-[75%]'}`}>
          <div className="h-full bg-white m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-6 space-y-6">
              {messages.map((m) => (
                <div key={m.id} className={`flex items-start space-x-4 ${m.sender === 'student' ? 'flex-row-reverse space-x-reverse' : ''}`}>
                  <div className={`w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold shadow-md ${m.sender === 'ai' ? 'bg-gradient-to-br from-blue-600 to-indigo-600 text-white' : 'bg-gradient-to-br from-slate-600 to-slate-700 text-white'}`}>
                    {m.sender === 'ai' ? 'AI' : <User className="w-5 h-5" />}
                  </div>
                  <div className={`flex-1 max-w-[85%] ${m.sender === 'student' ? 'text-right' : ''}`}>
                    <div className={`inline-block px-5 py-3 rounded-2xl shadow-sm ${m.sender === 'student' ? 'bg-gradient-to-r from-blue-600 to-blue-700 text-white' : 'bg-white border border-slate-200 text-slate-900'}`}>
                      <p className="text-sm leading-relaxed whitespace-pre-wrap">{m.content}</p>
                    </div>
                    <div className={`mt-2 flex items-center space-x-2 ${m.sender === 'student' ? 'justify-end' : 'justify-start'}`}>
                      <Clock className="w-3 h-3 text-slate-400" />
                      <span className="text-xs text-slate-500">{m.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    </div>
                  </div>
                </div>
              ))}
              {isTyping && (
                <div className="text-xs text-slate-500">Docente escribiendo‚Ä¶</div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <div className="px-6 py-3 border-t border-slate-200 bg-slate-50 rounded-b-2xl">
              <div className="flex items-end space-x-2">
                <textarea
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKey}
                  placeholder="Escribe tu respuesta..."
                  rows={1}
                  className="flex-1 w-full px-4 py-3 bg-white border border-slate-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  style={{ minHeight: '48px', maxHeight: '120px' }}
                />
                <VoiceRecorder onResult={(t)=>setInputValue((v)=> (v ? (v+ ' ' + t) : t))} />
                <button onClick={handleSend} disabled={!inputValue.trim()} className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-slate-300 disabled:to-slate-400 text-white p-3 rounded-xl transition-all duration-200 flex items-center justify-center shadow-lg disabled:shadow-none">
                  <Send className="w-5 h-5" />
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Middle: Contenido Multimedia */}
        <div className={`hidden lg:block transition-all duration-300 ${sidebarOpen ? 'lg:basis-[25%] xl:basis-[20%]' : 'lg:basis-[30%] xl:basis-[25%]'} `}>
          <div className="h-full bg-white m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="font-semibold text-slate-900">Contenido Multimedia</h3>
            </div>
            <div className="flex-1 p-6">
              <div className="bg-gradient-to-br from-slate-100 to-slate-200 rounded-xl text-slate-400 border border-slate-200 flex items-center justify-center aspect-video min-h-[180px]">
                <span className="text-xs">Imagen/Video</span>
              </div>
              <div className="mt-4 text-xs text-slate-600">Contenido multimedia de la sesi√≥n</div>
            </div>
          </div>
        </div>

        {/* Right side: Progreso (animado al cerrar) */}
        <div className={`hidden lg:block transition-all duration-300 pr-3 ${sidebarOpen ? 'lg:basis-[15%] xl:basis-[15%] opacity-100' : 'lg:basis-0 opacity-0 pointer-events-none'}`}>
          <div className={`h-full m-3 rounded-2xl shadow-sm border border-slate-200 flex flex-col bg-white transition-all duration-300 ${sidebarOpen ? 'scale-100' : 'scale-95'}`}>
            <div className="px-6 py-4 border-b border-slate-200">
              <h3 className="font-semibold text-slate-900">Progreso de la sesi√≥n</h3>
            </div>
            <div className="p-6 space-y-4 overflow-y-auto">
              {vm && state && (
                <>
                  <div>
                    <div className="flex justify-between text-sm mb-1">
                      <span className="text-slate-600">Momento</span>
                      <span className="font-medium text-slate-900">{state.momentIdx + 1}/{vm.moments.length}</span>
                    </div>
                    <div className="w-full bg-slate-100 rounded-full h-2">
                      <div className="bg-gradient-to-r from-blue-600 to-indigo-600 h-2 rounded-full transition-all" style={{ width: `${Math.round(((state.momentIdx + 1) / Math.max(1, vm.moments.length)) * 100)}%` }} />
                    </div>
                  </div>
                  <div>
                    <h4 className="text-xs font-medium text-slate-700 mb-2">Momentos</h4>
                    <div className="space-y-2">
                      {vm.moments.map((m: any, i: number) => (
                        <div key={`${m.title}-${i}`} className={`flex items-center gap-2 text-xs ${i === state.momentIdx ? 'text-blue-700' : 'text-slate-500'}`}>
                          <span className={`w-2 h-2 rounded-full ${i === state.momentIdx ? 'bg-blue-600' : 'bg-slate-300'}`} />
                          <span className="truncate">{m.title}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                  {vm.keyPoints && vm.keyPoints.length > 0 && (
                    <div>
                      <h4 className="text-xs font-medium text-slate-700 mb-2">Puntos Clave</h4>
                      <div className="space-y-2">
                        {vm.keyPoints.map((kp: any) => (
                          <div key={kp.id} className={`p-3 rounded-lg border ${kp.completed ? 'bg-green-50 border-green-200' : 'bg-slate-50 border-slate-200'}`}>
                            <div className="text-xs font-medium text-slate-800">{kp.title}</div>
                            {kp.description && <div className="text-[11px] text-slate-600 mt-1">{kp.description}</div>}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


```
=== EOF: src\components\EngineChatLayout.tsx

===  src\ai\prompt.ts
```typescript
export type DocenteAction = 'explain' | 'ask' | 'hint' | 'ok' | 'advance' | 'end' | 'ask_simple' | 'ask_options' | 'feedback';

export type DocentePromptContext = {
  language?: string;
  course?: { role?: string; tone?: string; style_guidelines?: string };
  action: DocenteAction;
  stepType: string;
  momentTitle?: string;
  objective?: string;
  contentBody?: string[];
  narrationText?: string;
  caseText?: string;
  questionText?: string;
  acceptable?: string[];
  userAnswer?: string;
  matched?: string[];
  missing?: string[];
  recentHistory?: string[];
  hintWordLimit?: number;
  simpleOptions?: string[];
  optionItems?: string[];
  kind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  closureCriteria?: string;
  allowQuestions?: boolean;
};

export function buildSystemPrompt(ctx: DocentePromptContext): string {
  const lang = ctx.language || 'es';
  const role = ctx.course?.role ? `Act√∫a como ${ctx.course.role}.` : '';
  const tone = ctx.course?.tone ? `Tono: ${ctx.course.tone}.` : '';
  const style = ctx.course?.style_guidelines ? `Gu√≠a de estilo: ${ctx.course.style_guidelines}.` : '';
  const rules = [
    `Eres un Docente IA uno-a-uno. Responde en ${lang}.`,
    role,
    tone,
    style,
    'Sigue estrictamente el paso actual del plan. No avances ni mezcles pasos.',
    'Nunca copies literal el JSON; reescribe con tus palabras. Evita vi√±etas/listas y par√°grafos largos.',
    'Preferentemente 2‚Äì3 frases por bloque; usar hasta 4‚Äì5 cuando el objetivo requiera retroalimentaci√≥n concreta. Lenguaje claro. No spoilers.',
    'Si el estudiante responde "no s√©" repetidamente, reduce dificultad seg√∫n la acci√≥n solicitada.',
    'Normaliza el error y la duda: valida el esfuerzo y anima a continuar antes de orientar.',
    'Al interpretar la respuesta del estudiante, considera equivalencias sem√°nticas razonables (t√©rminos extremos/coloquiales ‚âà categor√≠as profesionales) y reencuadra con lenguaje t√©cnico sin a√±adir conceptos fuera del objetivo/contenido.',
    'Mant√©n continuidad con el √∫ltimo turno: si ya respondi√≥, no repitas la misma pregunta; contin√∫a dentro del paso seg√∫n el plan.',
    'Evita repetir el mismo ejemplo en turnos consecutivos; var√≠alo o ad√°ptalo al contexto de la respuesta.',
    'No repitas exactamente la misma idea en dos turnos seguidos; a√±ade un matiz o detalle nuevo.',
    'Solo avanza cuando se cumpla el criterio de cierre del paso actual (si aplica).',
    'En acciones ask, hint, feedback, ask_simple y ask_options no re-narres el caso ni describas la situaci√≥n inicial; si fuera imprescindible, referencia en UNA sola frase sin repetir detalles. Reserva la narraci√≥n extensa solo para explain.'
  ].filter(Boolean).join(' ');
  return rules;
}

export function buildUserPrompt(ctx: DocentePromptContext): string {
  const lines: string[] = [];

  // Helpers
  const pushIf = (cond: any, s: string) => { if (cond) lines.push(s.trim()); };
  const hasAny = (...vals: Array<string | string[] | undefined | null>) =>
    vals.some(v => Array.isArray(v) ? v.filter(Boolean).length > 0 : !!v);

  // Header
  pushIf(true, `Momento: ${ctx.momentTitle || ''}`); // permite vac√≠o pero mantiene etiqueta
  pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);

  // Normalizaciones
  const contentItems = Array.from(new Set((ctx.contentBody || [])
    .filter(Boolean)
    .map(s => String(s).trim())))
    .slice(0, 20);
  const safeAnswer = String(ctx.userAnswer || '').trim().slice(0, 300);
  const matched = Array.from(new Set(ctx.matched || [])).filter(Boolean).slice(0, 8);
  const missing = Array.from(new Set(ctx.missing || [])).filter(Boolean).slice(0, 8);
  const recent = (ctx.recentHistory || []).slice(-3).join(' | ');
  pushIf(recent, `Historial reciente: ${recent}`);
  pushIf(ctx.closureCriteria, `Criterio de cierre: ${ctx.closureCriteria}`);

  switch (ctx.action) {
    case 'explain': {
      if (!hasAny(ctx.narrationText, contentItems, ctx.caseText)) {
        lines.push('Faltan insumos para explicar (narraci√≥n, contenido o caso).');
      }
      const payload = [
        ctx.narrationText ? `Narraci√≥n: ${ctx.narrationText}` : '',
        contentItems.length ? `Contenido: ${contentItems.join(' | ')}` : '',
        ctx.caseText ? `Caso: ${ctx.caseText}` : ''
      ].filter(Boolean).join('\n');
      pushIf(payload, payload);
      lines.push('Tarea: explica con TUS PALABRAS el contenido en 2‚Äì3 frases, sin listas ni preguntas.');
      lines.push('Reglas: si ya se us√≥ este ejemplo, var√≠alo o ad√°ptalo; no avances si el criterio de cierre no se cumple.');
      break;
    }

    case 'ask': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      lines.push('Tarea: enmarca brevemente y cierra con la PREGUNTA EXACTA tal cual. No a√±adas contenido nuevo.');
      lines.push('Reglas: si el estudiante ya respondi√≥ esta pregunta en el turno previo, no la repitas; produce una transici√≥n breve y contin√∫a dentro del paso sin avanzar al siguiente hasta cumplir el criterio de cierre. No re-narres el caso ni repitas la historia.');
      break;
    }

    case 'hint': {
      if (!ctx.questionText) lines.push('Falta la pregunta para la pista.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      pushIf(contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
      pushIf(safeAnswer, `Respuesta del estudiante: ${safeAnswer}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      const limit = ctx.hintWordLimit || 18;
      lines.push(
        `Tarea: primero escribe UNA pista (${limit} palabras aprox., sin signos de interrogaci√≥n) orientada al OBJETIVO (no listar soluciones ni definiciones generales). ` +
        `Si la respuesta del estudiante es "no s√©", "no lo s√©", "ninguna" o equivalente, empieza con UNA frase breve de empat√≠a/normalizaci√≥n; ` +
        `luego la pista. A continuaci√≥n, en una l√≠nea aparte, UNA sola micro‚Äëpregunta (‚â§8 palabras) centrada en el objetivo o el primer faltante. Nunca devuelvas solo preguntas.`
      );
      lines.push('Reglas: evita repetir la misma micro‚Äëpregunta usada en el turno previo (usa Historial reciente). No re‚Äënarrar el caso.');
      break;
    }

    case 'ask_simple': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const opts = Array.from(new Set(ctx.simpleOptions || [])).filter(Boolean).slice(0, 5);
      if (opts.length) {
        lines.push(`Opciones (elige una): ${opts.join(' / ')}`);
      }
      lines.push('Tarea: formula la elecci√≥n de forma clara y breve. No re‚Äënarrar el caso.');
      break;
    }

    case 'ask_options': {
      if (!ctx.questionText) lines.push('Falta la pregunta.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      const items = Array.from(new Set(ctx.optionItems || [])).filter(Boolean).slice(0, 5);
      if (items.length) {
        const labeled = items.map((s, i) => `${String.fromCharCode(65 + i)}) ${s}`);
        lines.push(`Opciones: ${labeled.join(' | ')}`);
      }
      lines.push('Tarea: pide que elija una opci√≥n (A, B, C, ‚Ä¶) y espera su selecci√≥n. No re‚Äënarrar el caso.');
      break;
    }

    case 'ok': {
      if (!ctx.questionText) lines.push('Falta la pregunta que se est√° validando.');
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      lines.push('Tarea: en 1‚Äì2 frases, reconoce lo correcto citando los aciertos y, si aplica, orienta brevemente lo que falta, sin preguntas. No introduzcas contenido nuevo.');
      break;
    }

    case 'advance': {
      lines.push('Tarea: micro‚Äëresumen de cierre (1‚Äì2 frases) y puente corto al siguiente foco.');
      break;
    }

    case 'end': {
      lines.push('Tarea: cierre final breve.');
      break;
    }

    case 'feedback': {
      const limit = ctx.hintWordLimit || 3; // n√∫mero de frases esperado, controlable por policies.feedback.maxSentences via caller
      const allowQ = ctx.allowQuestions !== false; // default: true
      pushIf(true, `Momento: ${ctx.momentTitle || ''}`);
      pushIf(ctx.objective, `Objetivo: ${ctx.objective}`);
      pushIf(ctx.questionText, `Pregunta: ${ctx.questionText}`);
      pushIf(ctx.userAnswer, `Respuesta del estudiante: ${safeAnswer}`);
      pushIf(matched.length, `Aciertos: ${matched.join(', ')}`);
      pushIf(missing.length, `Faltantes: ${missing.join(', ')}`);
      pushIf(contentItems.length, `Pistas de contenido: ${contentItems.join(' | ')}`);
      // Sem√°ntica para reencuadre sin hardcodeos
      const sem = [
        Array.isArray(ctx.acceptable) && ctx.acceptable.length ? `Aceptables: ${ctx.acceptable.join(' | ')}` : '',
        matched.length ? `Se√±ales presentes: ${matched.join(' | ')}` : '',
        missing.length ? `Se√±ales faltantes: ${missing.join(' | ')}` : ''
      ].filter(Boolean).join('\n');
      pushIf(sem, sem);
      const kind = (ctx.kind || 'HINT').toUpperCase();
      if (kind === 'ACCEPT') {
        lines.push(
          `Tarea (feedback: ACCEPT): escribe hasta ${limit} frases: ` +
          `1) empieza con una frase de refuerzo espec√≠fica citando 1‚Äì2 aciertos (usa Aciertos); ` +
          `2) si procede, orienta brevemente el siguiente foco` + (allowQ ? '' : `, sin preguntas`) + `, sin revelar respuestas. No re‚Äënarrar el caso.`
        );
      } else if (kind === 'PARTIAL') {
        lines.push(
          `Tarea (feedback: PARTIAL): escribe ${limit} frases: ` +
          `1) valida el esfuerzo y nombra lo correcto (usa Aciertos) sin repetir f√≥rmulas de √°nimo ya usadas; ` +
          `2) si el t√©rmino del estudiante es extremo/coloquial (p. ej., "se muere"), infiere su categor√≠a sem√°ntica pr√≥xima (p. ej., lesi√≥n grave por ca√≠da) y reencuadra con lenguaje profesional; ` +
          `orienta 1 faltante con una pista concreta alineada al objetivo/contenido (usa Faltantes y Pistas de contenido). ` +
          (allowQ ? '' : `No incluyas preguntas. `) + `Evita definiciones generales y no reveles soluciones completas.`
        );
      } else if (kind === 'REFOCUS') {
        lines.push(
          `Tarea (feedback: REFOCUS): escribe hasta ${limit} frases: ` +
          `1) ofrece √°nimo (sin repetirlo si ya fue expresado) y se√±ala con amabilidad el desv√≠o; ` +
          `2) redirige al criterio/objetivo central en forma concreta` + (allowQ ? '' : `, sin preguntas`) + `. No re‚Äënarrar el caso.`
        );
      } else {
        // HINT o evasiva
        lines.push(
          `Tarea (feedback: HINT): escribe ${limit} frases: ` +
          `1) normaliza la duda y anima a continuar (evita repetir empat√≠a si ya fue usada en el turno previo); ` +
          `2) da una pista concreta alineada al objetivo (usa Pistas de contenido o el primer Faltante); si el t√©rmino es extremo/coloquial, reencuadra con lenguaje profesional. No re‚Äënarrar el caso. ` +
          (allowQ ? `Cierra con UNA micro‚Äëpregunta (‚â§8 palabras) centrada en el objetivo.` : `No incluyas preguntas.`)
        );
      }
      break;
    }

    default: {
      lines.push(`Acci√≥n desconocida: ${String((ctx as any).action)}`);
      break;
    }
  }

  // Limpieza final: sin l√≠neas vac√≠as y con espacios normalizados
  return lines
    .map(s => s.trim())
    .filter(Boolean)
    .join('\n');
}


```
=== EOF: src\ai\prompt.ts

===  src\ai\orchestrator.ts
```typescript
import { getClient, pickModel } from '@/lib/ai';
import { DocentePromptContext, buildSystemPrompt, buildUserPrompt } from './prompt';

const client = getClient();

function stripQuestions(text?: string): string {
  const raw = (text || '').trim();
  if (!raw) return '';
  // Quita oraciones que terminen en ? o ¬ø a nivel de frase, manteniendo el resto
  const sentences = raw.split(/(?<=[\.!?¬ø])\s+/).filter(Boolean);
  return sentences.filter(s => !/[?¬ø]\s*$/.test(s.trim())).join(' ');
}

function lastQuestion(text?: string): string {
  const lines = (text || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
  const qs = lines.filter(l => /[?¬ø]\s*$/.test(l));
  return qs[qs.length - 1] || '';
}

function normalizeForMatch(s: string): string {
  return s
    		.toLowerCase()
		.normalize('NFD')
		.replace(/[\u0300-\u036f]/g, '')
		.replace(/\s+/g, ' ')
		.trim();
}

// Anti re‚Äënarraci√≥n: elimina p√°rrafos exactos presentes en el historial reciente
function stripRepeatedFromHistory(text: string, ctx: DocentePromptContext): string {
  const raw = (text || '').trim();
  if (!raw || !Array.isArray(ctx.recentHistory) || ctx.recentHistory.length === 0) return raw;
  const historyBlob = normalizeForMatch(ctx.recentHistory.join(' \n '));
  const paras = raw.split(/\n\n+/).map(s => s.trim()).filter(Boolean);
  const kept: string[] = [];
  for (const p of paras) {
    const pNorm = normalizeForMatch(p);
    const isRepeated = pNorm.length >= 60 && historyBlob.includes(pNorm);
    if (!isRepeated) kept.push(p);
  }
  return kept.join('\n\n').trim();
}

export async function runDocenteLLM(ctx: DocentePromptContext): Promise<{ message: string; followUp?: string }> {
  const system = buildSystemPrompt(ctx);
  const user = buildUserPrompt(ctx);
  const model = pickModel('cheap'); // Usar modelo barato para redacci√≥n docente
  const r = await client.responses.create({
    model,
    input: [
      { role: 'system', content: system },
      { role: 'user', content: user },
    ],
    temperature: 0.30,
  });
  const out = ((r as any).output_text || '').trim();
  if (ctx.action === 'explain') {
    return { message: stripQuestions(out) };
  }
  if (ctx.action === 'ask') {
    // Garantizar que la pregunta final sea la del JSON
    const q = (ctx.questionText || '').trim();
    let msg = stripQuestions(out);
    msg = stripRepeatedFromHistory(msg, ctx);
    const norm = (s: string) => s.replace(/\s+/g, ' ').toLowerCase();
    const already = norm(msg).includes(norm(q));
    return { message: already ? msg : [msg, q].filter(Boolean).join('\n\n') };
  }
  if (ctx.action === 'ok' || ctx.action === 'advance') {
    // Evitar que el reconocimiento o el puente incluyan preguntas
    let msg = stripQuestions(out);
    msg = stripRepeatedFromHistory(msg, ctx);
    return { message: msg };
  }
  if (ctx.action === 'hint') {
    let msg = stripQuestions(out);
    msg = stripRepeatedFromHistory(msg, ctx);
    const follow = lastQuestion(out);
    return { message: msg, followUp: follow };
  }
  if (ctx.action === 'ask_simple' || ctx.action === 'ask_options') {
    const msg = stripRepeatedFromHistory(out, ctx);
    return { message: msg };
  }
  if (ctx.action === 'feedback') {
    // No eliminar preguntas en feedback; solo evitar re‚Äënarraci√≥n repetida
    const msg = stripRepeatedFromHistory(out, ctx);
    return { message: msg };
  }
  return { message: out };
}


```
=== EOF: src\ai\orchestrator.ts

===  app\engine-chat\page.tsx
```tsx
"use client";
import EngineChatLayout from '@/components/EngineChatLayout';
import { usePlanChat } from '@/hooks/usePlanChat';
import { useEffect, useMemo, useState } from 'react';

type LessonRef = { id: string; name?: string; planUrl: string };
type CourseRef = { id: string; name?: string; lessons: LessonRef[] };
type Registry = { courses: CourseRef[] };

export default function EngineChatPage() {
  const [registry, setRegistry] = useState<Registry | null>(null);
  const [selectedCourseId, setSelectedCourseId] = useState<string>('');
  const [selectedLessonId, setSelectedLessonId] = useState<string>('');

  // derive current planUrl from selection
  const planUrl: string | null = useMemo(() => {
    if (!registry || !selectedCourseId || !selectedLessonId) return null;
    const course = registry.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return lesson?.planUrl || null;
  }, [registry, selectedCourseId, selectedLessonId]);

  const { messages, isTyping, done, sendMessage, clearMessages, adaptiveMode, setAdaptiveMode, budgetMetrics } = usePlanChat(planUrl || '/courses/SSO001/lessons/lesson02.json');

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        const res = await fetch('/courses/registry.json');
        if (!res.ok) return;
        const json = (await res.json()) as Registry;
        if (!alive) return;
        setRegistry(json);
        // default selection: first course/lesson
        const c = json.courses?.[0];
        if (c) {
          setSelectedCourseId(prev => prev || c.id);
          const l = c.lessons?.[0];
          if (l) setSelectedLessonId(prev => prev || l.id);
        }
      } catch {}
    })();
    return () => { alive = false; };
  }, []);

  // Simple VM/state placeholders for EngineChatLayout
  const vm = useMemo(() => {
    const course = registry?.courses.find(c => c.id === selectedCourseId);
    const lesson = course?.lessons.find(l => l.id === selectedLessonId);
    return {
      title: [course?.name || course?.id, lesson?.name || lesson?.id].filter(Boolean).join(' ¬∑ ') || 'DocenteIA',
      version: 'plan',
      locale: 'es-CL',
      moments: [],
      keyPoints: []
    } as any;
  }, [registry, selectedCourseId, selectedLessonId]);

  const state = useMemo(() => ({ momentIdx: 0 }), []);

  return (
    <div className="min-h-screen bg-slate-100">
      <div className="w-full px-2 md:px-4 py-4">
        <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4 mb-4 flex flex-col md:flex-row gap-3">
          <div className="flex-1 grid grid-cols-1 md:grid-cols-3 gap-3">
            <select
              className="border rounded-lg px-3 py-2"
              value={selectedCourseId}
              onChange={(e) => { setSelectedCourseId(e.target.value); setSelectedLessonId(''); clearMessages(); }}
            >
              <option value="">Selecciona curso‚Ä¶</option>
              {registry?.courses.map(c => (
                <option key={c.id} value={c.id}>{c.name || c.id}</option>
              ))}
            </select>
            <select
              className="border rounded-lg px-3 py-2"
              value={selectedLessonId}
              onChange={(e) => { setSelectedLessonId(e.target.value); clearMessages(); }}
              disabled={!selectedCourseId}
            >
              <option value="">Selecciona lecci√≥n‚Ä¶</option>
              {registry?.courses.find(c => c.id === selectedCourseId)?.lessons.map(l => (
                <option key={l.id} value={l.id}>{l.name || l.id}</option>
              ))}
            </select>
            <div className="flex items-center gap-2">
              <button onClick={() => clearMessages()} className="border rounded-lg px-3 py-2">Nueva sesi√≥n</button>
              {done && <span className="text-green-600 text-sm">Fin de la lecci√≥n</span>}
            </div>
          </div>
          
          {/* Controles de modo adaptativo y presupuesto */}
          <div className="flex items-center gap-4 border-t pt-4 mt-4">
            <div className="flex items-center gap-2">
              <label className="text-sm font-medium">Modo:</label>
              <select 
                value={adaptiveMode ? 'adaptive' : 'deterministic'} 
                onChange={(e) => setAdaptiveMode(e.target.value === 'adaptive')}
                className="border rounded-lg px-2 py-1 text-sm"
              >
                <option value="deterministic">Determinista</option>
                <option value="adaptive">Adaptativo</option>
              </select>
            </div>
            
            {budgetMetrics && (
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium">Presupuesto:</span>
                <div className="w-32 bg-gray-200 rounded-full h-2">
                  <div 
                    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                    style={{ width: `${(budgetMetrics.budgetCentsLeft / 100) * 100}%` }}
                  ></div>
                </div>
                <span className="text-xs text-gray-600">
                  ${(budgetMetrics.budgetCentsLeft / 100).toFixed(2)}
                </span>
              </div>
            )}
          </div>
        </div>

        <EngineChatLayout
          messages={messages as any}
          isTyping={isTyping}
          onSend={(t) => sendMessage(t)}
          vm={vm}
          state={state as any}
        />
      </div>
    </div>
  );
}


```
=== EOF: app\engine-chat\page.tsx

===  .data\history\plan-1755532890808-2mpn7beq.jsonl
```
{"ts":1755547601655,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Hola, bienvenido a la sesi√≥n. Hoy vamos a hablar sobre los procedimientos de seguridad, que son esenciales para garantizar un ambiente de trabajo seguro. Veremos por qu√© son importantes y c√≥mo pueden ayudarnos a prevenir accidentes y proteger a todos en el lugar de trabajo.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
```
=== EOF: .data\history\plan-1755532890808-2mpn7beq.jsonl

===  .data\history\plan-1755526234947-rojaqbok.jsonl
```
{"ts":1755528425739,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"¬°Hola! En esta sesi√≥n, vamos a hablar sobre los procedimientos de seguridad y por qu√© son tan importantes en el entorno laboral. Estos procedimientos nos ayudan a prevenir accidentes y a garantizar un ambiente de trabajo seguro para todos.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755528434614,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Piensa en los puntos clave. Comparte tus ideas en al menos 16 palabras. Gu√≠ate p","followUp":"En 16-24 palabras, cu√©ntame tus ideas principales sobre \"Elicitar expectativas del estudiante\"."}
```
=== EOF: .data\history\plan-1755526234947-rojaqbok.jsonl

===  .data\history\plan-1755488979318-vficrijj.jsonl
```
{"ts":1755492445742,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Hola, bienvenido. En esta sesi√≥n, vamos a hablar sobre los procedimientos de seguridad, que son las pautas que se deben seguir para garantizar un ambiente laboral seguro. Es fundamental entender su importancia, ya que ayudan a prevenir accidentes y proteger a todos en el trabajo.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
```
=== EOF: .data\history\plan-1755488979318-vficrijj.jsonl

===  .data\history\plan-1755442012156-hap7hutj.jsonl
```
{"ts":1755486402959,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Bienvenido a la sesi√≥n. Hoy vamos a hablar sobre los procedimientos de seguridad, que son esenciales para mantener un ambiente laboral seguro. Entenderemos su importancia y c√≥mo aplicarlos en nuestra rutina diaria para prevenir riesgos.","followUp":"¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?"}
{"ts":1755486409736,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Es normal no tener claridad al inicio, as√≠ que no te preocupes. En esta sesi√≥n, exploraremos las diferentes partes de los procedimientos de seguridad y su relevancia en el entorno laboral. Comprender c√≥mo se aplican y por qu√© es crucial seguirlos te ayudar√° a mantener un ambiente seguro.\n\nEs fundamental conocer las partes de un procedimiento de seguridad para aplicarlo correctamente y prevenir riesgos en el trabajo.","followUp":"¬øCu√°les crees que son esas partes?"}
{"ts":1755486419851,"planUrl":"/courses/SSO001/lessons/lesson02.json","stepIdx":3,"momentIdx":0,"message":"Es interesante ver tu inter√©s en los procedimientos de seguridad. Conocer sus partes es clave para aplicarlos de manera efectiva y as√≠ prevenir cualquier riesgo en el entorno laboral.\n\n¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?","followUp":""}
```
=== EOF: .data\history\plan-1755442012156-hap7hutj.jsonl

===  public\courses\SSO001\policies.json
```json
{
  "language": {
    "stopwords": ["el","la","los","las","un","una","unos","unas","de","en","y","o","a","para","con","sobre","que","es","son","del","al","por","se","como","mas","m√°s","menos","no","si","s√≠","qu√©","cuales","cu√°les"]
  },
  "thresholds": {
    "conceptual": { "min": 1 },
    "identificacion": { "min": 1 },
    "listado": { "kDefault": 2 },
    "aplicacion": { "requiresJustification": true },
    "metacognitiva": { "min": 1 },
    "experiencial": { "min": 1 },
    "reflexiva": { "min": 1 }
  },
  "hints": {
    "mentionCount": 2,
    "wordLimits": [16, 22, 28],
    "maxHints": 2,
    "variants": [
      "Piensa en los puntos clave.",
      "Evita generalidades y baja a concreto.",
      "Conecta con el objetivo de la pregunta."
    ],
    "templates": {
      "objective": "{opener} Enf√≥cate en {keywords}. {cueLine}",
      "reask": {
        "list": "Menciona en {maxWords} palabras 2 elementos de {base}.",
        "definition": "Define en {maxWords} palabras {base}.",
        "procedure": "Enumera en {maxWords} palabras 2 pasos clave de {base}.",
        "choice": "Indica en {maxWords} palabras la opci√≥n que aplica sobre {base}."
      },
      "open": {
        "hint": "Comparte tus ideas en al menos {minWords} palabras. {cuesLine} Conecta con tu experiencia.",
        "reask": "En {minWords}-{maxWords} palabras, cu√©ntame {aspects} sobre \"{objective}\".",
        "fallbackAspects": [
          "objetivo",
          "alcance",
          "responsables",
          "recursos",
          "pasos",
          "criterios"
        ],
        "aspectsLabel": "tus ideas principales"
      }
    }
  },

  "feedback": {
    "openers": {
      "hint": [
        "Considera revisar",
        "Piensa en",
        "Recuerda que",
        "Ten en cuenta"
      ]
    },
    "showDeterministic": false,
    "maxSentences": 3,
    "allowQuestions": true
  },
  "advance": {
    "allowForcedOn": ["SALUDO", "CONEXION"],
    "maxAttemptsBeforeForce": 2
  },
  "vague": {
    "minUsefulTokens": 2,
    "maxStopwordRatio": 0.7,
    "echoOverlap": 0.8,
    "repeatSimilarity": 0.85,
    "vagueAttemptsBeforeAB": 2,
    "vagueAttemptsBeforeExplain": 3,
    "simplifiedAskMaxWords": 10
  },
  "typeMap": {
    "abierta": "metacognitiva",
    "diagnostica": "identificacion",
    "diagn√≥stica": "identificacion",
    "aplicacion_practica": "aplicacion",
    "aplicacion": "aplicacion",
    "analisis": "conceptual",
    "analisis_comparativo": "conceptual",
    "analisis_critico": "conceptual",
    "seleccion_justificada": "aplicacion",
    "planificacion_aplicacion": "aplicacion",
    "autoevaluacion": "reflexiva",
    "identificacion": "identificacion",
    "conceptual": "conceptual",
    "listado": "listado",
    "reflexiva": "reflexiva",
    "experiencial": "experiencial"
  }
}


```
=== EOF: public\courses\SSO001\policies.json

===  public\courses\SSO001\overrides.json
```json
{
  "steps": {
    "M3-Q02": { "type": "listado", "k": 4 },
    "M4-Q01": { "type": "aplicacion", "requiresJustification": true }
  }
}



```
=== EOF: public\courses\SSO001\overrides.json

===  public\courses\SSO001\course.json
```json
{
  "id": "SSO001",
  "name": "Seguridad y Salud Ocupacional",
  "version": "1.0.0",
  "language": "es",
  "objectives": [
    "Identificar riesgos",
    "Aplicar procedimientos"
  ],
  "specialist": {},
  "lessons": [
    {
      "id": "lesson02",
      "title": "Procedimientos de Seguridad",
      "order": 2,
      "path": "/courses/SSO001/lessons/lesson02.json"
    }
  ]
}


```
=== EOF: public\courses\SSO001\course.json

===  src\engine\flow\transition.ts
```typescript
export type TransitionAction = 'ask' | 'hint' | 'ask_simple' | 'ask_options' | 'explain' | 'ok';

export type EscalationConfig = {
  noSeToHint?: number;
  hintToAskSimple?: number;
  askSimpleToOptions?: number;
  hardStopToExplain?: number;
};

export function decideNextAction(params: {
  lastAction?: TransitionAction;
  classKind?: 'ACCEPT' | 'PARTIAL' | 'HINT' | 'REFOCUS';
  attempts: number;
  noSeCount: number;
  cfg?: EscalationConfig;
}): { nextAction: TransitionAction; resetNoSe?: boolean } {
  const { lastAction, classKind, attempts, noSeCount, cfg } = params;

  // Acierto expl√≠cito del clasificador
  if (classKind === 'ACCEPT') {
    return { nextAction: 'ok', resetNoSe: true };
  }

  // Si hay configuraci√≥n expl√≠cita, resp√©tala
  if (cfg) {
    const toHint = cfg.noSeToHint ?? Number.POSITIVE_INFINITY;
    const toSimple = cfg.hintToAskSimple ?? Number.POSITIVE_INFINITY;
    const toOptions = cfg.askSimpleToOptions ?? Number.POSITIVE_INFINITY;
    const toExplain = cfg.hardStopToExplain ?? Number.POSITIVE_INFINITY;

    if (lastAction === 'ask') {
      if (noSeCount >= toHint) return { nextAction: 'hint' };
      return { nextAction: 'ask' };
    }
    if (lastAction === 'hint') {
      if (noSeCount >= toSimple) return { nextAction: 'ask_simple' };
      return { nextAction: 'hint' };
    }
    if (lastAction === 'ask_simple') {
      if (noSeCount >= toOptions) return { nextAction: 'ask_options' };
      return { nextAction: 'ask_simple' };
    }
    if (lastAction === 'ask_options') {
      if (noSeCount >= toExplain) return { nextAction: 'explain' };
      return { nextAction: 'ask_options' };
    }
    // Fallback config-driven: empezar por ask
    return { nextAction: 'ask' };
  }

  // Sin configuraci√≥n: preferir feedback primero cuando hay se√±ales parciales
  if (classKind === 'PARTIAL') {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  } else {
    if (lastAction === 'ask') return { nextAction: 'hint' };
    if (lastAction === 'hint') return { nextAction: 'ask_simple' };
    if (lastAction === 'ask_simple') return { nextAction: 'ask_options' };
    if (lastAction === 'ask_options') return { nextAction: 'explain' };
  }
  return { nextAction: 'ask' };
}


```
=== EOF: src\engine\flow\transition.ts

===  public\courses\SSO001\lessons\lesson02.json
```json
{
  "meta": {
    "lesson_id": "SSO001_lesson02",
    "lesson_name": "Procedimientos de Seguridad",
    "version": "1.0.0",
    "language": "es",
    "ordered": true,
    "generated_at": "2025-08-14T00:00:00Z"
  },
  "moments": [
    {
      "code": "M1",
      "order": 1,
      "title": "Saludo",
      "steps": [
        { "code": "M1-EL01", "order": 1, "type": "EXPECTED_LEARNING", "items": [
          "Comprender qu√© es un procedimiento de seguridad",
          "Identificar sus componentes principales",
          "Aplicar criterios b√°sicos de selecci√≥n de EPP"
        ]},
        { "code": "M1-KP01", "order": 2, "type": "KEY_POINTS", "items": [
          "Qu√© es un procedimiento", "Por qu√© es importante", "C√≥mo se aplica"
        ]},
        { "code": "M1-N01", "order": 3, "type": "NARRATION", "text": "Bienvenida y objetivo de la sesi√≥n. Exploraremos qu√© son los procedimientos de seguridad y su relevancia en el trabajo." },
        { "code": "M1-Q01", "order": 4, "type": "ASK",
          "question": "¬øQu√© esperas aprender sobre procedimientos de seguridad en esta sesi√≥n?",
          "objective": "Elicitar expectativas del estudiante",
          "answer_type": "open",
          "rubric": { "min_words": 18, "aspects": ["objetivo","alcance","responsables","recursos","pasos","criterios"] },
          "expected": ["objetivo","alcance","responsables","recursos","pasos","criterios"],
          "acceptable_answers": ["partes del procedimiento", "c√≥mo se aplica", "importancia de seguirlos", "selecci√≥n de EPP", "objetivo", "alcance", "responsables", "recursos", "pasos", "criterios"],
          "question_type": "metacognitiva"
        }
      ]
    },
    {
      "code": "M2",
      "order": 2,
      "title": "Conexi√≥n",
      "steps": [
        { "code": "M2-N01", "order": 1, "type": "NARRATION",
          "text": "Historia: En una obra, un trabajador debe instalar ventanas en el tercer piso. Recibe un arn√©s, pero no ha trabajado en altura antes." },
        { "code": "M2-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© elementos de seguridad identificas en esta situaci√≥n?",
          "objective": "Activar conocimientos previos",
          "expected": ["arn√©s", "l√≠nea de vida", "casco", "guantes", "inspecci√≥n previa", "supervisi√≥n"],
          "acceptable_answers": ["arn√©s", "arn√©s de seguridad", "l√≠nea", "l√≠nea de vida", "casco", "guantes", "inspecci√≥n previa", "supervisi√≥n"],
          "question_type": "diagn√≥stica"
        },
        { "code": "M2-Q02", "order": 3, "type": "ASK",
          "question": "¬øQu√© podr√≠a pasar si no se siguen los procedimientos correctos?",
          "objective": "Conciencia de riesgos",
          "expected": ["ca√≠das", "lesiones", "accidentes", "sanciones", "multas", "fatalidad"],
          "acceptable_answers": ["ca√≠das", "lesiones", "accidentes", "sanciones", "multas", "muerte", "fatalidad", "accidente mortal", "da√±o grave"],
          "question_type": "reflexiva"
        }
      ]
    },
    {
      "code": "M3",
      "order": 3,
      "title": "Adquisici√≥n",
      "steps": [
        { "code": "M3-C01", "order": 1, "type": "CONTENT",
          "title": "Definici√≥n de procedimiento de seguridad",
          "body": [
            "PROCEDIMIENTO DE SEGURIDAD: Secuencia ordenada y documentada de pasos espec√≠ficos para realizar una tarea de forma segura, minimizando riesgos laborales"
          ]
        },
        { "code": "M3-Q01", "order": 2, "type": "ASK",
          "question": "¬øC√≥mo definir√≠as un procedimiento de seguridad con tus palabras?",
          "objective": "Comprender la definici√≥n",
          "answer_type": "definition",
          "expected": ["secuencia de pasos", "seguridad", "minimizar riesgos", "documentado"],
          "acceptable_answers": ["secuencia documentada de pasos", "realizar una tarea de forma segura", "minimizar riesgos laborales"],
          "question_type": "conceptual"
        },
        { "code": "M3-C02", "order": 3, "type": "CONTENT",
          "title": "Partes de un procedimiento",
          "body": [
            "Objetivo", "Alcance", "Responsabilidades", "Pasos espec√≠ficos", "EPP requerido", "Medidas de emergencia", "Registros"
          ]
        },
        { "code": "M3-Q02", "order": 4, "type": "ASK",
          "question": "¬øQu√© partes debe incluir un procedimiento de seguridad completo?",
          "objective": "Identificar componentes",
          "expected": ["objetivo", "alcance", "responsabilidades", "pasos espec√≠ficos", "EPP", "emergencias", "registros"],
          "acceptable_answers": ["objetivo", "alcance", "responsabilidades", "pasos espec√≠ficos", "epp requerido", "medidas de emergencia", "registros"],
          "question_type": "listado"
        },
        { "code": "M3-C03", "order": 5, "type": "CONTENT",
          "title": "Criterios para seleccionar EPP",
          "body": [
            "Evaluar tipo de riesgo y nivel de exposici√≥n",
            "Compatibilidad, ajuste y comodidad",
            "Cumplimiento normativo y certificaciones"
          ]
        },
        { "code": "M3-Q03", "order": 6, "type": "ASK",
          "question": "Menciona dos criterios para seleccionar EPP adecuadamente.",
          "objective": "Dominar criterios de selecci√≥n de EPP",
          "answer_type": "list",
          "expected": ["tipo de riesgo", "nivel de exposici√≥n", "compatibilidad", "ajuste", "certificaciones"],
          "acceptable_answers": ["tipo de riesgo", "nivel de exposici√≥n", "compatibilidad", "ajuste", "normativa", "certificaciones"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M4",
      "order": 4,
      "title": "Aplicaci√≥n",
      "steps": [
        { "code": "M4-CASE01", "order": 1, "type": "CASE",
          "title": "Trabajo en altura en fachada",
          "description": "Instalaci√≥n de ventanas en tercer piso con uso de arn√©s y l√≠nea de vida.",
          "variables": ["altura > 2 m", "arn√©s", "l√≠nea de vida", "supervisi√≥n", "verificaci√≥n de anclajes"]
        },
        { "code": "M4-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© EPP m√≠nimo usar√≠as y por qu√©?",
          "objective": "Justificar selecci√≥n de EPP",
          "answer_type": "procedure",
          "expected": ["arn√©s con l√≠nea de vida", "casco", "guantes", "calzado antideslizante", "justificaci√≥n"],
          "acceptable_answers": ["arn√©s con l√≠nea de vida", "casco", "guantes", "calzado antideslizante"],
          "question_type": "aplicaci√≥n"
        }
      ]
    },
    {
      "code": "M5",
      "order": 5,
      "title": "Discusi√≥n",
      "steps": [
        { "code": "M5-TOP01", "order": 1, "type": "TOPICS",
          "items": ["Protocolizar vs. improvisar", "Cultura de seguridad"]
        },
        { "code": "M5-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© ventajas tiene documentar procedimientos frente a improvisar?",
          "objective": "Comparar enfoques",
          "expected": ["estandarizaci√≥n", "reducci√≥n de errores", "trazabilidad", "cumplimiento"],
          "acceptable_answers": ["estandariza", "reduce errores", "trazabilidad", "cumplimiento"],
          "question_type": "argumentativa"
        }
      ]
    },
    {
      "code": "M6",
      "order": 6,
      "title": "Reflexi√≥n",
      "steps": [
        { "code": "M6-REF01", "order": 1, "type": "REFLECTION_AREAS",
          "items": ["H√°bitos personales de seguridad", "Compromisos inmediatos"]
        },
        { "code": "M6-Q01", "order": 2, "type": "ASK",
          "question": "¬øQu√© cambio aplicar√°s esta semana para mejorar tu seguridad?",
          "objective": "Plan de mejora personal",
          "answer_type": "open",
          "expected": ["compromiso espec√≠fico", "c√≥mo lo implementar√°s", "beneficios esperados"],
          "acceptable_answers": ["ejemplo personal", "compromiso concreto"],
          "question_type": "reflexiva"
        }
      ]
    }
  ]
}


```
=== EOF: public\courses\SSO001\lessons\lesson02.json

===  app\api\engine\turn\route.ts
```typescript
import { runDocenteLLM } from '@/ai/orchestrator';
import { computeMatchedMissing, detectTopicDeviation, evaluateHybrid, type AskPolicy } from '@/engine/eval';
import { buildDeterministicFeedback as mkFb } from '@/engine/feedback';
import { extractKeywords, makeHintMessage, makeReaskMessage } from '@/engine/hints';
import { isAffirmativeToResume, isStudentAskingQuestion } from '@/engine/questions';
import { advanceTo, currentStep, decideAction, decideNextAction, getNextAskInSameCycle, next } from '@/engine/runner';
import { loadAndCompile } from '@/plan/compilePlan';
import { appendHistory, clearHistory, getRecentHistory } from '@/session/history';
import { SessionState, initSession } from '@/session/state';
import { getSessionStore } from '@/session/store';
import fs from 'fs/promises';
import { NextResponse } from 'next/server';
import path from 'path';

type ClientState = {
  momentIdx?: number;
  stepIdx?: number;
  attemptsByAskCode?: Record<string, number>;
  noSeCountByAskCode?: Record<string, number>;
  lastActionByAskCode?: Record<string, string>;
  lastAnswerByAskCode?: Record<string, string>;
  done?: boolean;
};

type Body = { sessionKey: string; userInput?: string; planUrl?: string; reset?: boolean; clientState?: ClientState; adaptiveMode?: boolean };

const SESSIONS = new Map<string, SessionState>();
const COURSE_POLICIES_CACHE = new Map<string, any>();

function mapMomentKind(title?: string): 'SALUDO'|'CONEXION'|'ADQUISICION'|'APLICACION'|'DISCUSION'|'REFLEXION'|'OTRO' {
  const t = (title || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  if (t.includes('saludo')) return 'SALUDO';
  if (t.includes('conexion')) return 'CONEXION';
  if (t.includes('adquisicion')) return 'ADQUISICION';
  if (t.includes('aplicacion')) return 'APLICACION';
  if (t.includes('discusion')) return 'DISCUSION';
  if (t.includes('reflexion')) return 'REFLEXION';
  return 'OTRO';
}

function deriveCourseId(planUrl: string): string | undefined {
  const m = planUrl.match(/\/courses\/(.*?)\//);
  return m?.[1];
}

async function loadCoursePolicies(courseId?: string) {
  if (!courseId) return undefined;
  if (COURSE_POLICIES_CACHE.has(courseId)) return COURSE_POLICIES_CACHE.get(courseId);

  try {
    const url = `/courses/${courseId}/policies.json`;
    let json: any;
    if (/^https?:/i.test(url)) {                       // remoto
      const res = await fetch(url);
      if (!res.ok) return undefined;
      json = await res.json();
    } else {                                           // relativo -> public/
      const filePath = path.join(process.cwd(), 'public', url.replace(/^\//, ''));
      const raw = await fs.readFile(filePath, 'utf-8');
      json = JSON.parse(raw);
    }
    COURSE_POLICIES_CACHE.set(courseId, json);
    return json;
  } catch {
    return undefined;
  }
}

function buildStudentFacingBase(questionText: string, objective: string, expected: string[]): string {
  const q = (questionText || '').toLowerCase();
  const idx = q.indexOf('sobre ');
  if (idx !== -1) {
    const topic = questionText.slice(idx + 'sobre '.length).replace(/[?¬ø.]/g, '').trim();
    if (topic) return `lo que esperas aprender sobre ${topic}`;
  }
  const fallback = (expected || []).filter(Boolean)[0] || objective || '';
  if (fallback) return `aspectos clave de ${fallback}`;
  return 'el tema actual';
}

export async function POST(req: Request) {
	try {
		const body = (await req.json()) as Body;
		const { sessionKey, userInput = '', planUrl = '/courses/SSO001/lessons/lesson02.json', reset = false, clientState, adaptiveMode = false } = body;
		let pendingInput = (userInput || '').toString();
		if (reset) {
			SESSIONS.delete(sessionKey);
			try { await getSessionStore().delete(sessionKey); } catch {}
			try { await clearHistory(sessionKey); } catch {}
		}
		let state = (await getSessionStore().get(sessionKey)) || SESSIONS.get(sessionKey);
    		if (!state) {
			const plan = await loadAndCompile(planUrl);
			state = initSession(planUrl, plan);
			// Aplicar modo adaptativo si se solicita
			if (adaptiveMode) {
				state.adaptiveMode = true;
			}
			SESSIONS.set(sessionKey, state);
			try { await getSessionStore().set(sessionKey, state); } catch {}
		}
    if (!state) {
      throw new Error('No se pudo inicializar la sesi√≥n');
    }
    // Rehidratar desde clientState si viene en el request (persistencia sin servidor)
    if (clientState) {
      // No sobrescribir con √≠ndices m√°s antiguos del cliente
      if (typeof clientState.momentIdx === 'number') {
        const m = Number(clientState.momentIdx);
        if (typeof state.momentIdx !== 'number' || m > (state.momentIdx as number)) {
          state.momentIdx = m;
        }
      }
      if (typeof clientState.stepIdx === 'number') {
        const sIdx = Number(clientState.stepIdx);
        if (typeof state.stepIdx !== 'number' || sIdx > (state.stepIdx as number)) {
          state.stepIdx = sIdx;
        }
      }
      state.attemptsByAskCode = { ...(state.attemptsByAskCode || {}), ...(clientState.attemptsByAskCode || {}) };
      state.noSeCountByAskCode = { ...(state.noSeCountByAskCode || {}), ...(clientState.noSeCountByAskCode || {}) };
      state.lastActionByAskCode = { ...(state.lastActionByAskCode || {}), ...(clientState.lastActionByAskCode || {}) };
      state.lastAnswerByAskCode = { ...(state.lastAnswerByAskCode || {}), ...(clientState.lastAnswerByAskCode || {}) };
      // Flag opcional
      if (typeof (clientState as any).justAskedFollowUp === 'boolean') {
        state.justAskedFollowUp = Boolean((clientState as any).justAskedFollowUp);
      }
		}
    const coursePolicies = await loadCoursePolicies(deriveCourseId(state.planUrl));
		const step = currentStep(state);
		// Debug inicio de turno
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st0 = currentStep(state);
				const payload0 = {
					tag: 'engine.turn.start',
					sessionKey,
					momentTitle: state.plan?.moments?.[st0?.momentIndex || 0]?.title,
					stepType: st0?.type,
					stepIdx: state.stepIdx,
					userInputLen: (pendingInput || '').length
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload0));
			}
		} catch {}
		
		// Interceptor universal de consultas (antes de evaluar el ASK)
		state.consultCtx = state.consultCtx || {};
		
		// Variables de salida
		let message = '';
		let followUp = '';
		
		// --- REEMITIR REPREGUNTA SI A√öN NO RESPONDE (continuidad) ---
		if (!pendingInput.trim() && state.justAskedFollowUp && state.lastFollowUpText) {
			return NextResponse.json({
				message: '',
				followUp: state.lastFollowUpText,
				state
			});
		}
		
		// 1) Si el alumno pide "permiso" para preguntar (p.ej. "te puedo hacer una pregunta"):
		if (isStudentAskingQuestion(pendingInput) && !/\w+\?/.test(pendingInput)) {
			message = '¬°Claro! Dime cu√°l es tu consulta y, cuando quede claro, me lo confirmas para continuar con la clase.';
			// "pausa": recuerda d√≥nde est√°s para retomar
			state.consultCtx.pausedAt = { momentIndex: state.momentIdx!, stepIndex: state.stepIdx! };
			// Debug log
			if (process.env.ENGINE_DEBUG === 'true') {
				console.log('[CONSULTA_INTENCION]', { pausedAt: state.consultCtx.pausedAt });
			}
			// No avances el plan ni eval√∫es; solo responde
			return NextResponse.json({ message, followUp: '', state });
		}
		
		// 2) Si trae una pregunta concreta (termina en ? o contiene palabras de pregunta):
		if (isStudentAskingQuestion(pendingInput) && /\w+\?/.test(pendingInput)) {
			const recent = await getRecentHistory(sessionKey, 6);
			const qa = await runDocenteLLM({
				language: 'es',
				action: 'feedback',
				stepType: 'ASK',
				questionText: pendingInput,
				objective: String(state.plan?.meta?.lesson_name || ''),
				recentHistory: recent
			});
			message = (qa.message || '').trim();
			// pides confirmaci√≥n para retomar
			const tail = '\n\n¬øTe qued√≥ claro? Responde "s√≠" para continuar o formula otra pregunta.';
			// Debug log
			if (process.env.ENGINE_DEBUG === 'true') {
				console.log('[CONSULTA_QA]', { len: message.length });
			}
			return NextResponse.json({ message: message + tail, followUp: '', state });
		}
		
		// 3) Si el alumno confirma que ya entendi√≥, retomas donde qued√≥
		if (state.consultCtx.pausedAt && isAffirmativeToResume(pendingInput)) {
			// Debug log
			if (process.env.ENGINE_DEBUG === 'true') {
				console.log('[CONSULTA_RESUME]', { resumedFrom: state.consultCtx.pausedAt });
			}
			// Limpiar contexto de pausa
			state.consultCtx.pausedAt = undefined;
			
			// Si estamos sobre una ASK, re-emitirla ya
			const st = currentStep(state);
			if (st?.type === 'ASK') {
				const q = st.data?.question || '';
				message = 'Perfecto, retomemos.';
				followUp = q;
				state.justAskedFollowUp = Boolean(followUp);
				return NextResponse.json({ message, followUp, state });
			}
			// Si no es ASK, contin√∫a flujo normal
		}
		
		// Bucle: saltar SKIP consecutivos y construir salida adecuada
		// Debug vars
		let dbg: any = null;
		let safety = 0;
    let skipGuarantee = false;
		while (safety++ < 20) {
			const act = decideAction(currentStep(state));
			if (act.kind === 'skip') {
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				continue;
			}
			if (act.kind === 'explain') {
				const data = act.step.data;
				const parts = [data.title, ...(data.body || []), data.text, ...(data.items || [])].filter(Boolean) as string[];
				const bodyArr: string[] = parts as string[];
				try {
					// Anti-repetici√≥n: emite narrativa s√≥lo una vez por momento
					const mIdx = act.step.momentIndex;
					const already = Boolean(state.narrativesShownByMoment?.[mIdx]);
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({
						language: 'es',
						action: 'explain',
						stepType: act.step.type,
						momentTitle: state.plan?.moments[act.step.momentIndex]?.title,
						objective: state.plan?.meta?.lesson_name || '',
						contentBody: bodyArr,
						recentHistory: recent
					});
					message = already ? '' : llm.message;
				} catch {
					message = bodyArr.join(' ‚Äî ') || 'Continuemos con el contenido.';
				}
				state = next(state);
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				// Buscar la siguiente ASK saltando pasos de metadatos y avanzar el puntero a ella
				const steps = state.plan?.allSteps || [];
				let targetIdx: number | undefined;
				for (let i = state.stepIdx; i < steps.length; i++) {
					const s = steps[i];
					const t = s.type;
					if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'EXPECTED_LEARNING') continue;
					if (t === 'ASK') { followUp = s.data.question || ''; targetIdx = i; }
					break;
				}
				// marcar flag para evitar eco y adelantar estado a la ASK
				state.justAskedFollowUp = Boolean(followUp);
				// marca narrativa mostrada
				try { (state.narrativesShownByMoment ||= {})[act.step.momentIndex] = true; } catch {}
				if (typeof targetIdx === 'number') { state = advanceTo(state, targetIdx); }
				SESSIONS.set(sessionKey, state);
				try { await getSessionStore().set(sessionKey, state); } catch {}
				break;
			}
        if (act.kind === 'ask') {
				const q = act.step.data.question || '';
				const acceptable = act.step.data.acceptable_answers || [];
				// Pol√≠tica por tipo con K din√°mico para LISTADO
				const qtype = String(act.step.data.question_type || '').toLowerCase();
				// Identificador del paso para contar intentos/acciones previas
				const stepCodeDyn = act.step.code || `Q:${q.substring(0,50)}`;
				const attemptsSoFar = Number(state.attemptsByAskCode?.[stepCodeDyn] || 0);
				const lastActionForStep = String(state.lastActionByAskCode?.[stepCodeDyn] || 'ask');
				const firstAttempt = attemptsSoFar === 0;
				const afterHint = lastActionForStep === 'hint';
				const dynamicK = qtype.includes('lista') ? (firstAttempt ? 1 : (afterHint ? 2 : 2)) : undefined;
				const policy: AskPolicy = qtype.includes('lista') ? { type: 'listado', thresholdK: dynamicK }
					: qtype.includes('aplica') ? { type: 'aplicacion', requiresJustification: true }
					: (qtype.includes('abierta') ? { type: 'metacognitiva' } : { type: (qtype as any) || 'conceptual' });
				// Derivar expected desde pasos previos (CONTENT/KEY_*) del mismo momento
				let expected: string[] = [];
				try {
					const moment = state.plan?.moments?.[act.step.momentIndex];
					const prior = (moment?.steps || []).slice(0, act.step.stepIndex);
					const texts: string[] = [];
					for (const ps of prior) {
						const t = ps.type;
						const d: any = ps.data;
						if (t === 'CONTENT') {
							if (d.title) texts.push(String(d.title));
							if (Array.isArray(d.body)) texts.push(...d.body.map((x: any)=>String(x)));
						} else if (t === 'KEY_CONTENT' || t === 'KEY_POINTS' || t === 'KEY_ELEMENTS' || t === 'TOPICS') {
							if (Array.isArray(d.items)) texts.push(...d.items.map((x: any)=>String(x)));
						} else if (t === 'NARRATION' && d.text) {
							texts.push(String(d.text));
						}
					}
					const explicit: string[] = Array.isArray(act.step.data?.expected) ? (act.step.data.expected as string[]) : [];
					const derived = extractKeywords(texts);
					const union = Array.from(new Set([...(explicit || []), ...(derived || [])]));
					expected = union;
				} catch {}
          const momentKind = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
          const maxAttempts = Number(coursePolicies?.advance?.maxAttemptsBeforeForce ?? 2);
          const allowForcedOn: string[] = Array.isArray(coursePolicies?.advance?.allowForcedOn) ? coursePolicies.advance.allowForcedOn : ['CONEXION'];
          const stepCode = act.step.code || `Q:${q.substring(0,50)}`;
          if (!pendingInput.trim()) {
            // evitar eco si acabamos de adjuntar followUp
            if (state.justAskedFollowUp) {
              message = '';
              followUp = '';
              state.justAskedFollowUp = false;
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
              skipGuarantee = true;
              break;
            }
            try {
              const recent = await getRecentHistory(sessionKey, 4);
              const llm = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q, objective: String(act.step.data.objective || ''), recentHistory: recent });
						message = llm.message;
					} catch { message = q; }
					break;
				}
          // Evaluaci√≥n para preguntas abiertas (answer_type: "open")
          const answerType = (act.step.data as any)?.answer_type || '';
          const rubric = (act.step.data as any)?.rubric || {};
          const objText = String(act.step.data?.objective || '');
          const isOpen = (answerType === 'open') || String((act.step.data as any)?.question_type || '').toLowerCase().includes('abierta') || ['SALUDO','CONEXION'].includes(momentKind);
          
          let cls: any;
          let vague: boolean;
          const hintsUsed = Number(state.hintsByAskCode?.[stepCode] || 0);
          const attempts = state.attemptsByAskCode?.[stepCode] || 0;
          
          if (isOpen) {
            // 1) Reglas r√°pidas + lectura de se√±ales de contenido
            const text = (pendingInput || '').trim();
            const minWords = Number(rubric.min_words ?? 12);
            const words = text.split(/\s+/).filter(Boolean);
            const tooShort = words.length < minWords;
            // Se√±ales de contenido (antes de gatear por longitud)
            const { matched: openMatched, missing: openMissing } = computeMatchedMissing(text, acceptable, expected, { maxEditDistance: 1, similarityMin: 0.25 });
            // 2) ON_TOPIC / VAGUE / OFF_TOPIC con detectTopicDeviation
            const deviation = detectTopicDeviation(text, act.step, objText);

            if (!text || (deviation === 'OFF_TOPIC' && openMatched.length === 0) || (tooShort && attempts < 1 && openMatched.length === 0)) {
              // Rama OPEN insuficiente: usar modelo y actualizar contadores/acciones para permitir escalamiento
              const aspectsFallback = coursePolicies?.hints?.templates?.open?.fallbackAspects || [];
              const contentForHint = rubric.aspects || aspectsFallback;
              const lastActionMap = state.lastActionByAskCode || (state.lastActionByAskCode = {});
              const hintsMap = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
              const attemptsSoFarOpen = state.attemptsByAskCode?.[stepCode] || 0;

              try {
                const recent = await getRecentHistory(sessionKey, 4);
                if (attemptsSoFarOpen >= 2) {
                  // Escalar a micro‚Äëexplicaci√≥n + re‚Äëpregunta (no avanzar)
                  const explain = await runDocenteLLM({
                    language: 'es',
                    action: 'explain',
                    stepType: 'ASK',
                    objective: objText,
                    contentBody: contentForHint,
                    recentHistory: recent
                  });
                  message = explain.message || '';
                  followUp = q;
                } else {
                  // Pista + micro‚Äëpregunta con LLM (usando se√±ales si existen)
                  const llmHint = await runDocenteLLM({
                    language: 'es',
                    action: 'hint',
                    stepType: 'ASK',
                    questionText: q,
                    userAnswer: text,
                    matched: openMatched,
                    missing: (openMissing && openMissing.length ? openMissing.slice(0,2) : (contentForHint || []).slice(0,2)),
                    objective: objText,
                    contentBody: contentForHint,
                    hintWordLimit: Number((coursePolicies?.hints?.wordLimits || [16])[0] || 16),
                    allowQuestions: true,
                    recentHistory: recent
                  } as any);
                  message = llmHint.message || '';
                  followUp = llmHint.followUp || '';
                }
              } catch {
                message = '';
                followUp = q;
              }

              // Actualizar contadores y √∫ltima acci√≥n
              state.attemptsByAskCode[stepCode] = attemptsSoFarOpen + 1;
              hintsMap[stepCode] = (hintsMap[stepCode] || 0) + 1;
              lastActionMap[stepCode] = 'hint';

              state.justAskedFollowUp = Boolean(followUp);
              state.lastFollowUpText = followUp;
              pendingInput = '';
              break;
            }

            // 3) Conversaci√≥n con evaluaci√≥n ligera para abiertas: aceptar si hay se√±ales suficientes; si no, retroalimentar y re‚Äëpreguntar
            {
              const acceptOpen = (openMatched.length >= 1) || (words.length >= minWords && attempts >= 1);
              if (acceptOpen) {
                cls = { kind: 'ACCEPT', reason: 'OPEN_OK', matched: openMatched, missing: openMissing };
                vague = false;
              } else {
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const fb = await runDocenteLLM({
                    language: 'es',
                    action: 'feedback',
                    stepType: 'ASK',
                    questionText: q,
                    userAnswer: text,
                    matched: openMatched,
                    missing: openMissing,
                    objective: objText,
                    contentBody: expected,
                    hintWordLimit: Number((coursePolicies?.feedback?.maxSentences ?? 2)),
                    allowQuestions: coursePolicies?.feedback?.allowQuestions !== false,
                    recentHistory: recent
                  });
                  message = fb.message || '';
                } catch { message = ''; }
                followUp = q; // re‚Äëpreguntar la misma abierta para mantener la conversaci√≥n centrada
                // Actualizar contadores y √∫ltima acci√≥n para permitir escalamiento
                state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
                const lastActionMap = state.lastActionByAskCode || (state.lastActionByAskCode = {});
                lastActionMap[stepCode] = 'reask';
                state.justAskedFollowUp = Boolean(followUp);
                state.lastFollowUpText = followUp;
                pendingInput = '';
                break;
              }
            }

            // 4) Aceptar reflexi√≥n abierta por defecto
            cls = { kind: 'ACCEPT', reason: 'OPEN_OK', matched: [], missing: [] };
            vague = false;
          } else {
            // Evaluaci√≥n h√≠brida: vaguedad ‚Üí r√°pido ‚Üí sem√°ntica (embeddings bajo demanda)
            const hybrid = await evaluateHybrid(
              pendingInput,
              acceptable,
              expected,
              policy,
              {
                fuzzy: { maxEditDistance: 1, similarityMin: 0.25 },
                semThresh: 0.48,
                semBestThresh: 0.40,
                maxHints: Number(coursePolicies?.hints?.maxHints ?? 2),
                vague: {
                  stopwords: coursePolicies?.language?.stopwords || [],
                  minUsefulTokens: coursePolicies?.vague?.minUsefulTokens,
                  maxStopwordRatio: coursePolicies?.vague?.maxStopwordRatio,
                  echoOverlap: coursePolicies?.vague?.echoOverlap,
                  repeatSimilarity: coursePolicies?.vague?.repeatSimilarity,
                }
              },
              { lastAnswer: state.lastAnswerByAskCode?.[stepCode], hintsUsed }
            );
            cls = { kind: hybrid.kind, matched: hybrid.matched, missing: hybrid.missing };
            vague = hybrid.reason === 'VAGUE';
            
            // Manejar casos VAGUE/REFOCUS con pista + micro‚Äëpregunta generada por LLM
            if (hybrid.reason === 'VAGUE' || cls.kind === 'REFOCUS') {
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const llmHint = await runDocenteLLM({
                  language: 'es',
                  action: 'hint',
                  stepType: 'ASK',
                  questionText: q,
                  userAnswer: pendingInput,
                  matched: hybrid.matched,
                  missing: hybrid.missing,
                  objective: objText,
                  contentBody: expected,
                  hintWordLimit: Number((coursePolicies?.hints?.wordLimits || [16])[0] || 16),
                  allowQuestions: true,
                  recentHistory: recent
                } as any);
                message = llmHint.message || '';
                followUp = llmHint.followUp || '';
              } catch {
                message = '';
                followUp = q;
              }
              // NO avanzar
              state.justAskedFollowUp = Boolean(followUp);
              state.lastFollowUpText = followUp;
              pendingInput = '';
              break;
            }
          }
          
          // Endurecer aceptaci√≥n en SALUDO/CONEXI√ìN (evitar falsos ACCEPT)
          const isSaludoConexion = ['SALUDO','CONEXION'].includes(momentKind);
          const isMeta = String(qtype).includes('abierta') || isSaludoConexion;
          
          // Aceptaci√≥n en metacognitivas: permitir avance con 1 se√±al v√°lida
          if (isMeta && cls.kind === 'ACCEPT') {
            const matchedCount = (cls.matched || []).length;
            const strongEnough = matchedCount >= 1;
            if (!strongEnough) {
              (cls as any).kind = 'HINT';
            }
          }
          
          // En metacognitiva (Saludo) NO aceptar respuestas DONT_KNOW/VAGUE ni por longitud.
          // La aceptaci√≥n debe basarse en se√±ales reales del objetivo/expected o acceptable.
          // Feedback determinista usando util reutilizable
          if (!vague && cls.kind === 'ACCEPT') {
            let fb = '';
            try {
              const fbCfg: any = (coursePolicies as any)?.feedback || {};
              const recent = await getRecentHistory(sessionKey, 4);
              const deterministic = mkFb(
                { kind: cls.kind, matched: cls.matched, missing: cls.missing },
                { attempts, hintsUsed, coursePolicies }
              );
              const llm = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: fbCfg.allowQuestions !== false, kind: 'ACCEPT' as any, recentHistory: recent });
              
              // Aplicar la misma l√≥gica de priorizaci√≥n LLM
              const showDeterministic = fbCfg.showDeterministic !== false; // default: true
              const llmHasContent = llm.message && llm.message.trim().length > 30;
              
              if (showDeterministic && !llmHasContent) {
                fb = deterministic || '';
              } else {
                fb = llm.message || '';  // Siempre priorizar LLM
              }
            } catch {}
            
            // ‚úÖ Marcar cumplimiento de la ASK actual
            state.answeredAskCodes = Array.isArray(state.answeredAskCodes) ? state.answeredAskCodes : [];
            const code = act.step.data?.code || stepCode;
            if (!state.answeredAskCodes.includes(code)) {
              state.answeredAskCodes.push(code);
            }
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            
            // Protecci√≥n de cumplimiento: verificar que la ASK actual est√© respondida antes de avanzar
            const currentStepCode = act.step.code || stepCode;
            const isAnswered = Array.isArray(state.answeredAskCodes) && state.answeredAskCodes.includes(currentStepCode);

            if (!isAnswered && act.step.type === 'ASK') {
              // No avanzar si la ASK actual no est√° respondida (excepto SALUDO/CONEXI√ìN)
              const mk = mapMomentKind(state.plan?.moments?.[act.step.momentIndex]?.title);
              const policyAllowsForce = ['SALUDO', 'CONEXION'].includes(mk);

              if (!policyAllowsForce) {
                // Re-preguntar la ASK actual
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'reask', stepCode };
                pendingInput = '';
                break;
              }
            }
            
            // Avanzar al siguiente paso en orden secuencial (no saltar ASKs)
            state = next(state);
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            
            // Componer salida seg√∫n el tipo de paso siguiente
            let nextMsg = '';
            const nextStep = currentStep(state);
            
            // Debug: verificar qu√© paso es el siguiente
            if (process.env.ENGINE_DEBUG === 'true') {
              console.log('[AVANCE_ACCEPT]', { 
                nextStepType: nextStep?.type, 
                nextStepCode: nextStep?.code,
                nextStepText: nextStep?.data?.text?.slice(0, 50),
                momentIndex: nextStep?.momentIndex,
                stepIndex: nextStep?.stepIndex
              });
            }
            
            if (nextStep?.type === 'NARRATION' || nextStep?.type === 'CONTENT') {
              // Blindaje anti-repetici√≥n: verificar si ya se mostr√≥ este contenido
              const shownMap = state.shownByStepIndex || (state.shownByStepIndex = {});
              const stepKey = `${nextStep.momentIndex}-${nextStep.stepIndex}`;
              
              if (!(shownMap as any)[stepKey]) {
                // Si NO se ha mostrado, ejecutarlo y marcar como mostrado
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const explain = await runDocenteLLM({ 
                    language: 'es', 
                    action: 'explain', 
                    stepType: nextStep.type, 
                    narrationText: nextStep.data?.text || '',
                    contentBody: nextStep.data?.body || [],
                    caseText: (nextStep.data as any)?.case || '',
                    objective: String(nextStep.data?.objective || state.plan?.meta?.lesson_name || ''),
                    recentHistory: recent 
                  });
                  // Blindaje: solo marcar como mostrado si hay contenido real
                  if ((explain.message || '').trim()) {
                    nextMsg = explain.message!;
                    (shownMap as any)[stepKey] = true; // marca solo si hubo contenido
                  } else {
                    nextMsg = '';
                    // NO marcar shownMap si est√° vac√≠o
                  }
                  
                  // Debug: confirmar que se ejecut√≥ la narrativa
                  if (process.env.ENGINE_DEBUG === 'true') {
                    console.log('[NARRATIVA_EJECUTADA]', { 
                      stepKey, 
                      nextMsgLength: nextMsg.length,
                      nextMsgPreview: nextMsg.slice(0, 100)
                    });
                  }
                } catch (error) { 
                  nextMsg = '';
                  if (process.env.ENGINE_DEBUG === 'true') {
                    console.log('[NARRATIVA_ERROR]', { stepKey, error: String(error) });
                  }
                }
              } else {
                // Debug: confirmar que ya se mostr√≥
                if (process.env.ENGINE_DEBUG === 'true') {
                  console.log('[NARRATIVA_YA_MOSTRADA]', { stepKey });
                }
              }
              // Avanzar al siguiente paso despu√©s de la narrativa (se haya mostrado o no)
              state = next(state);
              SESSIONS.set(sessionKey, state);
              try { await getSessionStore().set(sessionKey, state); } catch {}
            }
            
            // Si hay una pregunta siguiente, ponerla como followUp
            const nextAskStep = currentStep(state);
            if (nextAskStep?.type === 'ASK') {
              followUp = nextAskStep.data?.question || '';
              state.justAskedFollowUp = Boolean(followUp);
              dbg = { ...(dbg || {}), messageType: 'ask', nextAction: 'ask' };
            }
            
            SESSIONS.set(sessionKey, state);
            try { await getSessionStore().set(sessionKey, state); } catch {}
            message = [fb, nextMsg].filter(Boolean).join('\n\n');
            
            // Debug: verificar la composici√≥n final del mensaje
            if (process.env.ENGINE_DEBUG === 'true') {
              console.log('[MENSAJE_FINAL]', { 
                fbLength: fb.length,
                nextMsgLength: nextMsg.length,
                messageLength: message.length,
                messagePreview: message.slice(0, 200),
                hasNarrativa: nextMsg.length > 0
              });
            }
            dbg = { ...(dbg || {}), kind: 'ACCEPT', feedbackKind: 'ACCEPT', matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], stepCode };
					pendingInput = '';
            break;
				}
          // Contabilizar respuesta previa y contadores separados para 'no s√©'
          state.lastAnswerByAskCode![stepCode] = pendingInput;
          const noSeMap = state.noSeCountByAskCode || (state.noSeCountByAskCode = {});
          // Detecci√≥n real de "no s√©" / evasivas - M√ÅS PERMISIVO
          const isNo = /^\s*(no\s*(lo\s*)?s[e√©]|no\s*est[o√≥]y?\s*seguro|no\s*s[e√©]\s*bien)\s*$/i.test(pendingInput);
          if (isNo) {
            noSeMap[stepCode] = (noSeMap[stepCode] || 0) + 1;
            // Si es "no s√©", adem√°s de noSeCount, cuenta intento pedag√≥gico
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          } else {
            state.attemptsByAskCode[stepCode] = (state.attemptsByAskCode[stepCode] || 0) + 1;
          }
          const vagueCfg = coursePolicies?.vague || {};
          if (vague || cls.kind === 'PARTIAL' || cls.kind === 'HINT' || isNo || cls.reason === 'MAX_HINTS' || cls.reason === 'SEM_LOW') {
            // Pol√≠tica de reintentos por pregunta (loop control)
            const lastActionMap = state.lastActionByAskCode || (state.lastActionByAskCode = {});
            const hintsMap = state.hintsByAskCode || (state.hintsByAskCode = {} as any);
            const attempts = state.attemptsByAskCode[stepCode] || 0;
            const currentHints = hintsMap[stepCode] || 0;
            const lastAction = (lastActionMap[stepCode] as any) || 'ask';
            
            // Actualizar contadores
            if (cls.kind === 'HINT' || vague || isNo) {
              hintsMap[stepCode] = (currentHints || 0) + 1;   // <‚Äî SIEMPRE suma
              lastActionMap[stepCode] = 'hint';
            }
            
            // Detectar si el estudiante est√° haciendo una pregunta
            if (isStudentAskingQuestion(pendingInput)) {
              // Ruta clarify: insertar micro-explicaci√≥n del objetivo actual
              try {
                const recent = await getRecentHistory(sessionKey, 4);
                const clarify = await runDocenteLLM({ 
                  language: 'es', 
                  action: 'explain', 
                  stepType: 'ASK', 
                  objective: String(act.step.data.objective || ''),
                  contentBody: [String(act.step.data.objective || '')],
                  recentHistory: recent 
                });
                message = clarify.message || '';
                // Re-preguntar la ASK actual con reformulaci√≥n
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                dbg = { kind: 'CLARIFY', matched: [], missing: [], nextAction: 'clarify', stepCode };
              } catch {
                message = '';
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
              }
              pendingInput = '';
              break;
            }
            
            // Pol√≠tica de reintentos: 0‚ÜíHINT_1, 1‚ÜíHINT_2, ‚â•2‚Üíopciones o transici√≥n pedag√≥gica
            let fb = '';
            if (attempts < 2 && (cls.kind === 'HINT' || vague || isNo)) {
              // Mensaje alentador
              try {
                const fbCfg: any = (coursePolicies as any)?.feedback || {};
                const recent = await getRecentHistory(sessionKey, 4);
                const deterministic = mkFb(
                  { kind: cls.kind, matched: cls.matched, missing: cls.missing },
                  { attempts, hintsUsed, coursePolicies }
                );
                const llmFb = await runDocenteLLM({ language: 'es', action: 'feedback', stepType: 'ASK', questionText: q, userAnswer: pendingInput, matched: cls.matched, missing: cls.missing, objective: String(act.step.data.objective || ''), contentBody: expected, hintWordLimit: Number(fbCfg.maxSentences ?? 3), allowQuestions: fbCfg.allowQuestions !== false, kind: cls.kind as any, recentHistory: recent });
                
                // Siempre priorizar LLM, solo usar determinista como √∫ltimo recurso
                const showDeterministic = fbCfg.showDeterministic !== false; // default: true
                const llmHasContent = llmFb.message && llmFb.message.trim().length > 30;
                
                // Solo usar determinista si:
                // 1. Est√° habilitado
                // 2. El LLM no proporcion√≥ contenido
                if (showDeterministic && !llmHasContent) {
                  fb = deterministic || '';
                } else {
                  fb = llmFb.message || '';  // Siempre priorizar LLM
                }
              } catch {}
              // HINT generado por LLM (objetivo-primero)
              {
                const objText = String(act.step.data.objective || state.plan?.meta?.lesson_name || '');
                const expectedArr = Array.isArray(expected) ? expected : [];
                const missingArr = Array.isArray(cls.missing) ? cls.missing : [];
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const llmHint = await runDocenteLLM({
                    language: 'es',
                    action: 'hint',
                    stepType: 'ASK',
                    questionText: q,
                    userAnswer: pendingInput,
                    matched: cls.matched,
                    missing: missingArr,
                    objective: objText,
                    contentBody: expectedArr,
                    hintWordLimit: Number((coursePolicies?.hints?.wordLimits || [16])[0] || 16),
                    allowQuestions: true,
                    recentHistory: recent
                  } as any);
                  message = llmHint.message || '';
                  followUp = llmHint.followUp || '';
                } catch {
                  message = '';
                  followUp = q;
                }

                // Anti‚Äërepetici√≥n de follow‚Äëup
                if (state.lastFollowUpText && state.lastFollowUpText === followUp) {
                  const reask = makeReaskMessage({
                    questionText: q,
                    objective: objText,
                    expected: expectedArr,
                    answerType: (act.step.data as any)?.answer_type || 'list',
                    coursePolicies
                  });
                  followUp = reask;
                }
                state.justAskedFollowUp = Boolean(followUp);
                state.lastFollowUpText = followUp;
                hintsMap[stepCode] = (hintsMap[stepCode] || 0) + 1;   // solo si emitimos hint
              }
              dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              pendingInput = '';
              break;
            }
            // Transici√≥n pedag√≥gica: usar decideNextAction en lugar de DEFAULT_ACCEPT agresivo
            {
              const momentKind = state.plan?.moments?.[act.step.momentIndex]?.code || '';
              const lastAction = state.lastActionByAskCode?.[stepCode] || '';
              const noSeCount = state.noSeCountByAskCode?.[stepCode] || 0;
              
              const nextAction = decideNextAction({
                lastAction,
                noSeCount,
                attempts,
                momentKind
              });
              
              if (nextAction === 'force_advance') {
                // Solo avance forzado en SALUDO/CONEXI√ìN
                const nextAskIdx = getNextAskInSameCycle(state, state.stepIdx);
                if (typeof nextAskIdx === 'number') {
                  state = advanceTo(state, nextAskIdx);
                  followUp = (currentStep(state) as any)?.data?.question || '';
                  state.justAskedFollowUp = Boolean(followUp);
                }
                // Mensaje de cierre suave
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const bridge = await runDocenteLLM({ language: 'es', action: 'advance', stepType: 'ASK', objective: String(act.step.data.objective || ''), recentHistory: recent });
                  message = [fb, bridge.message].filter(Boolean).join('\n\n');
                } catch {}
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'force_advance', stepCode };
              } else if (nextAction === 'options') {
                // Presentar opciones basadas en expected
                const items = (expected || []).filter(Boolean).slice(0, 5);
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const llm = await runDocenteLLM({
                    language: 'es',
                    action: 'ask_options',
                    stepType: 'ASK',
                    questionText: q,
                    optionItems: items,
                    recentHistory: recent
                  } as any);
                  message = llm.message || '';
                  followUp = '';
                  state.justAskedFollowUp = false;
                } catch {
                  message = q;
                }
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'options';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'options', stepCode };
              } else if (nextAction === 'reask') {
                // Reformular pregunta breve (ask_simple)
                const reask = makeReaskMessage({
                  questionText: q,
                  objective: String(act.step.data.objective || ''),
                  expected,
                  answerType: (act.step.data as any)?.answer_type || 'list',
                  coursePolicies
                });
                message = reask;
                followUp = '';
                state.justAskedFollowUp = false;
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'reask';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'reask', stepCode };
              } else if (nextAction === 'hint') {
                // Emitir una pista adicional breve
                const objText = String(act.step.data.objective || state.plan?.meta?.lesson_name || '');
                const expectedArr = Array.isArray(expected) ? expected : [];
                const missingArr = Array.isArray(cls.missing) ? cls.missing : [];
                const hintMsg = makeHintMessage({
                  questionText: q,
                  objective: objText,
                  expected: expectedArr,
                  missing: missingArr,
                  answerType: (act.step.data as any)?.answer_type || 'list',
                  hintsUsed: (state.hintsByAskCode?.[stepCode] || 0),
                  attempts,
                  coursePolicies
                });
                message = hintMsg;
                followUp = '';
                state.justAskedFollowUp = false;
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'hint';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'hint', stepCode };
              } else if (nextAction === 'explain') {
                // Micro‚Äëexplicaci√≥n del objetivo actual
                try {
                  const recent = await getRecentHistory(sessionKey, 4);
                  const explain = await runDocenteLLM({
                    language: 'es',
                    action: 'explain',
                    stepType: 'ASK',
                    objective: String(act.step.data.objective || ''),
                    contentBody: expected,
                    recentHistory: recent
                  });
                  message = explain.message || '';
                } catch { message = ''; }
                followUp = q;
                state.justAskedFollowUp = Boolean(followUp);
                // Actualizar √∫ltima acci√≥n
                lastActionMap[stepCode] = 'explain';
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction: 'explain', stepCode };
              } else {
                // Transici√≥n pedag√≥gica por defecto
                dbg = { kind: cls.kind, matched: cls.matched?.slice(0,3) || [], missing: cls.missing?.slice(0,3) || [], nextAction, stepCode };
              }
              pendingInput = '';
              break;
            }
          }
			}
			if (act.kind === 'end') {
				try {
					const recent = await getRecentHistory(sessionKey, 4);
					const llm = await runDocenteLLM({ language: 'es', action: 'end', stepType: 'END', objective: String(state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm.message || '';
				} catch {
					message = '';
				}
				break;
			}
		}
		// Garant√≠a final: siempre devolver un mensaje del docente usando datos del plan
		if (!skipGuarantee && (!message || !String(message).trim()) && (!followUp || !String(followUp).trim())) {
			try {
				const st = currentStep(state);
				const recent = await getRecentHistory(sessionKey, 4);
				if (st?.type === 'ASK') {
					const q2 = (st as any).data?.question || '';
					const llm2 = await runDocenteLLM({ language: 'es', action: 'ask', stepType: 'ASK', questionText: q2, objective: String(((st as any).data?.objective) || state.plan?.meta?.lesson_name || ''), recentHistory: recent });
					message = llm2.message || q2;
					followUp = llm2.followUp || followUp;
				} else {
					const d: any = (st as any)?.data || {};
					const parts = [d.title, ...(d.body || []), d.text, ...(d.items || [])].filter(Boolean) as string[];
					const bodyArr: string[] = parts as string[];
					const llm2 = await runDocenteLLM({ language: 'es', action: 'explain', stepType: (st?.type as any) || 'CONTENT', momentTitle: state.plan?.moments[(st as any)?.momentIndex || 0]?.title, objective: state.plan?.meta?.lesson_name || '', contentBody: bodyArr, recentHistory: recent });
					message = llm2.message || bodyArr.join(' ‚Äî ');
				}
			} catch {
				const st: any = currentStep(state);
				const q2 = st?.data?.question || '';
				message = q2 || message || '';
			}
		}
		// Persist history (JSONL estilo MongoDB-like)
		try {
			await appendHistory(sessionKey, {
				planUrl: state.planUrl,
				stepIdx: state.stepIdx,
				momentIdx: state.momentIdx,
				message,
				followUp
			});
		} catch {}

		// Debug logging opcional
		try {
			const debugOn = process.env.ENGINE_DEBUG === 'true' || process.env.NEXT_PUBLIC_ENGINE_DEBUG === 'true' || Boolean((coursePolicies as any)?.debug?.logs);
			if (debugOn) {
				const st = currentStep(state);
				const messageType = (dbg && dbg.messageType) || (dbg && dbg.nextAction) || (st?.type === 'ASK' ? 'ask' : String(st?.type || '').toLowerCase());
				const payload = {
					tag: 'engine.turn',
					sessionKey,
					momentTitle: state.plan?.moments?.[st?.momentIndex || 0]?.title,
					momentKind: mapMomentKind(state.plan?.moments?.[st?.momentIndex || 0]?.title),
					stepType: st?.type,
					stepIdx: state.stepIdx,
					stepCode: (st as any)?.code || dbg?.stepCode,
					classification: dbg?.kind,
					feedbackKind: dbg?.feedbackKind || dbg?.kind,
					messageType,
					matched: dbg?.matched,
					missing: dbg?.missing,
					nextAction: dbg?.nextAction,
					messageChars: (message || '').length,
					followUpChars: (followUp || '').length,
					hasFollowUp: Boolean(followUp && String(followUp).trim()),
					userInputLen: (pendingInput || '').length,
					thresholds: { jaccardMin: 0.25, semThresh: 0.48, semBest: 0.40 },
					hintsUsed: Number(state.hintsByAskCode?.[(st as any)?.code || dbg?.stepCode] || 0)
				};
				// eslint-disable-next-line no-console
				console.debug(JSON.stringify(payload));
			}
		} catch {}
		// Obtener m√©tricas de presupuesto si est√° disponible
		const budgetMetrics = state.budgetCentsLeft !== undefined ? {
			budgetCentsLeft: state.budgetCentsLeft,
			escalationsUsed: state.escalationsUsed || 0,
			adaptiveMode: state.adaptiveMode || false
		} : null;

		return NextResponse.json({ 
			message, 
			followUp, 
			state: { stepIdx: state.stepIdx, done: state.done },
			budgetMetrics 
		});
	} catch (err: any) {
		return NextResponse.json({ error: String(err?.message || err) }, { status: 500 });
	}
}


```
=== EOF: app\api\engine\turn\route.ts

===  app\api\audio\transcribe\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';

export async function POST(request: NextRequest) {
  try {
    const form = await request.formData();
    const file = form.get('audio') as File | null;
    const language = (form.get('language') as string) || 'es';

    if (!file) return NextResponse.json({ error: 'Archivo de audio requerido (field: audio)' }, { status: 400 });

    const ai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const aiFile = new File([buffer], file.name || 'audio.webm', { type: file.type || 'audio/webm' });

    const result = await ai.audio.transcriptions.create({ file: aiFile, model: 'whisper-1', language });
    return NextResponse.json({ text: (result as any)?.text || '' });
  } catch (error) {
    console.error('Transcribe error:', error);
    return NextResponse.json({ error: 'Error transcribiendo audio' }, { status: 500 });
  }
}


```
=== EOF: app\api\audio\transcribe\route.ts

