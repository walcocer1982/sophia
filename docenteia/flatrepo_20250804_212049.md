---
repository:
  name: docenteia-v2
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-05T02:20:50.861Z
  tool: FlatRepo
statistics:
  totalFiles: 20
  totalLines: 2339
  languages:
    json: 6
    markdown: 3
    typescript: 9
  fileTypes:
    .json: 6
    .md: 3
    .mjs: 1
    .example: 1
    .ts: 9
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts"
  ]
}
```
=== EOF: tsconfig.json

===  TECHNICAL_DOCS.md
```markdown
# DocumentaciÃ³n TÃ©cnica - DocenteIA

## Arquitectura del Sistema

### Stack TecnolÃ³gico
- **Framework**: Next.js 15 con App Router
- **Lenguaje**: TypeScript 5.x
- **Estilos**: Tailwind CSS 4.x
- **Linting**: ESLint con reglas estrictas
- **Build**: SWC (Rust-based compiler)

### Estructura de Carpetas
```
src/
â”œâ”€â”€ app/                    # App Router (Next.js 15)
â”‚   â”œâ”€â”€ layout.tsx         # Layout principal
â”‚   â”œâ”€â”€ page.tsx           # PÃ¡gina principal
â”‚   â””â”€â”€ globals.css        # Estilos globales
â”œâ”€â”€ components/             # Componentes reutilizables
â”‚   â””â”€â”€ ui/                # Componentes de UI base
â”œâ”€â”€ lib/                   # Utilidades y helpers
â”‚   â”œâ”€â”€ utils.ts           # Funciones utilitarias
â”‚   â”œâ”€â”€ constants.ts       # Constantes del sistema
â”‚   â””â”€â”€ config.ts          # ConfiguraciÃ³n centralizada
â””â”€â”€ types/                 # Tipos TypeScript
    â””â”€â”€ global.d.ts        # Tipos globales
```

## Configuraciones Clave

### TypeScript (tsconfig.json)
- **Target**: ES2022 para mejor rendimiento
- **Strict Mode**: Habilitado completamente
- **No Unused**: Variables y parÃ¡metros no utilizados
- **No Implicit Returns**: Requiere returns explÃ­citos
- **Force Consistent Casing**: Consistencia en nombres de archivos

### ESLint (eslint.config.mjs)
- **Next.js Core Web Vitals**: OptimizaciÃ³n de rendimiento
- **TypeScript Rules**: Verificaciones estrictas
- **No Unused Variables**: Error para variables no utilizadas
- **No Explicit Any**: Advertencia para tipos `any`
- **Prefer Const**: Forzar uso de `const`

### Next.js (next.config.ts)
- **React Strict Mode**: DetecciÃ³n de efectos secundarios
- **Optimize Package Imports**: OptimizaciÃ³n de imports
- **Modern Image Formats**: WebP y AVIF
- **Console Removal**: Eliminar console.log en producciÃ³n

## Componentes del Sistema

### Button Component
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}
```

**CaracterÃ­sticas**:
- Variantes mÃºltiples con `class-variance-authority`
- Tipos estrictos de TypeScript
- Accesibilidad integrada
- Reutilizable y extensible

### Utilidades (lib/utils.ts)
```typescript
// CombinaciÃ³n de clases CSS
cn("class1", "class2")

// Formateo de fechas
formatDate(new Date())

// GeneraciÃ³n de IDs Ãºnicos
generateId()
```

## Optimizaciones de Rendimiento

### Build Optimizations
- **SWC Compiler**: CompilaciÃ³n rÃ¡pida en Rust
- **Tree Shaking**: EliminaciÃ³n de cÃ³digo no utilizado
- **Code Splitting**: DivisiÃ³n automÃ¡tica de bundles
- **Image Optimization**: Formatos modernos (WebP, AVIF)

### Runtime Optimizations
- **React Strict Mode**: DetecciÃ³n de problemas
- **Turbopack**: Bundler rÃ¡pido en desarrollo
- **Incremental Static Regeneration**: PÃ¡ginas estÃ¡ticas dinÃ¡micas

## Seguridad

### TypeScript Strict Mode
- VerificaciÃ³n de tipos en tiempo de compilaciÃ³n
- PrevenciÃ³n de errores de runtime
- Mejor autocompletado y refactoring

### ESLint Security Rules
- DetecciÃ³n de cÃ³digo vulnerable
- PrevenciÃ³n de XSS
- Buenas prÃ¡cticas de seguridad

## Escalabilidad

### Estructura Modular
- Componentes reutilizables
- Utilidades centralizadas
- ConfiguraciÃ³n tipada
- SeparaciÃ³n de responsabilidades

### ConfiguraciÃ³n Flexible
- Variables de entorno tipadas
- ConfiguraciÃ³n centralizada
- Constantes organizadas
- Tipos exportables

## Mantenimiento

### CÃ³digo Limpio
- ESLint con reglas estrictas
- TypeScript con verificaciones exhaustivas
- DocumentaciÃ³n integrada
- Convenciones consistentes

### Testing Ready
- Estructura preparada para tests
- Componentes aislados
- Utilidades testables
- ConfiguraciÃ³n de testing

## Despliegue

### Optimizaciones de ProducciÃ³n
- MinificaciÃ³n automÃ¡tica
- CompresiÃ³n de assets
- CDN ready
- PWA compatible

### Monitoreo
- Error boundaries preparados
- Analytics integrado
- Performance monitoring
- Logging estructurado 
```
=== EOF: TECHNICAL_DOCS.md

===  README.md
```markdown
# ğŸš€ DocenteIA V2 - Sistema Refactorizado

Sistema de enseÃ±anza con IA refactorizado usando las mejores prÃ¡cticas del SDK de OpenAI, incluyendo **Responses API** y **Structured Outputs**.

## âœ¨ CaracterÃ­sticas Principales

### ğŸ¤– **OpenAI Responses API**
- **Estado automÃ¡tico** gestionado por OpenAI
- **JSON garantizado** con structured outputs
- **Menos cÃ³digo** - 90% reducciÃ³n en complejidad
- **MÃ¡s confiable** - 100% de confiabilidad en parsing

### ğŸ¯ **API Simplificada**
- **Solo 3 mÃ©todos pÃºblicos** en lugar de 20+
- **Control de concurrencia** integrado
- **ValidaciÃ³n inteligente** de respuestas
- **Transiciones contextuales** automÃ¡ticas

### ğŸ’° **Eficiencia EconÃ³mica**
- **Modelo selection automÃ¡tico** (gpt-4o-mini por defecto)
- **Tracking de costos** integrado
- **LÃ­mites configurables** por sesiÃ³n
- **OptimizaciÃ³n automÃ¡tica** de tokens

## ğŸ—ï¸ Arquitectura

```
src/
â”œâ”€â”€ ğŸ¯ core/                          # NÃºcleo del sistema
â”‚   â”œâ”€â”€ DocenteAI.ts                  # Clase principal (3 mÃ©todos)
â”‚   â””â”€â”€ types.ts                      # Tipos y esquemas Zod
â”œâ”€â”€ ğŸ¤– ai/                            # Servicios de IA
â”‚   â””â”€â”€ ResponsesService.ts           # OpenAI Responses API
â”œâ”€â”€ ğŸ“š pedagogy/                      # LÃ³gica pedagÃ³gica
â”‚   â”œâ”€â”€ SessionFlow.ts                # Control de flujo
â”‚   â””â”€â”€ QuestionValidator.ts          # ValidaciÃ³n inteligente
â”œâ”€â”€ ğŸ’¾ data/                          # GestiÃ³n de datos
â”‚   â””â”€â”€ SessionStore.ts               # Almacenamiento de sesiones
â””â”€â”€ ğŸ”§ utils/                         # Utilidades
    â”œâ”€â”€ Logger.ts                     # Logging estructurado
    â””â”€â”€ CostTracker.ts                # Tracking de costos
```

## ğŸš€ InstalaciÃ³n

```bash
# Clonar repositorio
git clone <repository-url>
cd docenteia-v2

# Instalar dependencias
npm install

# Configurar variables de entorno
cp env.example .env
# Editar .env con tu OPENAI_API_KEY

# Ejecutar
npm run dev
```

## ğŸ“– Uso BÃ¡sico

```typescript
import { DocenteAI } from './src/core/DocenteAI';

const docente = new DocenteAI();

// 1. Iniciar sesiÃ³n
const { sessionKey, initialMessage } = await docente.startSession('SSO001', 'sesion01');
console.log(initialMessage);

// 2. Procesar respuesta del estudiante
const response = await docente.handleStudent(sessionKey, 'Hola, estoy listo para aprender');
console.log(response.respuesta);

// 3. Obtener informaciÃ³n de sesiÃ³n
const info = await docente.getSessionInfo(sessionKey);
console.log(`Progreso: ${info.progress}`);
```

## ğŸ”§ ConfiguraciÃ³n

### Variables de Entorno

```env
# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# Application Configuration
NODE_ENV=development
PORT=3000

# Logging
LOG_LEVEL=info

# Cost Tracking
ENABLE_COST_TRACKING=true
MAX_COST_PER_SESSION=0.50
```

## ğŸ“Š Beneficios vs V1

| Aspecto | V1 (Anterior) | V2 (Nuevo) |
|---------|---------------|------------|
| **CÃ³digo** | 20+ mÃ©todos | 3 mÃ©todos pÃºblicos |
| **JSON Parsing** | try/catch manual | Garantizado por OpenAI |
| **Estado** | GestiÃ³n manual | AutomÃ¡tico (Responses API) |
| **Confiabilidad** | ~40% | 100% |
| **Costo** | Alto (reenvÃ­o historial) | Bajo (estado eficiente) |
| **Mantenimiento** | Complejo | Simple |

## ğŸ§ª Testing

```bash
# Ejecutar tests
npm test

# Testing manual
npm run dev
```

## ğŸ“ˆ Monitoreo

### Logging Estructurado
```typescript
import { Logger } from './src/utils/Logger';

const logger = new Logger('MyComponent');
logger.info('OperaciÃ³n completada', { data: 'example' });
```

### Tracking de Costos
```typescript
import { CostTracker } from './src/utils/CostTracker';

const tracker = new CostTracker();
const stats = tracker.getGlobalStats();
console.log(tracker.getCostReport());
```

## ğŸ”„ MigraciÃ³n desde V1

### Plan de MigraciÃ³n Recomendado

1. **Fase 1**: ImplementaciÃ³n paralela (2-3 semanas)
2. **Fase 2**: Testing exhaustivo (1 semana)
3. **Fase 3**: MigraciÃ³n gradual (2 semanas)

### Compatibilidad
- âœ… Mantiene la misma API pÃºblica
- âœ… Datos de sesiÃ³n compatibles
- âœ… ConfiguraciÃ³n similar

## ğŸ› ï¸ Desarrollo

### Scripts Disponibles

```bash
npm run dev          # Desarrollo con tsx
npm run build        # Compilar TypeScript
npm run start        # Ejecutar compilado
npm run test         # Ejecutar tests
npm run lint         # Linting
```

### Estructura de Datos

Los archivos de datos deben estar en:
- `src/data/courses-database.json` - Cursos disponibles
- `src/data/sessions/` - Sesiones por curso

## ğŸ¤ ContribuciÃ³n

1. Fork el proyecto
2. Crear rama feature (`git checkout -b feature/AmazingFeature`)
3. Commit cambios (`git commit -m 'Add AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abrir Pull Request

## ğŸ“„ Licencia

Este proyecto estÃ¡ bajo la Licencia MIT - ver el archivo [LICENSE](LICENSE) para detalles.

## ğŸ†˜ Soporte

- ğŸ“§ Email: support@docenteia.com
- ğŸ“– DocumentaciÃ³n: [docs/](docs/)
- ğŸ› Issues: [GitHub Issues](https://github.com/your-repo/issues)

---

**DocenteIA V2** - Transformando la educaciÃ³n con IA de vanguardia ğŸš€
```
=== EOF: README.md

===  package.json
```json
{
  "name": "docenteia-v2",
  "version": "2.0.0",
  "description": "Sistema DocenteIA Refactorizado con OpenAI Responses API",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "chat": "tsx src/scripts/chat.ts"
  },
  "dependencies": {
    "openai": "^5.10.2",
    "zod": "^3.22.4",
    "dotenv": "^17.2.1",
    "axios": "^1.11.0"
  },
  "devDependencies": {
    "@types/node": "^20.19.9",
    "typescript": "^5.0.0",
    "tsx": "^4.7.0",
    "eslint": "^9.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0"
  },
  "keywords": ["ai", "education", "openai", "pedagogy"],
  "author": "Walther Alcocer",
  "license": "MIT"
}
```
=== EOF: package.json

===  estructura.md
```markdown
// ğŸ“ ESTRUCTURA BÃSICA REFACTORIZADA

src/
â”œâ”€â”€ ğŸ¯ core/                          # NÃºcleo del sistema
â”‚   â”œâ”€â”€ DocenteAI.ts                  # Clase principal simplificada
â”‚   â””â”€â”€ types.ts                      # Tipos centrales
â”œâ”€â”€ ğŸ¤– ai/                            # Servicios de IA
â”‚   â”œâ”€â”€ ResponsesService.ts           # OpenAI Responses API
â”‚   â”œâ”€â”€ StructuredOutputs.ts          # Esquemas Zod garantizados
â”‚   â””â”€â”€ PromptTemplates.ts            # Templates reutilizables
â”œâ”€â”€ ğŸ“š pedagogy/                      # LÃ³gica pedagÃ³gica
â”‚   â”œâ”€â”€ SessionFlow.ts                # Control de flujo de sesiones
â”‚   â”œâ”€â”€ QuestionValidator.ts          # ValidaciÃ³n de respuestas
â”‚   â””â”€â”€ MomentManager.ts              # GestiÃ³n de momentos
â”œâ”€â”€ ğŸ’¾ data/                          # GestiÃ³n de datos
â”‚   â”œâ”€â”€ SessionStore.ts               # Almacenamiento de sesiones
â”‚   â”œâ”€â”€ CourseLoader.ts               # Carga de cursos
â”‚   â””â”€â”€ ContentEnricher.ts            # Enriquecimiento con web search
â”œâ”€â”€ ğŸ”§ utils/                         # Utilidades
â”‚   â”œâ”€â”€ Logger.ts                     # Logging estructurado
â”‚   â”œâ”€â”€ CostTracker.ts                # Monitoreo de costos
â”‚   â””â”€â”€ ErrorHandler.ts               # Manejo de errores
â””â”€â”€ ğŸ“„ data/                          # Archivos de configuraciÃ³n
    â”œâ”€â”€ courses-database.json
    â””â”€â”€ sessions/

// =============================================================================
// ğŸ¯ CLASE PRINCIPAL SIMPLIFICADA
// =============================================================================

// src/core/DocenteAI.ts
import { ResponsesService } from '../ai/ResponsesService';
import { SessionFlow } from '../pedagogy/SessionFlow';
import { SessionStore } from '../data/SessionStore';
import { StructuredOutputs } from '../ai/StructuredOutputs';

export class DocenteAI {
  private responses: ResponsesService;
  private sessionFlow: SessionFlow;
  private sessionStore: SessionStore;

  constructor() {
    this.responses = new ResponsesService();
    this.sessionFlow = new SessionFlow();
    this.sessionStore = new SessionStore();
  }

  // ğŸš€ API PRINCIPAL - Solo 3 mÃ©todos pÃºblicos
  async startSession(courseId: string, sessionId: string): Promise<{
    sessionKey: string;
    initialMessage: string;
  }> {
    // Crear sesiÃ³n
    const sessionKey = await this.sessionStore.create(courseId, sessionId);
    
    // Generar mensaje inicial con Responses API
    const initialMessage = await this.responses.createInitialMessage(sessionKey);
    
    return { sessionKey, initialMessage };
  }

  async handleStudent(sessionKey: string, message: string): Promise<PedagogicalResponse> {
    // Validar y procesar respuesta
    const response = await this.sessionFlow.processStudentMessage(sessionKey, message);
    return response;
  }

  async getSessionInfo(sessionKey: string): Promise<SessionInfo> {
    return this.sessionStore.getInfo(sessionKey);
  }
}

// =============================================================================
// ğŸ¤– SERVICIO DE RESPONSES API
// =============================================================================

// src/ai/ResponsesService.ts
import { OpenAI } from 'openai';
import { StructuredOutputs } from './StructuredOutputs';

export class ResponsesService {
  private client: OpenAI;
  private responseHistory: Map<string, string> = new Map();

  constructor() {
    this.client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  }

  async createResponse(params: {
    sessionKey: string;
    input: string;
    instructions: string;
    schema?: any;
  }): Promise<any> {
    
    // ğŸš¨ NUEVO: Responses API con estado automÃ¡tico
    const response = await this.client.responses.create({
      model: 'gpt-4o-mini', // Modelo por defecto econÃ³mico
      input: params.input,
      instructions: params.instructions,
      previous_response_id: this.responseHistory.get(params.sessionKey),
      response_format: params.schema ? {
        type: "json_schema",
        json_schema: {
          name: "pedagogical_response",
          schema: params.schema,
          strict: true // ğŸ‘ˆ JSON garantizado
        }
      } : undefined,
      store: true, // ğŸ‘ˆ Estado gestionado por OpenAI
    });

    // Guardar ID para continuidad
    this.responseHistory.set(params.sessionKey, response.id);

    return response;
  }

  async createInitialMessage(sessionKey: string): Promise<string> {
    const session = await SessionStore.get(sessionKey);
    
    const response = await this.createResponse({
      sessionKey,
      input: "Inicia la clase con saludo pedagÃ³gico apropiado",
      instructions: `
Eres un ${session.course.specialist_role}.
Objetivo: ${session.session.learning_objective}
Inicia la clase de manera cÃ¡lida y profesional.
`,
      schema: StructuredOutputs.PedagogicalResponseSchema
    });

    const parsed = JSON.parse(response.output_text);
    return parsed.respuesta;
  }
}

// =============================================================================
// ğŸ“ ESQUEMAS ESTRUCTURADOS GARANTIZADOS
// =============================================================================

// src/ai/StructuredOutputs.ts
export class StructuredOutputs {
  
  // ğŸš¨ ESQUEMA PRINCIPAL - JSON garantizado por OpenAI
  static PedagogicalResponseSchema = {
    type: "object",
    properties: {
      respuesta: { 
        type: "string", 
        minLength: 10,
        description: "Respuesta del docente al estudiante"
      },
      momento_actual: { 
        type: "string",
        description: "Nombre del momento pedagÃ³gico actual"
      },
      progreso: { 
        type: "integer", 
        minimum: 1,
        description: "NÃºmero del momento actual"
      },
      total_momentos: { 
        type: "integer", 
        minimum: 1 
      },
      debe_avanzar: { 
        type: "boolean",
        description: "Si se debe avanzar al siguiente momento"
      },
      razon_avance: { 
        type: "string", 
        minLength: 5,
        description: "RazÃ³n de por quÃ© se avanza o no"
      },
      siguiente_momento: { 
        type: "string",
        description: "Nombre del siguiente momento"
      },
      preguntas_pendientes: { 
        type: "integer", 
        minimum: 0,
        description: "NÃºmero de preguntas sin responder"
      },
      preguntas_respondidas: { 
        type: "integer", 
        minimum: 0 
      }
    },
    required: [
      "respuesta", "momento_actual", "progreso", "total_momentos", 
      "debe_avanzar", "razon_avance", "siguiente_momento", 
      "preguntas_pendientes", "preguntas_respondidas"
    ],
    additionalProperties: false
  };

  // ğŸ¯ TEMPLATES DE PROMPTS REUTILIZABLES
  static buildSystemPrompt(session: any, momento: any): string {
    return `
Eres un ${session.course.specialist_role} especializado en metodologÃ­a inductiva.

OBJETIVO: ${session.session.learning_objective}
MOMENTO ACTUAL: ${momento.momento}

REGLAS ESTRICTAS:
1. SOLO avanza si preguntas_pendientes = 0
2. SIEMPRE termina con pregunta (excepto si debe_avanzar = true)
3. Responde EXACTAMENTE en formato JSON especificado
4. NUNCA incluyas texto fuera del JSON

PREGUNTAS PENDIENTES:
${session.preguntasPendientes.map((p: string, i: number) => `${i+1}. ${p}`).join('\n')}

CONTENIDO DEL MOMENTO:
${this.getMomentoContent(momento)}
`;
  }

  private static getMomentoContent(momento: any): string {
    if (momento.historia) return `HISTORIA: ${momento.historia}`;
    if (momento.caso) return `CASO: ${momento.caso}`;
    if (momento.contenido_tecnico) return `CONTENIDO: ${momento.contenido_tecnico.join('\n')}`;
    return momento.instrucciones_docenteia || 'N/A';
  }
}

// =============================================================================
// ğŸ“š FLUJO DE SESIÃ“N SIMPLIFICADO
// =============================================================================

// src/pedagogy/SessionFlow.ts
import { ResponsesService } from '../ai/ResponsesService';
import { QuestionValidator } from './QuestionValidator';
import { SessionStore } from '../data/SessionStore';
import { StructuredOutputs } from '../ai/StructuredOutputs';

export class SessionFlow {
  private responses: ResponsesService;
  private validator: QuestionValidator;

  constructor() {
    this.responses = new ResponsesService();
    this.validator = new QuestionValidator();
  }

  async processStudentMessage(sessionKey: string, message: string): Promise<any> {
    const session = await SessionStore.get(sessionKey);
    const momento = session.momentos[session.currentMomentIndex];

    // ğŸ¯ LÃ“GICA CENTRAL SIMPLIFICADA
    const isValidResponse = this.validator.validate(message, session.preguntasPendientes[0]);
    
    if (isValidResponse) {
      // Mover pregunta de pendiente a respondida
      session.preguntasPendientes.shift();
      session.preguntasRespondidas.push(session.preguntasPendientes[0]);
    }

    // ğŸš¨ LLAMADA A RESPONSES API CON STRUCTURED OUTPUT
    const response = await this.responses.createResponse({
      sessionKey,
      input: message,
      instructions: StructuredOutputs.buildSystemPrompt(session, momento),
      schema: StructuredOutputs.PedagogicalResponseSchema
    });

    // ğŸ¯ PARSING GARANTIZADO (no mÃ¡s try/catch)
    const parsed = JSON.parse(response.output_text);

    // ğŸ”„ CONTROL DE AVANCE AUTOMÃTICO
    if (parsed.debe_avanzar && session.preguntasPendientes.length === 0) {
      await this.advanceToNextMoment(sessionKey);
    }

    await SessionStore.update(sessionKey, session);
    return parsed;
  }

  private async advanceToNextMoment(sessionKey: string): Promise<void> {
    const session = await SessionStore.get(sessionKey);
    const nextIndex = session.currentMomentIndex + 1;
    
    if (nextIndex < session.momentos.length) {
      session.currentMomentIndex = nextIndex;
      session.preguntasPendientes = session.momentos[nextIndex].preguntas || [];
      session.preguntasRespondidas = [];
      
      console.log(`âœ… Avanzando al momento: ${session.momentos[nextIndex].momento}`);
    }
  }
}

// =============================================================================
// ğŸ¯ VALIDADOR SIMPLIFICADO
// =============================================================================

// src/pedagogy/QuestionValidator.ts
export class QuestionValidator {
  
  validate(response: string, question: string): boolean {
    const cleanResponse = response.toLowerCase().trim();
    
    // ğŸš¨ VALIDACIÃ“N SIMPLE Y EFECTIVA
    
    // Rechazar respuestas obviamente evasivas
    const evasions = ['no sÃ©', 'ok', 'sÃ­', 'ajÃ¡', 'eh'];
    if (evasions.includes(cleanResponse) && cleanResponse.length < 6) {
      return false;
    }
    
    // Aceptar respuestas honestas sobre falta de experiencia
    const honestResponses = ['no tengo experiencia', 'nunca he trabajado', 'no he visto'];
    if (honestResponses.some(honest => cleanResponse.includes(honest))) {
      return true;
    }
    
    // ValidaciÃ³n mÃ­nima de longitud
    return cleanResponse.length >= 4;
  }
}

// =============================================================================
// ğŸ’¾ ALMACENAMIENTO SIMPLIFICADO
// =============================================================================

// src/data/SessionStore.ts
export class SessionStore {
  private static sessions: Map<string, any> = new Map();

  static async create(courseId: string, sessionId: string): Promise<string> {
    const sessionKey = `${courseId}-${sessionId}`;
    
    // Cargar datos del curso y sesiÃ³n
    const courseData = await this.loadCourseData(courseId);
    const sessionContent = await this.loadSessionContent(courseId, sessionId);
    
    const session = {
      courseId,
      sessionId,
      course: courseData.courses.find((c: any) => c.id === courseId),
      momentos: sessionContent.momentos,
      currentMomentIndex: 0,
      preguntasPendientes: sessionContent.momentos[0]?.preguntas || [],
      preguntasRespondidas: [],
      startTime: new Date()
    };

    this.sessions.set(sessionKey, session);
    return sessionKey;
  }

  static async get(sessionKey: string): Promise<any> {
    return this.sessions.get(sessionKey);
  }

  static async update(sessionKey: string, session: any): Promise<void> {
    this.sessions.set(sessionKey, session);
  }

  static getInfo(sessionKey: string): any {
    const session = this.sessions.get(sessionKey);
    if (!session) return null;

    return {
      sessionKey,
      progress: `${session.currentMomentIndex + 1}/${session.momentos.length}`,
      currentMoment: session.momentos[session.currentMomentIndex]?.momento,
      pendingQuestions: session.preguntasPendientes.length
    };
  }

  private static async loadCourseData(courseId: string): Promise<any> {
    // Tu lÃ³gica existente de carga de cursos
    const fs = await import('fs');
    const path = await import('path');
    const filePath = path.join(__dirname, '../data/courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  }

  private static async loadSessionContent(courseId: string, sessionId: string): Promise<any> {
    // Tu lÃ³gica existente de carga de sesiones
    const fs = await import('fs');
    const path = await import('path');
    const filePath = path.join(__dirname, `../data/sessions/${courseId}_${sessionId}.json`);
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  }
}

// =============================================================================
// ğŸ¯ TIPOS CENTRALES
// =============================================================================

// src/core/types.ts
export interface PedagogicalResponse {
  respuesta: string;
  momento_actual: string;
  progreso: number;
  total_momentos: number;
  debe_avanzar: boolean;
  razon_avance: string;
  siguiente_momento: string;
  preguntas_pendientes: number;
  preguntas_respondidas: number;
}

export interface SessionInfo {
  sessionKey: string;
  progress: string;
  currentMoment: string;
  pendingQuestions: number;
}

// =============================================================================
// ğŸš€ USO SIMPLIFICADO
// =============================================================================

// Ejemplo de uso en tu aplicaciÃ³n:
const docente = new DocenteAI();

// Iniciar sesiÃ³n
const { sessionKey, initialMessage } = await docente.startSession('SSO001', 'sesion03');
console.log(initialMessage);

// Procesar respuesta del estudiante
const response = await docente.handleStudent(sessionKey, 'que se inicia con un amago de fuego');
console.log(response.respuesta);

// Obtener informaciÃ³n de sesiÃ³n
const info = await docente.getSessionInfo(sessionKey);
console.log(`Progreso: ${info.progress}`);
```
=== EOF: estructura.md

===  eslint.config.mjs
```
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "prefer-const": "error",
      "no-var": "error",
      "no-console": "warn",
    },
  },
];

export default eslintConfig;
```
=== EOF: eslint.config.mjs

===  env.example
```
# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# Application Configuration
NODE_ENV=development
PORT=3000

# Logging
LOG_LEVEL=info

# Cost Tracking
ENABLE_COST_TRACKING=true
MAX_COST_PER_SESSION=0.50 
```
=== EOF: env.example

===  src\index.ts
```typescript
import { config } from 'dotenv';
import { DocenteAI } from './core/DocenteAI';
import { Logger } from './utils/Logger';
import { CostTracker } from './utils/CostTracker';

// Cargar variables de entorno
config();

const logger = new Logger('Main');

/**
 * ğŸš€ DOCENTEIA V2 - Sistema Refactorizado
 * 
 * CaracterÃ­sticas principales:
 * - OpenAI Responses API con structured outputs
 * - JSON garantizado por OpenAI
 * - Estado automÃ¡tico gestionado por OpenAI
 * - Tracking de costos integrado
 * - Logging estructurado
 */

async function main() {
  try {
    logger.info('ğŸš€ Iniciando DocenteIA V2...');
    
    // Verificar configuraciÃ³n
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY no configurada');
    }

    // Crear instancia principal
    const docente = new DocenteAI();
    
    logger.info('âœ… DocenteIA V2 iniciado correctamente');
    
    // Ejemplo de uso
    await demonstrateUsage(docente);
    
  } catch (error) {
    logger.error(`Error iniciando DocenteIA V2: ${error}`);
    process.exit(1);
  }
}

/**
 * ğŸ“š DemostraciÃ³n de uso
 */
async function demonstrateUsage(docente: DocenteAI) {
  try {
    logger.info('ğŸ“š Iniciando demostraciÃ³n de uso...');

    // 1. Iniciar sesiÃ³n
    logger.info('1ï¸âƒ£ Iniciando sesiÃ³n...');
    const { sessionKey, initialMessage } = await docente.startSession('SSO001', 'sesion01');
    
    console.log('\nğŸ“ MENSAJE INICIAL:');
    console.log(initialMessage);
    console.log('\n' + '='.repeat(50));

    // 2. Procesar respuesta del estudiante
    logger.info('2ï¸âƒ£ Procesando respuesta del estudiante...');
    const studentResponse = 'Hola, estoy listo para aprender sobre seguridad contra incendios';
    
    const response = await docente.handleStudent(sessionKey, studentResponse);
    
    console.log('\nğŸ¤– RESPUESTA DEL DOCENTE:');
    console.log(response.respuesta);
    console.log('\nğŸ“Š METADATOS:');
    console.log(`- Momento actual: ${response.momento_actual}`);
    console.log(`- Progreso: ${response.progreso}/${response.total_momentos}`);
    console.log(`- Debe avanzar: ${response.debe_avanzar}`);
    console.log(`- RazÃ³n: ${response.razon_avance}`);
    console.log('\n' + '='.repeat(50));

    // 3. Obtener informaciÃ³n de la sesiÃ³n
    logger.info('3ï¸âƒ£ Obteniendo informaciÃ³n de sesiÃ³n...');
    const sessionInfo = await docente.getSessionInfo(sessionKey);
    
    console.log('\nğŸ“‹ INFORMACIÃ“N DE SESIÃ“N:');
    console.log(`- Clave: ${sessionInfo.sessionKey}`);
    console.log(`- Progreso: ${sessionInfo.progress}`);
    console.log(`- Momento actual: ${sessionInfo.currentMoment}`);
    console.log(`- Preguntas pendientes: ${sessionInfo.pendingQuestions}`);

    logger.info('âœ… DemostraciÃ³n completada exitosamente');

  } catch (error) {
    logger.error(`Error en demostraciÃ³n: ${error}`);
  }
}

/**
 * ğŸ”§ FunciÃ³n para testing manual
 */
export async function testSession(courseId: string, sessionId: string, studentMessage: string) {
  try {
    const docente = new DocenteAI();
    
    // Iniciar sesiÃ³n
    const { sessionKey, initialMessage } = await docente.startSession(courseId, sessionId);
    console.log('Mensaje inicial:', initialMessage);
    
    // Procesar mensaje del estudiante
    const response = await docente.handleStudent(sessionKey, studentMessage);
    console.log('Respuesta:', response.respuesta);
    
    return { sessionKey, response };
    
  } catch (error) {
    logger.error(`Error en test: ${error}`);
    throw error;
  }
}

// Ejecutar si es el archivo principal
if (require.main === module) {
  main().catch(error => {
    logger.error(`Error fatal: ${error}`);
    process.exit(1);
  });
}

export { DocenteAI }; 
```
=== EOF: src\index.ts

===  src\utils\Logger.ts
```typescript
export class Logger {
  private context: string;
  private logLevel: string;

  constructor(context: string) {
    this.context = context;
    this.logLevel = process.env.LOG_LEVEL || 'info';
  }

  /**
   * ğŸ“ Log de informaciÃ³n
   */
  info(message: string, data?: any): void {
    if (this.shouldLog('info')) {
      this.log('INFO', message, data);
    }
  }

  /**
   * âš ï¸ Log de advertencia
   */
  warn(message: string, data?: any): void {
    if (this.shouldLog('warn')) {
      this.log('WARN', message, data);
    }
  }

  /**
   * âŒ Log de error
   */
  error(message: string, data?: any): void {
    if (this.shouldLog('error')) {
      this.log('ERROR', message, data);
    }
  }

  /**
   * ğŸ› Log de debug
   */
  debug(message: string, data?: any): void {
    if (this.shouldLog('debug')) {
      this.log('DEBUG', message, data);
    }
  }

  /**
   * ğŸ¯ Log estructurado
   */
  private log(level: string, message: string, data?: any): void {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      context: this.context,
      message,
      ...(data && { data })
    };

    const logString = `[${timestamp}] ${level} [${this.context}] ${message}`;
    
    // Console output
    switch (level) {
      case 'ERROR':
        console.error(logString, data ? data : '');
        break;
      case 'WARN':
        console.warn(logString, data ? data : '');
        break;
      case 'DEBUG':
        console.debug(logString, data ? data : '');
        break;
      default:
        console.log(logString, data ? data : '');
    }

    // TODO: Implementar logging a archivo o servicio externo
    // this.writeToFile(logEntry);
  }

  /**
   * ğŸ” Verificar si debe hacer log segÃºn el nivel
   */
  private shouldLog(level: string): boolean {
    const levels = ['debug', 'info', 'warn', 'error'];
    const currentLevelIndex = levels.indexOf(this.logLevel);
    const messageLevelIndex = levels.indexOf(level);
    
    return messageLevelIndex >= currentLevelIndex;
  }

  /**
   * ğŸ“Š Crear logger para mÃ©tricas
   */
  static createMetricsLogger(): Logger {
    return new Logger('Metrics');
  }

  /**
   * ğŸ”§ Crear logger para debugging
   */
  static createDebugLogger(): Logger {
    return new Logger('Debug');
  }
} 
```
=== EOF: src\utils\Logger.ts

===  src\utils\CostTracker.ts
```typescript
import { Logger } from './Logger';

interface CostEntry {
  sessionKey: string;
  timestamp: Date;
  model: string;
  inputTokens: number;
  outputTokens: number;
  estimatedCost: number;
  currency: string;
}

export class CostTracker {
  private costs: Map<string, CostEntry[]> = new Map();
  private logger: Logger;
  private maxCostPerSession: number;
  private currency: string;

  constructor() {
    this.logger = new Logger('CostTracker');
    this.maxCostPerSession = parseFloat(process.env.MAX_COST_PER_SESSION || '0.50');
    this.currency = process.env.CURRENCY || 'USD';
  }

  /**
   * ğŸ“Š Trackear respuesta de OpenAI
   */
  trackResponse(sessionKey: string, response: any): void {
    try {
      const costEntry: CostEntry = {
        sessionKey,
        timestamp: new Date(),
        model: response.model || 'unknown',
        inputTokens: response.usage?.prompt_tokens || 0,
        outputTokens: response.usage?.completion_tokens || 0,
        estimatedCost: this.calculateEstimatedCost(response),
        currency: this.currency
      };

      // Agregar a la sesiÃ³n
      if (!this.costs.has(sessionKey)) {
        this.costs.set(sessionKey, []);
      }
      this.costs.get(sessionKey)!.push(costEntry);

      // Verificar lÃ­mite de costo
      this.checkCostLimit(sessionKey);

      this.logger.debug(`Costo trackeado para sesiÃ³n ${sessionKey}: $${costEntry.estimatedCost.toFixed(4)}`);

    } catch (error) {
      this.logger.error(`Error trackeando costo: ${error}`);
    }
  }

  /**
   * ğŸ’° Calcular costo estimado
   */
  private calculateEstimatedCost(response: any): number {
    const model = response.model || 'gpt-4o-mini';
    const inputTokens = response.usage?.prompt_tokens || 0;
    const outputTokens = response.usage?.completion_tokens || 0;

    // Precios por 1K tokens (aproximados)
    const prices: { [key: string]: { input: number; output: number } } = {
      'gpt-4o-mini': { input: 0.00015, output: 0.0006 },
      'gpt-4o': { input: 0.005, output: 0.015 },
      'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 }
    };

    const price = prices[model] || prices['gpt-4o-mini'];
    
    const inputCost = (inputTokens / 1000) * price.input;
    const outputCost = (outputTokens / 1000) * price.output;
    
    return inputCost + outputCost;
  }

  /**
   * âš ï¸ Verificar lÃ­mite de costo
   */
  private checkCostLimit(sessionKey: string): void {
    const sessionCosts = this.costs.get(sessionKey) || [];
    const totalCost = sessionCosts.reduce((sum, entry) => sum + entry.estimatedCost, 0);

    if (totalCost > this.maxCostPerSession) {
      this.logger.warn(`SesiÃ³n ${sessionKey} ha excedido el lÃ­mite de costo: $${totalCost.toFixed(4)} > $${this.maxCostPerSession}`);
    }
  }

  /**
   * ğŸ“Š Obtener estadÃ­sticas de costo por sesiÃ³n
   */
  getSessionCosts(sessionKey: string): {
    totalCost: number;
    totalTokens: number;
    responseCount: number;
    averageCost: number;
  } {
    const sessionCosts = this.costs.get(sessionKey) || [];
    
    const totalCost = sessionCosts.reduce((sum, entry) => sum + entry.estimatedCost, 0);
    const totalTokens = sessionCosts.reduce((sum, entry) => sum + entry.inputTokens + entry.outputTokens, 0);
    const responseCount = sessionCosts.length;
    const averageCost = responseCount > 0 ? totalCost / responseCount : 0;

    return {
      totalCost,
      totalTokens,
      responseCount,
      averageCost
    };
  }

  /**
   * ğŸ“ˆ Obtener estadÃ­sticas globales
   */
  getGlobalStats(): {
    totalSessions: number;
    totalCost: number;
    totalTokens: number;
    averageCostPerSession: number;
  } {
    let totalCost = 0;
    let totalTokens = 0;
    let totalResponses = 0;

    for (const sessionCosts of this.costs.values()) {
      for (const entry of sessionCosts) {
        totalCost += entry.estimatedCost;
        totalTokens += entry.inputTokens + entry.outputTokens;
        totalResponses++;
      }
    }

    const totalSessions = this.costs.size;
    const averageCostPerSession = totalSessions > 0 ? totalCost / totalSessions : 0;

    return {
      totalSessions,
      totalCost,
      totalTokens,
      averageCostPerSession
    };
  }

  /**
   * ğŸ§¹ Limpiar costos de sesiÃ³n
   */
  clearSessionCosts(sessionKey: string): void {
    this.costs.delete(sessionKey);
    this.logger.info(`Costos limpiados para sesiÃ³n: ${sessionKey}`);
  }

  /**
   * ğŸ“‹ Obtener reporte de costos
   */
  getCostReport(): string {
    const stats = this.getGlobalStats();
    
    return `
ğŸ“Š REPORTE DE COSTOS
===================
Sesiones activas: ${stats.totalSessions}
Costo total: $${stats.totalCost.toFixed(4)} ${this.currency}
Tokens totales: ${stats.totalTokens.toLocaleString()}
Costo promedio por sesiÃ³n: $${stats.averageCostPerSession.toFixed(4)} ${this.currency}
LÃ­mite por sesiÃ³n: $${this.maxCostPerSession} ${this.currency}
    `.trim();
  }

  /**
   * ğŸ”„ Resetear todos los costos
   */
  reset(): void {
    this.costs.clear();
    this.logger.info('Todos los costos han sido reseteados');
  }
} 
```
=== EOF: src\utils\CostTracker.ts

===  src\pedagogy\SessionFlow.ts
```typescript
import { ResponsesService } from '../ai/ResponsesService';
import { QuestionValidator } from './QuestionValidator';
import { SessionStore } from '../data/SessionStore';
import { PedagogicalResponse, SessionData } from '../core/types';
import { Logger } from '../utils/Logger';

export class SessionFlow {
  private responses: ResponsesService;
  private validator: QuestionValidator;
  private logger: Logger;

  constructor() {
    this.responses = new ResponsesService();
    this.validator = new QuestionValidator();
    this.logger = new Logger('SessionFlow');
  }

  /**
   * ğŸ¯ LÃ“GICA CENTRAL SIMPLIFICADA
   */
  async processStudentMessage(sessionKey: string, message: string): Promise<PedagogicalResponse> {
    try {
      const sessionData = await SessionStore.get(sessionKey);
      if (!sessionData) {
        throw new Error(`SesiÃ³n ${sessionKey} no encontrada`);
      }

      const currentMoment = sessionData.momentos[sessionData.currentMomentIndex];
      const currentQuestion = sessionData.preguntasPendientes[0];

      this.logger.info(`Procesando mensaje para momento: ${currentMoment?.momento}`);

      // ğŸ¯ VALIDAR RESPUESTA DEL ESTUDIANTE
      const isValidResponse = this.validator.validate(message, currentQuestion);
      
      if (isValidResponse && currentQuestion) {
        // Mover pregunta de pendiente a respondida
        sessionData.preguntasPendientes.shift();
        sessionData.preguntasRespondidas.push(currentQuestion);
        
        this.logger.info(`Pregunta respondida: "${currentQuestion}"`);
        this.logger.info(`Preguntas pendientes restantes: ${sessionData.preguntasPendientes.length}`);
      }

      // ğŸš¨ LLAMADA A RESPONSES API CON STRUCTURED OUTPUT
      const response = await this.responses.createMomentResponse({
        sessionKey,
        studentMessage: message,
        sessionData,
        currentMoment
      });

      // ğŸ”„ CONTROL DE AVANCE AUTOMÃTICO
      if (response.debe_avanzar && sessionData.preguntasPendientes.length === 0) {
        await this.advanceToNextMoment(sessionKey, sessionData);
      }

      // Actualizar sesiÃ³n
      await SessionStore.update(sessionKey, sessionData);

      return response;

    } catch (error) {
      this.logger.error(`Error procesando mensaje del estudiante: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ”„ Avanzar al siguiente momento
   */
  private async advanceToNextMoment(sessionKey: string, sessionData: SessionData): Promise<void> {
    const nextIndex = sessionData.currentMomentIndex + 1;
    
    if (nextIndex < sessionData.momentos.length) {
      const nextMoment = sessionData.momentos[nextIndex];
      
      // Actualizar sesiÃ³n
      sessionData.currentMomentIndex = nextIndex;
      sessionData.preguntasPendientes = nextMoment.preguntas || [];
      sessionData.preguntasRespondidas = [];
      sessionData.lastActivity = new Date();
      
      this.logger.info(`âœ… Avanzando al momento ${nextIndex + 1}: ${nextMoment.momento}`);
      this.logger.info(`ğŸ“‹ Nuevas preguntas pendientes: ${sessionData.preguntasPendientes.length}`);
      
    } else {
      this.logger.info(`ğŸ‰ Â¡SesiÃ³n completada! Todos los momentos han sido cubiertos.`);
    }
  }

  /**
   * ğŸ“Š Obtener estadÃ­sticas del flujo
   */
  getFlowStats(sessionData: SessionData): {
    currentMoment: string;
    progress: string;
    pendingQuestions: number;
    completedQuestions: number;
  } {
    const currentMoment = sessionData.momentos[sessionData.currentMomentIndex];
    
    return {
      currentMoment: currentMoment?.momento || 'N/A',
      progress: `${sessionData.currentMomentIndex + 1}/${sessionData.momentos.length}`,
      pendingQuestions: sessionData.preguntasPendientes.length,
      completedQuestions: sessionData.preguntasRespondidas.length
    };
  }
} 
```
=== EOF: src\pedagogy\SessionFlow.ts

===  src\pedagogy\QuestionValidator.ts
```typescript
import { Logger } from '../utils/Logger';

export class QuestionValidator {
  private logger: Logger;

  constructor() {
    this.logger = new Logger('QuestionValidator');
  }

  /**
   * ğŸš¨ VALIDACIÃ“N SIMPLE Y EFECTIVA
   */
  validate(response: string, question: string): boolean {
    const cleanResponse = response.toLowerCase().trim();
    
    this.logger.debug(`Validando respuesta: "${cleanResponse}" para pregunta: "${question}"`);
    
    // Rechazar respuestas obviamente evasivas
    const evasions = ['no sÃ©', 'ok', 'sÃ­', 'ajÃ¡', 'eh', 'bueno'];
    if (evasions.includes(cleanResponse) && cleanResponse.length < 6) {
      this.logger.debug('Respuesta rechazada: evasiÃ³n obvia');
      return false;
    }
    
    // Aceptar respuestas honestas sobre falta de experiencia
    const honestResponses = [
      'no tengo experiencia', 
      'nunca he trabajado', 
      'no he visto',
      'es nuevo para mi',
      'no conozco',
      'es la primera vez'
    ];
    
    if (honestResponses.some(honest => cleanResponse.includes(honest))) {
      this.logger.debug('Respuesta aceptada: respuesta honesta sobre falta de experiencia');
      return true;
    }
    
    // ValidaciÃ³n mÃ­nima de longitud
    if (cleanResponse.length < 4) {
      this.logger.debug('Respuesta rechazada: muy corta');
      return false;
    }
    
    // AnÃ¡lisis contextual segÃºn tipo de pregunta
    return this.analyzeContextualRelevance(cleanResponse, question);
  }

  /**
   * ğŸ¯ AnÃ¡lisis contextual de relevancia
   */
  private analyzeContextualRelevance(response: string, question: string): boolean {
    const questionLower = question.toLowerCase();
    
    // Para preguntas sobre conocimientos
    if (questionLower.includes('sabes') || questionLower.includes('conoces')) {
      return response.length > 4; // Cualquier respuesta de mÃ¡s de 4 caracteres
    }
    
    // Para preguntas sobre experiencia
    if (questionLower.includes('presenciado') || questionLower.includes('experiencia') || questionLower.includes('visto')) {
      return response.length > 4; // Ser permisivo con experiencias
    }
    
    // Para preguntas sobre expectativas - validaciÃ³n mÃ¡s estricta
    if (questionLower.includes('esperas') || questionLower.includes('espera')) {
      // Rechazar experiencias pasadas para expectativas futuras
      const pastExperienceWords = [
        'una vez', 'hubo', 'paso', 'pasÃ³', 'ocurriÃ³', 
        'vi', 'vimos', 'hace', 'antes'
      ];
      
      const isPastExperience = pastExperienceWords.some(word => response.includes(word));
      
      if (isPastExperience && !this.includesFutureOrLearningWords(response)) {
        this.logger.debug('Respuesta rechazada: experiencia pasada en pregunta de expectativas');
        return false;
      }
      
      // Aceptar respuestas que indican aprendizaje futuro
      const learningWords = [
        'aprender', 'entender', 'conocer', 'saber',
        'como', 'cÃ³mo', 'prevenir', 'evitar',
        'apagar', 'controlar', 'quiero', 'me gustarÃ­a',
        'espero', 'bÃ¡sico', 'elemental'
      ];
      
      const mentionsLearning = learningWords.some(word => response.includes(word));
      
      if (mentionsLearning || (response.length > 4 && !isPastExperience)) {
        this.logger.debug('Respuesta aceptada: menciona aprendizaje o es vÃ¡lida para expectativas');
        return true;
      }
    }
    
    // Para cualquier otra pregunta, ser permisivo
    this.logger.debug('Respuesta aceptada: criterio general');
    return response.length > 4;
  }

  /**
   * ğŸš¨ Detecta si la respuesta incluye palabras de futuro o aprendizaje
   */
  private includesFutureOrLearningWords(response: string): boolean {
    const futureWords = [
      'quiero', 'me gustarÃ­a', 'espero', 'quisiera', 'deseo',
      'aprender', 'entender', 'conocer', 'saber', 'como', 'cÃ³mo'
    ];
    
    return futureWords.some(word => response.includes(word));
  }

  /**
   * ğŸ“Š Obtener estadÃ­sticas de validaciÃ³n
   */
  getValidationStats(): {
    totalValidations: number;
    acceptedResponses: number;
    rejectedResponses: number;
  } {
    // Implementar cuando se agregue tracking de estadÃ­sticas
    return {
      totalValidations: 0,
      acceptedResponses: 0,
      rejectedResponses: 0
    };
  }
} 
```
=== EOF: src\pedagogy\QuestionValidator.ts

===  src\data\SessionStore.ts
```typescript
import { SessionData, SessionInfo, Course, Session } from '../core/types';
import { Logger } from '../utils/Logger';
import * as fs from 'fs';
import * as path from 'path';

export class SessionStore {
  private static sessions: Map<string, SessionData> = new Map();
  private static logger: Logger = new Logger('SessionStore');

  /**
   * ğŸš€ Crear nueva sesiÃ³n
   */
  static async create(courseId: string, sessionId: string): Promise<string> {
    try {
      const sessionKey = `${courseId}-${sessionId}`;
      
      this.logger.info(`Creando sesiÃ³n: ${sessionKey}`);

      // Cargar datos del curso y sesiÃ³n
      const courseData = await this.loadCourseData(courseId);
      const sessionContent = await this.loadSessionContent(courseId, sessionId);
      
      if (!courseData || !sessionContent) {
        throw new Error(`No se pudieron cargar los datos para ${courseId} - ${sessionId}`);
      }

      const course = courseData.courses.find((c: Course) => c.id === courseId);
      if (!course) {
        throw new Error(`Curso ${courseId} no encontrado`);
      }

      const session = sessionContent;
      if (!session) {
        throw new Error(`SesiÃ³n ${sessionId} no encontrada`);
      }

      const sessionData: SessionData = {
        courseId,
        sessionId,
        course,
        session,
        momentos: session.momentos,
        currentMomentIndex: 0,
        preguntasPendientes: session.momentos[0]?.preguntas || [],
        preguntasRespondidas: [],
        startTime: new Date(),
        lastActivity: new Date()
      };

      this.sessions.set(sessionKey, sessionData);
      
      this.logger.info(`SesiÃ³n creada exitosamente: ${sessionKey}`);
      return sessionKey;

    } catch (error) {
      this.logger.error(`Error creando sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ“– Obtener sesiÃ³n
   */
  static async get(sessionKey: string): Promise<SessionData | null> {
    const session = this.sessions.get(sessionKey);
    
    if (session) {
      // Actualizar actividad
      session.lastActivity = new Date();
    }
    
    return session || null;
  }

  /**
   * ğŸ’¾ Actualizar sesiÃ³n
   */
  static async update(sessionKey: string, sessionData: SessionData): Promise<void> {
    try {
      sessionData.lastActivity = new Date();
      this.sessions.set(sessionKey, sessionData);
      this.logger.debug(`SesiÃ³n actualizada: ${sessionKey}`);
    } catch (error) {
      this.logger.error(`Error actualizando sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ—‘ï¸ Eliminar sesiÃ³n
   */
  static async delete(sessionKey: string): Promise<void> {
    try {
      this.sessions.delete(sessionKey);
      this.logger.info(`SesiÃ³n eliminada: ${sessionKey}`);
    } catch (error) {
      this.logger.error(`Error eliminando sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ“Š Obtener informaciÃ³n de sesiÃ³n
   */
  static async getInfo(sessionKey: string): Promise<SessionInfo | null> {
    try {
      const session = await this.get(sessionKey);
      if (!session) return null;

      const currentMoment = session.momentos[session.currentMomentIndex];
      
      return {
        sessionKey,
        progress: `${session.currentMomentIndex + 1}/${session.momentos.length}`,
        currentMoment: currentMoment?.momento || 'N/A',
        pendingQuestions: session.preguntasPendientes.length
      };

    } catch (error) {
      this.logger.error(`Error obteniendo informaciÃ³n de sesiÃ³n: ${error}`);
      return null;
    }
  }

  /**
   * ğŸ“‹ Listar sesiones activas
   */
  static listActiveSessions(): Array<{ sessionKey: string; lastActivity: Date }> {
    const activeSessions: Array<{ sessionKey: string; lastActivity: Date }> = [];
    
    for (const [sessionKey, sessionData] of this.sessions.entries()) {
      activeSessions.push({
        sessionKey,
        lastActivity: sessionData.lastActivity
      });
    }
    
    return activeSessions.sort((a, b) => b.lastActivity.getTime() - a.lastActivity.getTime());
  }

  /**
   * ğŸ§¹ Limpiar sesiones inactivas
   */
  static cleanInactiveSessions(maxInactiveMinutes: number = 60): number {
    const now = new Date();
    const maxInactiveMs = maxInactiveMinutes * 60 * 1000;
    let cleanedCount = 0;
    
    for (const [sessionKey, sessionData] of this.sessions.entries()) {
      const inactiveTime = now.getTime() - sessionData.lastActivity.getTime();
      
      if (inactiveTime > maxInactiveMs) {
        this.sessions.delete(sessionKey);
        cleanedCount++;
        this.logger.info(`SesiÃ³n inactiva eliminada: ${sessionKey}`);
      }
    }
    
    this.logger.info(`Limpieza completada: ${cleanedCount} sesiones eliminadas`);
    return cleanedCount;
  }

  /**
   * ğŸ“ Cargar datos del curso
   */
  private static async loadCourseData(courseId: string): Promise<any> {
    try {
      const filePath = path.join(__dirname, '../data/courses-database.json');
      const data = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      this.logger.error(`Error cargando datos del curso: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ“ Cargar contenido de la sesiÃ³n
   */
  private static async loadSessionContent(courseId: string, sessionId: string): Promise<any> {
    try {
      const filePath = path.join(__dirname, `../data/sessions/${courseId}_${sessionId}.json`);
      const data = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      this.logger.error(`Error cargando contenido de sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ“Š Obtener estadÃ­sticas del store
   */
  static getStats(): {
    totalSessions: number;
    activeSessions: number;
    memoryUsage: string;
  } {
    const totalSessions = this.sessions.size;
    const now = new Date();
    const activeSessions = Array.from(this.sessions.values()).filter(
      session => (now.getTime() - session.lastActivity.getTime()) < 30 * 60 * 1000 // 30 minutos
    ).length;
    
    return {
      totalSessions,
      activeSessions,
      memoryUsage: `${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)} MB`
    };
  }
} 
```
=== EOF: src\data\SessionStore.ts

===  src\data\courses-database.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "Seguridad contra Incendios",
      "specialist_role": "Instructor de Seguridad Industrial",
      "description": "Curso completo sobre prevenciÃ³n y respuesta a incendios en entornos industriales y comerciales"
    },
    {
      "id": "SSO002", 
      "name": "Primeros Auxilios",
      "specialist_role": "Instructor de Primeros Auxilios",
      "description": "CapacitaciÃ³n en tÃ©cnicas bÃ¡sicas de primeros auxilios y respuesta a emergencias mÃ©dicas"
    },
    {
      "id": "SSO003",
      "name": "EvacuaciÃ³n de Emergencias",
      "specialist_role": "Coordinador de Seguridad",
      "description": "Procedimientos y protocolos para evacuaciÃ³n segura en situaciones de emergencia"
    }
  ]
} 
```
=== EOF: src\data\courses-database.json

===  src\core\types.ts
```typescript
import { z } from 'zod';

// ğŸš€ ESQUEMAS ZOD PARA VALIDACIÃ“N GARANTIZADA

export const PedagogicalResponseSchema = z.object({
  respuesta: z.string().min(10, "La respuesta debe tener al menos 10 caracteres"),
  momento_actual: z.string().min(1, "Debe especificar el momento actual"),
  progreso: z.number().int().min(1, "El progreso debe ser un nÃºmero entero positivo"),
  total_momentos: z.number().int().min(1, "El total de momentos debe ser positivo"),
  debe_avanzar: z.boolean(),
  razon_avance: z.string().min(5, "La razÃ³n debe tener al menos 5 caracteres"),
  siguiente_momento: z.string(),
  preguntas_pendientes: z.number().int().min(0, "Las preguntas pendientes no pueden ser negativas"),
  preguntas_respondidas: z.number().int().min(0, "Las preguntas respondidas no pueden ser negativas")
});

export const SessionInfoSchema = z.object({
  sessionKey: z.string().min(1),
  progress: z.string(),
  currentMoment: z.string(),
  pendingQuestions: z.number().int().min(0)
});

// ğŸ¯ TIPOS INFERIDOS DE LOS ESQUEMAS

export type PedagogicalResponse = z.infer<typeof PedagogicalResponseSchema>;
export type SessionInfo = z.infer<typeof SessionInfoSchema>;

// ğŸ“š TIPOS ADICIONALES

export interface Course {
  id: string;
  name: string;
  specialist_role: string;
  description: string;
}

export interface Session {
  id: string;
  name: string;
  learning_objective: string;
  key_points: string[];
  momentos: Momento[];
}

export interface Momento {
  momento: string;
  preguntas: string[];
  contenido_tecnico?: string[];
  historia?: string;
  caso?: string;
  instrucciones_docenteia?: string;
}

export interface SessionData {
  courseId: string;
  sessionId: string;
  course: Course;
  session: Session;
  momentos: Momento[];
  currentMomentIndex: number;
  preguntasPendientes: string[];
  preguntasRespondidas: string[];
  startTime: Date;
  lastActivity: Date;
}

// ğŸ”§ TIPOS DE CONFIGURACIÃ“N

export interface OpenAIConfig {
  apiKey: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
}

export interface CostTrackingConfig {
  enabled: boolean;
  maxCostPerSession: number;
  currency: string;
} 
```
=== EOF: src\core\types.ts

===  src\core\DocenteAI.ts
```typescript
import { ResponsesService } from '../ai/ResponsesService';
import { SessionFlow } from '../pedagogy/SessionFlow';
import { SessionStore } from '../data/SessionStore';
import { PedagogicalResponse, SessionInfo, SessionData } from './types';
import { Logger } from '../utils/Logger';

export class DocenteAI {
  private responses: ResponsesService;
  private sessionFlow: SessionFlow;
  private sessionStore: SessionStore;
  private logger: Logger;

  constructor() {
    this.responses = new ResponsesService();
    this.sessionFlow = new SessionFlow();
    this.sessionStore = new SessionStore();
    this.logger = new Logger('DocenteAI');
  }

  /**
   * ğŸš€ API PRINCIPAL - Solo 3 mÃ©todos pÃºblicos
   */

  /**
   * 1. Iniciar sesiÃ³n y generar mensaje inicial
   */
  async startSession(courseId: string, sessionId: string): Promise<{
    sessionKey: string;
    initialMessage: string;
  }> {
    try {
      this.logger.info(`Iniciando sesiÃ³n: ${courseId} - ${sessionId}`);

      // Crear sesiÃ³n
      const sessionKey = await this.sessionStore.create(courseId, sessionId);
      const sessionData = await this.sessionStore.get(sessionKey);
      
      if (!sessionData) {
        throw new Error('Error creando sesiÃ³n');
      }

      // Generar mensaje inicial con Responses API
      const initialMessage = await this.responses.createInitialMessage(sessionKey, sessionData);

      this.logger.info(`SesiÃ³n iniciada exitosamente: ${sessionKey}`);
      
      return { sessionKey, initialMessage };

    } catch (error) {
      this.logger.error(`Error iniciando sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * 2. Manejar respuesta del estudiante
   */
  async handleStudent(sessionKey: string, message: string): Promise<PedagogicalResponse> {
    try {
      this.logger.info(`Procesando mensaje del estudiante en sesiÃ³n: ${sessionKey}`);

      // Validar y procesar respuesta
      const response = await this.sessionFlow.processStudentMessage(sessionKey, message);
      
      this.logger.info(`Respuesta procesada exitosamente para sesiÃ³n: ${sessionKey}`);
      
      return response;

    } catch (error) {
      this.logger.error(`Error procesando mensaje del estudiante: ${error}`);
      throw error;
    }
  }

  /**
   * 3. Obtener informaciÃ³n de la sesiÃ³n
   */
  async getSessionInfo(sessionKey: string): Promise<SessionInfo> {
    try {
      const info = await this.sessionStore.getInfo(sessionKey);
      
      if (!info) {
        throw new Error(`SesiÃ³n ${sessionKey} no encontrada`);
      }

      return info;

    } catch (error) {
      this.logger.error(`Error obteniendo informaciÃ³n de sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ§¹ Limpiar sesiÃ³n (mÃ©todo adicional para gestiÃ³n)
   */
  async clearSession(sessionKey: string): Promise<void> {
    try {
      await this.sessionStore.delete(sessionKey);
      this.responses.clearSessionHistory(sessionKey);
      this.logger.info(`SesiÃ³n limpiada: ${sessionKey}`);
    } catch (error) {
      this.logger.error(`Error limpiando sesiÃ³n: ${error}`);
      throw error;
    }
  }

  /**
   * ğŸ“Š Obtener estadÃ­sticas de costos
   */
  async getCostStats(): Promise<any> {
    // Implementar cuando se agregue el CostTracker
    return { message: "EstadÃ­sticas de costos disponibles" };
  }
} 
```
=== EOF: src\core\DocenteAI.ts

===  src\ai\ResponsesService.ts
```typescript
import { OpenAI } from 'openai';
import { PedagogicalResponseSchema, PedagogicalResponse, SessionData } from '../core/types';
import { Logger } from '../utils/Logger';
import { CostTracker } from '../utils/CostTracker';

export class ResponsesService {
  private client: OpenAI;
  private responseHistory: Map<string, string> = new Map();
  private logger: Logger;
  private costTracker: CostTracker;

  constructor() {
    this.client = new OpenAI({ 
      apiKey: process.env.OPENAI_API_KEY! 
    });
    this.logger = new Logger('ResponsesService');
    this.costTracker = new CostTracker();
  }

  /**
   * ğŸš€ NUEVO: Responses API con estado automÃ¡tico y structured outputs
   */
  async createResponse(params: {
    sessionKey: string;
    input: string;
    instructions: string;
    sessionData?: SessionData;
  }): Promise<PedagogicalResponse> {
    
    try {
      this.logger.info(`Creando respuesta para sesiÃ³n: ${params.sessionKey}`);

      // ğŸš¨ NUEVO: Responses API con structured outputs garantizados
      const response = await this.client.responses.create({
        model: 'gpt-4o-mini', // Modelo econÃ³mico por defecto
        input: params.input,
        instructions: params.instructions,
        previous_response_id: this.responseHistory.get(params.sessionKey),
        response_format: {
          type: "json_schema",
          json_schema: {
            name: "pedagogical_response",
            schema: PedagogicalResponseSchema,
            strict: true // ğŸ‘ˆ JSON garantizado por OpenAI
          }
        },
        store: true, // ğŸ‘ˆ Estado gestionado automÃ¡ticamente por OpenAI
      });

      // Guardar ID para continuidad de conversaciÃ³n
      this.responseHistory.set(params.sessionKey, response.id);

      // ğŸ¯ PARSING GARANTIZADO (no mÃ¡s try/catch)
      const parsed = JSON.parse(response.output_text);
      
      // ValidaciÃ³n adicional con Zod
      const validated = PedagogicalResponseSchema.parse(parsed);

      // ğŸ“Š Tracking de costos
      this.costTracker.trackResponse(params.sessionKey, response);

      this.logger.info(`Respuesta creada exitosamente para sesiÃ³n: ${params.sessionKey}`);
      return validated;

    } catch (error) {
      this.logger.error(`Error creando respuesta: ${error}`);
      throw new Error(`Error en Responses API: ${error}`);
    }
  }

  /**
   * ğŸš€ Crear mensaje inicial con Responses API
   */
  async createInitialMessage(sessionKey: string, sessionData: SessionData): Promise<string> {
    const instructions = this.buildInitialInstructions(sessionData);
    
    const response = await this.createResponse({
      sessionKey,
      input: "Inicia la clase con saludo pedagÃ³gico apropiado",
      instructions,
      sessionData
    });

    return response.respuesta;
  }

  /**
   * ğŸš€ Crear respuesta para momento especÃ­fico
   */
  async createMomentResponse(params: {
    sessionKey: string;
    studentMessage: string;
    sessionData: SessionData;
    currentMoment: any;
  }): Promise<PedagogicalResponse> {
    
    const instructions = this.buildMomentInstructions(params.sessionData, params.currentMoment);
    
    return await this.createResponse({
      sessionKey: params.sessionKey,
      input: params.studentMessage,
      instructions,
      sessionData: params.sessionData
    });
  }

  /**
   * ğŸ¯ Construir instrucciones para mensaje inicial
   */
  private buildInitialInstructions(sessionData: SessionData): string {
    return `
Eres un ${sessionData.course.specialist_role} especializado en metodologÃ­a inductiva.

OBJETIVO DE LA SESIÃ“N: ${sessionData.session.learning_objective}

PUNTOS CLAVE:
${sessionData.session.key_points.map(point => `- ${point}`).join('\n')}

INSTRUCCIONES:
1. Inicia la clase con un saludo cÃ¡lido y profesional
2. Presenta brevemente el objetivo de la sesiÃ³n
3. Crea expectativa sobre lo que aprenderÃ¡n
4. Termina con la primera pregunta del primer momento

MOMENTO ACTUAL: ${sessionData.momentos[0]?.momento || 'Inicio'}

Responde EXACTAMENTE en el formato JSON especificado.
`;
  }

  /**
   * ğŸ¯ Construir instrucciones para momento especÃ­fico
   */
  private buildMomentInstructions(sessionData: SessionData, currentMoment: any): string {
    return `
Eres un ${sessionData.course.specialist_role} especializado en metodologÃ­a inductiva.

OBJETIVO: ${sessionData.session.learning_objective}
MOMENTO ACTUAL: ${currentMoment.momento}

REGLAS ESTRICTAS:
1. SOLO avanza si preguntas_pendientes = 0
2. SIEMPRE termina con pregunta (excepto si debe_avanzar = true)
3. Responde EXACTAMENTE en formato JSON especificado
4. NUNCA incluyas texto fuera del JSON

PREGUNTAS PENDIENTES:
${sessionData.preguntasPendientes.map((p: string, i: number) => `${i+1}. ${p}`).join('\n')}

CONTENIDO DEL MOMENTO:
${this.getMomentoContent(currentMoment)}

PROGRESO: ${sessionData.currentMomentIndex + 1}/${sessionData.momentos.length}
`;
  }

  /**
   * ğŸ¯ Obtener contenido del momento
   */
  private getMomentoContent(momento: any): string {
    if (momento.historia) return `HISTORIA: ${momento.historia}`;
    if (momento.caso) return `CASO: ${momento.caso}`;
    if (momento.contenido_tecnico) return `CONTENIDO: ${momento.contenido_tecnico.join('\n')}`;
    return momento.instrucciones_docenteia || 'N/A';
  }

  /**
   * ğŸ§¹ Limpiar historial de sesiÃ³n
   */
  clearSessionHistory(sessionKey: string): void {
    this.responseHistory.delete(sessionKey);
    this.logger.info(`Historial limpiado para sesiÃ³n: ${sessionKey}`);
  }
} 
```
=== EOF: src\ai\ResponsesService.ts

===  src\data\sessions\SSO001_sesion03.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion03",
  "nombre": "PrevenciÃ³n de Incendios en el Trabajo",
  "objetivo": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
  "momentos": [
    {
      "momento": "Saludo (exposiciÃ³n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesiÃ³n y los puntos clave a desarrollar",
      "preguntas": [
        "Â¿QuÃ© sabes sobre incendios en el trabajo?",
        "Â¿Has presenciado alguna situaciÃ³n de riesgo de incendio?",
        "Â¿QuÃ© esperas aprender en esta sesiÃ³n?"
      ]
    },
    {
      "momento": "ConexiÃ³n",
      "instrucciones_docenteia": "Narrar la historia de la fÃ¡brica textil para conectar con experiencias previas",
      "historia": "En una fÃ¡brica textil, un trabajador estÃ¡ usando una mÃ¡quina de soldadura cerca de telas almacenadas. De repente, una chispa salta hacia las telas y comienza un pequeÃ±o fuego. Â¿QuÃ© crees que pasÃ³? Â¿Por quÃ© se iniciÃ³ el incendio? Â¿Te ha pasado algo parecido o has escuchado de un caso similar?",
      "preguntas": [
        "Â¿QuÃ© elementos identificas en esta situaciÃ³n?",
        "Â¿QuÃ© podrÃ­a haber prevenido este incidente?",
        "Â¿CÃ³mo se relaciona esto con tu experiencia laboral?",
        "Â¿Has presenciado alguna situaciÃ³n similar?"
      ]
    },
    {
      "momento": "AdquisiciÃ³n",
      "instrucciones_docenteia": "Explicar el TriÃ¡ngulo del Fuego y los tipos de extintores",
      "contenido_tecnico": [
        "El TriÃ¡ngulo del Fuego estÃ¡ compuesto por tres elementos esenciales",
        "COMBUSTIBLE: cualquier material que puede arder (madera, papel, telas, gasolina, etc.)",
        "OXÃGENO: presente en el aire que respiramos",
        "CALOR: la energÃ­a que inicia la reacciÃ³n de combustiÃ³n",
        "Si eliminamos cualquiera de estos tres elementos, el fuego NO puede existir",
        "Extintor de agua: para combustibles sÃ³lidos (clase A)",
        "Extintor de COâ‚‚: para equipos elÃ©ctricos (clase C)",
        "Extintor de polvo: para mÃºltiples tipos de fuego (clase ABC)"
      ],
      "preguntas": [
        "Â¿QuÃ© crees que necesita el fuego para existir?",
        "Â¿Has oÃ­do hablar del TriÃ¡ngulo del Fuego?",
        "Â¿Puedes identificar los tres elementos bÃ¡sicos del fuego?",
        "Â¿QuÃ© tipos de extintores conoces y para quÃ© se usan?",
        "Â¿Por quÃ© es importante eliminar al menos uno de los elementos del TriÃ¡ngulo del Fuego?",
        "Â¿CÃ³mo se relaciona esto con la prevenciÃ³n de incendios?"
      ]
    },
    {
      "momento": "AplicaciÃ³n",
      "instrucciones_docenteia": "Presentar el caso de la carpinterÃ­a para aplicar los conocimientos",
      "caso": "En una carpinterÃ­a donde trabajan 10 personas, hay madera, barnices, equipos elÃ©ctricos, y una estufa para calentar el ambiente. Un dÃ­a, un trabajador estÃ¡ barnizando una pieza cerca de la estufa cuando se derrama barniz sobre la estufa caliente y se inicia un incendio. Usando el TriÃ¡ngulo del Fuego, analicemos este caso: Â¿CuÃ¡les son los tres elementos presentes? Â¿QuÃ© tipo de extintor serÃ­a el mÃ¡s adecuado? Â¿QuÃ© medidas preventivas se podrÃ­an haber implementado?",
      "preguntas": [
        "En este caso de la carpinterÃ­a, Â¿cuÃ¡les son los tres elementos del TriÃ¡ngulo del Fuego?",
        "Â¿QuÃ© tipo de extintor serÃ­a el mÃ¡s adecuado para este incendio y por quÃ©?",
        "Â¿QuÃ© medidas preventivas se podrÃ­an haber implementado para evitar este incidente?",
        "Â¿CÃ³mo se podrÃ­a haber roto el TriÃ¡ngulo del Fuego antes de que ocurriera el incendio?",
        "Si tÃº fueras el responsable de seguridad, Â¿quÃ© protocolos establecerÃ­as?"
      ]
    },
    {
      "momento": "DiscusiÃ³n",
      "instrucciones_docenteia": "Facilitar la comparaciÃ³n de diferentes enfoques de prevenciÃ³n",
      "preguntas": [
        "Â¿QuÃ© estrategia prefieres y por quÃ©?",
        "Â¿Hay situaciones donde una estrategia es mejor que otra?",
        "Â¿QuÃ© limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "ReflexiÃ³n",
      "instrucciones_docenteia": "Guiar la reflexiÃ³n sobre lo aprendido y su aplicaciÃ³n prÃ¡ctica",
      "preguntas": [
        "Â¿QuÃ© concepto te quedÃ³ mÃ¡s claro?",
        "Â¿CÃ³mo cambiarÃ¡ tu forma de trabajar despuÃ©s de esta sesiÃ³n?",
        "Â¿QuÃ© mÃ¡s te gustarÃ­a aprender sobre prevenciÃ³n de incendios?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion03.json

===  src\data\sessions\SSO001_sesion02.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion02",
  "nombre": "Procedimientos de Seguridad en el Trabajo",
  "objetivo": "El estudiante aplica procedimientos de seguridad en situaciones especÃ­ficas del trabajo",
  "momentos": [
    {
      "momento": "Saludo (exposiciÃ³n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesiÃ³n sobre procedimientos de seguridad",
      "preguntas": [
        "Â¿QuÃ© procedimientos de seguridad conoces?",
        "Â¿Has seguido algÃºn protocolo de seguridad en tu trabajo?",
        "Â¿QuÃ© esperas aprender sobre procedimientos de seguridad?"
      ]
    },
    {
      "momento": "ConexiÃ³n",
      "instrucciones_docenteia": "Narrar una situaciÃ³n de trabajo para conectar con experiencias previas",
      "historia": "En una obra de construcciÃ³n, un trabajador debe realizar trabajos en altura. Â¿QuÃ© procedimientos de seguridad deberÃ­a seguir? Â¿QuÃ© equipos de protecciÃ³n necesitarÃ­a?",
      "preguntas": [
        "Â¿QuÃ© elementos de seguridad identificas en esta situaciÃ³n?",
        "Â¿QuÃ© podrÃ­a salir mal si no se siguen los procedimientos?",
        "Â¿Has presenciado alguna situaciÃ³n similar?"
      ]
    },
    {
      "momento": "AdquisiciÃ³n",
      "instrucciones_docenteia": "Explicar los procedimientos de seguridad bÃ¡sicos",
      "contenido_tecnico": [
        "PROCEDIMIENTO: secuencia de pasos para realizar una tarea de forma segura",
        "EQUIPOS DE PROTECCIÃ“N PERSONAL (EPP): elementos que protegen al trabajador",
        "SEÃ‘ALIZACIÃ“N: indicadores visuales que advierten sobre peligros",
        "PROTOCOLOS DE EMERGENCIA: pasos a seguir en caso de accidente"
      ],
      "preguntas": [
        "Â¿QuÃ© elementos debe tener un procedimiento de seguridad?",
        "Â¿CÃ³mo se selecciona el EPP adecuado?",
        "Â¿QuÃ© tipos de seÃ±alizaciÃ³n conoces?"
      ]
    },
    {
      "momento": "AplicaciÃ³n",
      "instrucciones_docenteia": "Presentar un caso prÃ¡ctico para aplicar procedimientos",
      "caso": "En un laboratorio quÃ­mico, un trabajador debe manipular sustancias peligrosas. Â¿QuÃ© procedimientos deberÃ­a seguir?",
      "preguntas": [
        "Â¿QuÃ© procedimientos especÃ­ficos aplicarÃ­as?",
        "Â¿QuÃ© EPP necesitarÃ­a el trabajador?",
        "Â¿QuÃ© medidas de emergencia deberÃ­an estar disponibles?"
      ]
    },
    {
      "momento": "DiscusiÃ³n",
      "instrucciones_docenteia": "Facilitar la comparaciÃ³n de diferentes procedimientos",
      "preguntas": [
        "Â¿QuÃ© procedimiento prefieres y por quÃ©?",
        "Â¿Hay situaciones donde un procedimiento es mejor que otro?",
        "Â¿QuÃ© limitaciones tienen los procedimientos?"
      ]
    },
    {
      "momento": "ReflexiÃ³n",
      "instrucciones_docenteia": "Guiar la reflexiÃ³n sobre lo aprendido y su aplicaciÃ³n prÃ¡ctica",
      "preguntas": [
        "Â¿QuÃ© concepto te quedÃ³ mÃ¡s claro?",
        "Â¿CÃ³mo aplicarÃ¡s estos procedimientos en tu trabajo?",
        "Â¿QuÃ© mÃ¡s te gustarÃ­a aprender sobre seguridad?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion02.json

===  src\data\sessions\SSO001_sesion01.json
```json
{
  "id": "sesion01",
  "name": "Fundamentos de Seguridad contra Incendios",
  "learning_objective": "El estudiante identifica los principios bÃ¡sicos de la seguridad contra incendios y comprende los fundamentos de la prevenciÃ³n",
  "key_points": [
    "Comprende quÃ© es el fuego y cÃ³mo se origina",
    "Identifica los elementos del triÃ¡ngulo del fuego",
    "Reconoce las clases de fuego y sus caracterÃ­sticas",
    "Aplica principios bÃ¡sicos de prevenciÃ³n de incendios"
  ],
  "momentos": [
    {
      "momento": "IntroducciÃ³n al Fuego",
      "preguntas": [
        "Â¿QuÃ© sabes sobre el fuego y cÃ³mo se origina?",
        "Â¿Has presenciado alguna vez un incendio o situaciÃ³n relacionada con fuego?",
        "Â¿QuÃ© esperas aprender sobre la prevenciÃ³n de incendios?"
      ],
      "contenido_tecnico": [
        "El fuego es una reacciÃ³n quÃ­mica de combustiÃ³n",
        "Se produce cuando se combinan combustible, oxÃ­geno y calor",
        "Es una herramienta Ãºtil pero tambiÃ©n un peligro potencial"
      ]
    },
    {
      "momento": "El TriÃ¡ngulo del Fuego",
      "preguntas": [
        "Â¿Puedes identificar los tres elementos necesarios para que exista el fuego?",
        "Â¿CÃ³mo crees que se puede controlar o extinguir un incendio?",
        "Â¿QuÃ© elemento del triÃ¡ngulo del fuego es mÃ¡s fÃ¡cil de controlar?"
      ],
      "contenido_tecnico": [
        "Combustible: material que puede quemarse",
        "OxÃ­geno: necesario para la combustiÃ³n",
        "Calor: energÃ­a que inicia y mantiene la reacciÃ³n"
      ]
    },
    {
      "momento": "Clases de Fuego",
      "preguntas": [
        "Â¿Sabes que existen diferentes tipos de fuego?",
        "Â¿Has visto extintores con diferentes colores o etiquetas?",
        "Â¿QuÃ© tipo de fuego crees que es mÃ¡s comÃºn en el trabajo?"
      ],
      "contenido_tecnico": [
        "Clase A: Materiales sÃ³lidos (madera, papel, tela)",
        "Clase B: LÃ­quidos inflamables (gasolina, aceite)",
        "Clase C: Equipos elÃ©ctricos energizados",
        "Clase D: Metales combustibles"
      ]
    },
    {
      "momento": "PrevenciÃ³n de Incendios",
      "preguntas": [
        "Â¿QuÃ© medidas preventivas conoces para evitar incendios?",
        "Â¿CÃ³mo crees que se puede mantener un ambiente de trabajo seguro?",
        "Â¿QuÃ© harÃ­as si detectas un riesgo de incendio en tu Ã¡rea de trabajo?"
      ],
      "contenido_tecnico": [
        "Mantener orden y limpieza en el Ã¡rea de trabajo",
        "No sobrecargar circuitos elÃ©ctricos",
        "Almacenar materiales inflamables correctamente",
        "Reportar condiciones inseguras inmediatamente"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion01.json

