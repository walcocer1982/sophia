import { OpenAI } from 'openai';
import { PedagogicalResponseSchema, PedagogicalResponse, SessionData } from '../core/types';
import { Logger } from '../utils/Logger';
import { CostTracker } from '../utils/CostTracker';
import { OpenAIValidator } from './OpenAIValidator';

export class ResponsesService {
  private client: OpenAI;
  private responseHistory: Map<string, string> = new Map();
  private logger: Logger;
  private costTracker: CostTracker;
  private model: string;

  constructor() {
    const apiKey = process.env.OPENAI_API_KEY;
    
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY no configurada en variables de entorno');
    }

    this.client = new OpenAI({ apiKey });
    this.model = 'gpt-4o-mini'; // Default
    this.logger = new Logger('ResponsesService');
    this.costTracker = new CostTracker();
    
    // ‚úÖ VALIDAR EN CONSTRUCCI√ìN (opcional - puede ralentizar inicio)
    // this.validateSetup();
  }

  private async validateSetup(): Promise<void> {
    try {
      await OpenAIValidator.validateApiKey(process.env.OPENAI_API_KEY!);
      const isModelAvailable = await OpenAIValidator.checkModelAvailability(
        process.env.OPENAI_API_KEY!, 
        this.model
      );
      
      if (!isModelAvailable) {
        this.model = 'gpt-3.5-turbo'; // Fallback
      }
      
    } catch (error) {
      this.logger.error(`Error en setup de OpenAI: ${error}`);
      throw error;
    }
  }

  /**
   * üöÄ NUEVO: Responses API con estado autom√°tico y structured outputs
   */
  async createResponse(params: {
    sessionKey: string;
    input: string;
    instructions: string;
    sessionData?: SessionData;
  }): Promise<PedagogicalResponse> {
    
    try {
      this.logger.info(`Creando respuesta para sesi√≥n: ${params.sessionKey}`);

      // üö® NUEVO: Responses API con structured outputs garantizados
      const response = await this.client.responses.create({
        model: this.model, // Usar modelo configurado
        input: params.input,
        instructions: params.instructions,
        previous_response_id: this.responseHistory.get(params.sessionKey) || null,
        text: {
          format: {
            type: "json_schema",
            name: "pedagogical_response",
            schema: {
              type: "object",
              additionalProperties: false,
              properties: {
                respuesta: {
                  type: "string",
                  description: "La respuesta pedag√≥gica del docente"
                },
                momento_actual: {
                  type: "string",
                  description: "El momento actual de la sesi√≥n"
                },
                progreso: {
                  type: "integer",
                  description: "N√∫mero del momento actual"
                },
                total_momentos: {
                  type: "integer",
                  description: "Total de momentos en la sesi√≥n"
                },
                debe_avanzar: {
                  type: "boolean",
                  description: "Si debe avanzar al siguiente momento"
                },
                razon_avance: {
                  type: "string",
                  description: "Raz√≥n por la que avanza o no"
                },
                siguiente_momento: {
                  type: "string",
                  description: "Nombre del siguiente momento"
                },
                preguntas_pendientes: {
                  type: "integer",
                  description: "N√∫mero de preguntas pendientes"
                },
                preguntas_respondidas: {
                  type: "integer",
                  description: "N√∫mero de preguntas respondidas"
                }
              },
              required: [
                "respuesta",
                "momento_actual",
                "progreso",
                "total_momentos",
                "debe_avanzar",
                "razon_avance",
                "siguiente_momento",
                "preguntas_pendientes",
                "preguntas_respondidas"
              ]
            },
            strict: true // üëà JSON garantizado por OpenAI
          }
        },
        store: true, // üëà Estado gestionado autom√°ticamente por OpenAI
      });

      // Guardar ID para continuidad de conversaci√≥n
      this.responseHistory.set(params.sessionKey, response.id);

      // üéØ PARSING GARANTIZADO (no m√°s try/catch)
      const parsed = JSON.parse(response.output_text);
      
      // Validaci√≥n adicional con Zod
      const validated = PedagogicalResponseSchema.parse(parsed);

      // üìä Tracking de costos
      this.costTracker.trackResponse(params.sessionKey, response);

      this.logger.info(`Respuesta creada exitosamente para sesi√≥n: ${params.sessionKey}`);
      return validated;

    } catch (error) {
      this.logger.error(`Error creando respuesta: ${error}`);
      throw new Error(`Error en Responses API: ${error}`);
    }
  }

  /**
   * üöÄ Crear mensaje inicial con Responses API
   */
  async createInitialMessage(sessionKey: string, sessionData: SessionData): Promise<string> {
    const instructions = this.buildInitialInstructions(sessionData);
    
    const response = await this.createResponse({
      sessionKey,
      input: "Inicia la clase con saludo pedag√≥gico apropiado",
      instructions,
      sessionData
    });

    return response.respuesta;
  }

  /**
   * üöÄ Crear respuesta para momento espec√≠fico
   */
  async createMomentResponse(params: {
    sessionKey: string;
    studentMessage: string;
    sessionData: SessionData;
    currentMoment: any;
  }): Promise<PedagogicalResponse> {
    
    const instructions = this.buildMomentInstructions(params.sessionData, params.currentMoment);
    
    return await this.createResponse({
      sessionKey: params.sessionKey,
      input: params.studentMessage,
      instructions,
      sessionData: params.sessionData
    });
  }

  /**
   * üéØ Construir instrucciones para mensaje inicial
   */
  private buildInitialInstructions(sessionData: SessionData): string {
    return `
Eres un ${sessionData.course.specialist_role} especializado en metodolog√≠a inductiva.

OBJETIVO DE LA SESI√ìN: ${sessionData.session.learning_objective}

PUNTOS CLAVE:
${sessionData.session.key_points.map(point => `- ${point}`).join('\n')}

INSTRUCCIONES:
1. ü´Ç SIEMPRE s√© EMP√ÅTICO y COMPRENSIVO con el estudiante.
2. üéØ La sesi√≥n es solo de un estudiante, no hay otros estudiantes en la sesi√≥n.
3. üìö El estudiante no tiene experiencia en el trabajo, puede conocer algunos conceptos b√°sicos, pero no tiene experiencia pr√°ctica.
4. üåü Inicia la clase con un saludo c√°lido y profesional, pregunta c√≥mo se siente el estudiante.
5. üíô Si el estudiante responde que se siente "mal", "triste", "cansado", etc., muestra EMPAT√çA y comprensi√≥n. Preg√∫ntale por qu√© y ofr√©cele apoyo.
6. üéØ Presenta brevemente el objetivo de la sesi√≥n y los puntos clave (key points).
7. ‚ú® Crea expectativa sobre lo que aprender√°n de manera motivadora.
8. ü§ù Realiza pregunta por pregunta, si el estudiante las esquiva, ay√∫dalo a responderlas con paciencia y comprensi√≥n.
9. üöÄ Si consideras pasar al siguiente momento, preg√∫ntale si le gustar√≠a pasar al siguiente momento, menciona el nombre del momento.
10. üîÑ Si la sesi√≥n se desv√≠a de la secuencia de los momentos, trata de volver a la secuencia de manera amigable.

MOMENTO ACTUAL: ${sessionData.momentos[0]?.momento || 'Inicio'}

Responde EXACTAMENTE en el formato JSON especificado.
`;
  }

  /**
   * üéØ Construir instrucciones para momento espec√≠fico
   */
  private buildMomentInstructions(sessionData: SessionData, currentMoment: any): string {
    return `
Eres un ${sessionData.course.specialist_role} especializado en metodolog√≠a inductiva.

OBJETIVO: ${sessionData.session.learning_objective}
MOMENTO ACTUAL: ${currentMoment.momento}

üß† RECONOCE Y MEMORIZA ESTA SECUENCIA OBLIGATORIA:

MOMENTO 0 (Saludo):
1. Saludo emp√°tico
2. Respuesta del estudiante
3. Presentaci√≥n del objetivo y puntos clave
4. Pregunta espec√≠fica del JSON
5. Respuesta del estudiante
6. Pregunta espec√≠fica del JSON
7. Respuesta del estudiante

MOMENTO 1 (Conexi√≥n):
1. NARRAR la historia completa de la f√°brica textil
2. Pregunta espec√≠fica del JSON
3. Respuesta del estudiante
4. Pregunta espec√≠fica del JSON
5. Respuesta del estudiante
6. Pregunta espec√≠fica del JSON
7. Respuesta del estudiante
8. Pregunta espec√≠fica del JSON
9. Respuesta del estudiante

MOMENTO 2 (Adquisici√≥n):
1. PRESENTAR el contenido t√©cnico del Tri√°ngulo del Fuego
2. Pregunta espec√≠fica del JSON
3. Respuesta del estudiante
4. Pregunta espec√≠fica del JSON
5. Respuesta del estudiante
6. Pregunta espec√≠fica del JSON
7. Respuesta del estudiante
8. Pregunta espec√≠fica del JSON
9. Respuesta del estudiante
10. Pregunta espec√≠fica del JSON
11. Respuesta del estudiante
12. Pregunta espec√≠fica del JSON
13. Respuesta del estudiante

MOMENTO 3 (Aplicaci√≥n):
1. PRESENTAR el caso de la carpinter√≠a
2. Pregunta espec√≠fica del JSON
3. Respuesta del estudiante
4. Pregunta espec√≠fica del JSON
5. Respuesta del estudiante
6. Pregunta espec√≠fica del JSON
7. Respuesta del estudiante
8. Pregunta espec√≠fica del JSON
9. Respuesta del estudiante
10. Pregunta espec√≠fica del JSON
11. Respuesta del estudiante

REGLAS:
1. ü´Ç S√© EMP√ÅTICO y COMPRENSIVO con el estudiante.
2. üö® OBLIGATORIO: Si hay HISTORIA o CASO, n√°rralo PRIMERO antes de cualquier pregunta.
3. ‚úÖ SOLO haz las preguntas de la lista "PREGUNTAS DEL MOMENTO".
4. ‚úÖ Haz UNA pregunta a la vez, en orden.
5. ‚úÖ SIEMPRE responde al estudiante.
6. üíô Si responde "mal", "triste", etc., muestra empat√≠a.
7. ‚úÖ Si preguntas_pendientes = 0, eval√∫a avanzar al siguiente momento.
8. ‚úÖ Responde SOLO en formato JSON.
9. üß† SIGUE EXACTAMENTE la secuencia que reconociste arriba.

PREGUNTAS DEL MOMENTO:
${sessionData.preguntasPendientes.map((p: string, i: number) => `${i+1}. ${p}`).join('\n')}

CONTENIDO DEL MOMENTO:
${this.getMomentoContent(currentMoment)}

PROGRESO: ${sessionData.currentMomentIndex + 1}/${sessionData.momentos.length}
`;
  }

  /**
   * üéØ Obtener contenido del momento
   */
  private getMomentoContent(momento: any): string {
    let content = '';
    
    if (momento.historia) {
      content += `HISTORIA: ${momento.historia}\n\n`;
    }
    
    if (momento.caso) {
      content += `CASO: ${momento.caso}\n\n`;
    }
    
    if (momento.contenido_tecnico) {
      content += `CONTENIDO T√âCNICO:\n${momento.contenido_tecnico.join('\n')}\n\n`;
    }
    
    if (momento.instrucciones_docenteia) {
      content += `INSTRUCCIONES: ${momento.instrucciones_docenteia}`;
    }
    
    return content || 'N/A';
  }

  /**
   * üßπ Limpiar historial de sesi√≥n
   */
  clearSessionHistory(sessionKey: string): void {
    this.responseHistory.delete(sessionKey);
    this.logger.info(`Historial limpiado para sesi√≥n: ${sessionKey}`);
  }
} 