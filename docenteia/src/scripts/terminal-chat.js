#!/usr/bin/env node

const readline = require('readline');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configurar readline
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Colores simples
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
};

function print(color, text) {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// Funci√≥n para consultar OpenAI
// Funci√≥n para detectar el puerto del servidor Next.js
async function detectServerPort() {
  const ports = [3000, 3001, 3002, 3003, 3004, 3005];
  
  for (const port of ports) {
    try {
      const response = await axios.get(`http://localhost:${port}`, { timeout: 1000 });
      if (response.status === 200) {
        return port;
      }
    } catch (error) {
      // Continuar con el siguiente puerto
    }
  }
  
  // Si no encuentra ning√∫n puerto, usar 3000 por defecto
  return 3000;
}

async function queryVectorStore(query, sessionId = null, courseId = null) {
  try {
    print('yellow', 'üîç Consultando OpenAI...');
    
    // Detectar puerto autom√°ticamente
    const port = await detectServerPort();
    print('cyan', `üåê Conectando al servidor en puerto ${port}...`);
    
    const requestBody = {
      query,
      ...(sessionId && { sessionId }),
      ...(courseId && { courseId })
    };
    
    const response = await axios.post(`http://localhost:${port}/api/openai-vector`, requestBody, {
      headers: {
        'Content-Type': 'application/json',
      },
    });

    print('green', '\nü§ñ Respuesta:');
    console.log(response.data.response);
    console.log('');
    
    return response.data.response;
    
  } catch (error) {
    if (error.code === 'ECONNREFUSED') {
      print('red', '‚ùå Error: El servidor Next.js no est√° corriendo.');
      print('yellow', 'üí° Ejecuta: npm run dev');
    } else {
      print('red', `Error: ${error.message}`);
    }
    return null;
  }
}

// Funci√≥n para mostrar sesiones disponibles
function showSessions() {
  print('cyan', '\nüéØ Cursos Disponibles:');
  print('white', '1. SSO001 - Seguridad y Salud Ocupacional');
  print('white', '2. PER001 - Operaci√≥n de Equipos de Perforaci√≥n');
  print('cyan', '\nüí° Usa: /select <curso> <sesi√≥n> para seleccionar');
  print('cyan', '   Ejemplos:');
  print('cyan', '   /select SSO001 1 - SSO, sesi√≥n 1 (IPERC)');
  print('cyan', '   /select PER001 1 - Perforaci√≥n, sesi√≥n 1 (Fundamentos)\n');
}

// Variables globales
let currentCourse = null;
let currentSession = null;
let loadedMoments = null;
let isClassActive = false;
let currentMoment = 0;
let conversationHistory = [];
let isInConversation = false;
let studentName = null;

// Funci√≥n para limpiar variables globales
function clearGlobalState() {
  currentCourse = null;
  currentSession = null;
  loadedMoments = null;
  isClassActive = false;
  currentMoment = 0;
  conversationHistory = [];
  isInConversation = false;
  studentName = null;
}

// Funci√≥n para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const coursesPath = path.join(__dirname, '../data/courses-database.json');
    const coursesData = fs.readFileSync(coursesPath, 'utf8');
    return JSON.parse(coursesData).courses;
  } catch (error) {
    print('red', '‚ùå Error al cargar la base de datos de cursos');
    return [];
  }
}

// Funci√≥n para seleccionar curso y sesi√≥n
async function selectSession(courseId, sessionNumber) {
  const courses = loadCoursesDatabase();
  
  // Buscar el curso
  const course = courses.find(c => c.id === courseId);
  if (!course) {
    print('red', `‚ùå Curso ${courseId} no encontrado. Cursos disponibles: SSO001, PER001\n`);
    return null;
  }
  
  // Buscar la sesi√≥n
  const sessionIndex = parseInt(sessionNumber) - 1;
  if (sessionIndex < 0 || sessionIndex >= course.sessions.length) {
    print('red', `‚ùå N√∫mero de sesi√≥n inv√°lido. Sesiones disponibles: 1-${course.sessions.length}\n`);
    return null;
  }
  
  const session = course.sessions[sessionIndex];
  
  // Establecer curso y sesi√≥n actuales
  currentCourse = course;
  currentSession = session;
  
  print('green', `‚úÖ Curso seleccionado: ${currentCourse.id}`);
  print('cyan', `üë®‚Äçüè´ Especialista: ${currentCourse.specialist_role}`);
  print('green', `‚úÖ Sesi√≥n seleccionada: ${currentSession.id}`);
  print('cyan', `üìö Tema: ${currentSession.name}`);
  print('cyan', `üéØ Objetivo: ${currentSession.learning_objective}`);
  
  // Cargar momentos autom√°ticamente
  print('yellow', 'üîÑ Cargando momentos autom√°ticamente...');
  await loadAllMoments();
  
  // Iniciar conversaci√≥n autom√°ticamente
  print('green', 'üöÄ Iniciando conversaci√≥n autom√°ticamente...\n');
  await startConversation();
  
  return { course: currentCourse, session: currentSession };
}

// Funci√≥n para cargar todos los momentos de una sesi√≥n
async function loadAllMoments() {
  if (!currentSession) {
    print('red', '‚ùå No hay sesi√≥n seleccionada. Usa /select primero.\n');
    return;
  }

  print('yellow', `üîÑ Cargando todos los momentos de ${currentSession.id}...`);
  
  // Cargar gu√≠a de ense√±anza para obtener t√≠tulos precisos
  const teachingGuide = loadTeachingGuide();
  
  if (teachingGuide) {
    loadedMoments = teachingGuide.momentos.map(moment => ({
      id: moment.momento,
      title: moment.titulo
    }));
    print('green', `üìñ Usando gu√≠a de ense√±anza: ${teachingGuide.rol_docente_ia}`);
  } else {
    // Fallback a t√≠tulos b√°sicos si no se puede cargar la gu√≠a
    loadedMoments = [
      { id: 'MOMENTO_0', title: 'SALUDO Y ENCENDIDO DEL AULA' },
      { id: 'MOMENTO_1', title: 'CONEXI√ìN CON SABERES PREVIOS Y RELEVANCIA' },
      { id: 'MOMENTO_2', title: 'ADQUISICI√ìN DE CONOCIMIENTOS B√ÅSICOS' },
      { id: 'MOMENTO_3', title: 'APLICACI√ìN PR√ÅCTICA' },
      { id: 'MOMENTO_4', title: 'DISCUSI√ìN Y CONTRASTE' },
      { id: 'MOMENTO_5', title: 'REFLEXI√ìN FINAL Y CIERRE' }
    ];
  }

  print('green', `‚úÖ Momentos de ${currentSession.id} cargados exitosamente\n`);
}

// Funci√≥n para cargar la gu√≠a de ense√±anza
function loadTeachingGuide() {
  try {
    const guidePath = path.join(__dirname, '../data/teaching-guide.json');
    const guideData = fs.readFileSync(guidePath, 'utf8');
    return JSON.parse(guideData);
  } catch {
    print('red', '‚ùå Error al cargar la gu√≠a de ense√±anza');
    return null;
  }
}

// Funci√≥n para generar prompt espec√≠fico de un momento
function generateMomentPrompt(momentoId, sessionContent, teachingGuide) {
  const moment = teachingGuide.momentos.find(m => m.momento === momentoId);
  if (!moment) {
    return `¬øQu√© dice el ${momentoId} del contenido ${sessionContent}?`;
  }

  const randomExample = moment.ejemplos[Math.floor(Math.random() * moment.ejemplos.length)];
  
  return `Act√∫a como un ${teachingGuide.rol_docente_ia} en modalidad ${teachingGuide.modalidad}.

${moment.titulo}: ${moment.descripcion}

Ejemplo de interacci√≥n: "${randomExample}"

Ahora, bas√°ndote en el contenido del ${momentoId} del archivo ${sessionContent}, desarrolla este momento de la clase de manera natural y pedag√≥gica. Incluye:
1. Una introducci√≥n al contenido espec√≠fico del momento
2. Preguntas interactivas basadas en el material
3. Ejemplos pr√°cticos relacionados
4. Verificaci√≥n de comprensi√≥n

Contenido a consultar: ¬øQu√© dice el ${momentoId} del contenido ${sessionContent}?`;
}

// Funci√≥n para comenzar la clase autom√°tica
async function startClass() {
  if (!currentSession) {
    print('red', '‚ùå No hay sesi√≥n seleccionada. Usa /select primero.\n');
    return;
  }

  if (!loadedMoments) {
    print('red', '‚ùå No hay momentos cargados. Usa /load primero.\n');
    return;
  }

  // Cargar gu√≠a de ense√±anza
  const teachingGuide = loadTeachingGuide();
  if (!teachingGuide) {
    print('red', '‚ùå No se pudo cargar la gu√≠a de ense√±anza. Continuando sin ella...\n');
  } else {
    print('green', `üìñ Gu√≠a de ense√±anza cargada: ${teachingGuide.rol_docente_ia}`);
  }

  isClassActive = true;
  print('green', `üéì ¬°Bienvenidos a la clase de ${currentSession.name}!`);
  print('cyan', 'üöÄ Iniciando clase autom√°tica con Docente-IA...\n');

  for (let i = 0; i < loadedMoments.length; i++) {
    if (!isClassActive) break; // Permitir pausar la clase
    
    const moment = loadedMoments[i];
    print('yellow', `\nüìö ${moment.id}: ${moment.title}`);
    print('cyan', 'üîÑ Docente-IA preparando el momento...');
    
    // Generar prompt espec√≠fico del momento
    const sessionContent = `contenido_sso_${currentSession.id}_MSEII`;
    const query = teachingGuide 
      ? generateMomentPrompt(moment.id, sessionContent, teachingGuide)
      : `¬øQu√© dice el ${moment.id} del contenido ${sessionContent}?`;
    
    await queryVectorStore(query);
    
    if (i < loadedMoments.length - 1) {
      print('yellow', '‚è∏Ô∏è  Presiona Enter para continuar al siguiente momento...');
      await new Promise(resolve => {
        rl.question('', () => resolve());
      });
    }
  }

  if (isClassActive) {
    print('green', '\nüéâ ¬°Clase completada exitosamente!');
    print('cyan', 'üìù Gracias por participar en la sesi√≥n.\n');
  }
  
  isClassActive = false;
}

// Funci√≥n para esperar respuesta del estudiante
async function waitForStudentResponse() {
  return new Promise((resolve) => {
    // Usar readline de forma m√°s controlada
    const tempRl = require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    tempRl.question(`${colors.green}üë§ T√∫: ${colors.reset}`, (input) => {
      tempRl.close();
      resolve(input.trim());
    });
  });
}



// Funci√≥n para guiar conversaci√≥n por momentos
async function guideThroughMoments() {
  if (!loadedMoments) {
    print('red', '‚ùå No hay momentos cargados. Usa /load primero.');
    return;
  }

  print('green', `üéì ¬°Bienvenido a la clase de ${currentSession.name}!`);
  print('cyan', 'üöÄ Iniciando conversaci√≥n guiada...\n');

  for (let i = 0; i < loadedMoments.length; i++) {
    if (!isInConversation) break; // Permitir pausar
    
    currentMoment = i;
    const moment = loadedMoments[i];
    
    print('yellow', `\nüìö ${moment.id}: ${moment.title}`);
    
    // 1. Obtener contenido real del momento
    const contentQuery = `¬øQu√© dice el ${moment.id} del ${currentSession.file_name}?`;
    print('cyan', 'üîÑ Obteniendo contenido del momento...');
    print('cyan', `üìÅ Archivo: ${currentSession.file_name}`);
    print('cyan', `üéØ Curso: ${currentCourse?.id} - ${currentCourse?.name}`);
    
    const momentContent = await queryVectorStore(contentQuery, currentSession.id, currentCourse?.id);
    
    // 2. Obtener estructura del momento desde teaching-guide.json
    const teachingGuide = loadTeachingGuide();
    const momentGuide = teachingGuide?.momentos.find(m => m.momento === moment.id);
    
    if (momentGuide) {
      print('green', `üìñ Usando gu√≠a: ${momentGuide.titulo}`);
      
      // 3. Seguir estructura espec√≠fica del momento
      if (moment.id === 'MOMENTO_0') {
        // MOMENTO_0: Saludo espec√≠fico
        const saludo = momentGuide.ejemplos[0].replace('[nombre]', studentName || 'estudiante');
        print('cyan', `\nüéì ${saludo}`);
        
        // Esperar respuesta del estudiante
        const respuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${saludo}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Segunda pregunta del MOMENTO_0
        const segundaPregunta = momentGuide.ejemplos[1];
        print('cyan', `\nüéì ${segundaPregunta}`);
        const segundaRespuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${segundaPregunta}`);
        conversationHistory.push(`Estudiante: ${segundaRespuesta}`);
        
      } else if (moment.id === 'MOMENTO_1') {
        // MOMENTO_1: Historia/caso espec√≠fico sobre el contenido
        print('cyan', `\nüìö ${momentGuide.titulo}:`);
        print('cyan', momentGuide.descripcion);
        
        // Mostrar contenido espec√≠fico
        print('cyan', '\nüìñ Contenido del tema:');
        console.log(momentContent);
        
        // Generar historia/caso espec√≠fico sobre el contenido
        const historiaPrompt = `Bas√°ndote en este contenido espec√≠fico del ${moment.id}:

${momentContent}

Genera una historia o caso breve relacionado con este contenido sobre prevenci√≥n de incendios que:
- Est√© directamente relacionada con el material mostrado
- Sea realista y relevante
- Active el pensamiento cr√≠tico
- Termine con una pregunta que invite a opinar

Responde SOLO con la historia y pregunta, sin explicaciones adicionales.`;
        
        print('yellow', 'üîÑ Generando historia espec√≠fica del momento...');
        const historiaEspecifica = await queryVectorStore(historiaPrompt, currentSession.id, currentCourse?.id);
        
        print('cyan', `\nüéì ${historiaEspecifica}`);
        print('yellow', '‚è≥ Escribe tu respuesta y presiona Enter...');
        const respuesta = await waitForStudentResponse();
        print('green', `‚úÖ Respuesta capturada: "${respuesta}"`);
        conversationHistory.push(`Docente: ${historiaEspecifica}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Generar respuesta del docente basada en la respuesta del estudiante
        const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera emp√°tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaci√≥n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesi√≥n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
        
        print('yellow', 'üîÑ Generando respuesta del docente...');
        const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
        print('cyan', `\nüë®‚Äçüè´ ${respuestaDocente}`);
        conversationHistory.push(`Docente: ${respuestaDocente}`);
        
        // Pausa para que el estudiante lea la respuesta
        print('yellow', '\n‚è∏Ô∏è  Presiona Enter para continuar...');
        await waitForStudentResponse();
        
      } else if (moment.id === 'MOMENTO_2') {
        // MOMENTO_2: Explicaci√≥n de conceptos
        print('cyan', `\nüìö ${momentGuide.titulo}:`);
        print('cyan', momentGuide.descripcion);
        
                 // Explicar contenido del file_id
         print('cyan', '\nüìñ Contenido espec√≠fico:');
         console.log(momentContent);
        
        // Hacer pregunta de verificaci√≥n
        const preguntaVerificacion = momentGuide.ejemplos[0];
        print('cyan', `\nüéì ${preguntaVerificacion}`);
        const respuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${preguntaVerificacion}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Generar respuesta del docente basada en la respuesta del estudiante
        const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera emp√°tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaci√≥n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesi√≥n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
        
        print('yellow', 'üîÑ Generando respuesta del docente...');
        const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
        print('cyan', `\nüë®‚Äçüè´ ${respuestaDocente}`);
        conversationHistory.push(`Docente: ${respuestaDocente}`);
        
             } else {
         // Otros momentos: Combinar contenido con estructura de la gu√≠a
         print('cyan', `\nüìö ${momentGuide.titulo}:`);
         print('cyan', momentGuide.descripcion);
         
         // Mostrar contenido espec√≠fico
         print('cyan', '\nüìñ Contenido del tema:');
         console.log(momentContent);
         
         // Generar pregunta espec√≠fica sobre el contenido del momento
         const preguntaPrompt = `Bas√°ndote en este contenido espec√≠fico del ${moment.id}:

${momentContent}

Y siguiendo la estructura del momento: ${momentGuide.titulo}
${momentGuide.descripcion}

Genera UNA SOLA pregunta espec√≠fica sobre este contenido que:
- Est√© directamente relacionada con el material mostrado
- Siga el prop√≥sito del momento (${momentGuide.titulo})
- Sea conversacional y emp√°tica
- Invite a la reflexi√≥n sobre el contenido espec√≠fico

Responde SOLO con la pregunta, sin explicaciones.`;
         
         print('yellow', 'üîÑ Generando pregunta espec√≠fica del momento...');
         const preguntaEspecifica = await queryVectorStore(preguntaPrompt, currentSession.id, currentCourse?.id);
         
         print('cyan', `\nüéì ${preguntaEspecifica}`);
         const respuesta = await waitForStudentResponse();
         conversationHistory.push(`Docente: ${preguntaEspecifica}`);
         conversationHistory.push(`Estudiante: ${respuesta}`);
         
         // Generar respuesta del docente basada en la respuesta del estudiante
         const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera emp√°tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaci√≥n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesi√≥n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
         
         print('yellow', 'üîÑ Generando respuesta del docente...');
         const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
         print('cyan', `\nüë®‚Äçüè´ ${respuestaDocente}`);
         conversationHistory.push(`Docente: ${respuestaDocente}`);
       }
    } else {
      // Fallback si no se encuentra la gu√≠a
      print('yellow', '‚ö†Ô∏è No se encontr√≥ gu√≠a espec√≠fica para este momento');
      
      // Hacer pregunta gen√©rica
      const preguntaPrompt = `Bas√°ndote en este contenido del ${moment.id}:

${momentContent}

Genera UNA SOLA pregunta espec√≠fica y conversacional sobre este contenido. Responde SOLO con la pregunta.`;
      
      const pregunta = await queryVectorStore(preguntaPrompt, currentSession.id, currentCourse?.id);
      print('cyan', `\nüéì ${pregunta}`);
      const respuesta = await waitForStudentResponse();
      conversationHistory.push(`Docente: ${pregunta}`);
      conversationHistory.push(`Estudiante: ${respuesta}`);
      
      // Generar respuesta del docente basada en la respuesta del estudiante
      const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera emp√°tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaci√≥n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesi√≥n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
      
      print('yellow', 'üîÑ Generando respuesta del docente...');
      const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
      print('cyan', `\nüë®‚Äçüè´ ${respuestaDocente}`);
      conversationHistory.push(`Docente: ${respuestaDocente}`);
    }
    
    // 5. Transicionar al siguiente momento
    if (i < loadedMoments.length - 1) {
      print('yellow', '\n‚è∏Ô∏è  Presiona Enter para continuar al siguiente momento...');
      await new Promise(resolve => {
        rl.question('', () => resolve());
      });
    }
  }

  if (isInConversation) {
    print('green', '\nüéâ ¬°Conversaci√≥n completada exitosamente!');
    print('cyan', 'üìù Gracias por participar en la sesi√≥n.\n');
  }
  
  isInConversation = false;
}

// Funci√≥n para iniciar conversaci√≥n
async function startConversation() {
  if (!currentSession) {
    print('red', '‚ùå No hay sesi√≥n seleccionada. Usa /select primero.\n');
    return;
  }

  if (!loadedMoments) {
    print('red', '‚ùå No hay momentos cargados. Usa /load primero.\n');
    return;
  }

  isInConversation = true;
  currentMoment = 0;
  conversationHistory = [];
  
  // Preguntar nombre del estudiante
  print('cyan', 'üëã ¬°Hola! Soy tu docente virtual. ¬øC√≥mo te llamas?');
  studentName = await waitForStudentResponse();
  
  if (studentName) {
    print('green', `¬°Hola ${studentName}! Es un placer conocerte.`);
  }
  
  // Iniciar conversaci√≥n guiada por momentos
  await guideThroughMoments();
}

// Funci√≥n para mostrar ayuda
function showHelp() {
  print('cyan', '\n=== COMANDOS ===');
  print('white', '/vector <consulta> - Consultar contenido del curso');
  print('white', '/sessions - Mostrar sesiones disponibles');
  print('white', '/select <curso> <sesi√≥n> - Seleccionar curso y sesi√≥n (ej: /select SSO001 1)');
  print('white', '/start - Comenzar clase autom√°tica');
  print('white', '/conversar - Iniciar conversaci√≥n guiada con Docente-IA');
  print('white', '/clear - Limpiar estado y variables globales');
  print('white', '/help - Mostrar ayuda');
  print('white', '/exit - Salir');
  print('cyan', '================\n');
}

// Funci√≥n principal
async function startChat() {
  print('cyan', 'ü§ñ Chat Terminal - Docente-IA');
  print('yellow', 'Escribe /help para ver comandos\n');
  
  // Mostrar sesiones disponibles autom√°ticamente
  showSessions();

  const askQuestion = () => {
    rl.question(`${colors.green}üë§ T√∫: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();

      if (trimmedInput === '') {
        askQuestion();
        return;
      }

      if (trimmedInput === '/exit') {
        print('yellow', '¬°Hasta luego! üëã');
        rl.close();
        return;
      }

      if (trimmedInput === '/help') {
        showHelp();
        askQuestion();
        return;
      }

      if (trimmedInput === '/sessions') {
        showSessions();
        askQuestion();
        return;
      }

      if (trimmedInput.startsWith('/select ')) {
        const parts = trimmedInput.substring(8).trim().split(' ');
        if (parts.length >= 2) {
          const courseId = parts[0];
          const sessionNumber = parts[1];
          await selectSession(courseId, sessionNumber);
        } else {
          print('red', '‚ùå Formato incorrecto. Usa: /select <curso> <sesi√≥n>');
          print('cyan', '   Ejemplo: /select SSO001 1');
        }
        askQuestion();
        return;
      }

      if (trimmedInput === '/load') {
        await loadAllMoments();
        askQuestion();
        return;
      }

      if (trimmedInput === '/start') {
        await startClass();
        askQuestion();
        return;
      }

      if (trimmedInput === '/clear') {
        clearGlobalState();
        print('green', '‚úÖ Estado limpiado. Variables globales reiniciadas.');
        askQuestion();
        return;
      }

      if (trimmedInput === '/conversar') {
        await startConversation();
        askQuestion();
        return;
      }

      if (trimmedInput.startsWith('/vector ')) {
        const query = trimmedInput.substring(8);
        await queryVectorStore(query);
        askQuestion();
        return;
      }

      print('red', '‚ùå Comando no reconocido. Usa /help para ver comandos disponibles.');
      askQuestion();
    });
  };

  askQuestion();
}

// Manejar salida
rl.on('close', () => {
  process.exit(0);
});

// Iniciar
startChat().catch(console.error); 