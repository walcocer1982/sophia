---
repository:
  name: docenteia
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-04T23:34:44.277Z
  tool: FlatRepo
statistics:
  totalFiles: 37
  totalLines: 5255
  languages:
    json: 8
    markdown: 4
    javascript: 3
    typescript: 15
    tsx: 4
    css: 1
  fileTypes:
    .json: 8
    .md: 4
    .js: 3
    .mjs: 1
    .example: 1
    .ts: 15
    .tsx: 4
    .css: 1
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```
=== EOF: tsconfig.json

===  TECHNICAL_DOCS.md
```markdown
# Documentaci√≥n T√©cnica - DocenteIA

## Arquitectura del Sistema

### Stack Tecnol√≥gico
- **Framework**: Next.js 15 con App Router
- **Lenguaje**: TypeScript 5.x
- **Estilos**: Tailwind CSS 4.x
- **Linting**: ESLint con reglas estrictas
- **Build**: SWC (Rust-based compiler)

### Estructura de Carpetas
```
src/
‚îú‚îÄ‚îÄ app/                    # App Router (Next.js 15)
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx         # Layout principal
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # P√°gina principal
‚îÇ   ‚îî‚îÄ‚îÄ globals.css        # Estilos globales
‚îú‚îÄ‚îÄ components/             # Componentes reutilizables
‚îÇ   ‚îî‚îÄ‚îÄ ui/                # Componentes de UI base
‚îú‚îÄ‚îÄ lib/                   # Utilidades y helpers
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Funciones utilitarias
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts       # Constantes del sistema
‚îÇ   ‚îî‚îÄ‚îÄ config.ts          # Configuraci√≥n centralizada
‚îî‚îÄ‚îÄ types/                 # Tipos TypeScript
    ‚îî‚îÄ‚îÄ global.d.ts        # Tipos globales
```

## Configuraciones Clave

### TypeScript (tsconfig.json)
- **Target**: ES2022 para mejor rendimiento
- **Strict Mode**: Habilitado completamente
- **No Unused**: Variables y par√°metros no utilizados
- **No Implicit Returns**: Requiere returns expl√≠citos
- **Force Consistent Casing**: Consistencia en nombres de archivos

### ESLint (eslint.config.mjs)
- **Next.js Core Web Vitals**: Optimizaci√≥n de rendimiento
- **TypeScript Rules**: Verificaciones estrictas
- **No Unused Variables**: Error para variables no utilizadas
- **No Explicit Any**: Advertencia para tipos `any`
- **Prefer Const**: Forzar uso de `const`

### Next.js (next.config.ts)
- **React Strict Mode**: Detecci√≥n de efectos secundarios
- **Optimize Package Imports**: Optimizaci√≥n de imports
- **Modern Image Formats**: WebP y AVIF
- **Console Removal**: Eliminar console.log en producci√≥n

## Componentes del Sistema

### Button Component
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}
```

**Caracter√≠sticas**:
- Variantes m√∫ltiples con `class-variance-authority`
- Tipos estrictos de TypeScript
- Accesibilidad integrada
- Reutilizable y extensible

### Utilidades (lib/utils.ts)
```typescript
// Combinaci√≥n de clases CSS
cn("class1", "class2")

// Formateo de fechas
formatDate(new Date())

// Generaci√≥n de IDs √∫nicos
generateId()
```

## Optimizaciones de Rendimiento

### Build Optimizations
- **SWC Compiler**: Compilaci√≥n r√°pida en Rust
- **Tree Shaking**: Eliminaci√≥n de c√≥digo no utilizado
- **Code Splitting**: Divisi√≥n autom√°tica de bundles
- **Image Optimization**: Formatos modernos (WebP, AVIF)

### Runtime Optimizations
- **React Strict Mode**: Detecci√≥n de problemas
- **Turbopack**: Bundler r√°pido en desarrollo
- **Incremental Static Regeneration**: P√°ginas est√°ticas din√°micas

## Seguridad

### TypeScript Strict Mode
- Verificaci√≥n de tipos en tiempo de compilaci√≥n
- Prevenci√≥n de errores de runtime
- Mejor autocompletado y refactoring

### ESLint Security Rules
- Detecci√≥n de c√≥digo vulnerable
- Prevenci√≥n de XSS
- Buenas pr√°cticas de seguridad

## Escalabilidad

### Estructura Modular
- Componentes reutilizables
- Utilidades centralizadas
- Configuraci√≥n tipada
- Separaci√≥n de responsabilidades

### Configuraci√≥n Flexible
- Variables de entorno tipadas
- Configuraci√≥n centralizada
- Constantes organizadas
- Tipos exportables

## Mantenimiento

### C√≥digo Limpio
- ESLint con reglas estrictas
- TypeScript con verificaciones exhaustivas
- Documentaci√≥n integrada
- Convenciones consistentes

### Testing Ready
- Estructura preparada para tests
- Componentes aislados
- Utilidades testables
- Configuraci√≥n de testing

## Despliegue

### Optimizaciones de Producci√≥n
- Minificaci√≥n autom√°tica
- Compresi√≥n de assets
- CDN ready
- PWA compatible

### Monitoreo
- Error boundaries preparados
- Analytics integrado
- Performance monitoring
- Logging estructurado 
```
=== EOF: TECHNICAL_DOCS.md

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
} 
```
=== EOF: tailwind.config.js

===  README.md
```markdown
# DocenteIA - Sistema Estable con Next.js y TypeScript

Un sistema robusto y estable construido con Next.js 14, TypeScript estricto y Tailwind CSS.

## üéØ Prop√≥sito

DocenteIA es un asistente de ense√±anza inteligente que utiliza OpenAI para crear experiencias de aprendizaje personalizadas y conversacionales. El sistema permite a los docentes crear sesiones interactivas con contenido espec√≠fico y gu√≠as de ense√±anza estructuradas.

## üöÄ Caracter√≠sticas

- **Next.js 14**: Versi√≥n estable con App Router
- **TypeScript Estricto**: Configuraci√≥n robusta con verificaciones exhaustivas
- **Tailwind CSS 3**: Estilos modernos y optimizados
- **OpenAI Integration**: Chat conversacional inteligente
- **Teaching Guide System**: Estructura de momentos pedag√≥gicos
- **Course Database**: Gesti√≥n de cursos y sesiones
- **ESLint Configurado**: Reglas estrictas para c√≥digo limpio
- **Componentes Reutilizables**: Sistema de componentes con TypeScript
- **Utilidades Optimizadas**: Funciones helper para desarrollo eficiente
- **OpenAI Integrado**: Chat inteligente con GPT-3.5-turbo
- **API Routes Seguras**: Endpoints protegidos para comunicaci√≥n con IA

## üì¶ Instalaci√≥n

```bash
# Clonar el repositorio
git clone <tu-repositorio>
cd docenteia

# Instalar dependencias
npm install

# Configurar variables de entorno
cp env.example .env.local
# Editar .env.local y agregar tu OPENAI_API_KEY

# Ejecutar en desarrollo
npm run dev
```

## üõ†Ô∏è Scripts Disponibles

```bash
npm run dev          # Servidor de desarrollo
npm run build        # Construcci√≥n para producci√≥n
npm run start        # Servidor de producci√≥n
npm run lint         # Verificaci√≥n de c√≥digo con ESLint
npm run chat         # Chat terminal con IA y vector store
```

## üèóÔ∏è Estructura del Proyecto

```
src/
‚îú‚îÄ‚îÄ app/                 # App Router de Next.js
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx      # Layout principal
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx        # P√°gina principal
‚îÇ   ‚îî‚îÄ‚îÄ globals.css     # Estilos globales
‚îú‚îÄ‚îÄ components/          # Componentes reutilizables
‚îÇ   ‚îî‚îÄ‚îÄ ui/             # Componentes de UI
‚îÇ       ‚îî‚îÄ‚îÄ Button.tsx  # Componente Button
‚îú‚îÄ‚îÄ lib/                # Utilidades y helpers
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts        # Funciones utilitarias
‚îÇ   ‚îú‚îÄ‚îÄ openai.ts       # Configuraci√≥n de OpenAI
‚îÇ   ‚îú‚îÄ‚îÄ vector-store.ts # Configuraci√≥n de vector store
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts    # Constantes del sistema
‚îÇ   ‚îî‚îÄ‚îÄ config.ts       # Configuraci√≥n centralizada
‚îú‚îÄ‚îÄ components/         # Componentes reutilizables
‚îÇ   ‚îú‚îÄ‚îÄ ui/            # Componentes de UI
‚îÇ   ‚îî‚îÄ‚îÄ ChatInterface.tsx # Chat con IA
‚îî‚îÄ‚îÄ types/              # Tipos TypeScript
    ‚îî‚îÄ‚îÄ global.d.ts     # Tipos globales
```

## ‚öôÔ∏è Configuraciones

### TypeScript
- Target: ES2022
- Strict mode habilitado
- Verificaciones estrictas de tipos
- No unused locals/parameters

### ESLint
- Reglas estrictas para TypeScript
- Prevenci√≥n de c√≥digo no utilizado
- Advertencias para `any` types

### Next.js
- React Strict Mode
- SWC Minify
- Optimizaci√≥n de imports
- Soporte para im√°genes modernas

## üé® Componentes

### Button Component
Componente reutilizable con m√∫ltiples variantes:

```tsx
import { Button } from "@/components/ui/Button";

<Button variant="default" size="lg">
  Comenzar
</Button>
```

### ChatInterface Component
Chat inteligente con OpenAI:

```tsx
import { ChatInterface } from "@/components/ChatInterface";

<ChatInterface />
```

## üíª Chat Terminal

```bash
npm run chat
```

**Comandos disponibles:**
- `/help` - Mostrar ayuda
- `/history` - Mostrar historial
- `/clear` - Limpiar historial
- `/vector <consulta>` - Consultar vector store
- `/search <consulta>` - Buscar documentos en vector store
- `/exit` - Salir del chat

**‚ö†Ô∏è Importante:** Para usar el vector store, necesitas tener el servidor corriendo:
```bash
# Terminal 1: Iniciar servidor
npm run dev

# Terminal 2: Ejecutar chat
npm run chat
```

## üìù Utilidades

### Funciones Helper
```tsx
import { cn, formatDate, generateId } from "@/lib/utils";

// Combinar clases CSS
cn("class1", "class2")

// Formatear fechas
formatDate(new Date())

// Generar IDs √∫nicos
generateId()
```

### Funciones de OpenAI
```tsx
import { sendChatMessage, generateText, analyzeSentiment } from "@/lib/openai";

// Enviar mensaje a ChatGPT
const response = await sendChatMessage(messages, 'gpt-3.5-turbo');

// Generar texto
const text = await generateText("Escribe un poema sobre la tecnolog√≠a");

// Analizar sentimiento
const sentiment = await analyzeSentiment("Me encanta este producto!");
```

## üîß Desarrollo

### Agregar Nuevos Componentes
1. Crear en `src/components/ui/`
2. Usar TypeScript estricto
3. Implementar variantes con `class-variance-authority`
4. Exportar tipos de props

### Agregar Utilidades
1. Crear en `src/lib/`
2. Documentar con JSDoc
3. Exportar tipos TypeScript

## üöÄ Despliegue

El proyecto est√° optimizado para despliegue en Vercel:

```bash
npm run build
```

## üìÑ Licencia

MIT License - ver archivo LICENSE para detalles.

## ü§ù Contribuir

1. Fork el proyecto
2. Crear una rama feature (`git checkout -b feature/AmazingFeature`)
3. Commit los cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abrir un Pull Request

## üìû Soporte

Para soporte t√©cnico, contacta al equipo de desarrollo.
```
=== EOF: README.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "chat": "tsc src/scripts/chat-v2.ts --outDir dist && node dist/scripts/chat-v2.js",
    "chat:dev": "tsx src/scripts/chat-v2.ts"
  },
  "dependencies": {
    "@openai/agents": "^0.0.13",
    "autoprefixer": "^10.4.21",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.532.0",
    "next": "^14.2.0",
    "openai": "^5.10.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20.19.9",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "eslint": "^9",
    "eslint-config-next": "15.4.4",
    "flatrepo": "^1.2.0",
    "tsx": "^4.7.0",
    "typescript": "^5"
  }
}
```
=== EOF: package.json

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    optimizePackageImports: ["lucide-react"],
  },
  images: {
    formats: ["image/webp", "image/avif"],
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
};

module.exports = nextConfig;
```
=== EOF: next.config.js

===  instrucciondemejora.md
```markdown
El c√≥digo que utilizas puede optimizarse tanto en su estructura como en la forma en la que interact√∫a con la API de OpenAI. A continuaci√≥n te recomiendo algunas pr√°cticas para mantenerlo limpio y eficiente:

Modularizaci√≥n clara: Divide las funciones en m√≥dulos bien definidos. Por ejemplo, un m√≥dulo para la gesti√≥n de sesiones, otro para la extracci√≥n de momentos y otro para la interacci√≥n con el usuario. Esto facilita el mantenimiento y las pruebas.

Cach√© efectiva: Usa el mapa de cach√© (this.cache) para almacenar resultados frecuentes. Puedes guardar el resultado de b√∫squedas en el vector store o de llamadas a responses.create con prompts similares. Solo deber√≠as volver a llamar a la API si cambia el curso, la sesi√≥n o el momento.

Prompt minimalista: Crea plantillas de prompt reutilizables. Por ejemplo, define un systemMessageBase fuera de las funciones y a√±ade solo la informaci√≥n variable (momento actual, fragmentos) en cada interacci√≥n. Esto evita repetir bloques largos de texto.

Funciones peque√±as y reutilizables: Mant√©n las funciones cortas y con responsabilidad √∫nica. Por ejemplo, validateContentTheme podr√≠a aislar la l√≥gica de filtrado y ser testeada por separado; buildSystemPrompt podr√≠a generar el texto final a partir de par√°metros como la sesi√≥n y los fragmentos.

Modelos escalables: Implementa una capa de abstracci√≥n para elegir el modelo en funci√≥n de la tarea. Si es una extracci√≥n sencilla, utiliza gpt‚Äë3.5‚Äëturbo; si es un feedback pedag√≥gico complejo, usa gpt‚Äë4o. Esto puede ser una funci√≥n getModel(type) o un par√°metro configurable.

Gesti√≥n de sesiones: Aseg√∫rate de limpiar sesiones inactivas y de actualizar correctamente los √≠ndices de momento. Esto evita mantener demasiada informaci√≥n en memoria y hacer llamadas innecesarias.

Control de tokens: Agrega par√°metros opcionales a la llamada de la API para ajustar max_tokens y response_format. Limitar la longitud de la respuesta es una forma directa de reducir costes.

Implementando estas recomendaciones, tendr√°s un c√≥digo m√°s legible, f√°cil de mantener y que te permitir√° controlar mejor el uso y el costo de la API.







T√∫ dijiste:
Respuesta autom√°tica
Continuar
ChatGPT Plus

Trabaj√≥ durante 18 segundos
El usuario ha solicitado continuar, por lo que proporcionar√© m√°s detalles sobre la optimizaci√≥n del c√≥digo y el control de costos. Incluir√© ejemplos espec√≠ficos de mejores pr√°cticas, como la implementaci√≥n de t√©cnicas de almacenamiento en cach√© y modularidad, para ayudar a mejorar la eficiencia y reducir costos.

Listo
Claro, contin√∫o con algunas sugerencias adicionales m√°s concretas:

Uso de variables de entorno y configuraciones: Mant√©n las claves API y par√°metros sensibles en archivos .env y no en el c√≥digo fuente. Adem√°s, define en el .env un par√°metro como OPENAI_MODEL_DEFAULT para poder cambiar de modelo sin modificar cada llamada. Esto te ayuda a probar f√°cilmente distintas combinaciones de modelos y configuraciones para encontrar el equilibrio entre costo y calidad.

Gesti√≥n centralizada de llamadas a la API: Crea un ‚Äúservicio‚Äù dedicado a manejar todas las llamadas a OpenAI. Este servicio puede aplicar patrones como retry en caso de errores transitorios, registrar tiempos de ejecuci√≥n y token usage, e incluso medir costos aproximados. As√≠ tendr√°s un punto √∫nico donde ajustar par√°metros y monitorear el uso.

Manejo de errores robusto: Mejora la captura de errores para evitar reintentos innecesarios. Por ejemplo, si el modelo responde con un JSON malformado, en lugar de volver a hacer una llamada completa, intenta corregir la respuesta o devolver un mensaje predefinido al usuario.

Pruebas unitarias y de integraci√≥n: Al modularizar tu c√≥digo, es m√°s sencillo escribir pruebas. Esto te permite asegurar que cada componente funciona correctamente y que los cambios (como acortar prompts o cambiar modelos) no rompen la funcionalidad existente.

Monitoreo y m√©tricas: Implementa un sistema de logging propio que recoja el n√∫mero de solicitudes, tokens enviados y recibidos, tiempo de respuesta y modelo utilizado. Esta informaci√≥n te dar√° visibilidad en tiempo real de los patrones de uso y te permitir√° ajustar tu c√≥digo bas√°ndote en datos concretos en lugar de suposiciones.

Optimizaci√≥n de b√∫squeda en Vector Store: Si vas a consultar repetidamente los mismos fragmentos, guarda los resultados de vectorStore.search en cach√©. Adem√°s, revisa si puedes indexar documentos de manera que la b√∫squeda sea m√°s espec√≠fica y necesites menos resultados (max_num_results).

Revisi√≥n peri√≥dica de prompts: Lo que funciona al principio puede dejar de ser √≥ptimo conforme cambian los modelos o la cantidad de usuarios. Programa revisiones peri√≥dicas de los prompts y del flujo de conversaci√≥n para eliminar instrucciones redundantes y adaptar tu estrategia a las mejoras de la API.

Seguir estas buenas pr√°cticas te ayudar√° no solo a reducir costes sino tambi√©n a mejorar la mantenibilidad y escalabilidad de tu proyecto docente con IA.







T√∫ dijiste:
Continue


ChatGPT Plus

Trabaj√≥ durante 16 segundos
Por supuesto, aqu√≠ dejo algunas ideas finales con ejemplos concretos de c√≥mo podr√≠as refactorizar y optimizar tu c√≥digo:

1. Crear un generador de prompts reutilizable
En lugar de construir cadenas enormes dentro de cada funci√≥n, define una funci√≥n utilitaria que reciba solo los par√°metros variables. Por ejemplo:

js
Copiar
Editar
function buildSystemPrompt({ specialistRole, sessionName, courseName, learningObjective, keyPoints, momentos, currentIndex, fragmentos }) {
  const momentosContext = momentos.map((m, idx) => {
    const estado = idx < currentIndex ? 'COMPLETADO' : (idx === currentIndex ? 'ACTUAL' : 'PENDIENTE');
    return `${idx + 1}. ${m.momento} (${estado})`;
  }).join('\n');

  const fragmentosContext = fragmentos.map((frag, idx) => `Fragmento ${idx + 1}: ${frag.text.substring(0, 200)}...`).join('\n');

  return `
Eres un ${specialistRole} que est√° ense√±ando la sesi√≥n "${sessionName}" del curso "${courseName}".
OBJETIVO: ${learningObjective}

PUNTOS CLAVE:
${keyPoints.map(p => `- ${p}`).join('\n')}

ESTRUCTURA:
${momentosContext}

MOMENTO ACTUAL: ${momentos[currentIndex].momento}
CONTENIDO DEL MOMENTO: ${momentos[currentIndex].texto}

FRAGMENTOS:
${fragmentosContext}

Instrucciones pedag√≥gicas (resumidas): Usa la metodolog√≠a Teach Like a Champion, corrige de forma constructiva y decide si avanzar al siguiente momento.
`.trim();
}
Este generador concentra toda la l√≥gica de construcci√≥n del prompt. Luego tu funci√≥n handleStudent puede usarla as√≠:

js
Copiar
Editar
const systemPrompt = buildSystemPrompt({
  specialistRole: session.course.specialist_role,
  sessionName: session.session.name,
  courseName: session.course.name,
  learningObjective: session.session.learning_objective,
  keyPoints: session.session.key_points,
  momentos: session.momentos,
  currentIndex: session.currentMomentIndex,
  fragmentos: fragmentosActuales.fragmentos,
});
El texto resultante ser√° m√°s compacto y limpio, adem√°s puedes modificarlo en un solo sitio si cambias de estrategia.

2. A√±adir control de modelo y tokens
Centraliza la llamada a responses.create en una funci√≥n que reciba el nombre del modelo y otros par√°metros configurables:

js
Copiar
Editar
async function callOpenAI({ systemPrompt, userPrompt, model = process.env.OPENAI_MODEL_DEFAULT, maxTokens = 600 }) {
  return await this.client.responses.create({
    model,
    instructions: systemPrompt,
    input: userPrompt,
    max_tokens: maxTokens,
    // response_format: { type: "json_object" }, // Opcional: asegura JSON
    tools: [{
      type: "file_search",
      vector_store_ids: [session.vectorStoreId],
      max_num_results: 3, // Reducido
    }],
  });
}
As√≠ puedes variar f√°cilmente el modelo y el tama√±o de la respuesta sin modificar el flujo principal.

3. Implementar cach√© de fragmentos
Podr√≠as almacenar los fragmentos obtenidos por preCalculateFragmentos en this.cache utilizando como clave una combinaci√≥n de vectorStoreId + momento + expectedTheme. Por ejemplo:

js
Copiar
Editar
const cacheKey = `${vectorStoreId}-${momento.momento}-${expectedTheme}`;
if (this.cache.has(cacheKey)) {
  fragmentos.push({ momento: momento.momento, fragmentos: this.cache.get(cacheKey) });
  continue;
}
// ... ejecutar b√∫squeda ...
this.cache.set(cacheKey, validResults.map(r => ({ texto: r.text, score: r.score })));
Este patr√≥n evita volver a llamar a la API para b√∫squedas id√©nticas.

4. Estimar costes en tiempo de ejecuci√≥n
Dentro de tu servicio de llamadas podr√≠as capturar el recuento de tokens de cada respuesta (OpenAI lo devuelve en la propiedad usage) y sumarizarlo:

js
Copiar
Editar
const response = await callOpenAI({ systemPrompt, userPrompt });
const { prompt_tokens, completion_tokens } = response.usage;
console.log(`Tokens de entrada: ${prompt_tokens}, Tokens de salida: ${completion_tokens}`);
Con esta informaci√≥n puedes registrar consumos por sesi√≥n y ajustar l√≠mites (max_tokens) en funci√≥n de los resultados.

5. Paralelizar pre‚Äëc√°lculo de fragmentos
Si tienes muchas sesiones o momentos, podr√≠as realizar las b√∫squedas en paralelo usando Promise.all, reduciendo el tiempo total:

js
Copiar
Editar
const fragmentos = await Promise.all(momentos.map(async (momento) => {
  // b√∫squeda individual...
}));
Siempre teniendo en cuenta que cada llamada adicional a la API incrementar√° el uso, por lo que debes balancear coste y rapidez.

Implementar estas t√©cnicas te permitir√° mantener un c√≥digo m√°s organizado y con un control fino sobre el gasto asociado a las llamadas de la API. Adem√°s, una vez que tengas m√©tricas claras podr√°s experimentar reduciendo instrucciones o cambiando de modelo y observar c√≥mo var√≠a el coste.







T√∫ dijiste:
Respuesta autom√°tica
Continuar
ChatGPT Plus

Trabaj√≥ durante 15 segundos
Para cerrar con algunas recomendaciones adicionales y consideraciones de organizaci√≥n:

6. Documentaci√≥n y comentarios claros
Un c√≥digo que interact√∫a con modelos de lenguaje y vector stores puede ser complejo para quien no lo desarroll√≥ inicialmente. Aseg√∫rate de documentar cada funci√≥n, describiendo:

Qu√© hace y cu√°l es su entrada/salida.

Por qu√© tomas ciertas decisiones (por ejemplo, ‚Äúlimitamos max_num_results a 3 para reducir tokens‚Äù).

Referencias a la documentaci√≥n de OpenAI para funciones como responses.create o vectorStore.search.

Esto permitir√° que t√∫ o cualquier otro desarrollador entienda la l√≥gica y pueda ajustarla si cambian las APIs o los precios.

7. Separar la l√≥gica de negocio de las llamadas a la API
Actualmente el c√≥digo mezcla la obtenci√≥n de datos (sessions, fragmentos) con la llamada al modelo y la construcci√≥n del prompt. Considera separar las responsabilidades en capas:

Capa de datos: gestiona sesiones, lee el JSON de cursos y se conecta al vector store.

Capa de l√≥gica: decide qu√© informaci√≥n necesita cada interacci√≥n (momento actual, fragmentos) y prepara el prompt.

Capa de servicios: encapsula las llamadas a la API de OpenAI, centralizando par√°metros como modelo, tokens y herramientas.

Al estructurar de este modo, el impacto de cambiar de modelo o ajustar par√°metros se reduce a un √∫nico archivo o m√≥dulo.

8. Monitorizaci√≥n y alertas
Adem√°s del registro de tokens, puedes configurar alertas autom√°ticas cuando se supere cierto umbral de gasto o solicitudes. Por ejemplo, un peque√±o script que lea los datos de la API de OpenAI (si tienes acceso) y env√≠e una notificaci√≥n cuando se acerque a un l√≠mite mensual de presupuesto.

9. Revisi√≥n de la l√≥gica pedag√≥gica
Aunque no est√° directamente relacionado con el costo, repasar la forma en que se gu√≠a al estudiante tambi√©n puede reducir la duraci√≥n de las sesiones y, por tanto, las llamadas. Si logras que el estudiante avance m√°s r√°pido entre momentos con prompts m√°s precisos y preguntas m√°s enfocadas, necesitar√°s menos interacciones para cubrir el contenido.

10. Versionado y pruebas de regresi√≥n
Cuando hagas cambios (por ejemplo, switching de GPT‚Äë4o a GPT‚Äë3.5 para ciertas tareas o reduciendo el tama√±o del prompt), te recomiendo mantener un control de versiones (Git) y, si es posible, un entorno de pruebas. As√≠ podr√°s comparar la calidad de las respuestas y el consumo de tokens entre versiones y revertir si algo no funciona como esperabas.

Ejemplo final de estructura de clases
Podr√≠as reescribir la clase original separando responsabilidades y usando algunas de las optimizaciones mencionadas:

js
Copiar
Editar
class SessionManager {
  // gestiona sesiones, carga cursos, maneja cach√©...
}

class PromptBuilder {
  buildSystemPrompt(args) { /* ... */ }
  buildUserPrompt(studentMsg, context) { /* ... */ }
}

class OpenAIService {
  constructor(apiKey, defaultModel, maxTokens) { /* ... */ }
  async ask(systemPrompt, userPrompt, vectorStoreIds, maxResults) { /* ... */ }
}

class DocenteIA {
  constructor() {
    this.sessionManager = new SessionManager();
    this.promptBuilder = new PromptBuilder();
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY, 'gpt-3.5-turbo', 600);
  }

  async iniciarSesion(courseId, sessionId) { /* usa sessionManager */ }
  async responder(studentMsg, sessionKey) {
    const context = this.sessionManager.getContext(sessionKey);
    const systemPrompt = this.promptBuilder.buildSystemPrompt(context);
    const userPrompt = this.promptBuilder.buildUserPrompt(studentMsg, context);
    return await this.openAIService.ask(systemPrompt, userPrompt, [context.vectorStoreId], 3);
  }
}
Esta estructura facilita el cambio de modelo, la optimizaci√≥n del prompt y la gesti√≥n de sesiones sin tener que editar una √∫nica clase gigante.

Con estas gu√≠as y ejemplos deber√≠as poder refactorizar tu c√≥digo de manera que sea m√°s eficiente, escalable y econ√≥mico.
```
=== EOF: instrucciondemejora.md

===  implementacion2.md
```markdown

1Ô∏è‚É£ Un primer mensaje de ‚Äúesp√≠ritu‚Äù claro y completo
La mejor pr√°ctica en dise√±ar sistemas conversacionales estructurados (como dicen en OpenAI) es definir al inicio un rol y misi√≥n muy claros. Esto:

Crea un prop√≥sito compartido (por ejemplo: seguridad industrial, seguimiento de aprendizaje).

Permite estandarizar el tono y estilo durante toda la sesi√≥n.

Evita que se ‚Äúpierda la intenci√≥n‚Äù cuando avanza al an√°lisis del contenido üîÅ

Por eso, el prompt de sistema debe incluir ese esp√≠ritu pedag√≥gico desde el primer mensaje, antes que cualquier pregunta o memoria.

2Ô∏è‚É£ Luego la memoria conversacional para evaluar clase a clase
Despu√©s del mensaje de esp√≠ritu, cada turno se convierte en c√°psulas de interacci√≥n. En lugar de enviar solo la instrucci√≥n del momento tal como hiciste antes, se recomienda:

Enviar todo el conversationLog (historial) resumido en uno o dos p√°rrafos, o solo las √∫ltimas interacciones relevantes.

Adjuntar las preguntas espec√≠ficas del momento (momento_actual.preguntas).

Pedir al modelo que:

eval√∫e qu√© se cubri√≥,

qu√© falt√≥ por responder,

y si puede pasar al siguiente momento o debe repreguntar.

Esto es coherente con las mejores pr√°cticas para ‚Äúcontext window + role adherence + fact retention‚Äù en conversaciones de LLM 
confident-ai.com
.

üîß Ejemplo de dise√±o de mensajes
jsonc
Copiar
Editar
// SYSTEM MESSAGE (solo una vez al inicio de la sesi√≥n):
‚ÄúYou are a safety‚Äëengineering instructor who leads the session ‚ÄúSeguridad contra incendios‚Äù.
// Here‚Äôs your SPIRIT:
Your purpose: that the student:
 ‚Äì Identifique las causas reales de incendios en el trabajo.
 ‚Äì Relacione la teor√≠a del Tri√°ngulo del Fuego con ejemplos concretos.
 ‚Äì Al final de la sesi√≥n sea capaz de crear un plan de prevenci√≥n paso a paso.

This is your guiding spirit. Always refer back to it. You ARE NOT improvising ‚Äì you are following the ‚Äúguion‚Äù pedag√≥gico concretamente.
‚Äú


// En cada turno (SessionExtractor.handleStudent):
// 1) Enviar como ‚Äúsystem‚Äù:
// Historial de conversaci√≥n (√∫ltimos N turnos):
Estudiante: ‚Äú...‚Äù  
Docente: ‚Äú...‚Äù  

Guion del momento actual (objetivo y preguntas espec√≠ficas, sacadas del JSON).

Instrucciones: responde a EXACTAMENTE una pregunta por turno, en orden, hasta que todas est√©n contestadas; comenta brevemente; luego eval√∫a si puedes pasar al siguiente momento. Si hay dudas o falta informaci√≥n, repregunta y da pistas.

// 2) Enviar como ‚Äúuser‚Äù el mensaje del alumno:
// ‚ÄúEstudiante: {texto del estudiante}‚Äù
‚úÖ Por qu√© funciona mejor
Objetivo	Por qu√© es efectivo
Marcar el esp√≠ritu desde el inicio	Cumple con ‚ÄúUse el rol de sistema para establecer misi√≥n‚Äù (OpenAI dice ser claro al inicio) 
OpenAI Help Center
OpenAI
.
Memoria conversacional antes de cada turno	Ayuda a la fidelidad del modelo a lo que ya ha ocurrido y no repetir preguntas. Alineado con m√©tricas de retenci√≥n de conocimiento en di√°logo AI 
confident-ai.com
.
Evaluaci√≥n y decisi√≥n de avance integradas	El sistema no avanza prematuramente; eval√∫a si el estudiante ha respondido todo o si falta informaci√≥n.

‚úÖ En resumen
S√≠: primero el esp√≠ritu y prop√≥sito de la sesi√≥n, como mensaje general.

Despu√©s: en cada turno, memoria + preguntas espec√≠ficas + evaluaci√≥n de cumplimiento, para evitar repeticiones y asegurar fidelidad al guion.

Esta es la mejor pr√°ctica de ingenier√≠a conversacional actual para chatbots educativos controlados, flexible y de calidad.

¬øQuieres que genere el c√≥digo completo tipo ‚ÄúPromptBuilder.buildSystemPrompt‚Äù y ‚ÄúSessionExtractor.handleStudent‚Äù que implemente esto ya integrado?













Fuentes
T√∫ dijiste:
a ver


ChatGPT Plus
üîß Aqu√≠ tienes una versi√≥n integrada y ‚Äúlista para usar‚Äù del mecanismo de ense√±anza, con los siguientes componentes:

Mensaje de sistema ‚Äúesp√≠ritu‚Äù que se env√≠a solo una vez al comenzar la sesi√≥n.

Funci√≥n buildSystemPrompt que genera un guion literal por momento, incluyendo preguntas espec√≠ficas.

Manejo de memoria conversacional (conversationLog) en SessionManager y SessionExtractor.

Control de avance: se fuerza una evaluaci√≥n del modelo antes de avanzar al siguiente momento.

Te lo explico pieza por pieza y luego te doy el c√≥digo completo.

1Ô∏è‚É£ Mensaje de sistema ‚Äúesp√≠ritu‚Äù ‚Äî se env√≠a solo al inicio
Este mensaje establece el prop√≥sito general de la sesi√≥n, el estilo de docente y el tono humano cercano:

ts
Copiar
Editar
// Solo una vez, al crear la sesi√≥n:
const systemSpirit = `
Eres un **docente experto en seguridad industrial** que imparte la sesi√≥n **"${sessionName}"** del curso **"${courseName}"**.

üß≠ PROP√ìSITO GENERAL:
Tu misi√≥n:  
  ‚Äì que el estudiante **identifique las causas reales** de incendios laborales.  
  ‚Äì que relacione la **teor√≠a del Tri√°ngulo del Fuego** con casos concretos.  
  ‚Äì que al final sea capaz de **crear un plan de prevenci√≥n paso a paso**.

Esta es tu **ense√±anza gu√≠a** para toda la sesi√≥n.  
Desde ahora, act√∫a como si siguieras un guion **pedag√≥gico concreto**, sin improvisar preguntas ni saltarte pasos.  
Usa un tono **cercano, claro y docente**.

No comiences a√∫n con preguntas.**
`.trim();
üìå Esta pr√°ctica est√° alineada con las ‚Äúbest practices‚Äù de OpenAI: usar el prompt del sistema para definir un prop√≥sito claro y rol de manera expl√≠cita desde el inicio 
community.openai.com
community.openai.com
+2
community.openai.com
+2
cookbook.openai.com
+2
.

2Ô∏è‚É£ PromptBuilder.buildSystemPrompt() ‚Äî guion por momento
Aqu√≠ el prompt que se env√≠a antes de cada mensaje excepto el primero:

ts
Copiar
Editar
// PromptBuilder.ts
static buildSystemPrompt(params: PromptParams): string {
  const { sessionName, courseName, learningObjective, momentos, currentMomentIndex } = params;
  const momentoActual = momentos[currentMomentIndex];
  const siguiente = (currentMomentIndex + 1 < momentos.length) ? momentos[currentMomentIndex + 1].momento : 'FIN';

  // Contenido espec√≠fico del momento (historia, caso, etc.)
  const contenido = this.getMomentoContent(momentoActual);

  // Preguntas espec√≠ficas del JSON
  const preguntas = Array.isArray(momentoActual.preguntas) ? momentoActual.preguntas : [];
  const preguntasTexto = preguntas.map((p, i) => `  ${i+1}. ${p}`).join('\n');

  return `
**Guion de momento pedag√≥gico**
Sesi√≥n: "${sessionName}" (curso: ${courseName})

**OBJETIVO DE APRENDIZAJE**  
${learningObjective}

**Momento actual:** ${momentoActual.momento}  
**Siguiente momento:** ${siguiente}

**Contenido del momento:**  
${contenido}

üìã **Instrucciones (obligatorias):**  
1. Haz exactamente TODAS las preguntas listadas a continuaci√≥n, **en ese orden**, sin saltear ni improvisar otras.  
2. Despu√©s de cada respuesta del estudiante, **comenta brevemente** (1 o 2 frases) reconociendo el avance.  
3. No avances al siguiente momento hasta que todas las preguntas est√©n completamente respondidas.  
4. Si la respuesta del estudiante no cubre alg√∫n punto, **repregunta con una pista centr√°ndote en lo que falta**.  
5. Usa un tono **cercano y docente**, como si estuvieras dando clase frente a un estudiante real.  
6. No otorgues informaci√≥n del siguiente momento.

**Preguntas del momento:**  
${preguntasTexto}

üí° Si el estudiante no responde o responde parcialmente, insiste antes de avanzar.
`.trim();
}
‚úÖ En reforche con los principios de prompt engineering: claridad, formato estricto, instrucciones segmentadas por momentos, perfil del modelo definido 
OpenAI Help Center
bridgemind.ai
.

3Ô∏è‚É£ Memoria conversacional: SessionManager y SessionExtractor
Cambios en SessionManager
En el objeto de sesi√≥n (SessionData) a√±ade:

ts
Copiar
Editar
interface SessionData {
  currentMomentIndex: number;
  progress: string;
  // ...
  conversationLog: { role: 'user' | 'assistant'; content: string }[];
}
Inicializaci√≥n:

ts
Copiar
Editar
const session: SessionData = {
  currentMomentIndex: 0,
  progress: '1/6',
  // ...
  conversationLog: [],
};
handleStudent() ‚Äî central del flujo
ts
Copiar
Editar
async handleStudent(studentMessage: string, session: SessionData, promptParams: PromptParams) {
  // Guardar respuesta del estudiante
  session.conversationLog.push({ role: 'user', content: studentMessage });

  // Armar historial: √∫ltimas N interacciones o todas
  const history = session.conversationLog
    .map(m => m.role === 'user' ? `Estudiante: "${m.content}"` : `Docente: "${m.content}"`)
    .join('\n');

  // Generar prompt de sistema + user
  const systemPrompt = this.buildSystemPrompt(promptParams);

  const userPrompt = `
Historial reciente de clase:
${history}

**√öltimo mensaje del estudiante:**
"${studentMessage}"

Sigue el guion del momento actual de forma exacta y estructurada como se indica.`
  .trim();

  // Llamada a OpenAI
  const result = await this.openAI.callChatCompletion([
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ]);

  // Parseo b√°sico (ajusta seg√∫n formato esperado)
  const assistantText: string = result.choices[0].message.content;

  // Guardar salida del docente
  session.conversationLog.push({ role: 'assistant', content: assistantText });

  return assistantText;
}
üìå Con esto, el modelo siempre sabe lo que ya pregunt√≥ y lo que falta por cubrir. Evita preguntas repetidas y salidas fuera del guion.

4Ô∏è‚É£ Justificaci√≥n t√©cnica oficial üß†
Estas pr√°cticas son recomendadas por expertos:

Prompt altamente estructurado y espec√≠fico: evita ambig√ºedad e improvisaci√≥n en las salidas‚Ää‚Äî ideales para clases y flujos repetibles. 
ibm.com
+13
OpenAI Help Center
+13
cookbook.openai.com
+13
community.openai.com

Historial como contexto: copiar los √∫ltimos turnos evita que el modelo pierda la secuencia o vuelva a preguntar lo mismo. Clave en interfaces instructivas. 
bridgemind.ai
community.openai.com

Prompt dividido por etapas o momentos: forma parte de lo que en prompt engineering se conoce como ‚Äústructured prompting‚Äù o ‚Äúconversation routines‚Äù, dise√±adas para sistemas pedag√≥gicos mediante flujos bien definidos. 
community.openai.com
+5
Prompt Engineering Institute
+5
OpenAI Help Center
+5

üöÄ ¬øY ahora qu√©?
Ya tienes el c√≥digo base buildSystemPrompt, handleStudent, conversationLog.

Puedes montar esto directamente en tu aplicaci√≥n y probar con un escenario.

Mejora adicional: resumir hist√≥ricamente el conversationLog si crece mucho, limitando a, por ejemplo, las √∫ltimas 5 interacciones para no saturar tokens.

Con esto tendr√°s un sistema que:

Marca el tono desde el inicio (esp√≠ritu pedag√≥gico).

Pregunta solo lo que debe, con concreci√≥n y control.

Comunica evoluci√≥n y no repite preguntas ya hechas.

Eval√∫a si puede avanzar o debe insistir a√∫n.

¬øQuieres tambi√©n la versi√≥n en JSON del prompt o ejemplo completo de un turno con salida estructurada? Puedo prepar√°rtela.













Fuentes
T√∫ dijiste:
a ver


ChatGPT Plus
Aqu√≠ tienes el prompt completo y un ejemplo de turno listo para integrar:

1Ô∏è‚É£ Mensaje de sistema ‚Äúesp√≠ritu‚Äù ‚Äî solo al inicio de la sesi√≥n
json
Copiar
Editar
{
  "role": "system",
  "content": "Eres un **docente experto en seguridad industrial** que imparte la sesi√≥n **\"Seguridad contra incendios\"** del curso **\"Capacitaci√≥n CETEMIN\".\n\nüß≠ PROP√ìSITO PEDAG√ìGICO:\n‚Äì El estudiante debe **identificar las causas reales** de incendios laborales.\n‚Äì Relacionar la **teor√≠a del Tri√°ngulo del Fuego** con ejemplos concretos.\n‚Äì Al final, crear un **plan de prevenci√≥n paso a paso**.\n\nEste es tu guion pedag√≥gico: **no improvises preguntas ni te saltes pasos**.\nHabla en un tono **cercano y docente**.\n\n‚úã Espera a que empiece el turno del estudiante antes de preguntar cualquier cosa.\n"
}
Esto define el rol y el tono desde el primer mensaje ‚Äî una pr√°ctica recomendada seg√∫n las gu√≠as oficiales de OpenAI: establecer claramente prop√≥sito y tono del sistema desde el principio mejora la fidelidad del modelo a dicho perfil 
OpenAI Community
+8
OpenAI Help Center
+8
orq.ai
+8
.

2Ô∏è‚É£ Sistema por momento ‚Äî buildSystemPrompt() en tiempo de ejecuci√≥n
Este prompt se env√≠a cada vez antes de procesar la respuesta del estudiante en un momento pedag√≥gico (por ejemplo: "Saludo"):

ts
Copiar
Editar
const systemPromptSaludo = `
**Guion del momento: SALUDO**
Sesi√≥n: "Seguridad contra incendios" (CETEMIN)

**OBJETIVO DE APRENDIZAJE:**  
El estudiante identifica causas de incendios laborales y qu√© espera aprender.

---

**Contenido del momento (instrucciones + presentaci√≥n):**  
Objetivo de la sesi√≥n: asegurarte de que el estudiante comprenda los riesgos de incendios y qu√© va a aprender hoy.  
Puntos clave:  
1. Identificaci√≥n del objetivo  
2. Tres preguntas para conocer conocimientos y expectativas

üìã **Instrucciones estrictas:**  
1. Haz exactamente estas 3 preguntas en orden, **sin saltear ni modificar**.  
2. Tras cada respuesta, comenta brevemente (1 o 2 frases) para reconocer el avance.  
3. No pases al siguiente momento hasta que el estudiante responda las tres preguntas por completo.  
4. Si la respuesta es parcial, pregunta de nuevo centrado en la informaci√≥n que falta.  
5. Usa un tono **cercano, claro y docente**, como frente a un estudiante real.

**Preguntas del momento:**  
  1. ¬øQu√© sabes sobre incendios en el trabajo?  
  2. ¬øHas presenciado alguna situaci√≥n de riesgo de incendio? Descr√≠bela.  
  3. ¬øQu√© esperas aprender en esta sesi√≥n?  
`.trim();
Este estilo, con prompts estructurados y guardrails, sigue las mejores pr√°cticas de dise√±o de prompts: claridad, concreci√≥n y formato estricto de salida 
OpenAI Community
.

3Ô∏è‚É£ Ejemplo completo de un turno: integraci√≥n y resultado
üîÑ Env√≠o a la API
jsonc
Copiar
Editar
[
  // Si es el primer turno de la sesi√≥n, incluir el systemSpirit antes del guion
  { "role": "system", "content": systemSpirit },
  
  // Luego, en cada mensaje:
  { "role": "system", "content": systemPromptSaludo },
  { "role": "user", "content": "Estudiante: se muy poco sobre incendios, nunca trabaj√© en f√°bricas y solo espero aprender los elementos b√°sicos." }
]
üßë‚Äçüè´ Ejemplo de respuesta del asistente (formato simulado, modelo debe seguirlo)
txt
Copiar
Editar
Docente: ¬°Perfecto empezar por ah√≠!

**Pregunta 1:** ¬øQu√© sabes sobre incendios en el trabajo?  
‚Üí ‚ÄúS√© muy poco sobre incendios en el trabajo.‚Äù  
**Comentario:** Entiendo, no hay problema: comenzaremos por la base.

**Pregunta 2:** ¬øHas presenciado alguna situaci√≥n de riesgo de incendio? Descr√≠bela.  
‚Üí ‚ÄúNo, nunca he visto algo as√≠.‚Äù  
**Comentario:** Muy bien, eso nos mantiene limpios de preconcepciones. Te comparto que vamos a trabajar con el Tri√°ngulo del Fuego para identificar qu√© riesgos podr√≠an existir.

**Pregunta 3:** ¬øQu√© esperas aprender en esta sesi√≥n?  
‚Üí ‚ÄúQuiero entender qu√© provoca incendios y c√≥mo evitarlos en mi trabajo.‚Äù  
**Comentario:** ¬°Excelente! Ese es justo el objetivo pedag√≥gico principal.

üü¢ Has respondido todas las preguntas del momento SALUDO.  
Cuando est√©s listo, procederemos al siguiente paso: CONEXI√ìN: narrar√© un caso para que lo analicemos juntos.
4Ô∏è‚É£ C√≥mo aplica memoria conversacional
Antes de llamar a la API transporta siempre en el prompt:

El historial de preguntas y respuestas anteriores del propio sistema.

Las preguntas restantes del momento actual.

El prop√≥sito del momento mostrado.

De esta forma, el modelo ‚Äúrecuerda‚Äù qu√© ya pregunt√≥ y no repite.
Este enfoque ‚Äîguardar el historial de conversaci√≥n y reenviarlo cada turno‚Äî es una t√©cnica est√°ndar para asegurar coherencia en di√°logo prolongado con LLMs 
OpenAI Community
stackoverflow.com
.

üìå Por qu√© este enfoque mejora la fidelidad al guion
Evita improvisaci√≥n: el modelo recibe copia exacta de las preguntas.

Estructura pedag√≥gica: valida que todas sean contestadas antes de avanzar.

Uso de memoria conversacional: mantiene coherencia y evita repetir.

Adopta el ‚Äúesp√≠ritu‚Äù desde el principio: el modelo sabe qui√©n debe ser desde la primera l√≠nea.

En conclusi√≥n, usando estas t√©cnicas podr√°s lograr un flujo con:

Control estricto del guion.

Memoria funcional entre preguntas.

Predicci√≥n del avance pedag√≥gico solo cuando el alumno complet√≥ el momento.

¬øQuieres que integre ya la l√≥gica de control de avance (debe_avanzar = true/false) y formato JSON en la salida del asistente? D√≠melo y preparo el c√≥digo tambi√©n.













Fuentes
T√∫ dijiste:
si 


ChatGPT Plus
Aqu√≠ tienes un snippet completo listo para usar, con:

Prompt base que define el esp√≠ritu pedag√≥gico y la estructura base (solo se env√≠a una vez al inicio).

buildSystemPrompt() que solo plantea preguntas del momento, exige formato JSON y controla el avance.

C√≥digo handleStudent() que mantiene la memoria conversacional y gestiona debe_avanzar = true|false seg√∫n las respuestas.

1Ô∏è‚É£ Mensaje inicial (SPIRIT)
ts
Copiar
Editar
const systemSpirit = {
  role: "system",
  content: `
Eres un docente experto en seguridad industrial. Impartes la sesi√≥n ‚ÄúSeguridad contra incendios‚Äù del curso ‚ÄúCETEMIN Capacitaci√≥n‚Äù.

üß≠ ESENCIA PEDAG√ìGICA:
‚Äì Hacer que el estudiante identifique causas reales de incendios.
‚Äì Relacionar el Tri√°ngulo del Fuego con ejemplos concretos.
‚Äì Al final, que pueda proponer un plan de prevenci√≥n paso a paso.

Act√∫as como si siguieras un guion educativo estricto: no improvises, no cambies preguntas.   
Habla de forma cercana y clara.  
No hagas preguntas hasta que comience el turno del estudiante.
  `.trim()
};
Establecer un prop√≥sito y tono claros desde el primer mensaje es una pr√°ctica recomendada por OpenAI: ‚ÄúBe specific ‚Ä¶ Clearly define the desired format, constraints, and role‚Äù 
OpenAI Help Center
.

2Ô∏è‚É£ buildSystemPrompt() para cada momento
ts
Copiar
Editar
static buildSystemPrompt(params: PromptParams): string {
  const m = params.momentos[params.currentMomentIndex];
  const preguntas = Array.isArray(m.preguntas) ? m.preguntas : [];

  const preguntasTexto = preguntas
    .map((p, i) => `  ${i + 1}. ${p}`)
    .join('\n');

  return `
**MOMENTO ACTUAL:** ${m.momento}
Objetivo: ${params.learningObjective}

CONTENIDO: 
${this.getMomentoContent(m)}

üìã Sigue exactamente estas preguntas, en orden, sin modificar ni saltar:
${preguntasTexto}

**Al responder, usa este formato JSON exacto:**

\`\`\`json
{
  "respuesta": "...",              
  "momento_actual": "${m.momento}",
  "progreso": "${params.progress}", 
  "debe_avanzar": true|false,      
  "razon_avance": "‚Ä¶",             
  "siguiente_momento": "‚Ä¶"
}
\`\`\`

Instrucciones:
1. Haz UNA sola pregunta por mensaje. Espera respuesta JSON.
2. Si la respuesta es incompleta, repregunta con una pista clara.
3. Solo avanza (`debe_avanzar=true`) si se respondieron todas las preguntas; en otro caso repregunta.
`.trim();
}
Este enfoque representa una especificaci√≥n rigurosa de formato y guion, alineada con las mejores pr√°cticas de ingenier√≠a de prompts para salidas estructuradas y consistentes 
OpenAI Help Center
.

3Ô∏è‚É£ handleStudent() con control de avance y log conversacional
ts
Copiar
Editar
async handleStudent(studentMsg: string, session: SessionData, params: PromptParams) {
  session.conversationLog.push({ role: 'user', content: studentMsg });

  const history = session.conversationLog
    .slice(-6)
    .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: ${m.content}`)
    .join('\n');

  const systemPrompt = this.buildSystemPrompt(params);

  const messages = [
    ...(session.firstTurn ? [{ role: 'system', content: systemSpirit }] : []),
    { role: 'system', content: `${history}\n\n[Si ya viste esa pregunta, dilo claramente.]` },
    { role: 'system', content: systemPrompt },
    { role: 'user', content: studentMsg }
  ];

  const ml = await this.openAI.callChatCompletion(messages);

  const assistantRaw = ml.choices[0].message.content;
  let assistantJSON;
  try {
    assistantJSON = JSON.parse(assistantRaw);
  } catch (err) {
    // manejar parsing error (p. ej., enviar prompt de resiliencia)
    throw new Error('El modelo no entreg√≥ JSON v√°lido');
  }

  session.conversationLog.push({ role: 'assistant', content: assistantRaw });

  if (assistantJSON.debe_avanzar) {
    params.currentMomentIndex++;
    session.progress = `${params.currentMomentIndex + 1}/${params.momentos.length}`;
  }

  return assistantJSON;
}
Este flujo garantiza que se:

Mantenga el contexto reciente (conversationLog fragmentado si crece mucho).

Se forz√≥ el formato JSON con campos sem√°nticos claros.

Se eval√∫e si seguir o insistir antes de avanzar.

üìä ¬øPor qu√© funciona?
Elemento	Beneficio
Prompt segmentado por momento	Controla el guion y evita improvisaci√≥n
Esquema JSON mandatorio	Hace predecible la respuesta y facilita parsing
Memoria conversacional limitada	Evita repeticiones y mantiene coherencia
Evaluaci√≥n interna de avance	Solo se avanza cuando el bloque actual est√° completo

Es una arquitectura de conversaci√≥n basada en ‚Äúroutines‚Äù y control expl√≠cito del flujo, tal como proponen frameworks modernos para di√°logos educativos con LLM (ver ‚ÄúConversation Routines: task‚Äëoriented dialog systems‚Äù) 
arxiv.org
.

‚úÖ Con este dise√±o, el sistema:

Nunca salta preguntas, solo avanza cuando toca.

Nunca improvisa, solo pregunta lo que est√° en el JSON.

Nunca pierde el hilo, gracias al log conversacional.

Entrega salidas estructuradas con l√≥gica explicativa y control interna.

¬øQuieres tambi√©n una forma de auto-validaci√≥n (e.g., que compruebe si debe_avanzar tiene sentido por conteo de preguntas)? ¬øO ejemplos de prueba con varios momentos? D√≠melo y lo preparo.












Fuentes
T√∫ dijiste:
si 


ChatGPT Plus
Aqu√≠ tienes una versi√≥n completa, integrada y lista para usar, que incluye:

Auto‚Äëvalidaci√≥n autom√°tica del avance (debe_avanzar) basada en cantidad de preguntas respondidas.

Manejo de historia de la clase (conversationLog resumido si crece mucho).

Ejemplo pr√°ctico con dos momentos completos (Saludo ‚Üí Conexi√≥n) mostrando c√≥mo funciona el flujo.

‚úÖ 1. Validaci√≥n autom√°tica: control de debe_avanzar
Usamos el siguiente fragmento dentro de handleStudent(), justo despu√©s de parsear el JSON que devuelve el modelo:

ts
Copiar
Editar
// Ejemplo de JSON parseado
interface MomentoRich {
  preguntas?: string[];
  // ...
}

interface AssistantJSON {
  respuesta: string;
  momento_actual: string;
  progreso: string;
  debe_avanzar: boolean;
  siguiente_momento: string;
  razon_avance?: string;
}

// Auto-validaci√≥n: comparo n√∫mero de respuestas con n√∫mero de preguntas del momento
const m: MomentoRich = params.momentos[params.currentMomentIndex];
const totalPreguntas = m.preguntas?.length ?? 0;

// Encuentro cu√°ntas respuestas mencion√≥ el alumno en su n√∫mero
const answeredCount =
  typeof assistantJSON.respuesta === "string"
    ? 
// Asumo que el modelo repite el n√∫mero de pregunta: "Pregunta‚ÄØ1: ‚Ä¶ ‚Üí ‚Ä¶"
      (assistantJSON.respuesta.match(/^Pregunta\s+\d+/gm) || []).length
    : 0;

if (assistantJSON.debe_avanzar) {
  if (answeredCount !== totalPreguntas) {
    // Advertencia: el modelo dijo avanzar pero no respondi√≥ todo
    // Se fuerza la insistencia
    assistantJSON.debe_avanzar = false;
    assistantJSON.razon_avance =
      `Solo respondi√≥ ${answeredCount} de ${totalPreguntas} preguntas. Por favor termina todas antes de avanzar.`;
  }
} else {
  // Si no dijo avanzar, lo dejamos como est√°
}

if (assistantJSON.debe_avanzar) {
  params.currentMomentIndex++;
  session.progress = `${params.currentMomentIndex + 1}/${params.momentos.length}`;
}
¬øPor qu√© esto es importante?
De esta forma proteges el flujo:

Si el modelo intenta avanzar sin cubrir todas las preguntas, se corrige autom√°ticamente.

Mantienes coherencia con el guion: solo avanza cuando debe.

üß† 2. Memoria conversacional con l√≠mite de tokens
Para evitar saturar el contexto, alargar el prompt y mantener eficiencia, puedes recortar el conversationLog a las √∫ltimas N interacciones. Por ejemplo:

ts
Copiar
Editar
const MAX_HISTORIA = 5;
const recorte = session.conversationLog.length - MAX_HISTORIA * 2; // penaliza por turnos ‚Äúdocente + estudiante‚Äú
if (recorte > 0) {
  session.conversationLog.splice(0, recorte);
}
Esto asegura que env√≠es solo las √∫ltimas 5 interacciones completas (dos mensajes cada interacci√≥n), manteniendo coherencia sin exceder tokens.

üìö 3. Ejemplo pr√°ctico: escenarios en c√≥digo con dos momentos
Supongamos que tienes 2 momentos en tu sesi√≥n: Saludo y Conexi√≥n:

ts
Copiar
Editar
const momentos = [
  {
    momento: "Saludo",
    preguntas: [
      "¬øQu√© sabes sobre incendios en el trabajo?",
      "¬øHas presenciado alguna situaci√≥n de riesgo? Descr√≠bela",
      "¬øQu√© esperas aprender en esta sesi√≥n?"
    ]
  },
  {
    momento: "Conexi√≥n",
    preguntas: [
      "¬øQu√© elementos identificas en esta situaci√≥n?",
      "¬øQu√© podr√≠a haber prevenido este incidente?",
      "¬øC√≥mo se relaciona esto con tu experiencia laboral?",
      "¬øHas presenciado algo similar?"
    ],
    historia: "En una f√°brica textil, un trabajador est√° usando una m√°quina de soldadura cerca de telas inflamables..."
  }
];
üß™ Simulaci√≥n de turno #1: estudiante responde ‚Äúse muy poco‚Äù
Historial enviado al modelo (turno 1):

text
Copiar
Editar
Estudiante: ‚ÄúS√© muy poco sobre incendios‚Ä¶‚Äù
Prompt de sistema para Saludo:

text
Copiar
Editar
Guion del momento: SALUDO
Objetivo: Identificar conocimientos y expectativas.
¬∑¬∑¬∑ (instrucciones y las 3 preguntas del momento)
Respuesta esperada del modelo:

(formato JSON como dijimos)

json
Copiar
Editar
{
  "respuesta": "‚Ä¶",
  "momento_actual": "Saludo",
  "progreso": "1/2",
  "debe_avanzar": false,
  "siguiente_momento": "Saludo"
}
Y se repreguntar√° hasta cubrir todas ‚Äî tal como debe_avanzar=false y continuar√°n.

üîÑ Turno #2: estudiante completa 3 respuestas
Despu√©s de las tres respuestas completas en formato JSON, el sistema detecta:

contando coincidencias con ^Pregunta 3: ‚Üí answeredCount === totalPreguntas ‚Üí debe_avanzar se mantiene true

se avanza autom√°ticamente a Conexi√≥n con currentMomentIndex = 1.

Nuevo systemPrompt para momento ‚ÄúConexi√≥n‚Äù se env√≠a antes del mensaje del siguiente turno.

üìñ 4. Por qu√© esta pr√°ctica es recomendada
Estudios de Prompt Engineering como el art√≠culo Conversation Routines (Robino et al., arXiv 2025) recomiendan justamente el uso de prompts estructurados con l√≥gica de avance integrada y divisi√≥n en momentos bien definidos 
OpenAI Community
+1
OpenAI
+1
arXiv
+1
OpenAI Cookbook
+1
Future Skills Academy
arXiv
+4
arXiv
+4
arXiv
+4
.

La gu√≠a oficial de OpenAI recuerda: ‚ÄúS√© espec√≠fico ‚Ä¶ define claramente el formato de salida, las restricciones, el rol‚Ä¶‚Äù (help.openai.com y el Prompt Engineering Guide, abril 2025) 
OpenAI Help Center
+1
OpenAI Help Center
+1
.

Este enfoque consolida un flujo r√≠gido y pedag√≥gico controlado, donde:

No hay improvisaci√≥n: el modelo solo pregunta lo que debe, cuando debe.

No hay avance prematuro: solo si todas las preguntas fueron respondidas.

Se recuerda lo ya preguntado, evitando repeticiones.

üõ†Ô∏è ¬øQu√© puedes hacer ahora?
Copia estas funciones en tu flujo: buildSystemPrompt(), auto-validaci√≥n, control de conversationLog.

Prueba con una sesi√≥n completa de ejemplo (como el de dos momentos) ‚Äî verifica logs y comportamiento.

Ajusta el n√∫mero MAX_HISTORIA seg√∫n tu l√≠mite de tokens.

Opcional: incluye una l√≥gica de ‚Äúfallback‚Äù si el modelo no entrega JSON v√°lido ‚Äî puedes enviar un prompt de rescate para forzarlo a repetir el formato.

Con esta arquitectura tendr√°s un sistema educativo con:

Memoria de clase

Control pedag√≥gico estricto

Evaluaci√≥n autom√°tica de avance
```
=== EOF: implementacion2.md

===  eslint.config.mjs
```
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "prefer-const": "error",
      "no-var": "error",
      "no-console": "warn",
    },
  },
];

export default eslintConfig;
```
=== EOF: eslint.config.mjs

===  env.example
```
# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here

# App Configuration
NEXT_PUBLIC_APP_NAME=DocenteIA
NEXT_PUBLIC_APP_VERSION=1.0.0

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3000/api 
```
=== EOF: env.example

===  src\types\index.ts
```typescript
// Tipos e interfaces para DocenteIA
export interface Course {
  id: string;
  name: string;
  specialist_role: string;
  sessions: Session[];
}

export interface Session {
  id: string;
  name: string;
  session_file?: string; // Archivo JSON de la sesi√≥n (opcional)
  learning_objective: string;
  key_points: string[];
  theme_keywords: string[];
}

export interface Moment {
  momento: string;
  instrucciones_docenteia?: string;
  contenido_tecnico?: string[];
  historia?: string;
  caso?: string;
  preguntas?: string[];
}

export interface SessionData {
  courseId: string;
  sessionId: string;
  sessionFile: string;
  course: Course;
  session: Session;
  expectedTheme: string;
  momentos: Moment[];
  currentMomentIndex: number;
  startTime: Date;
  lastActivity: Date;
  sessionContent?: any; // Contenido completo de la sesi√≥n desde JSON
  conversationLog: Array<{ role: 'user' | 'assistant'; content: string; timestamp: Date }>; // Memoria conversacional
  isFirstTurn: boolean; // Para enviar el mensaje de "esp√≠ritu" solo una vez
  preguntasPendientes: string[]; // Preguntas pendientes del momento actual
  preguntasRespondidas: string[]; // Preguntas ya respondidas del momento actual
}

export interface AIResponse {
  respuesta: string;
  momento_actual: string;
  progreso: number;
  total_momentos: number;
  debe_avanzar: boolean;
  razon_avance: string;
  siguiente_momento: string;
  momentos?: Moment[];
  sessionKey?: string;
  pregunta_actual?: string;
  preguntas_pendientes?: number;
  preguntas_respondidas?: number;
}

export interface CostMetrics {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
  estimated_cost: number;
  model_used: string;
}

export interface SessionInfo {
  sessionKey: string;
  course: string;
  session: string;
  currentMoment: string;
  progress: string;
  startTime: Date;
  lastActivity: Date;
}

export interface CacheStats {
  cacheSize: number;
  sessionsSize: number;
  activeSessions: number;
}

export interface PromptParams {
  specialistRole: string;
  sessionName: string;
  courseName: string;
  learningObjective: string;
  keyPoints: string[];
  momentos: Moment[];
  currentIndex: number;
}

export interface UserPromptContext {
  currentMoment: string;
  progress: string;
}

export interface OpenAICallParams {
  systemPrompt: string;
  userPrompt: string;
  model?: string;
  maxTokens?: number;
}

export interface OpenAICallResult {
  response: any;
  metrics: CostMetrics;
}

 
```
=== EOF: src\types\index.ts

===  src\types\global.d.ts
```typescript
declare global {
  interface Window {
    __NEXT_DATA__: unknown;
  }
}

export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
} 
```
=== EOF: src\types\global.d.ts

===  src\services\SessionManager.ts
```typescript
import { SessionData, SessionInfo, CacheStats, Course, Session, Moment } from '../types';
import * as fs from 'fs';
import * as path from 'path';

export class SessionManager {
  private sessions = new Map<string, SessionData>();
  private cache = new Map<string, any>();
  private courseData: any;

  constructor() {
    this.courseData = JSON.parse(fs.readFileSync(path.join(__dirname, '../data/courses-database.json'), 'utf8'));
  }

  /**
   * Inicia una sesi√≥n cargando JSON directamente
   */
  async startSession(courseId: string, sessionId: string): Promise<string> {
    const sessionKey = `${courseId}-${sessionId}`;
    
    // Si la sesi√≥n ya existe, retornarla
    if (this.sessions.has(sessionKey)) {
      console.log(`‚úÖ Sesi√≥n ${sessionKey} ya existe, reutilizando`);
      return sessionKey;
    }

    console.log(`üöÄ Iniciando nueva sesi√≥n: ${sessionKey}`);
    
    // Obtener informaci√≥n del curso y sesi√≥n
    const { course, session } = this.getCourseSessionInfo(courseId, sessionId);
    
    // Cargar contenido de la sesi√≥n desde JSON
    const sessionContent = this.loadSessionContent(courseId, sessionId);
    
    // Extraer tema esperado
    const expectedTheme = this.extractThemeFromSession(session.name);
    
    // Crear datos de sesi√≥n iniciales
    const sessionData: SessionData = {
      courseId,
      sessionId,
      sessionFile: `${courseId}_${sessionId}.json`,
      course,
      session,
      expectedTheme,
      momentos: sessionContent.momentos || [],
      currentMomentIndex: 0,
      startTime: new Date(),
      lastActivity: new Date(),
      sessionContent, // Agregar contenido completo de la sesi√≥n
      conversationLog: [], // Inicializar memoria conversacional vac√≠a
      isFirstTurn: true, // Marcar como primer turno para enviar el "esp√≠ritu"
      preguntasPendientes: sessionContent.momentos?.[0]?.preguntas || [], // Inicializar con preguntas del primer momento
      preguntasRespondidas: [] // Inicializar array vac√≠o de preguntas respondidas
    };

    this.sessions.set(sessionKey, sessionData);
    
    return sessionKey;
  }

  /**
   * Obtiene informaci√≥n del curso y sesi√≥n
   */
  getCourseSessionInfo(courseId: string, sessionId: string): {
    course: Course;
    session: Session;
  } {
    const course = this.courseData.courses.find((c: Course) => c.id === courseId);
    if (!course) {
      throw new Error(`Curso ${courseId} no encontrado`);
    }

    const session = course.sessions.find((s: Session) => s.id === sessionId);
    if (!session) {
      throw new Error(`Sesi√≥n ${sessionId} no encontrada en curso ${courseId}`);
    }

    return {
      course,
      session
    };
  }

  /**
   * Carga el contenido de la sesi√≥n desde JSON
   */
  private loadSessionContent(courseId: string, sessionId: string): any {
    try {
      // Obtener informaci√≥n de la sesi√≥n para saber qu√© archivo cargar
      const { session } = this.getCourseSessionInfo(courseId, sessionId);
      
      // Usar session_file si existe, sino usar la convenci√≥n est√°ndar
      const fileName = session.session_file || `${courseId}_${sessionId}.json`;
      
      // Intentar m√∫ltiples rutas posibles
      const possiblePaths = [
        path.join(__dirname, '../data/sessions', fileName),
        path.join(__dirname, '../../data/sessions', fileName),
        path.join(__dirname, '../../../data/sessions', fileName)
      ];
      
      let filePath: string | null = null;
      for (const testPath of possiblePaths) {
        if (fs.existsSync(testPath)) {
          filePath = testPath;
          break;
        }
      }
      
      if (!filePath) {
        console.log(`‚ö†Ô∏è Archivo no encontrado en rutas: ${possiblePaths.join(', ')}`);
        console.log(`üìÅ Usando contenido b√°sico para: ${fileName}`);
        return this.createBasicSessionContent();
      }
      
      const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      console.log(`‚úÖ Contenido cargado desde: ${filePath}`);
      return content;
    } catch (error) {
      console.error(`‚ùå Error cargando contenido de sesi√≥n: ${error}`);
      return this.createBasicSessionContent();
    }
  }

  /**
   * Crea contenido b√°sico de sesi√≥n si no existe el archivo
   */
  private createBasicSessionContent(): any {
    return {
      momentos: [
        {
          momento: "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
          instrucciones_docenteia: "Presentar el objetivo de la sesi√≥n y los puntos clave a desarrollar",
          preguntas: ["¬øQu√© sabes sobre este tema?", "¬øQu√© esperas aprender hoy?"]
        },
        {
          momento: "Conexi√≥n",
          instrucciones_docenteia: "Narrar una historia o situaci√≥n para conectar con experiencias previas",
          preguntas: ["¬øQu√© observas en esta situaci√≥n?", "¬øC√≥mo se relaciona con tu experiencia?"]
        },
        {
          momento: "Adquisici√≥n",
          instrucciones_docenteia: "Explicar los conceptos t√©cnicos principales",
          preguntas: ["¬øQu√© conceptos nuevos identificas?", "¬øC√≥mo se conectan con lo que ya sab√≠as?"]
        },
        {
          momento: "Aplicaci√≥n",
          instrucciones_docenteia: "Presentar un caso pr√°ctico para aplicar los conocimientos",
          preguntas: ["¬øC√≥mo aplicar√≠as estos conceptos?", "¬øQu√© pasos seguir√≠as?"]
        },
        {
          momento: "Discusi√≥n",
          instrucciones_docenteia: "Facilitar la comparaci√≥n y discusi√≥n de diferentes enfoques",
          preguntas: ["¬øQu√© opinas sobre este enfoque?", "¬øHay otras alternativas?"]
        },
        {
          momento: "Reflexi√≥n",
          instrucciones_docenteia: "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
          preguntas: ["¬øQu√© aprendiste hoy?", "¬øC√≥mo aplicar√°s estos conocimientos?"]
        }
      ]
    };
  }

  /**
   * Obtiene una sesi√≥n por clave
   */
  getSession(sessionKey: string): SessionData | undefined {
    return this.sessions.get(sessionKey);
  }

  /**
   * Actualiza una sesi√≥n
   */
  updateSession(sessionKey: string, updates: Partial<SessionData>): void {
    const session = this.sessions.get(sessionKey);
    if (session) {
      Object.assign(session, updates);
      session.lastActivity = new Date();
    }
  }

  /**
   * Lista todas las sesiones activas
   */
  listActiveSessions(): SessionInfo[] {
    return Array.from(this.sessions.entries()).map(([key, session]) => ({
      sessionKey: key,
      course: session.course.name,
      session: session.session.name,
      currentMoment: session.momentos[session.currentMomentIndex]?.momento || 'N/A',
      progress: `${session.currentMomentIndex + 1}/${session.momentos.length}`,
      startTime: session.startTime,
      lastActivity: session.lastActivity
    }));
  }

  /**
   * Limpia una sesi√≥n espec√≠fica
   */
  clearSession(sessionKey: string): boolean {
    return this.sessions.delete(sessionKey);
  }

  /**
   * Limpia todas las sesiones
   */
  clearAllSessions(): void {
    this.sessions.clear();
  }

  /**
   * Obtiene estad√≠sticas del cach√©
   */
  getCacheStats(): CacheStats {
    return {
      cacheSize: this.cache.size,
      sessionsSize: this.sessions.size,
      activeSessions: this.sessions.size
    };
  }

  /**
   * Limpia el cach√©
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Obtiene un valor del cach√©
   */
  getFromCache(key: string): any {
    return this.cache.get(key);
  }

  /**
   * Guarda un valor en el cach√©
   */
  setCache(key: string, value: any): void {
    this.cache.set(key, value);
  }

  /**
   * Verifica si existe una clave en el cach√©
   */
  hasCache(key: string): boolean {
    return this.cache.has(key);
  }

  /**
   * Extrae el tema de una sesi√≥n
   */
  private extractThemeFromSession(sessionName: string): string {
    const sessionNameLower = sessionName.toLowerCase();
    if (sessionNameLower.includes('iperc')) return 'IPERC';
    if (sessionNameLower.includes('incendio')) return 'Incendios';
    return 'Seguridad';
  }

  /**
   * Valida que los momentos correspondan al tema
   */
  validateMomentosTheme(momentos: Moment[], expectedTheme: string): void {
    if (!momentos || momentos.length === 0) {
      throw new Error(`No se encontraron momentos v√°lidos para el tema ${expectedTheme}`);
    }
  }
} 
```
=== EOF: src\services\SessionManager.ts

===  src\services\PromptBuilderUniversal.ts
```typescript
import { PromptParams } from '../types';

export class PromptBuilderUniversal {
  private static pedagogiaUniversal = {
    momentos: {
      "Saludo": {
        instrucciones: "Presentar el objetivo de la sesi√≥n y los puntos clave a desarrollar",
        validaciones: ["El estudiante debe mostrar comprensi√≥n del objetivo", "Debe expresar expectativas de aprendizaje"],
        pistas: ["¬øQu√© esperas aprender hoy?", "¬øQu√© sabes sobre este tema?", "¬øC√≥mo crees que esto se relaciona con tu trabajo?"]
      },
      "Conexi√≥n": {
        instrucciones: "Conectar con experiencias previas del estudiante",
        validaciones: ["El estudiante debe relacionar con su experiencia", "Debe identificar elementos de la situaci√≥n"],
        pistas: ["Piensa en tu experiencia laboral...", "¬øQu√© has observado en tu trabajo?", "Reflexiona sobre lo que acabamos de ver..."]
      },
      "Adquisici√≥n": {
        instrucciones: "Ense√±ar la teor√≠a y conceptos fundamentales",
        validaciones: ["El estudiante debe demostrar comprensi√≥n de conceptos", "Debe poder explicar los elementos clave"],
        pistas: ["¬øQu√© crees que significa...?", "Piensa en los elementos b√°sicos...", "¬øC√≥mo se relacionan estos conceptos?"]
      },
      "Aplicaci√≥n": {
        instrucciones: "Aplicar conocimientos en casos pr√°cticos",
        validaciones: ["El estudiante debe analizar el caso", "Debe proponer soluciones basadas en la teor√≠a"],
        pistas: ["Usando lo que aprendimos...", "¬øC√≥mo aplicar√≠as estos conceptos?", "Analicemos paso a paso..."]
      },
      "Discusi√≥n": {
        instrucciones: "Facilitar la comparaci√≥n de diferentes enfoques",
        validaciones: ["El estudiante debe comparar estrategias", "Debe justificar sus preferencias"],
        pistas: ["¬øQu√© ventajas y desventajas ves?", "¬øEn qu√© situaciones preferir√≠as cada enfoque?", "Compara las diferentes opciones..."]
      },
      "Reflexi√≥n": {
        instrucciones: "Guiar la reflexi√≥n sobre lo aprendido",
        validaciones: ["El estudiante debe reflexionar sobre su aprendizaje", "Debe planificar la aplicaci√≥n pr√°ctica"],
        pistas: ["¬øQu√© te qued√≥ m√°s claro?", "¬øC√≥mo cambiar√° tu forma de trabajar?", "Reflexiona sobre lo aprendido..."]
      }
    }
  };

  /**
   * Construye el prompt del esp√≠ritu (solo se env√≠a una vez al inicio)
   */
  static buildSpiritPrompt(params: { 
    specialistRole: string; 
    sessionName: string; 
    courseName: string; 
    learningObjective: string 
  }): string {
    return `üéì **ROL DEL DOCENTE IA:**
Eres un ${params.specialistRole} especializado en guiar el aprendizaje de manera inductiva y participativa.

**PROP√ìSITO PEDAG√ìGICO:**
- Guiar al estudiante a trav√©s de momentos estructurados de aprendizaje
- Hacer preguntas espec√≠ficas que lleven al descubrimiento
- Validar cada respuesta antes de avanzar
- Proporcionar pistas cuando el estudiante no sabe o responde parcialmente
- Mantener engagement constante terminando siempre con una pregunta

**OBJETIVO DE LA SESI√ìN:**
${params.learningObjective}

**ESTILO DE COMUNICACI√ìN:**
- Tono cercano pero profesional
- Preguntas claras y espec√≠ficas
- Reconocimiento de avances
- Pistas constructivas cuando sea necesario
- Nunca dar respuestas directas, guiar hacia el descubrimiento

**REGLAS FUNDAMENTALES:**
1. SIEMPRE termina tu respuesta con una pregunta (excepto en el cierre final)
2. NO avances al siguiente momento hasta que todas las preguntas est√©n completamente respondidas
3. Si el estudiante dice "no s√©" o responde parcialmente, da pistas y repregunta
4. Valida cada respuesta antes de considerar que la pregunta est√° respondida
5. Mant√©n el foco en el momento actual, no adelantes informaci√≥n del siguiente`.trim();
  }

  /**
   * Construye el prompt espec√≠fico para un momento
   */
  static buildMomentPrompt(params: PromptParams & { 
    preguntasPendientes: string[];
    preguntasRespondidas: string[];
  }): string {
    const momentoActual = params.momentos[params.currentIndex];
    const momentoName = momentoActual?.momento?.toLowerCase() || '';
    const pedagogia = this.getPedagogiaForMoment(momentoName);
    
    const siguiente = params.currentIndex < params.momentos.length - 1
      ? params.momentos[params.currentIndex + 1].momento
      : 'FIN';

    // Contenido espec√≠fico del momento
    const contenido = this.getMomentoContent(momentoActual);
    
    // Preguntas pendientes del momento
    const preguntasPendientes = params.preguntasPendientes;
    const primeraPregunta = preguntasPendientes[0] || 'N/A';

    return `**MOMENTO ACTUAL: ${momentoActual?.momento || 'N/A'}**
**SIGUIENTE MOMENTO: ${siguiente}**

**INSTRUCCIONES PEDAG√ìGICAS:**
${pedagogia.instrucciones}

**CONTENIDO DEL MOMENTO:**
${contenido}

      **PREGUNTAS PENDIENTES:**
      ${preguntasPendientes.map((p: string, idx: number) => `${idx + 1}. ${p}`).join('\n')}

      **PISTAS DISPONIBLES:**
      ${pedagogia.pistas.map((p: string, idx: number) => `${idx + 1}. ${p}`).join('\n')}

      **VALIDACIONES REQUERIDAS:**
      ${pedagogia.validaciones.map((v: string, idx: number) => `${idx + 1}. ${v}`).join('\n')}

üìã **INSTRUCCIONES ESTRICTAS:**
1. **SIEMPRE** comienza mostrando el contenido del momento con la frase apropiada:
   - Conexi√≥n: "Te cuento una historia: [historia]"
   - Adquisici√≥n: "Ahora vamos a aprender: [contenido t√©cnico]"
   - Aplicaci√≥n: "Te presento un caso: [caso]"
   - Otros: "[instrucciones]"

2. **DESPU√âS** haz la primera pregunta pendiente: "${primeraPregunta}"

3. **SI** el estudiante dice "no s√©", "no recuerdo", "no tengo idea", etc., usa una pista de la lista y repregunta.

4. **NO** avances al siguiente momento hasta que todas las preguntas est√©n completamente respondidas.

5. **SIEMPRE** termina tu respuesta con una pregunta (excepto en el cierre final).

**FORMATO DE RESPUESTA OBLIGATORIO:**
\`\`\`json
{
  "respuesta": "Tu respuesta como docente aqu√≠",
  "momento_actual": "${momentoActual?.momento || 'N/A'}",
  "progreso": ${params.currentIndex + 1},
  "total_momentos": ${params.momentos.length},
  "debe_avanzar": false,
  "razon_avance": "Raz√≥n del avance o por qu√© no avanza",
  "siguiente_momento": "${siguiente}",
  "pregunta_actual": "${primeraPregunta}",
  "preguntas_pendientes": ${preguntasPendientes.length},
  "preguntas_respondidas": ${params.preguntasRespondidas.length}
}
\`\`\`

**REGLAS PARA debe_avanzar:**
- **debe_avanzar: true** ‚Üí SOLO si preguntas_pendientes = 0 (todas respondidas)
- **debe_avanzar: false** ‚Üí Si hay preguntas pendientes o respuestas incompletas

**NO incluyas texto fuera del JSON. NO uses markdown. SOLO el JSON.**`.trim();
  }

  /**
   * Obtiene la pedagog√≠a espec√≠fica para un momento
   */
  private static getPedagogiaForMoment(momentoName: string): any {
    for (const [key, value] of Object.entries(this.pedagogiaUniversal.momentos)) {
      if (momentoName.includes(key.toLowerCase())) {
        return value;
      }
    }
    // Pedagog√≠a por defecto
    return {
      instrucciones: "Guiar el aprendizaje del estudiante",
      validaciones: ["El estudiante debe demostrar comprensi√≥n"],
      pistas: ["¬øQu√© piensas sobre esto?", "Reflexiona sobre lo que vimos...", "¬øC√≥mo se relaciona con tu experiencia?"]
    };
  }

  /**
   * Extrae el contenido espec√≠fico del momento
   */
  private static getMomentoContent(momento: any): string {
    if (!momento) return 'N/A';

    const momentoName = momento.momento?.toLowerCase() || '';

    // Para Conexi√≥n, mostrar la historia
    if (momentoName.includes('conexi√≥n') && momento.historia) {
      return `HISTORIA: ${momento.historia}`;
    }

    // Para Adquisici√≥n, mostrar el contenido t√©cnico
    if (momentoName.includes('adquisici√≥n') && momento.contenido_tecnico) {
      const contenido = Array.isArray(momento.contenido_tecnico)
        ? momento.contenido_tecnico.join('\n')
        : momento.contenido_tecnico;
      return `CONTENIDO T√âCNICO:\n${contenido}`;
    }

    // Para Aplicaci√≥n, mostrar el caso
    if (momentoName.includes('aplicaci√≥n') && momento.caso) {
      return `CASO PR√ÅCTICO: ${momento.caso}`;
    }

    // Para otros momentos, mostrar las instrucciones
    const instruccionesDocente = (momento as any)["instrucciones docenteia"] 
      ?? momento.instrucciones_docenteia;
    
    if (typeof instruccionesDocente === 'string' && instruccionesDocente.trim().length > 0) {
      return `INSTRUCCIONES: ${instruccionesDocente}`;
    }

    return 'N/A';
  }

  /**
   * Valida si una respuesta es completa o evasiva
   */
  static isEvasionResponse(response: string): boolean {
    const evasions = [
      'no s√©', 'no se', 'no recuerdo', 'no tengo idea', 'no estoy seguro',
      'nunca', 'no', 'ok', 's√≠', 'aj√°', 'mmm', 'eh', 'bueno', 'hola', 'hi',
      'otra vez', 'la misma pregunta', 'ya preguntaste', 'repetir', 'cansado',
      'aburrido', 'no entiendo', 'confuso', 'dif√≠cil', 'complicado'
    ];
    
    const cleanResponse = response.toLowerCase().trim();
    
    // Detectar evasiones exactas
    const isExactEvasion = evasions.some(evasion => cleanResponse === evasion);
    if (isExactEvasion) return true;
    
    // Detectar evasiones parciales (pero no palabras t√©cnicas)
    const technicalTerms = ['co2', 'abc', 'agua', 'polvo', 'madera', 'papel', 'gasolina', 'incendio', 'fuego', 'prevenci√≥n'];
    const hasTechnicalTerm = technicalTerms.some(term => cleanResponse.includes(term));
    
    if (hasTechnicalTerm && cleanResponse.length > 15) return false; // No es evasiva si contiene t√©rminos t√©cnicos y es larga
    
    const isPartialEvasion = evasions.some(evasion => cleanResponse.includes(evasion));
    
    // Respuestas muy cortas sin t√©rminos t√©cnicos
    const isTooShort = cleanResponse.length < 10 && !hasTechnicalTerm;
    
    return isPartialEvasion || isTooShort;
  }

  /**
   * Genera una pista basada en el momento y la pregunta
   */
  static generateHint(momentoName: string, pregunta: string): string {
    const pedagogia = this.getPedagogiaForMoment(momentoName);
    const hints = pedagogia.pistas;
    
    // Seleccionar pista basada en el tipo de pregunta
    if (pregunta.includes('elementos') || pregunta.includes('identificas')) {
      return hints[0] || "Piensa en los elementos que viste en la situaci√≥n...";
    }
    if (pregunta.includes('experiencia') || pregunta.includes('relaciona')) {
      return hints[1] || "Reflexiona sobre tu experiencia laboral...";
    }
    if (pregunta.includes('conceptos') || pregunta.includes('significa')) {
      return hints[2] || "Piensa en los conceptos b√°sicos que hemos visto...";
    }
    
    return hints[0] || "Reflexiona sobre lo que acabamos de ver...";
  }
} 
```
=== EOF: src\services\PromptBuilderUniversal.ts

===  src\services\PromptBuilder.ts
```typescript
import { PromptParams, UserPromptContext } from '../types';

export class PromptBuilder {
  /**
   * Mensaje de "esp√≠ritu" que se env√≠a solo al inicio de la sesi√≥n
   */
  static buildSpiritPrompt(params: { specialistRole: string; sessionName: string; courseName: string; learningObjective: string }): string {
    return `Eres un **${params.specialistRole}** que imparte la sesi√≥n **"${params.sessionName}"** del curso **"${params.courseName}"**.

üß≠ PROP√ìSITO PEDAG√ìGICO:
Tu misi√≥n es que el estudiante:
- **Comprenda y aplique** los conceptos clave de esta sesi√≥n
- **Relacione la teor√≠a** con ejemplos concretos y casos pr√°cticos
- **Desarrolle habilidades** que pueda aplicar en situaciones reales
- **Al final de la sesi√≥n** sea capaz de demostrar lo aprendido

OBJETIVO DE APRENDIZAJE:
${params.learningObjective}

üìã TU ROL COMO DOCENTE:
- Act√∫as como si siguieras un **guion pedag√≥gico estricto**
- **NO improvises** preguntas ni te saltes pasos
- Usa un tono **cercano, claro y docente**
- Construye conocimiento **inductivamente**
- Valida y corrige respuestas **constructivamente**
- **NO des definiciones directas** - gu√≠a al descubrimiento

‚úã Espera a que empiece el turno del estudiante antes de preguntar cualquier cosa.`.trim();
  }

  // BASE_PROMPT removido - ahora usamos prompts din√°micos espec√≠ficos por momento

  /**
   * Obtiene el contenido apropiado del momento seg√∫n su tipo
   */
    private static getMomentoContent(momento: any): string {
    if (!momento) return 'N/A';

    const momentoName = momento.momento?.toLowerCase() || '';

    // Para Conexi√≥n, mostrar la historia
    if (momentoName.includes('conexi√≥n') && momento.historia) {
      return `HISTORIA: ${momento.historia}`;
    }

    // Para Adquisici√≥n, mostrar el contenido t√©cnico
    if (momentoName.includes('adquisici√≥n') && momento.contenido_tecnico) {
      const contenido = Array.isArray(momento.contenido_tecnico)
        ? momento.contenido_tecnico.join('\n')
        : momento.contenido_tecnico;
      return `CONTENIDO T√âCNICO:\n${contenido}`;
    }

    // Para Aplicaci√≥n, mostrar el caso
    if (momentoName.includes('aplicaci√≥n') && momento.caso) {
      return `CASO PR√ÅCTICO: ${momento.caso}`;
    }

    // Para otros momentos, mostrar las instrucciones
    // Algunos archivos usan clave con espacio, otros con guion bajo
    const instruccionesDocente = (momento as any)["instrucciones docenteia"] 
      ?? momento.instrucciones_docenteia;
    
    if (typeof instruccionesDocente === 'string' && instruccionesDocente.trim().length > 0) {
      return `INSTRUCCIONES: ${instruccionesDocente}`;
    }

    return 'N/A';
  }

  /**
   * Construye el prompt del sistema optimizado con guion espec√≠fico por momento
   */
  static buildSystemPrompt(params: PromptParams): string {
    const momentoActual = params.momentos[params.currentIndex];
    const siguiente = params.currentIndex < params.momentos.length - 1
      ? params.momentos[params.currentIndex + 1].momento
      : 'FIN';

    // Solo incluir puntos clave m√°s esenciales (m√°ximo 3)
    const keyPointsList = params.keyPoints
      .slice(0, 3)
      .map((point, idx) => `${idx + 1}. ${point}`)
      .join('\n');

    // Obtener preguntas espec√≠ficas del momento actual
    const preguntas = momentoActual?.preguntas || [];
    const preguntasTexto = preguntas
      .map((p, idx) => `  ${idx + 1}. ${p}`)
      .join('\n');

    // Contenido espec√≠fico del momento (historia, contenido t√©cnico, caso, etc.)
    const contenido = this.getMomentoContent(momentoActual);

    return `**GUION DEL MOMENTO: ${momentoActual?.momento || 'N/A'}**
Sesi√≥n: "${params.sessionName}" (Curso: ${params.courseName})

**OBJETIVO DE APRENDIZAJE:**
${params.learningObjective}

**PUNTOS CLAVE:**
${keyPointsList}

**MOMENTO ACTUAL:** ${momentoActual?.momento || 'N/A'}
**SIGUIENTE MOMENTO:** ${siguiente}

**CONTENIDO DEL MOMENTO:**
${contenido}

üìã **INSTRUCCIONES ESTRICTAS:**
1. **SIEMPRE** comienza mostrando el contenido del momento:
   - Para **Conexi√≥n**: "Te cuento una historia: [historia]"
   - Para **Adquisici√≥n**: "Ahora vamos a aprender: [contenido t√©cnico]"
   - Para **Aplicaci√≥n**: "Te presento un caso: [caso]"
2. **DESPU√âS** haz la primera pregunta de la lista: "${preguntas[0] || 'N/A'}"
3. **SI** el estudiante no responde o dice "ok", "s√≠", etc., **ay√∫dalo** con pistas como:
   - "Piensa en tu experiencia laboral..."
   - "¬øQu√© has observado en tu trabajo?"
   - "Reflexiona sobre lo que acabamos de ver..."
4. **NO** hagas preguntas gen√©ricas como "¬øEst√°s listo?" o "¬øC√≥mo est√°s?"
5. **NO** esperes a que el estudiante responda sin hacer la pregunta espec√≠fica.
6. Despu√©s de cada respuesta del estudiante, **comenta brevemente** (1 o 2 frases) reconociendo el avance.
7. **Solo** avanza a la siguiente pregunta cuando la respuesta sea completa.
8. Si la respuesta del estudiante no cubre alg√∫n punto, **repregunta con una pista** centr√°ndote en lo que falta.
9. Usa un tono **cercano y docente**, como si estuvieras dando clase frente a un estudiante real.
10. No otorgues informaci√≥n del siguiente momento.

**PREGUNTAS DEL MOMENTO:**
${preguntasTexto}

üí° **IMPORTANTE:** 
- **SIEMPRE** comienza tu respuesta mostrando el contenido del momento:
  - **Conexi√≥n**: "Te cuento una historia: [historia]"
  - **Adquisici√≥n**: "Ahora vamos a aprender: [contenido t√©cnico]"
  - **Aplicaci√≥n**: "Te presento un caso: [caso]"
- **DESPU√âS** haz la primera pregunta: "${preguntas[0] || 'N/A'}"
- **NO** avances al siguiente momento solo por mostrar el contenido
- **DEBES** hacer las preguntas espec√≠ficas del momento
- **SI** el estudiante dice "ok", "s√≠", etc., **ay√∫dalo** con pistas docentes
- **NO** esperes a que el estudiante hable primero, t√∫ gu√≠a la conversaci√≥n.

**FORMATO DE RESPUESTA OBLIGATORIO:**
Debes responder √öNICAMENTE en formato JSON v√°lido, sin texto adicional:

\`\`\`json
{
  "respuesta": "Tu respuesta como docente aqu√≠",
  "momento_actual": "${momentoActual?.momento || 'N/A'}",
  "progreso": ${params.currentIndex + 1},
  "total_momentos": ${params.momentos.length},
  "debe_avanzar": true,
  "razon_avance": "Todas las preguntas del momento han sido respondidas completamente",
  "siguiente_momento": "${siguiente}"
}
\`\`\`

**REGLAS PARA debe_avanzar:**
- **debe_avanzar: true** ‚Üí SOLO si el estudiante ha respondido TODAS las preguntas del momento de manera completa y espec√≠fica
- **debe_avanzar: false** ‚Üí Si el estudiante no ha respondido todas las preguntas, responde parcialmente, o solo dice "ok", "s√≠", etc.

**IMPORTANTE:** Mostrar el contenido (historia, teor√≠a, caso) NO es suficiente para avanzar. DEBES hacer las preguntas espec√≠ficas del momento.

**EJEMPLO:**
- Estudiante dice "ok" ‚Üí debe_avanzar: false
- Estudiante responde solo 1 de 4 preguntas ‚Üí debe_avanzar: false  
- Estudiante responde las 4 preguntas completamente ‚Üí debe_avanzar: true
- Solo mostrar historia/teor√≠a sin preguntas ‚Üí debe_avanzar: false

**NO incluyas texto fuera del JSON. NO uses markdown. SOLO el JSON.**`.trim();
  }

  /**
   * Construye el prompt del usuario optimizado
   */
  static buildUserPrompt(studentMessage: string, context: UserPromptContext): string {
    const [progresoActual, totalMomentos] = context.progress.split('/');
    
    return `Estudiante: "${studentMessage}"

Responde en JSON:
{
  "respuesta": "Respuesta del docente",
  "momento_actual": "${context.currentMoment}",
  "progreso": ${progresoActual},
  "total_momentos": ${totalMomentos},
  "debe_avanzar": true,
  "razon_avance": "Todas las preguntas del momento han sido respondidas completamente",
  "siguiente_momento": "MOMENTO_X"
}

**REGLAS PARA debe_avanzar:**
- **debe_avanzar: true** ‚Üí SOLO si el estudiante ha respondido TODAS las preguntas del momento de manera completa y espec√≠fica
- **debe_avanzar: false** ‚Üí Si el estudiante no ha respondido todas las preguntas, responde parcialmente, o solo dice "ok", "s√≠", etc.

**EJEMPLO:**
- Estudiante dice "ok" ‚Üí debe_avanzar: false
- Estudiante responde solo 1 de 3 preguntas ‚Üí debe_avanzar: false  
- Estudiante responde las 3 preguntas completamente ‚Üí debe_avanzar: true`;
  }

  /**
   * Carga el archivo de sesi√≥n seg√∫n el curso y sesi√≥n
   */
  static async loadSessionFile(courseId: string, sessionId: string): Promise<any> {
    try {
      const sessionFileName = `${courseId}_${sessionId}.json`;
      
      // Intentar m√∫ltiples rutas posibles para import din√°mico
      const possiblePaths = [
        `../data/sessions/${sessionFileName}`,
        `../../data/sessions/${sessionFileName}`,
        `../../../data/sessions/${sessionFileName}`
      ];
      
      let sessionData: any = null;
      let lastError: any = null;
      
      for (const sessionPath of possiblePaths) {
        try {
          sessionData = await import(sessionPath);
          console.log(`‚úÖ Sesi√≥n cargada desde: ${sessionPath}`);
          break;
        } catch (error) {
          lastError = error;
          continue;
        }
      }
      
      if (!sessionData) {
        throw lastError || new Error(`No se pudo cargar la sesi√≥n ${courseId}_${sessionId}`);
      }
      
      return sessionData.default || sessionData;
    } catch (error) {
      console.error(`Error cargando sesi√≥n ${courseId}_${sessionId}:`, error);
      throw new Error(`No se pudo cargar la sesi√≥n ${courseId}_${sessionId}`);
    }
  }

  /**
   * Obtiene la informaci√≥n de la sesi√≥n desde el archivo JSON
   */
  static async getSessionData(courseId: string, sessionId: string): Promise<{
    curso: string;
    sesion: string;
    nombre: string;
    objetivo: string;
    momentos: any[];
  }> {
    const sessionData = await this.loadSessionFile(courseId, sessionId);
    
    return {
      curso: sessionData.curso,
      sesion: sessionData.sesion,
      nombre: sessionData.nombre,
      objetivo: sessionData.objetivo,
      momentos: sessionData.momentos || []
    };
  }
} 
```
=== EOF: src\services\PromptBuilder.ts

===  src\services\OpenAIService.ts
```typescript
import { OpenAI } from 'openai';
import { OpenAICallParams, OpenAICallResult } from '../types';
import { CostMonitor } from './CostMonitor';

export class OpenAIService {
  private client: OpenAI;
  private costMonitor: CostMonitor;

  constructor(apiKey: string) {
    this.client = new OpenAI({ apiKey });
    this.costMonitor = new CostMonitor();
  }

  /**
   * Llama a la API de OpenAI con par√°metros optimizados
   */
  async callOpenAI(params: OpenAICallParams): Promise<OpenAICallResult> {
    const model = params.model || this.getOptimalModel(params.systemPrompt);
    const maxTokens = Math.floor(params.maxTokens || this.calculateOptimalTokens(params.systemPrompt));

    try {
      const response = await this.client.responses.create({
        model,
        instructions: params.systemPrompt,
        input: params.userPrompt,
        max_output_tokens: maxTokens
      });

      const metrics = this.costMonitor.calculateMetrics(
        { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }, // OpenAI no devuelve usage en responses API
        model
      );
      this.costMonitor.logUsage(metrics);

      return { response, metrics };
    } catch (error) {
      console.error('Error en llamada a OpenAI:', error);
      throw error;
    }
  }

  /**
   * Selecciona el modelo √≥ptimo basado en la complejidad del prompt
   */
  private getOptimalModel(systemPrompt: string): string {
    const tokenCount = systemPrompt.length / 4; // Estimaci√≥n aproximada
    
    // Para prompts simples, usar gpt-3.5-turbo
    if (tokenCount < 800) {
      return 'gpt-3.5-turbo';
    }
    
    // Para prompts complejos, usar gpt-4o
    return 'gpt-4o';
  }

  /**
   * Calcula tokens √≥ptimos basado en la complejidad
   */
  private calculateOptimalTokens(systemPrompt: string): number {
    const baseTokens = 600;
    const complexity = systemPrompt.length / 1000;
    
    // Limitar entre 400 y 1000 tokens y convertir a entero
    return Math.floor(Math.min(Math.max(baseTokens + (complexity * 100), 400), 1000));
  }



  /**
   * Obtiene estad√≠sticas de costo
   */
  getCostStats() {
    return this.costMonitor.getCostStats();
  }

  /**
   * Limpia costos de una sesi√≥n
   */
  clearSessionCost(sessionKey: string): void {
    this.costMonitor.clearSessionCost(sessionKey);
  }

  /**
   * Limpia todos los costos
   */
  clearAllCosts(): void {
    this.costMonitor.clearAllCosts();
  }

  /**
   * Agrega costo a una sesi√≥n espec√≠fica
   */
  addSessionCost(sessionKey: string, cost: number): void {
    this.costMonitor.addSessionCost(sessionKey, cost);
  }

  /**
   * Obtiene el cliente OpenAI (para uso interno)
   */
  getClient(): OpenAI {
    return this.client;
  }
} 
```
=== EOF: src\services\OpenAIService.ts

===  src\services\CostMonitor.ts
```typescript
import { CostMetrics } from '../types';

export class CostMonitor {
  private static readonly COSTS = {
    'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 },
    'gpt-4o': { input: 0.005, output: 0.015 },
    'gpt-4o-mini': { input: 0.00015, output: 0.0006 }
  };

  private sessionCosts = new Map<string, number>();
  private totalCost = 0;
  private totalTokens = 0;

  /**
   * Calcula m√©tricas de costo basadas en el uso de tokens
   */
  calculateMetrics(usage: any, model: string): CostMetrics {
    const costs = CostMonitor.COSTS[model as keyof typeof CostMonitor.COSTS];
    if (!costs) {
      console.warn(`Modelo ${model} no encontrado en costos, usando gpt-3.5-turbo`);
      return this.calculateMetrics(usage, 'gpt-3.5-turbo');
    }

    const estimatedCost = (usage.prompt_tokens * costs.input + usage.completion_tokens * costs.output) / 1000;

    return {
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
      total_tokens: usage.total_tokens,
      estimated_cost: estimatedCost,
      model_used: model
    };
  }

  /**
   * Registra el uso de tokens y costo
   */
  logUsage(metrics: CostMetrics, sessionKey?: string): void {
    console.log(`üí∞ Costo estimado: $${metrics.estimated_cost.toFixed(4)}`);
    console.log(`üìä Tokens: ${metrics.prompt_tokens} + ${metrics.completion_tokens} = ${metrics.total_tokens}`);
    console.log(`ü§ñ Modelo: ${metrics.model_used}`);

    // Actualizar totales
    this.totalCost += metrics.estimated_cost;
    this.totalTokens += metrics.total_tokens;

    // Actualizar costo por sesi√≥n
    if (sessionKey) {
      this.addSessionCost(sessionKey, metrics.estimated_cost);
    }
  }

  /**
   * Obtiene el costo total de una sesi√≥n
   */
  getSessionCost(sessionKey: string): number {
    return this.sessionCosts.get(sessionKey) || 0;
  }

  /**
   * Agrega costo a una sesi√≥n espec√≠fica
   */
  addSessionCost(sessionKey: string, cost: number): void {
    const current = this.sessionCosts.get(sessionKey) || 0;
    this.sessionCosts.set(sessionKey, current + cost);
  }

  /**
   * Obtiene estad√≠sticas de costo
   */
  getCostStats(): { totalCost: number; totalTokens: number; sessionCosts: Map<string, number> } {
    return {
      totalCost: this.totalCost,
      totalTokens: this.totalTokens,
      sessionCosts: this.sessionCosts
    };
  }

  /**
   * Limpia los costos de una sesi√≥n
   */
  clearSessionCost(sessionKey: string): void {
    this.sessionCosts.delete(sessionKey);
  }

  /**
   * Limpia todos los costos
   */
  clearAllCosts(): void {
    this.sessionCosts.clear();
    this.totalCost = 0;
    this.totalTokens = 0;
  }

  /**
   * Obtiene el costo promedio por sesi√≥n
   */
  getAverageSessionCost(): number {
    if (this.sessionCosts.size === 0) return 0;
    const totalSessionCost = Array.from(this.sessionCosts.values()).reduce((sum, cost) => sum + cost, 0);
    return totalSessionCost / this.sessionCosts.size;
  }
} 
```
=== EOF: src\services\CostMonitor.ts

===  src\scripts\package.json
```json
{
  "type": "commonjs"
} 
```
=== EOF: src\scripts\package.json

===  src\scripts\chat-v2.ts
```typescript
import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import { SessionExtractorUniversal } from '../lib/SessionExtractorUniversal';
import { Course, Session } from '../types';
import * as dotenv from 'dotenv';

// Configurar variables de entorno
dotenv.config({ path: path.join(__dirname, '../../.env.local') });

// Colores para la terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Estado global de la conversaci√≥n
interface ConversationState {
  selectedCourse: Course | null;
  selectedSession: Session | null;
  sessionExtractor: SessionExtractorUniversal | null;
  currentSessionKey: string | null;
  momentoActual: number;
  momentos: any[];
  messages: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp: Date;
  }>;
  isInClass: boolean;
}

const conversationState: ConversationState = {
  selectedCourse: null,
  selectedSession: null,
  sessionExtractor: null,
  currentSessionKey: null,
  momentoActual: 0,
  momentos: [],
  messages: [],
  isInClass: false
};

// Funci√≥n para imprimir con colores
function print(color: keyof typeof colors, text: string): void {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// Funci√≥n para cargar la base de datos de cursos
function loadCoursesDatabase(): any {
  try {
    const filePath = path.join(__dirname, '../data/courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch {
    print('red', '‚ùå Error cargando la base de datos de cursos');
    return null;
  }
}

// Funci√≥n para mostrar cursos disponibles
function showCourses(): void {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return;
  
  print('cyan', '\nüìö Cursos Disponibles:');
  data.courses.forEach((course: Course, index: number) => {
    print('white', `${index + 1}. ${course.id} - ${course.name}`);
    print('yellow', `   üë®‚Äçüè´ ${course.specialist_role}`);
    print('yellow', `   üìä ${course.sessions.length} sesiones disponibles`);
  });
  print('yellow', '\nüí° Usa: /select <curso> <sesi√≥n> para seleccionar');
  print('yellow', '   Ejemplo: /select SSO001 1');
}

// Funci√≥n para seleccionar curso y sesi√≥n
async function selectCourse(courseId: string, sessionNumber: number): Promise<void> {
  try {
    const sessionId = `sesion0${sessionNumber}`;
    
    // Cargar datos del curso desde la base de datos
    const data = loadCoursesDatabase();
    if (!data || !data.courses) {
      console.error('‚ùå No se pudo cargar la base de datos de cursos');
      return;
    }
  
    const course = data.courses.find((c: Course) => c.id === courseId);
    if (!course) {
      console.error(`‚ùå Curso ${courseId} no encontrado`);
      return;
    }
  
    // Validar que el n√∫mero de sesi√≥n sea v√°lido
    if (sessionNumber < 1 || sessionNumber > course.sessions.length) {
      console.error(`‚ùå Sesi√≥n ${sessionNumber} no encontrada. Sesiones disponibles: 1-${course.sessions.length}`);
      return;
    }
  
    const session = course.sessions[sessionNumber - 1];
    if (!session) {
      console.error(`‚ùå Sesi√≥n ${sessionNumber} no encontrada`);
      return;
    }
    
    // Actualizar estado de la conversaci√≥n
    conversationState.selectedCourse = course;
    conversationState.selectedSession = session;
    
    console.log(`‚úÖ Curso seleccionado: ${course.name}`);
    console.log(`‚úÖ Sesi√≥n seleccionada: ${session.name}`);
    console.log(`‚úÖ Especialista: ${course.specialist_role}`);
    console.log(`‚úÖ Objetivo: ${session.learning_objective}`);
    console.log(`üìÅ Archivo de sesi√≥n: ${courseId}_${sessionId}.json`);

    // Inicializar el extractor universal
    conversationState.sessionExtractor = new SessionExtractorUniversal();
    
    console.log(`üöÄ Iniciando sesi√≥n...`);
    
    // Iniciar sesi√≥n cargando JSON directamente
    const sessionInfo = await conversationState.sessionExtractor.startSession(courseId, sessionId);
    conversationState.currentSessionKey = sessionInfo.sessionKey;
    
    console.log(`‚úÖ Sesi√≥n iniciada: ${sessionInfo.momentos} momentos`);
    console.log(`‚úÖ Clave de sesi√≥n: ${sessionInfo.sessionKey}`);
    console.log(`‚úÖ Momento actual: ${sessionInfo.currentMoment}`);

    // Obtener momentos para mostrar estructura
    const sessionData = conversationState.sessionExtractor.getSessionInfo(sessionInfo.sessionKey);
    conversationState.momentos = sessionData?.momentos || [];
    conversationState.momentoActual = 0;

    console.log(`üìÑ Momentos extra√≠dos: ${conversationState.momentos.length}`);
    console.log(`üîó Estructura de la clase:`);
    conversationState.momentos.forEach((momento: any, index: number) => {
      console.log(`   ${index + 1}. ${momento.momento}`);
    });

  } catch (error) {
    console.error(`‚ùå Error seleccionando curso: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

// Funci√≥n para procesar mensajes del estudiante
async function processStudentMessage(message: string): Promise<void> {
  if (!conversationState.selectedCourse || !conversationState.selectedSession || !conversationState.currentSessionKey) {
    print('red', '‚ùå Debes seleccionar un curso y sesi√≥n primero con /select');
    return;
  }

  try {
    print('cyan', `\nüë§ Estudiante: ${message}`);

    // Usar el m√©todo simplificado
    const respuesta = await conversationState.sessionExtractor!.handleStudent(
      conversationState.currentSessionKey, 
      message
    );

    // Actualizar estado de la conversaci√≥n
    conversationState.momentoActual = respuesta.progreso - 1; // Convertir progreso a √≠ndice

    // Agregar mensajes al historial
    conversationState.messages.push({
      role: 'user',
      content: message,
      timestamp: new Date()
    });
    conversationState.messages.push({
      role: 'assistant',
      content: respuesta.respuesta,
      timestamp: new Date()
    });

    // Mostrar respuesta del docente
    print('green', `\nüìÅ ${conversationState.selectedCourse.specialist_role}:`);
    print('white', respuesta.respuesta);
    print('cyan', `üöÄ Progreso: ${respuesta.progreso}/${respuesta.total_momentos}`);
    print('cyan', `üìÅ Momento actual: ${respuesta.momento_actual}`);
    print('cyan', `üìÅ ${respuesta.razon_avance}`);
    print('yellow', `‚è≠Ô∏è Siguiente: ${respuesta.siguiente_momento}`);

  } catch (error) {
    print('red', `‚ùå Error procesando mensaje: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

// Funci√≥n para mostrar el progreso actual
function showProgress(): void {
  if (!conversationState.selectedCourse || !conversationState.selectedSession) {
    print('red', '‚ùå No est√°s en una clase');
    return;
  }

  print('cyan', '\nüìä PROGRESO DE LA SESI√ìN:');
  print('white', `üìÅ Curso: ${conversationState.selectedCourse.name}`);
  print('white', `üìö Sesi√≥n: ${conversationState.selectedSession.name}`);
  print('white', `üë®‚Äçüè´ Especialista: ${conversationState.selectedCourse.specialist_role}`);
  print('white', `   Sesi√≥n activa: ${conversationState.currentSessionKey || 'N/A'}`);
  
  // Mostrar estad√≠sticas del sistema si hay extractor
  if (conversationState.sessionExtractor) {
    const stats = conversationState.sessionExtractor.getCacheStats();
    print('cyan', `\nüìä ESTAD√çSTICAS DEL SISTEMA:`);
    print('white', `   üéì Sesiones activas: ${stats.activeSessions}`);
    print('white', `   üíæ Cache: ${stats.cacheSize} elementos`);
    print('white', `   üéì Tama√±o de sesiones: ${stats.sessionsSize}`);
  } else {
    print('red', '‚ùå No hay extractor inicializado');
  }
  
  if (conversationState.messages && conversationState.messages.length > 0) {
    print('cyan', `\nüí¨ Mensajes intercambiados: ${conversationState.messages.length}`);
  }
}

// Funci√≥n para procesar comandos
async function processCommand(input: string): Promise<void> {
  const parts = input.trim().split(' ');
  const command = parts[0];
  
  switch (command) {
    case '/select':
      if (parts.length < 3) {
        print('red', '‚ùå Uso: /select <courseId> <sessionNumber>');
        print('yellow', '   Ejemplo: /select SSO001 1');
        return;
      }
      const courseId = parts[1];
      const sessionNumber = parseInt(parts[2]);
      await selectCourse(courseId, sessionNumber);
      break;
      
    case '/start':
      if (!conversationState.selectedCourse || !conversationState.selectedSession) {
        print('red', '‚ùå Debes seleccionar un curso y sesi√≥n primero con /select');
        return;
      }
      conversationState.isInClass = true;
      print('green', `üíæ ¬°Bienvenido a la clase de ${conversationState.selectedSession.name}!`);
      print('cyan', `üß† Docente IA especializado cargado`);
      print('cyan', `üìÅ Contenido cargado desde archivo JSON`);
      print('cyan', `‚ö° Interfaz interactiva lista`);
      print('cyan', `üîóüè´üè´ ¬°Hola! Soy tu ${conversationState.selectedCourse.specialist_role}`);
      print('cyan', `üöÄ Hoy aprenderemos sobre: ${conversationState.selectedSession.name}`);
      print('cyan', `üöÄ Objetivo: ${conversationState.selectedSession.learning_objective}`);
      print('cyan', `üìÅ Empezaremos con: MOMENTO_0`);
      print('cyan', `üë§ ¬°Escribe tu mensaje para comenzar la interacci√≥n!`);
      break;
      
    case '/sessions':
          if (conversationState.sessionExtractor) {
      const sessions = conversationState.sessionExtractor.listActiveSessions();
        if (sessions.length === 0) {
          print('yellow', 'üìã No hay sesiones activas');
        } else {
          print('cyan', 'üìã Sesiones activas:');
          sessions.forEach(session => {
            print('white', `   ${session.sessionKey}: ${session.course} - ${session.session} (${session.progress})`);
          });
        }
      } else {
        print('red', '‚ùå No hay extractor inicializado');
      }
      break;

    case '/clear-session':
      if (parts.length < 2) {
        print('red', '‚ùå Uso: /clear-session <sessionKey>');
        return;
      }
      if (conversationState.sessionExtractor) {
        const sessionKey = parts[1];
        const cleared = conversationState.sessionExtractor.clearSession(sessionKey);
        print(cleared ? 'green' : 'red', `‚úÖ Sesi√≥n ${sessionKey} eliminada`);
      }
      break;

    case '/clear-all-sessions':
      if (conversationState.sessionExtractor) {
        conversationState.sessionExtractor.clearAllSessions();
        print('green', '‚úÖ Todas las sesiones eliminadas');
      }
      break;
      
    case '/progress':
      showProgress();
      break;
      
    case '/stats':
      if (conversationState.sessionExtractor) {
        const stats = conversationState.sessionExtractor.getCacheStats();
        print('cyan', '\nüìä ESTAD√çSTICAS DEL SISTEMA:');
        print('white', `   üéì Sesiones activas: ${stats.activeSessions}`);
        print('white', `   üíæ Tama√±o del cache: ${stats.cacheSize}`);
        print('white', `   üéì Tama√±o de sesiones: ${stats.sessionsSize}`);
      } else {
        print('red', '‚ùå No hay extractor inicializado');
      }
      break;
      
    case '/reset':
      conversationState.selectedCourse = null;
      conversationState.selectedSession = null;
      conversationState.sessionExtractor = null;
      conversationState.currentSessionKey = null;
      conversationState.momentoActual = 0;
      conversationState.momentos = [];
      conversationState.messages = [];
      conversationState.isInClass = false;
      print('green', '‚úÖ Estado de conversaci√≥n reiniciado');
      break;
      
    case '/help':
      showHelp();
      break;
      
    case '/exit':
      print('yellow', 'üëã ¬°Hasta luego!');
      process.exit(0);
      break;
      
    default:
      print('red', `‚ùå Comando no reconocido. Usa /help para ver comandos disponibles.`);
  }
}

// Funci√≥n para mostrar ayuda
function showHelp(): void {
  print('cyan', '\nüìö DOCENTEIA - COMANDOS DISPONIBLES:');
  print('white', '\nüéØ SELECCI√ìN Y CONTROL:');
  print('yellow', '   /select <courseId> <sessionNumber>  - Seleccionar curso y sesi√≥n');
  print('yellow', '   /start                              - Iniciar la clase interactiva');
  print('yellow', '   /reset                              - Reiniciar estado de conversaci√≥n');

  print('white', '\nüìã GESTI√ìN DE SESIONES:');
  print('yellow', '   /sessions                           - Listar sesiones activas');
  print('yellow', '   /clear-session <sessionKey>         - Eliminar sesi√≥n espec√≠fica');
  print('yellow', '   /clear-all-sessions                 - Eliminar todas las sesiones');

  print('white', '\nüìä INFORMACI√ìN:');
  print('yellow', '   /progress                           - Mostrar progreso actual');
  print('yellow', '   /stats                              - Estad√≠sticas del sistema');
  print('yellow', '   /help                               - Mostrar esta ayuda');

  print('white', '\nüí¨ INTERACCI√ìN:');
  print('yellow', '   Escribe cualquier mensaje para interactuar con el docente IA');
  print('yellow', '   El sistema avanzar√° autom√°ticamente entre momentos seg√∫n tu progreso');

  print('cyan', '\n‚ö° CARACTER√çSTICAS OPTIMIZADAS:');
  print('white', '   ‚Ä¢ Fragmentos pre-calculados para respuestas m√°s r√°pidas');
  print('white', '   ‚Ä¢ Gesti√≥n inteligente de sesiones');
  print('white', '   ‚Ä¢ Coordinaci√≥n autom√°tica del avance de la clase');
  print('white', '   ‚Ä¢ Cache optimizado para mejor rendimiento');
  print('white', '   ‚Ä¢ Control de costos en tiempo real');
  print('white', '   ‚Ä¢ Selecci√≥n din√°mica de modelos');
}

// Funci√≥n principal del chat
function startChat(): void {
  // Crear interfaz de readline
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });
  
  print('cyan', 'ü§ñ Chat Terminal - DocenteIA v3.0 (TypeScript + Optimizaciones)');
  print('cyan', 'Escribe /help para ver comandos\n');
  
  // Mostrar cursos disponibles
  showCourses();
  
  // Loop principal de conversaci√≥n
  const askQuestion = () => {
    rl.question(`${colors.green}üë§ T√∫: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();
      
      if (!trimmedInput) {
        askQuestion();
        return;
      }
      
      // Procesar comandos
      if (trimmedInput.startsWith('/')) {
        await processCommand(trimmedInput);
        askQuestion();
        return;
      }
      
      // Si estamos en clase, procesar como mensaje del estudiante
      if (conversationState.isInClass) {
        await processStudentMessage(trimmedInput);
      } else {
        print('yellow', 'üí° Usa /select para elegir un curso y sesi√≥n, luego /start para iniciar la clase');
      }
      
      askQuestion();
    });
  };
  
  askQuestion();
}

// Manejar se√±ales de salida
process.on('SIGINT', () => {
  print('green', '\nüëã ¬°Hasta luego!');
  process.exit(0);
});

// Iniciar el chat
startChat(); 
```
=== EOF: src\scripts\chat-v2.ts

===  src\lib\utils.ts
```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("es-ES", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date)
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
} 
```
=== EOF: src\lib\utils.ts

===  src\lib\SessionExtractorUniversal.ts
```typescript
import { AIResponse } from '../types';
import { OpenAIService } from '../services/OpenAIService';
import { SessionManager } from '../services/SessionManager';
import { PromptBuilderUniversal } from '../services/PromptBuilderUniversal';

export class SessionExtractorUniversal {
  private openAIService: OpenAIService;
  private sessionManager: SessionManager;
  private intentosEvasion: Map<string, number> = new Map(); // Contador de intentos por momento

  constructor() {
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY!);
    this.sessionManager = new SessionManager();
  }

  /**
   * Inicia una sesi√≥n cargando JSON directamente
   */
  async startSession(courseId: string, sessionId: string): Promise<{
    sessionKey: string;
    momentos: number;
    currentMoment: string;
  }> {
    try {
      // Iniciar sesi√≥n b√°sica
      const sessionKey = await this.sessionManager.startSession(courseId, sessionId);
      const session = this.sessionManager.getSession(sessionKey);
      
      if (!session) {
        throw new Error('Error iniciando sesi√≥n');
      }

      console.log(`üöÄ Iniciando sesi√≥n: ${session.course.name} - ${session.session.name}`);
      console.log(`üìÅ Archivo: ${session.sessionFile}`);
      console.log(`‚úÖ Sesi√≥n iniciada: ${session.momentos.length} momentos`);

      return {
        sessionKey,
        momentos: session.momentos.length,
        currentMoment: session.momentos[0]?.momento || 'N/A'
      };

    } catch (error) {
      console.error('Error iniciando sesi√≥n:', error);
      throw error;
    }
  }

  /**
   * Maneja la interacci√≥n del estudiante con control de preguntas
   */
  async handleStudent(sessionKey: string, studentMessage: string): Promise<AIResponse> {
    try {
      const session = this.sessionManager.getSession(sessionKey);
      if (!session) {
        throw new Error(`Sesi√≥n ${sessionKey} no encontrada`);
      }

      // Actualizar √∫ltima actividad
      this.sessionManager.updateSession(sessionKey, { lastActivity: new Date() });

      console.log(`üéì ${session.course.specialist_role} respondiendo...`);

      // Guardar mensaje del estudiante en la memoria conversacional
      session.conversationLog.push({
        role: 'user',
        content: studentMessage,
        timestamp: new Date()
      });

      // Obtener el momento actual
      const momentoActual = session.momentos[session.currentMomentIndex] || null;
      const siguienteMomento = session.momentos[session.currentMomentIndex + 1] || null;

      // Construir historial de conversaci√≥n (√∫ltimas 6 interacciones)
      const MAX_HISTORIA = 6;
      const historialRecortado = session.conversationLog
        .slice(-MAX_HISTORIA)
        .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: "${m.content}"`)
        .join('\n');

      // Preparar mensajes para OpenAI
      let finalSystemPrompt = '';
      
      // Si es el primer turno, enviar el mensaje de "esp√≠ritu"
      if (session.isFirstTurn) {
        const spiritPrompt = PromptBuilderUniversal.buildSpiritPrompt({
          specialistRole: session.course.specialist_role,
          sessionName: session.session.name,
          courseName: session.course.name,
          learningObjective: session.session.learning_objective
        });
        finalSystemPrompt += spiritPrompt + '\n\n';
        
        // Marcar que ya no es el primer turno
        this.sessionManager.updateSession(sessionKey, { isFirstTurn: false });
      }

      // Agregar historial de conversaci√≥n si existe
      if (historialRecortado.trim()) {
        finalSystemPrompt += `HISTORIAL RECIENTE DE LA CLASE:\n${historialRecortado}\n\n`;
      }

      // Construir prompt del momento usando PromptBuilderUniversal
      const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
        specialistRole: session.course.specialist_role,
        sessionName: session.session.name,
        courseName: session.course.name,
        learningObjective: session.session.learning_objective,
        keyPoints: session.session.key_points,
        momentos: session.momentos,
        currentIndex: session.currentMomentIndex,
        preguntasPendientes: session.preguntasPendientes,
        preguntasRespondidas: session.preguntasRespondidas
      });

      finalSystemPrompt += momentPrompt;

      // Llamar a OpenAI
      const { response, metrics } = await this.openAIService.callOpenAI({
        systemPrompt: finalSystemPrompt,
        userPrompt: studentMessage,
        model: 'gpt-3.5-turbo'
      });

      // Registrar costo de la sesi√≥n
      this.openAIService.clearSessionCost(sessionKey);
      this.openAIService.addSessionCost(sessionKey, metrics.estimated_cost);

      // Parsear respuesta JSON del modelo
      let parsedResponse = this.parseAIResponse(response.output_text);
      
      // Asegurar que la respuesta tenga la estructura correcta
      if (!parsedResponse || typeof parsedResponse !== 'object') {
        parsedResponse = {
          respuesta: response.output_text,
          momento_actual: momentoActual ? momentoActual.momento : 'N/A',
          progreso: session.currentMomentIndex + 1,
          total_momentos: session.momentos.length,
          debe_avanzar: false,
          razon_avance: "Respuesta no estructurada",
          siguiente_momento: siguienteMomento ? siguienteMomento.momento : 'FIN',
          pregunta_actual: session.preguntasPendientes[0] || 'N/A',
          preguntas_pendientes: session.preguntasPendientes.length,
          preguntas_respondidas: session.preguntasRespondidas.length
        };
      }

      // FORZAR PREGUNTA AL FINAL (excepto en cierre final)
      const siguienteMomentoCheck = session.momentos[session.currentMomentIndex + 1];
      const isLastMoment = !siguienteMomentoCheck;
      const isLastQuestion = session.preguntasPendientes.length <= 1;
      
      if (!isLastMoment && !parsedResponse.respuesta.trim().endsWith("?")) {
        const nextQuestion = session.preguntasPendientes[0] || "¬øPuedes elaborar m√°s tu respuesta?";
        parsedResponse.respuesta = `${parsedResponse.respuesta.trim()} ${nextQuestion}`;
        console.log(`‚ùì Forzando pregunta al final: "${nextQuestion}"`);
      }

      // Guardar respuesta del docente en la memoria conversacional
      session.conversationLog.push({
        role: 'assistant',
        content: parsedResponse.respuesta,
        timestamp: new Date()
      });

      // Procesar la respuesta del estudiante y actualizar preguntas
      this.processStudentResponse(sessionKey, studentMessage, parsedResponse);

      // CONTROL ESTRICTO DE AVANCE - Solo avanza si no hay preguntas pendientes
      if (session.preguntasPendientes.length > 0) {
        parsedResponse.debe_avanzar = false;
        parsedResponse.razon_avance = `A√∫n hay ${session.preguntasPendientes.length} pregunta(s) pendiente(s)`;
        console.log(`üö´ Bloqueando avance: ${session.preguntasPendientes.length} preguntas pendientes`);
      }

      // Actualizar progreso si debe avanzar (despu√©s del control estricto)
      if (parsedResponse.debe_avanzar && session.currentMomentIndex < session.momentos.length - 1) {
        const nuevoIndice = session.currentMomentIndex + 1;
        const nuevoMomento = session.momentos[nuevoIndice];
        
        // Actualizar √≠ndice y preguntas del nuevo momento
        this.sessionManager.updateSession(sessionKey, {
          currentMomentIndex: nuevoIndice,
          preguntasPendientes: nuevoMomento?.preguntas || [],
          preguntasRespondidas: []
        });
        
        console.log(`üíæ Avanzando al momento ${nuevoIndice + 1}: ${nuevoMomento?.momento}`);
        
        // Generar respuesta inmediata para el nuevo momento
        return await this.generateNewMomentResponse(sessionKey, nuevoIndice);
      } else if (parsedResponse.debe_avanzar) {
        console.log(`üéâ ¬°Clase completada! Todos los momentos han sido cubiertos.`);
      }

      return {
        ...parsedResponse,
        momentos: session.momentos,
        sessionKey
      };

    } catch (error) {
      console.error('Error en respuesta del docente:', error);
      return {
        respuesta: "Lo siento, tuve un problema generando la respuesta. ¬øPodr√≠as reformular tu pregunta?",
        momento_actual: 'ERROR',
        progreso: 0,
        total_momentos: 0,
        debe_avanzar: false,
        razon_avance: "Error en el sistema",
        siguiente_momento: 'ERROR',
        momentos: [],
        sessionKey
      };
    }
  }

  /**
   * Procesa la respuesta del estudiante y actualiza las preguntas
   */
  private processStudentResponse(sessionKey: string, studentMessage: string, aiResponse: any): void {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) return;

    const preguntaActual = session.preguntasPendientes[0];
    if (!preguntaActual) return;

    // Verificar si la respuesta es evasiva
    const isEvasion = PromptBuilderUniversal.isEvasionResponse(studentMessage);
    
    if (!isEvasion && studentMessage.trim().length > 10) {
      // Respuesta v√°lida - mover pregunta de pendiente a respondida
      const nuevasPendientes = session.preguntasPendientes.slice(1);
      const nuevasRespondidas = [...session.preguntasRespondidas, preguntaActual];
      
      this.sessionManager.updateSession(sessionKey, {
        preguntasPendientes: nuevasPendientes,
        preguntasRespondidas: nuevasRespondidas
      });
      
      console.log(`‚úÖ Pregunta respondida: "${preguntaActual}"`);
      console.log(`üìã Preguntas pendientes: ${nuevasPendientes.length}`);
      
      // TRANSICI√ìN AUTOM√ÅTICA: Si no hay m√°s preguntas pendientes, preparar siguiente momento
      if (nuevasPendientes.length === 0) {
        console.log(`üéØ ¬°Todas las preguntas del momento respondidas! Preparando transici√≥n...`);
        aiResponse.debe_avanzar = true;
        aiResponse.razon_avance = "Todas las preguntas del momento han sido respondidas completamente";
        
        // Limpiar contador de intentos para el siguiente momento
        const siguienteMomento = session.momentos[session.currentMomentIndex + 1];
        if (siguienteMomento) {
          this.intentosEvasion.delete(siguienteMomento.momento);
        }
      }
    } else {
      console.log(`‚ö†Ô∏è Respuesta evasiva detectada: "${studentMessage}"`);
      
      // AYUDAR AL ESTUDIANTE A RESOLVER LA PREGUNTA
      const momentoActual = session.momentos[session.currentMomentIndex];
      
      // Incrementar contador de intentos para este momento
      const momentoKey = momentoActual?.momento || '';
      const intentosActuales = this.intentosEvasion.get(momentoKey) || 0;
      this.intentosEvasion.set(momentoKey, intentosActuales + 1);
      
      // Construir respuesta que ayude al estudiante
      const ayudaRespuesta = this.buildHelpfulResponse(studentMessage, preguntaActual, momentoKey);
      
      aiResponse.respuesta = ayudaRespuesta;
      aiResponse.debe_avanzar = false;
      aiResponse.razon_avance = "Ayudando al estudiante a resolver la pregunta";
      
      console.log(`üîÑ Ayudando al estudiante (intento ${intentosActuales + 1}): "${ayudaRespuesta.substring(0, 50)}..."`);
    }
  }

  /**
   * Construye una respuesta que ayude al estudiante a resolver la pregunta
   */
  private buildHelpfulResponse(studentMessage: string, preguntaActual: string, momentoName: string): string {
    const cleanMessage = studentMessage.toLowerCase();
    
    // Detectar el tipo de evasiva para dar ayuda espec√≠fica
    if (cleanMessage.includes('no s√©') || cleanMessage.includes('no se')) {
      return this.buildNoSeResponse(preguntaActual, momentoName);
    } else if (cleanMessage.includes('no recuerdo') || cleanMessage.includes('no tengo idea')) {
      return this.buildNoRecuerdoResponse(preguntaActual, momentoName);
    } else if (cleanMessage.length < 10) {
      return this.buildShortResponse(preguntaActual, momentoName);
    } else {
      // Respuesta que contiene informaci√≥n pero necesita ayuda
      return this.buildPartialResponse(studentMessage, preguntaActual, momentoName);
    }
  }

  /**
   * Respuesta para "no s√©" con rotaci√≥n de pistas
   */
  private buildNoSeResponse(pregunta: string, momento: string): string {
    // Usar el contador de intentos por momento
    const intentos = this.intentosEvasion.get(momento) || 0;
    
    const ayudas = {
      'saludo': [
        "Entiendo que no sepas mucho sobre incendios, eso est√° bien. Te ayudo: los incendios en el trabajo pueden ser causados por chispas, sobrecargas el√©ctricas, o materiales inflamables. ¬øHas visto alguna de estas situaciones en tu trabajo?",
        "No te preocupes por no saber todo. Piensa en tu trabajo: ¬øhas visto alguna vez cables pelados, herramientas que hacen chispas, o materiales apilados cerca de algo caliente?",
        "Vamos a simplificar: ¬øen tu trabajo hay cosas que pueden arder? ¬øHay fuentes de calor como m√°quinas, estufas, o soldadoras?"
      ],
      'conexi√≥n': [
        "No te preocupes si no recuerdas casos espec√≠ficos. Piensa en situaciones comunes: ¬øhas visto cables en mal estado, herramientas que generan chispas, o materiales apilados cerca de fuentes de calor?",
        "Vamos a pensar diferente: ¬øhas estado en lugares donde hay trabajos que generan chispas o calor? ¬øO donde hay materiales que pueden arder?",
        "Te ayudo con un ejemplo: imagina que est√°s en un taller y alguien est√° soldando cerca de telas. ¬øQu√© crees que podr√≠a pasar?"
      ],
      'adquisici√≥n': [
        "No hay problema en no saber los conceptos t√©cnicos. Te explico: el fuego necesita tres cosas b√°sicas para existir. ¬øPuedes pensar en qu√© elementos crees que necesita el fuego para arder?",
        "Vamos a simplificar: para que algo arda, necesita algo que se queme, necesita aire, y necesita calor. ¬øPuedes identificar estos tres elementos en tu entorno?",
        "Te doy una pista: piensa en una vela. ¬øQu√© necesita para mantenerse encendida? ¬øQu√© pasa si le quitas el aire o la apagas?"
      ],
      'aplicaci√≥n': [
        "No te preocupes si no recuerdas los detalles. Vamos paso a paso: en este caso hay madera, hay aire, y hay una estufa caliente. ¬øQu√© crees que pasar√≠a si se derrama algo inflamable sobre la estufa?",
        "Vamos a analizar juntos: aqu√≠ tenemos madera (algo que arde), aire (ox√≠geno), y una estufa (calor). ¬øQu√© crees que falta para que se inicie un incendio?",
        "Te ayudo con un ejemplo: imagina que tienes una estufa encendida y se derrama gasolina cerca. ¬øQu√© crees que pasar√≠a?"
      ],
      'discusi√≥n': [
        "No hay problema en no tener preferencia. Te ayudo a pensar: ¬øqu√© crees que ser√≠a m√°s importante: prevenir el incendio antes de que ocurra, o saber c√≥mo apagarlo cuando ya est√° ardiendo?",
        "Vamos a pensarlo diferente: ¬øprefieres gastar tiempo y dinero en prevenir, o arriesgarte a perder todo en un incendio?",
        "Te doy un ejemplo: ¬øprefieres revisar los cables de tu casa cada mes, o esperar a que se incendie?"
      ],
      'reflexi√≥n': [
        "No te preocupes si no tienes todo claro a√∫n. Piensa en lo que m√°s te llam√≥ la atenci√≥n de lo que hemos visto. ¬øHay algo que te haya quedado m√°s claro que lo dem√°s?",
        "Vamos a simplificar: de todo lo que hemos hablado, ¬øqu√© te parece m√°s importante para recordar en tu trabajo?",
        "Te ayudo a reflexionar: ¬øqu√© cambiar√≠as en tu forma de trabajar despu√©s de esta clase?"
      ]
    };
    
    const momentoKey = momento.toLowerCase().includes('saludo') ? 'saludo' :
                      momento.toLowerCase().includes('conexi√≥n') ? 'conexi√≥n' :
                      momento.toLowerCase().includes('adquisici√≥n') ? 'adquisici√≥n' :
                      momento.toLowerCase().includes('aplicaci√≥n') ? 'aplicaci√≥n' :
                      momento.toLowerCase().includes('discusi√≥n') ? 'discusi√≥n' :
                      momento.toLowerCase().includes('reflexi√≥n') ? 'reflexi√≥n' : 'saludo';
    
    const pistasDelMomento = ayudas[momentoKey as keyof typeof ayudas] || ayudas.saludo;
    const indicePista = intentos % pistasDelMomento.length;
    
    return pistasDelMomento[indicePista];
  }

  /**
   * Respuesta para "no recuerdo"
   */
  private buildNoRecuerdoResponse(pregunta: string, momento: string): string {
    return "No te preocupes si no recuerdas. Te ayudo a refrescar la memoria: ¬øhas estado en situaciones donde hay materiales que pueden arder, fuentes de calor, o trabajos que generan chispas?";
  }

  /**
   * Respuesta para respuestas muy cortas
   */
  private buildShortResponse(pregunta: string, momento: string): string {
    return "Entiendo que tu respuesta es breve. Te ayudo a pensar m√°s: ¬øpuedes contarme m√°s sobre tu experiencia con situaciones de riesgo en el trabajo?";
  }

  /**
   * Respuesta para respuestas parciales
   */
  private buildPartialResponse(studentMessage: string, pregunta: string, momento: string): string {
    return `Veo que tienes algunas ideas sobre ${momento.toLowerCase()}. Tu respuesta muestra que entiendes parte del tema. ¬øPuedes contarme m√°s espec√≠ficamente sobre lo que sabes?`;
  }

  /**
   * Genera respuesta para el nuevo momento
   */
  private async generateNewMomentResponse(sessionKey: string, nuevoIndice: number): Promise<AIResponse> {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) {
      throw new Error('Sesi√≥n no encontrada');
    }

    const nuevoMomento = session.momentos[nuevoIndice];
    const siguiente = nuevoIndice < session.momentos.length - 1
      ? session.momentos[nuevoIndice + 1].momento
      : 'FIN';

    // Construir prompt para el nuevo momento
    const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective,
      keyPoints: session.session.key_points,
      momentos: session.momentos,
      currentIndex: nuevoIndice,
      preguntasPendientes: session.preguntasPendientes,
      preguntasRespondidas: session.preguntasRespondidas
    });

    // Llamar a OpenAI para el nuevo momento
    const { response } = await this.openAIService.callOpenAI({
      systemPrompt: momentPrompt,
      userPrompt: "Contin√∫a con el siguiente momento",
      model: 'gpt-3.5-turbo'
    });

    // Parsear la nueva respuesta
    const nuevaRespuesta = this.parseAIResponse(response.output_text);
    
    return {
      ...nuevaRespuesta,
      momentos: session.momentos,
      sessionKey
    };
  }

  /**
   * Parsea respuesta JSON del modelo
   */
  private parseAIResponse(responseText: string): any {
    try {
      // Limpiar la respuesta de espacios extra
      const cleanedText = responseText.trim();
      
      // Buscar JSON en la respuesta (varios formatos de markdown)
      const jsonMatch = cleanedText.match(/```(?:json|js)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1].trim());
      }

      // Buscar JSON sin markdown (m√°s espec√≠fico)
      const jsonObjectMatch = cleanedText.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/);
      if (jsonObjectMatch) {
        return JSON.parse(jsonObjectMatch[0]);
      }
      
      // Si no hay markdown, intentar parsear directamente
      return JSON.parse(cleanedText);
    } catch (error) {
      console.error('Error parseando JSON:', error);
      console.error('Respuesta recibida:', responseText);
      return null;
    }
  }

  // M√âTODOS DE GESTI√ìN DE SESIONES (delegados al SessionManager)
  getSessionInfo(sessionKey: string) {
    return this.sessionManager.getSession(sessionKey);
  }

  listActiveSessions() {
    return this.sessionManager.listActiveSessions();
  }

  clearSession(sessionKey: string) {
    return this.sessionManager.clearSession(sessionKey);
  }

  clearAllSessions() {
    this.sessionManager.clearAllSessions();
  }

  getCacheStats() {
    return this.sessionManager.getCacheStats();
  }

  clearCache() {
    this.sessionManager.clearCache();
  }
} 
```
=== EOF: src\lib\SessionExtractorUniversal.ts

===  src\lib\SessionExtractor.ts
```typescript
import { AIResponse, Moment } from '../types';
import { OpenAIService } from '../services/OpenAIService';
import { SessionManager } from '../services/SessionManager';
import { PromptBuilder } from '../services/PromptBuilder';

export class SessionExtractor {
  private openAIService: OpenAIService;
  private sessionManager: SessionManager;

  constructor() {
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY!);
    this.sessionManager = new SessionManager();
  }

  /**
   * Inicia una sesi√≥n cargando JSON directamente
   */
  async startSession(courseId: string, sessionId: string): Promise<{
    sessionKey: string;
    momentos: number;
    currentMoment: string;
  }> {
    try {
      // Iniciar sesi√≥n b√°sica
      const sessionKey = await this.sessionManager.startSession(courseId, sessionId);
      const session = this.sessionManager.getSession(sessionKey);
      
      if (!session) {
        throw new Error('Error iniciando sesi√≥n');
      }

      console.log(`üöÄ Iniciando sesi√≥n: ${session.course.name} - ${session.session.name}`);
      console.log(`üìÅ Archivo: ${session.sessionFile}`);

      console.log(`‚úÖ Sesi√≥n iniciada: ${session.momentos.length} momentos`);

      return {
        sessionKey,
        momentos: session.momentos.length,
        currentMoment: session.momentos[0]?.momento || 'N/A'
      };

    } catch (error) {
      console.error('Error iniciando sesi√≥n:', error);
      throw error;
    }
  }

  /**
   * Maneja la interacci√≥n del estudiante usando contenido del JSON con memoria conversacional
   */
  async handleStudent(sessionKey: string, studentMessage: string): Promise<AIResponse> {
    try {
      const session = this.sessionManager.getSession(sessionKey);
      if (!session) {
        throw new Error(`Sesi√≥n ${sessionKey} no encontrada`);
      }

      // Actualizar √∫ltima actividad
      this.sessionManager.updateSession(sessionKey, { lastActivity: new Date() });

      console.log(`üéì ${session.course.specialist_role} respondiendo...`);

      // Guardar mensaje del estudiante en la memoria conversacional
      session.conversationLog.push({
        role: 'user',
        content: studentMessage,
        timestamp: new Date()
      });

      // Obtener el momento actual
      const momentoActual = session.momentos[session.currentMomentIndex] || null;
      const siguienteMomento = session.momentos[session.currentMomentIndex + 1] || null;

      // Construir historial de conversaci√≥n (√∫ltimas 6 interacciones para no saturar tokens)
      const MAX_HISTORIA = 6;
      const historialRecortado = session.conversationLog
        .slice(-MAX_HISTORIA)
        .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: "${m.content}"`)
        .join('\n');

      // Construir prompts optimizados
      const systemPrompt = PromptBuilder.buildSystemPrompt({
        specialistRole: session.course.specialist_role,
        sessionName: session.session.name,
        courseName: session.course.name,
        learningObjective: session.session.learning_objective,
        keyPoints: session.session.key_points,
        momentos: session.momentos,
        currentIndex: session.currentMomentIndex
      });



      // Preparar mensajes para OpenAI
      let finalSystemPrompt = '';
      
      // Si es el primer turno, enviar el mensaje de "esp√≠ritu"
      if (session.isFirstTurn) {
        const spiritPrompt = PromptBuilder.buildSpiritPrompt({
          specialistRole: session.course.specialist_role,
          sessionName: session.session.name,
          courseName: session.course.name,
          learningObjective: session.session.learning_objective
        });
        finalSystemPrompt += spiritPrompt + '\n\n';
        
        // Marcar que ya no es el primer turno
        this.sessionManager.updateSession(sessionKey, { isFirstTurn: false });
      }

      // Agregar historial de conversaci√≥n si existe
      if (historialRecortado.trim()) {
        finalSystemPrompt += `HISTORIAL RECIENTE DE LA CLASE:\n${historialRecortado}\n\n[Si ya hiciste esa pregunta, dilo claramente y contin√∫a con la siguiente.]\n\n`;
      }

      // Agregar el prompt del sistema
      finalSystemPrompt += systemPrompt;

      // Llamar a OpenAI con par√°metros optimizados
      const { response, metrics } = await this.openAIService.callOpenAI({
        systemPrompt: finalSystemPrompt,
        userPrompt: studentMessage,
        model: 'gpt-3.5-turbo'  // Usar gpt-3.5-turbo para interacciones
      });

      // Registrar costo de la sesi√≥n
      this.openAIService.clearSessionCost(sessionKey);
      this.openAIService.addSessionCost(sessionKey, metrics.estimated_cost);

      // Parsear respuesta JSON del modelo
      let parsedResponse = this.parseAIResponse(response.output_text);
      
      // Asegurar que la respuesta tenga la estructura correcta
      if (!parsedResponse || typeof parsedResponse !== 'object') {
        parsedResponse = {
          respuesta: response.output_text,
          momento_actual: momentoActual ? momentoActual.momento : 'N/A',
          progreso: session.currentMomentIndex + 1,
          total_momentos: session.momentos.length,
          debe_avanzar: false,
          razon_avance: "Respuesta no estructurada",
          siguiente_momento: siguienteMomento ? siguienteMomento.momento : 'FIN'
        };
      }

      // Guardar respuesta del docente en la memoria conversacional
      session.conversationLog.push({
        role: 'assistant',
        content: parsedResponse.respuesta,
        timestamp: new Date()
      });

      // Actualizar progreso si debe avanzar
      if (parsedResponse.debe_avanzar && session.currentMomentIndex < session.momentos.length - 1) {
        const nuevoIndice = session.currentMomentIndex + 1;
        this.sessionManager.updateSession(sessionKey, {
          currentMomentIndex: nuevoIndice
        });
        const siguienteMomento = session.momentos[nuevoIndice]?.momento || 'FIN';
        console.log(`üíæ Avanzando al momento ${nuevoIndice + 1}: ${siguienteMomento}`);
        
        // Construir respuesta inmediata para el nuevo momento
        const nuevoSystemPrompt = PromptBuilder.buildSystemPrompt({
          specialistRole: session.course.specialist_role,
          sessionName: session.session.name,
          courseName: session.course.name,
          learningObjective: session.session.learning_objective,
          keyPoints: session.session.key_points,
          momentos: session.momentos,
          currentIndex: nuevoIndice
        });
        
        // Llamar a OpenAI con el nuevo momento
        const { response: newResponse } = await this.openAIService.callOpenAI({
          systemPrompt: nuevoSystemPrompt,
          userPrompt: "Contin√∫a con el siguiente momento",
          model: 'gpt-3.5-turbo'
        });
        
        // Parsear la nueva respuesta
        const nuevaRespuesta = this.parseAIResponse(newResponse.output_text);
        
        return {
          ...nuevaRespuesta,
          momentos: session.momentos,
          sessionKey
        };
      } else if (parsedResponse.debe_avanzar) {
        console.log(`üéâ ¬°Clase completada! Todos los momentos han sido cubiertos.`);
      }

      return {
        ...parsedResponse,
        momentos: session.momentos,
        sessionKey
      };

    } catch (error) {
      console.error('Error en respuesta del docente:', error);
      return {
        respuesta: "Lo siento, tuve un problema generando la respuesta. ¬øPodr√≠as reformular tu pregunta?",
        momento_actual: 'ERROR',
        progreso: 0,
        total_momentos: 0,
        debe_avanzar: false,
        razon_avance: "Error en el sistema",
        siguiente_momento: 'ERROR',
        momentos: [],
        sessionKey
      };
    }
  }

  /**
   * Recoge los momentos del archivo JSON (M√âTODO LEGACY - mantiene compatibilidad)
   */
  async getMomentosDelArchivo(courseId: string, sessionId: string): Promise<Moment[]> {
    try {
      // Iniciar sesi√≥n optimizada
      const sessionInfo = await this.startSession(courseId, sessionId);
      
      // Obtener la sesi√≥n para devolver los momentos
      const session = this.sessionManager.getSession(sessionInfo.sessionKey);
      
      return session ? session.momentos : [];
    } catch (error) {
      console.error('Error recogiendo momentos del archivo:', error);
      return [];
    }
  }

  /**
   * Parsea respuesta JSON del modelo
   */
  private parseAIResponse(responseText: string): any {
    try {
      // Limpiar la respuesta de espacios extra
      const cleanedText = responseText.trim();
      
      // Buscar JSON en la respuesta (varios formatos de markdown)
      const jsonMatch = cleanedText.match(/```(?:json|js)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1].trim());
      }

      // Buscar JSON sin markdown (m√°s espec√≠fico)
      const jsonObjectMatch = cleanedText.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/);
      if (jsonObjectMatch) {
        return JSON.parse(jsonObjectMatch[0]);
      }
      
      // Si no hay markdown, intentar parsear directamente
      return JSON.parse(cleanedText);
    } catch (error) {
      console.error('Error parseando JSON:', error);
      console.error('Respuesta recibida:', responseText);
      return null;
    }
  }

  // M√âTODOS DE GESTI√ìN DE SESIONES (delegados al SessionManager)
  getSessionInfo(sessionKey: string) {
    return this.sessionManager.getSession(sessionKey);
  }

  listActiveSessions() {
    return this.sessionManager.listActiveSessions();
  }

  clearSession(sessionKey: string) {
    return this.sessionManager.clearSession(sessionKey);
  }

  clearAllSessions() {
    this.sessionManager.clearAllSessions();
  }

  getCacheStats() {
    return this.sessionManager.getCacheStats();
  }

  clearCache() {
    this.sessionManager.clearCache();
  }
} 
```
=== EOF: src\lib\SessionExtractor.ts

===  src\lib\openai.ts
```typescript
import OpenAI from 'openai';

// Configuraci√≥n de OpenAI
export const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
  dangerouslyAllowBrowser: false, // Solo para servidor
});

// Tipos para las respuestas de OpenAI
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// Funci√≥n para enviar mensaje a ChatGPT
export async function sendChatMessage(
  messages: ChatMessage[],
  model: string = 'gpt-3.5-turbo'
): Promise<ChatResponse> {
  try {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY no est√° configurada');
    }

    const completion = await openai.chat.completions.create({
      model,
      messages,
      max_tokens: 1000,
      temperature: 0.7,
    });

    const response = completion.choices[0]?.message?.content || '';
    
    return {
      content: response,
      usage: completion.usage ? {
        prompt_tokens: completion.usage.prompt_tokens,
        completion_tokens: completion.usage.completion_tokens,
        total_tokens: completion.usage.total_tokens,
      } : undefined,
    };
  } catch (error) {
    console.error('Error al comunicarse con OpenAI:', error);
    throw new Error('Error al procesar la solicitud');
  }
}

// Funci√≥n para generar texto con GPT
export async function generateText(
  prompt: string,
  model: string = 'gpt-3.5-turbo'
): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 500,
      temperature: 0.7,
    });

    return completion.choices[0]?.message?.content || '';
  } catch (error) {
    console.error('Error al generar texto:', error);
    throw new Error('Error al generar texto');
  }
}

// Funci√≥n para analizar sentimientos
export async function analyzeSentiment(text: string): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'Analiza el sentimiento del siguiente texto y responde solo con: POSITIVO, NEGATIVO o NEUTRAL.'
        },
        {
          role: 'user',
          content: text
        }
      ],
      max_tokens: 10,
      temperature: 0.3,
    });

    return completion.choices[0]?.message?.content || 'NEUTRAL';
  } catch (error) {
    console.error('Error al analizar sentimiento:', error);
    return 'NEUTRAL';
  }
} 
```
=== EOF: src\lib\openai.ts

===  src\lib\constants.ts
```typescript
export const APP_CONFIG = {
  name: "DocenteIA",
  version: "1.0.0",
  description: "Sistema estable con Next.js y TypeScript",
  author: "Tu Nombre",
  repository: "https://github.com/tu-usuario/docenteia",
} as const;

export const API_ENDPOINTS = {
  base: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
  auth: "/auth",
  users: "/users",
  courses: "/courses",
} as const;

export const ROUTES = {
  home: "/",
  about: "/about",
  contact: "/contact",
  dashboard: "/dashboard",
} as const;

export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
} as const; 
```
=== EOF: src\lib\constants.ts

===  src\lib\config.ts
```typescript
export const config = {
  app: {
    name: process.env.NEXT_PUBLIC_APP_NAME || "DocenteIA",
    version: process.env.NEXT_PUBLIC_APP_VERSION || "1.0.0",
    description: "Sistema estable con Next.js y TypeScript",
  },
  api: {
    baseUrl: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
    timeout: 10000,
  },
  auth: {
    secret: process.env.NEXTAUTH_SECRET,
    url: process.env.NEXTAUTH_URL || "http://localhost:3000",
  },
  features: {
    analytics: process.env.NEXT_PUBLIC_GA_ID,
    darkMode: true,
    pwa: false,
  },
} as const;

export type Config = typeof config; 
```
=== EOF: src\lib\config.ts

===  src\data\pedagogia-universal.json
```json
{
  "pedagogia_universal": {
    "metadatos": {
      "nombre": "Sistema Pedag√≥gico por Momentos",
      "basado_en": "Teach Like a Champion (Doug Lemov)",
      "version": "1.0",
      "aplicable_a": "Todas las materias y niveles educativos",
      "enfoque": "Docente IA con metodolog√≠a inductiva",
      "fecha_creacion": "2025-07-30"
    },
    "principios_fundamentales": {
      "filosofia_base": "Aprendizaje activo a trav√©s de descubrimiento guiado",
      "enfoque_respuestas": "Construcci√≥n sobre respuestas parciales, nunca descarte total",
      "manejo_errores": "Errores como oportunidades de aprendizaje, no fallas",
      "validacion": "Verificaci√≥n constante de comprensi√≥n antes de avanzar",
      "personalizacion": "Adaptaci√≥n al ritmo y estilo del estudiante individual"
    },
    "momentos_pedagogicos": {
      "momento_saludo": {
        "objetivo_pedagogico": "Establecer conexi√≥n emocional y ambiente propicio para el aprendizaje",
        "tecnicas_teach_like_champion": [
          "Warm/Strict (C√°lido pero con altas expectativas)",
          "Joy Factor (Generar entusiasmo genuino por el aprendizaje)",
          "Strong Start (Comenzar con energ√≠a positiva)"
        ],
        "instrucciones_ia": [
          "Aplica t√©cnica 'Warm/Strict': ser genuinamente c√°lido mientras mantienes altas expectativas",
          "Usa 'Joy Factor': transmite entusiasmo real por el tema y el proceso de aprendizaje",
          "Implementa 'Strong Start': comenzar con energ√≠a y prop√≥sito claro",
          "Personaliza el saludo seg√∫n informaci√≥n disponible del estudiante",
          "Establece tono de confianza pero profesional desde el primer momento",
          "Genera expectativa positiva hacia la sesi√≥n sin revelar contenido espec√≠fico"
        ],
        "estrategias_conexion": [
          "Mostrar inter√©s genuino por el bienestar del estudiante",
          "Usar lenguaje inclusivo y cercano apropiado para el nivel educativo",
          "Crear atmosfera de seguridad psicol√≥gica para el aprendizaje",
          "Establecer que el error es parte natural del proceso de aprendizaje"
        ],
        "validacion_momento": [
          "Confirmar que el estudiante responde de manera receptiva",
          "Verificar que se establece ambiente de confianza mutua",
          "Asegurar que hay apertura para el di√°logo y participaci√≥n",
          "Observar indicadores de engagement inicial"
        ],
        "errores_evitar": [
          "Ser demasiado formal o distante",
          "Adelantar contenido acad√©mico en este momento",
          "Ignorar se√±ales de resistencia o desconfort del estudiante",
          "Saltar directamente a objetivos sin conexi√≥n humana"
        ]
      },
      "momento_presentacion_aprendizajes": {
        "objetivo_pedagogico": "Crear claridad de prop√≥sito y motivaci√≥n intr√≠nseca hacia los objetivos",
        "tecnicas_teach_like_champion": [
          "Begin with the End (Empezar con el resultado final claro)",
          "Hook (Capturar inter√©s desde el inicio)",
          "Champion's Clarity (Claridad absoluta en expectativas)"
        ],
        "instrucciones_ia": [
          "Aplica 'Begin with the End': presenta claramente qu√© lograr√° el estudiante al finalizar",
          "Usa t√©cnica 'Hook': crea inter√©s genuino mostrando la relevancia pr√°ctica",
          "Implementa 'Champion's Clarity': ser absolutamente espec√≠fico sobre resultados esperados",
          "Conecta objetivos con beneficios tangibles para el estudiante",
          "Usa lenguaje de acci√≥n y resultado, no de proceso pasivo",
          "Verifica que el estudiante ve el valor de lo que aprender√°"
        ],
        "estructura_presentacion": [
          "Resultado espec√≠fico que lograr√° (qu√© podr√° hacer)",
          "Beneficio tangible en su vida/carrera (para qu√© le sirve)",
          "Relevancia inmediata (cu√°ndo lo aplicar√°)",
          "Confirmaci√≥n de comprensi√≥n y aceptaci√≥n del objetivo"
        ],
        "frases_potentes": [
          "Al terminar esta sesi√≥n, t√∫ ser√°s capaz de...",
          "Esto te permitir√°... en tu trabajo/estudios",
          "Imag√≠nate poder... despu√©s de hoy",
          "Esta habilidad te dar√° la confianza para..."
        ],
        "validacion_momento": [
          "El estudiante puede reformular el objetivo con sus palabras",
          "Expresa inter√©s o motivaci√≥n hacia el resultado prometido",
          "Hace preguntas relacionadas con la aplicaci√≥n pr√°ctica",
          "Muestra compromiso con el proceso de aprendizaje"
        ]
      },
      "momento_puntos_clave": {
        "objetivo_pedagogico": "Crear organizadores previos y mapa mental de la ruta de aprendizaje",
        "tecnicas_teach_like_champion": [
          "Name the Steps (Nombrar pasos espec√≠ficos)",
          "Batch Process (Agrupar informaci√≥n l√≥gicamente)",
          "Foreshadowing (Anticipar lo que viene)"
        ],
        "instrucciones_ia": [
          "Aplica 'Name the Steps': presenta cada punto clave como paso espec√≠fico y medible",
          "Usa 'Batch Process': agrupa contenidos relacionados de manera l√≥gica y secuencial",
          "Implementa 'Foreshadowing': crea anticipaci√≥n sobre cada punto sin revelarlo completamente",
          "Presenta estructura visual/mental clara del recorrido de aprendizaje",
          "Explica la l√≥gica de la secuencia para que tenga sentido",
          "Genera curiosidad sobre cada punto sin dar informaci√≥n detallada"
        ],
        "estrategias_organizacion": [
          "Usar numeraci√≥n clara y secuencial",
          "Mostrar conexiones l√≥gicas entre puntos",
          "Crear expectativa creciente hacia cada punto",
          "Usar analog√≠as de viaje/construcci√≥n para la estructura"
        ],
        "tecnicas_anticipacion": [
          "Usar frases como 'Primero descubriremos...', 'Luego exploraremos...'",
          "Crear intriga: 'Algo fascinante que aprender√°s en el punto 3 es...'",
          "Conectar cada punto con el resultado final",
          "Mostrar c√≥mo cada punto construye sobre el anterior"
        ],
        "validacion_momento": [
          "El estudiante puede repetir la secuencia de puntos",
          "Entiende la l√≥gica de la progresi√≥n",
          "Muestra curiosidad por puntos espec√≠ficos",
          "Ve la conexi√≥n entre estructura y objetivo final"
        ]
      },
      "momento_conexion": {
        "objetivo_pedagogico": "Activar conocimientos previos y crear puentes cognitivos hacia nuevos aprendizajes",
        "tecnicas_teach_like_champion": [
          "Retrieval Practice (Pr√°ctica de recuperaci√≥n)",
          "Bridge the Gap (Conectar lo conocido con lo nuevo)",
          "Universal Prompt (Preguntas que todos pueden responder)"
        ],
        "instrucciones_ia": [
          "Aplica 'Retrieval Practice': ayuda al estudiante a recordar conocimientos relacionados",
          "Usa 'Bridge the Gap': conecta expl√≠citamente experiencias previas con nuevos conceptos",
          "Implementa 'Universal Prompt': haz preguntas que el estudiante definitivamente puede responder",
          "Explora experiencias personales relacionadas con el tema",
          "Valida conocimientos previos como base v√°lida para construir",
          "Identifica conceptos err√≥neos para abordarlos durante la sesi√≥n"
        ],
        "estrategias_activacion": [
          "Preguntas abiertas sobre experiencias relacionadas",
          "Analog√≠as con situaciones familiares del estudiante",
          "Recuperaci√≥n de aprendizajes previos relevantes",
          "Conexi√≥n emocional con el tema a trav√©s de experiencias personales"
        ],
        "tipos_preguntas": [
          "Experienciales: '¬øHas vivido alguna situaci√≥n donde...?'",
          "Observacionales: '¬øQu√© has notado cuando...?'",
          "Comparativas: '¬øEn qu√© se parece esto a...?'",
          "Reflexivas: '¬øQu√© piensas sobre...?'"
        ],
        "manejo_respuestas": [
          "Validar todas las experiencias como valiosas",
          "Construir sobre respuestas parciales o incompletas",
          "Conectar respuestas individuales con conceptos generales",
          "Usar respuestas como trampol√≠n hacia nuevos aprendizajes"
        ],
        "validacion_momento": [
          "El estudiante comparte experiencias relacionadas",
          "Se activan recuerdos y conocimientos previos relevantes",
          "Hay conexi√≥n emocional evidente con el tema",
          "Se establece base s√≥lida para nuevos aprendizajes"
        ]
      },
      "momento_adquisicion": {
        "objetivo_pedagogico": "Facilitar construcci√≥n activa de conocimientos mediante descubrimiento guiado",
        "tecnicas_teach_like_champion": [
          "Cold Call (Preguntar sin avisar para mantener participaci√≥n)",
          "No Opt Out (No permitir que estudiantes se desconecten)",
          "Right is Right (Solo respuestas completamente correctas)",
          "Stretch It (Extender pensamiento m√°s all√° de respuesta inicial)",
          "Turn and Talk (Tiempo para procesar antes de responder)"
        ],
        "instrucciones_ia": [
          "Aplica metodolog√≠a INDUCTIVA PURA: NUNCA dar definiciones directas",
          "Usa 'Cold Call': mant√©n al estudiante participando activamente con preguntas constantes",
          "Implementa 'No Opt Out': no aceptes 'no s√©' como respuesta final, gu√≠a hacia descubrimiento",
          "Aplica 'Right is Right': no apruebes respuestas parciales como completas",
          "Usa 'Stretch It': cuando respuesta es correcta, profundiza con '¬øPor qu√©?' o '¬øQu√© m√°s?'",
          "Implementa secuencia: Observaci√≥n ‚Üí Pregunta ‚Üí Deducci√≥n ‚Üí Confirmaci√≥n",
          "Construye sobre cada respuesta parcial para llegar a comprensi√≥n completa"
        ],
        "metodologia_inductiva": [
          "Presentar ejemplos/casos antes que definiciones",
          "Hacer preguntas que lleven al estudiante a deducir conceptos",
          "Esperar respuesta del estudiante antes de confirmar o corregir",
          "Usar m√∫ltiples ejemplos para que el estudiante vea patrones",
          "Permitir que el estudiante 'descubra' la regla o principio"
        ],
        "manejo_respuestas": {
          "respuesta_correcta_completa": [
            "Confirmar con entusiasmo genuino",
            "Aplicar 'Stretch It' para profundizar",
            "Conectar con ejemplos adicionales",
            "Usar como base para siguiente concepto"
          ],
          "respuesta_parcialmente_correcta": [
            "Reconocer la parte correcta espec√≠ficamente",
            "Hacer pregunta que gu√≠e hacia completar la respuesta",
            "No descartar, sino construir sobre lo correcto",
            "Dar pista orientadora hacia aspecto faltante"
          ],
          "respuesta_incorrecta": [
            "No decir simplemente 'incorrecto'",
            "Identificar el punto exacto donde se desv√≠a el razonamiento",
            "Hacer pregunta que redirija el pensamiento",
            "Proporcionar contraejemplo si es necesario"
          ],
          "no_respuesta": [
            "Reformular pregunta de manera m√°s simple",
            "Proporcionar ejemplo adicional",
            "Hacer pregunta m√°s espec√≠fica",
            "Dar pista que active conocimiento previo"
          ]
        },
        "validacion_comprension": [
          "Pedir al estudiante que explique con sus propias palabras",
          "Solicitar ejemplos diferentes a los presentados",
          "Hacer preguntas de aplicaci√≥n en contexto ligeramente diferente",
          "Verificar que puede distinguir ejemplos de contra-ejemplos"
        ],
        "errores_criticos_evitar": [
          "Dar definici√≥n directa antes que el estudiante deduzca",
          "Aceptar respuestas vagas o incompletas",
          "Avanzar sin confirmar comprensi√≥n s√≥lida",
          "Corregir sin explicar por qu√© la respuesta es incorrecta"
        ]
      },
      "momento_aplicacion": {
        "objetivo_pedagogico": "Transferir conocimientos a situaciones pr√°cticas mediante pr√°ctica guiada",
        "tecnicas_teach_like_champion": [
          "I Do, We Do, You Do (Modelamiento gradual)",
          "Check for Understanding (Verificaci√≥n constante)",
          "Circulate (Monitorear progreso individual)",
          "Show Me (Evidencia visible de comprensi√≥n)"
        ],
        "instrucciones_ia": [
          "Aplica 'I Do, We Do, You Do': modela, practica guiada, pr√°ctica independiente",
          "Usa 'Check for Understanding': verifica comprensi√≥n antes de aumentar complejidad",
          "Implementa 'Show Me': solicita evidencia espec√≠fica de aplicaci√≥n correcta",
          "Comienza con casos simples y aumenta complejidad gradualmente",
          "Solicita verbalizaci√≥n del proceso de pensamiento en cada paso",
          "Conecta constantemente aplicaci√≥n pr√°ctica con conceptos te√≥ricos aprendidos"
        ],
        "secuencia_aplicacion": [
          "Modelamiento: Demostrar aplicaci√≥n paso a paso",
          "Pr√°ctica guiada: Estudiante aplica con soporte",
          "Pr√°ctica independiente: Estudiante aplica solo",
          "Transferencia: Aplicar en contexto ligeramente diferente"
        ],
        "estrategias_scaffolding": [
          "Proporcionar estructura inicial y retirarla gradualmente",
          "Dar pistas espec√≠ficas cuando el estudiante se atasca",
          "Permitir errores como oportunidades de aprendizaje",
          "Celebrar aproximaciones correctas antes de perfeccionar"
        ],
        "preguntas_guia": [
          "¬øQu√© har√≠as primero en esta situaci√≥n?",
          "¬øQu√© concepto aplicar√≠as aqu√≠?",
          "¬øPor qu√© elegiste esa opci√≥n?",
          "¬øQu√© pasar√≠a si...?",
          "¬øC√≥mo sabes que tu respuesta es correcta?"
        ],
        "validacion_aplicacion": [
          "Estudiante puede aplicar proceso sin ayuda",
          "Explica su razonamiento claramente",
          "Transfiere habilidad a contextos similares",
          "Identifica errores y los corrige independientemente"
        ]
      },
      "momento_discusion": {
        "objetivo_pedagogico": "Profundizar comprensi√≥n mediante an√°lisis cr√≠tico y metacognici√≥n",
        "tecnicas_teach_like_champion": [
          "Turn and Talk (Reflexi√≥n antes de compartir)",
          "Think Ratio (Maximizar tiempo de pensamiento del estudiante)",
          "Wait Time (Tiempo suficiente para procesar)",
          "Pepper (Discusi√≥n din√°mica y participativa)"
        ],
        "instrucciones_ia": [
          "Aplica 'Think Ratio': el estudiante debe hablar/pensar m√°s que t√∫",
          "Usa 'Wait Time': da tiempo suficiente para que procese preguntas complejas",
          "Implementa preguntas abiertas que no tengan una sola respuesta correcta",
          "Facilita an√°lisis cr√≠tico de decisiones tomadas durante aplicaci√≥n",
          "Promueve metacognici√≥n: que el estudiante reflexione sobre su propio proceso de aprendizaje",
          "Explora m√∫ltiples perspectivas y enfoques del mismo problema"
        ],
        "tipos_preguntas": [
          "An√°lisis: '¬øPor qu√© crees que...?'",
          "S√≠ntesis: '¬øC√≥mo conectar√≠as...?'",
          "Evaluaci√≥n: '¬øCu√°l ser√≠a la mejor opci√≥n y por qu√©?'",
          "Metacognici√≥n: '¬øC√≥mo llegaste a esa conclusi√≥n?'",
          "Perspectiva: '¬øQu√© otros enfoques podr√≠an funcionar?'"
        ],
        "facilitacion_dialogica": [
          "Hacer preguntas que generen m√°s preguntas",
          "Desafiar suposiciones de manera constructiva",
          "Ayudar a examinar implicaciones de diferentes decisiones",
          "Promover argumentaci√≥n fundamentada en evidencia"
        ],
        "manejo_perspectivas": [
          "Validar m√∫ltiples enfoques cuando sean correctos",
          "Ayudar a evaluar pros y contras de cada opci√≥n",
          "Facilitar s√≠ntesis de ideas aparentemente contradictorias",
          "Mantener enfoque en aprendizaje, no en 'ganar' la discusi√≥n"
        ],
        "validacion_momento": [
          "El estudiante reflexiona profundamente sobre su aprendizaje",
          "Puede articular su proceso de pensamiento",
          "Considera m√∫ltiples perspectivas de un problema",
          "Demuestra pensamiento cr√≠tico y anal√≠tico"
        ]
      },
      "momento_retroalimentacion": {
        "objetivo_pedagogico": "Consolidar aprendizajes y orientar mejora continua mediante feedback espec√≠fico",
        "tecnicas_teach_like_champion": [
          "Precise Praise (Elogio espec√≠fico y merecido)",
          "Challenge (Desaf√≠o apropiado para crecimiento)",
          "Culture of Error (Normalizar error como parte del aprendizaje)",
          "Normalize Error (Hacer que el error sea esperado y valioso)"
        ],
        "instrucciones_ia": [
          "Aplica 'Precise Praise': elogia aspectos espec√≠ficos del desempe√±o, no generalidades",
          "Usa 'Challenge': establece expectativas altas y espec√≠ficas para mejora",
          "Implementa 'Culture of Error': trata errores como informaci√≥n valiosa sobre el aprendizaje",
          "Aplica modelo: Fortaleza espec√≠fica ‚Üí √Årea de crecimiento ‚Üí Pasos concretos",
          "Balancea reconocimiento genuino con orientaci√≥n para mejora",
          "Facilita autorreflexi√≥n antes de proporcionar feedback externo"
        ],
        "estructura_feedback": {
          "reconocimiento_especifico": [
            "Identifica logro espec√≠fico y observable",
            "Explica por qu√© ese logro es significativo",
            "Conecta logro con esfuerzo o estrategia utilizada"
          ],
          "area_crecimiento": [
            "Se√±ala aspecto espec√≠fico para mejorar",
            "Explica por qu√© esa mejora es importante",
            "Proporciona criterio claro para el √©xito"
          ],
          "pasos_siguientes": [
            "Da acci√≥n espec√≠fica y realizable",
            "Establece expectativa clara de mejora",
            "Conecta con aplicaci√≥n futura"
          ]
        },
        "preguntas_autoreflexion": [
          "¬øQu√© fue lo que m√°s te desafi√≥ en esta sesi√≥n?",
          "¬øCu√°l fue tu mayor logro hoy?",
          "¬øQu√© har√≠as diferente la pr√≥xima vez?",
          "¬øC√≥mo aplicar√≠as esto en tu contexto real?",
          "¬øQu√© necesitas practicar m√°s?"
        ],
        "proyeccion_futura": [
          "Conectar aprendizajes con situaciones reales del estudiante",
          "Sugerir pr√≥ximos pasos espec√≠ficos para profundizar",
          "Generar compromiso personal con la pr√°ctica continua",
          "Inspirar confianza en capacidades desarrolladas"
        ],
        "errores_evitar_feedback": [
          "Elogios vagos como 'buen trabajo' sin especificidad",
          "Criticar a la persona en lugar del desempe√±o",
          "Dar demasiada informaci√≥n correctiva a la vez",
          "Terminar solo con √°reas de mejora sin reconocimiento"
        ]
      }
    },
    "principios_transversales": {
      "adaptacion_ritmo": [
        "Acelerar cuando el estudiante domina r√°pidamente",
        "Desacelerar cuando hay confusi√≥n o resistencia",
        "Proporcionar refuerzo adicional cuando sea necesario",
        "Ajustar complejidad seg√∫n respuestas del estudiante"
      ],
      "mantenimiento_engagement": [
        "Variar tipos de preguntas para mantener inter√©s",
        "Usar ejemplos relevantes al contexto del estudiante",
        "Celebrar progreso incremental regularmente",
        "Mantener expectativas altas pero alcanzables"
      ],
      "construccion_confianza": [
        "Estructurar experiencias de √©xito frecuentes",
        "Reconocer esfuerzo y estrategias efectivas",
        "Normalizar la dificultad como parte natural del aprendizaje",
        "Proporcionar soporte suficiente para prevenir frustraci√≥n"
      ]
    }
  }
} 
```
=== EOF: src\data\pedagogia-universal.json

===  src\data\courses-database.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "Seguridad y Salud Ocupacional",
      "description": "Curso completo de SSO con m√∫ltiples sesiones de capacitaci√≥n",
      "specialist_role": "Especialista en Seguridad y Salud Ocupacional",
      "vector_store_id": "vs_68823f69d9f08191889fed8f8edd891c",
      "sessions": [
        {
          "id": "sesion01",
          "name": "IPERC - Identificaci√≥n de Peligros, Evaluaci√≥n de Riesgos y Controles",
          "session_file": "SSO001_sesion01.json",
          "learning_objective": "El estudiante identifica peligros en una situaci√≥n laboral, eval√∫a los riesgos asociados y propone controles adecuados para prevenir accidentes",
          "key_points": [
            "Comprende qu√© es un peligro y c√≥mo se reconoce en el ambiente laboral",
            "Diferencia entre peligro y riesgo en el contexto de SSO",
            "Relaciona la severidad y probabilidad para evaluar un riesgo",
            "Propone controles adecuados seg√∫n el tipo de peligro identificado"
          ],
          "theme_keywords": [
            "iperc",
            "identificaci√≥n",
            "peligros",
            "evaluaci√≥n",
            "riesgos",
            "control",
            "seguridad",
            "prevenci√≥n",
            "accidente"
          ]
        },
        {
          "id": "sesion02", 
          "name": "Sesi√≥n 02 de SSO",
          "session_file": "SSO001_sesion02.json",
          "learning_objective": "El estudiante aplica procedimientos de seguridad en situaciones espec√≠ficas del trabajo",
          "key_points": [
            "Identifica procedimientos de seguridad relevantes",
            "Aplica medidas de protecci√≥n personal",
            "Reconoce se√±ales y se√±alizaci√≥n de seguridad",
            "Implementa protocolos de emergencia"
          ],
          "theme_keywords": [
            "procedimientos",
            "seguridad",
            "protecci√≥n",
            "personal",
            "se√±ales",
            "se√±alizaci√≥n",
            "protocolos",
            "emergencia",
            "medidas"
          ]
        },
        {
          "id": "sesion03",
          "name": "Prevenci√≥n de Incendios en el Trabajo", 
          "session_file": "SSO001_sesion03.json",
          "learning_objective": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
          "key_points": [
            "Reconoce las causas principales de incendios en el trabajo",
            "Identifica medidas preventivas para evitar incendios",
            "Aplica procedimientos de evacuaci√≥n en caso de emergencia",
            "Utiliza correctamente equipos contra incendios"
          ],
          "theme_keywords": [
            "incendio",
            "fuego",
            "extintor",
            "prevenci√≥n",
            "combusti√≥n",
            "tri√°ngulo del fuego",
            "evacuaci√≥n",
            "emergencia",
            "equipos"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    },
    {
      "id": "PER001",
      "name": "Operaci√≥n de Equipos de Perforaci√≥n",
      "description": "Curso completo de perforaci√≥n con m√∫ltiples sesiones de capacitaci√≥n",
      "specialist_role": "Especialista en operaci√≥n de equipos de perforaci√≥n",
      "vector_store_id": "vs_perforacion_equipos_2025",
      "sessions": [
        {
          "id": "sesion01",
          "name": "Fundamentos de Perforaci√≥n",
          "learning_objective": "El estudiante identifica los componentes principales de un equipo de perforaci√≥n y explica su funci√≥n en el proceso",
          "key_points": [
            "Comprende qu√© es un equipo de perforaci√≥n y sus aplicaciones",
            "Identifica los componentes principales del equipo de perforaci√≥n",
            "Explica la funci√≥n de cada componente en el proceso",
            "Relaciona el funcionamiento de los componentes para lograr la perforaci√≥n efectiva"
          ],
          "theme_keywords": [
            "perforaci√≥n",
            "equipo",
            "componentes",
            "fundamentos",
            "mecanismo",
            "funcionamiento",
            "aplicaciones",
            "proceso"
          ]
        },
        {
          "id": "sesion02",
          "name": "T√©cnicas de Perforaci√≥n",
          "learning_objective": "El estudiante aplica t√©cnicas de perforaci√≥n seg√∫n el tipo de terreno y objetivo",
          "key_points": [
            "Reconoce diferentes tipos de t√©cnicas de perforaci√≥n",
            "Selecciona la t√©cnica apropiada seg√∫n el terreno",
            "Aplica procedimientos de seguridad en perforaci√≥n",
            "Eval√∫a la eficiencia de la t√©cnica utilizada"
          ],
          "theme_keywords": [
            "t√©cnicas",
            "perforaci√≥n",
            "terreno",
            "m√©todos",
            "selecci√≥n",
            "eficiencia",
            "procedimientos",
            "seguridad"
          ]
        },
        {
          "id": "sesion03",
          "name": "Mantenimiento de Equipos de Perforaci√≥n",
          "learning_objective": "El estudiante realiza mantenimiento preventivo y correctivo en equipos de perforaci√≥n",
          "key_points": [
            "Identifica componentes que requieren mantenimiento regular",
            "Aplica procedimientos de mantenimiento preventivo",
            "Diagnostica problemas comunes en equipos de perforaci√≥n",
            "Ejecuta mantenimiento correctivo b√°sico"
          ],
          "theme_keywords": [
            "mantenimiento",
            "preventivo",
            "correctivo",
            "equipos",
            "perforaci√≥n",
            "diagn√≥stico",
            "componentes",
            "procedimientos",
            "problemas"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    }
  ]
} 
```
=== EOF: src\data\courses-database.json

===  src\components\ChatInterface.tsx
```tsx
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ChatMessage } from '@/lib/openai';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const chatMessages: ChatMessage[] = [
        ...messages.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        { role: 'user', content: input },
      ];

      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: chatMessages,
          model: 'gpt-3.5-turbo',
        }),
      });

      if (!response.ok) {
        throw new Error('Error en la respuesta del servidor');
      }

      const data = await response.json();
      
      const assistantMessage: Message = {
        role: 'assistant',
        content: data.content,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      const errorMessage: Message = {
        role: 'assistant',
        content: 'Lo siento, hubo un error al procesar tu mensaje.',
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        {/* Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 p-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Chat con IA
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Pregunta lo que quieras a la inteligencia artificial
          </p>
        </div>

        {/* Messages */}
        <div className="h-96 overflow-y-auto p-4 space-y-4">
          {messages.length === 0 && (
            <div className="text-center text-gray-500 dark:text-gray-400">
              <p>¬°Hola! Soy tu asistente de IA. ¬øEn qu√© puedo ayudarte?</p>
            </div>
          )}
          
          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              <div
                className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white'
                }`}
              >
                <p className="text-sm">{message.content}</p>
                <p className="text-xs opacity-70 mt-1">
                  {message.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))}
          
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-gray-100 dark:bg-gray-700 px-4 py-2 rounded-lg">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  Pensando...
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <div className="border-t border-gray-200 dark:border-gray-700 p-4">
          <div className="flex space-x-2">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Escribe tu mensaje..."
              className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white resize-none"
              rows={2}
              disabled={isLoading}
            />
            <Button
              onClick={sendMessage}
              disabled={!input.trim() || isLoading}
              className="px-4 py-2"
            >
              {isLoading ? 'Enviando...' : 'Enviar'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
} 
```
=== EOF: src\components\ChatInterface.tsx

===  src\app\page.tsx
```tsx
import { Button } from "@/components/ui/Button";
import { formatDate } from "@/lib/utils";
import { ChatInterface } from "@/components/ChatInterface";

export default function Home() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800">
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <h1 className="text-4xl md:text-6xl font-bold text-gray-900 dark:text-white mb-4">
            DocenteIA
          </h1>
          <p className="text-xl text-gray-600 dark:text-gray-300 mb-8">
            Sistema estable con Next.js, TypeScript e IA
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button size="lg" className="bg-blue-600 hover:bg-blue-700">
              Comenzar
            </Button>
            <Button variant="outline" size="lg">
              Documentaci√≥n
            </Button>
          </div>
        </div>

        <div className="grid md:grid-cols-3 gap-8 mt-16 mb-16">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              TypeScript Estricto
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Configuraci√≥n robusta con verificaciones estrictas de tipos para mayor estabilidad.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Next.js 14
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              La versi√≥n m√°s estable con App Router y optimizaciones avanzadas.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              OpenAI Integrado
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Chat inteligente con GPT-3.5-turbo para asistencia autom√°tica.
            </p>
          </div>
        </div>

        {/* Chat Interface */}
        <div className="mt-16">
          <ChatInterface />
        </div>

        <div className="mt-12 text-center">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            √öltima actualizaci√≥n: {formatDate(new Date())}
          </p>
        </div>
      </div>
    </div>
  );
}
```
=== EOF: src\app\page.tsx

===  src\app\layout.tsx
```tsx
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "DocenteIA - Sistema Estable",
  description: "Sistema estable con Next.js y TypeScript",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```
=== EOF: src\app\layout.tsx

===  src\app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 0 0% 3.9%;
  --card: 0 0% 100%;
  --card-foreground: 0 0% 3.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 0 0% 3.9%;
  --primary: 0 0% 9%;
  --primary-foreground: 0 0% 98%;
  --secondary: 0 0% 96.1%;
  --secondary-foreground: 0 0% 9%;
  --muted: 0 0% 96.1%;
  --muted-foreground: 0 0% 45.1%;
  --accent: 0 0% 96.1%;
  --accent-foreground: 0 0% 9%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 89.8%;
  --input: 0 0% 89.8%;
  --ring: 0 0% 3.9%;
  --radius: 0.5rem;
}

.dark {
  --background: 0 0% 3.9%;
  --foreground: 0 0% 98%;
  --card: 0 0% 3.9%;
  --card-foreground: 0 0% 98%;
  --popover: 0 0% 3.9%;
  --popover-foreground: 0 0% 98%;
  --primary: 0 0% 98%;
  --primary-foreground: 0 0% 9%;
  --secondary: 0 0% 14.9%;
  --secondary-foreground: 0 0% 98%;
  --muted: 0 0% 14.9%;
  --muted-foreground: 0 0% 63.9%;
  --accent: 0 0% 14.9%;
  --accent-foreground: 0 0% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 14.9%;
  --input: 0 0% 14.9%;
  --ring: 0 0% 83.1%;
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
```
=== EOF: src\app\globals.css

===  src\components\ui\Button.tsx
```tsx
import React from "react";
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants }; 
```
=== EOF: src\components\ui\Button.tsx

===  src\data\sessions\SSO001_sesion03.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion03",
  "nombre": "Prevenci√≥n de Incendios en el Trabajo",
  "objetivo": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
  "momentos": [
    {
      "momento": "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesi√≥n y los puntos clave a desarrollar",
      "preguntas": [
        "¬øQu√© sabes sobre incendios en el trabajo?",
        "¬øHas presenciado alguna situaci√≥n de riesgo de incendio?",
        "¬øQu√© esperas aprender en esta sesi√≥n?"
      ]
    },
    {
      "momento": "Conexi√≥n",
      "instrucciones_docenteia": "Narrar la historia de la f√°brica textil para conectar con experiencias previas",
      "historia": "En una f√°brica textil, un trabajador est√° usando una m√°quina de soldadura cerca de telas almacenadas. De repente, una chispa salta hacia las telas y comienza un peque√±o fuego. ¬øQu√© crees que pas√≥? ¬øPor qu√© se inici√≥ el incendio? ¬øTe ha pasado algo parecido o has escuchado de un caso similar?",
      "preguntas": [
        "¬øQu√© elementos identificas en esta situaci√≥n?",
        "¬øQu√© podr√≠a haber prevenido este incidente?",
        "¬øC√≥mo se relaciona esto con tu experiencia laboral?",
        "¬øHas presenciado alguna situaci√≥n similar?"
      ]
    },
    {
      "momento": "Adquisici√≥n",
      "instrucciones_docenteia": "Explicar el Tri√°ngulo del Fuego y los tipos de extintores",
      "contenido_tecnico": [
        "El Tri√°ngulo del Fuego est√° compuesto por tres elementos esenciales",
        "COMBUSTIBLE: cualquier material que puede arder (madera, papel, telas, gasolina, etc.)",
        "OX√çGENO: presente en el aire que respiramos",
        "CALOR: la energ√≠a que inicia la reacci√≥n de combusti√≥n",
        "Si eliminamos cualquiera de estos tres elementos, el fuego NO puede existir",
        "Extintor de agua: para combustibles s√≥lidos (clase A)",
        "Extintor de CO‚ÇÇ: para equipos el√©ctricos (clase C)",
        "Extintor de polvo: para m√∫ltiples tipos de fuego (clase ABC)"
      ],
      "preguntas": [
        "¬øQu√© crees que necesita el fuego para existir?",
        "¬øHas o√≠do hablar del Tri√°ngulo del Fuego?",
        "¬øPuedes identificar los tres elementos b√°sicos del fuego?",
        "¬øQu√© tipos de extintores conoces y para qu√© se usan?",
        "¬øPor qu√© es importante eliminar al menos uno de los elementos del Tri√°ngulo del Fuego?",
        "¬øC√≥mo se relaciona esto con la prevenci√≥n de incendios?"
      ]
    },
    {
      "momento": "Aplicaci√≥n",
      "instrucciones_docenteia": "Presentar el caso de la carpinter√≠a para aplicar los conocimientos",
      "caso": "En una carpinter√≠a donde trabajan 10 personas, hay madera, barnices, equipos el√©ctricos, y una estufa para calentar el ambiente. Un d√≠a, un trabajador est√° barnizando una pieza cerca de la estufa cuando se derrama barniz sobre la estufa caliente y se inicia un incendio. Usando el Tri√°ngulo del Fuego, analicemos este caso: ¬øCu√°les son los tres elementos presentes? ¬øQu√© tipo de extintor ser√≠a el m√°s adecuado? ¬øQu√© medidas preventivas se podr√≠an haber implementado?",
      "preguntas": [
        "En este caso de la carpinter√≠a, ¬øcu√°les son los tres elementos del Tri√°ngulo del Fuego?",
        "¬øQu√© tipo de extintor ser√≠a el m√°s adecuado para este incendio y por qu√©?",
        "¬øQu√© medidas preventivas se podr√≠an haber implementado para evitar este incidente?",
        "¬øC√≥mo se podr√≠a haber roto el Tri√°ngulo del Fuego antes de que ocurriera el incendio?",
        "Si t√∫ fueras el responsable de seguridad, ¬øqu√© protocolos establecer√≠as?"
      ]
    },
    {
      "momento": "Discusi√≥n",
      "instrucciones_docenteia": "Facilitar la comparaci√≥n de diferentes enfoques de prevenci√≥n",
      "preguntas": [
        "¬øQu√© estrategia prefieres y por qu√©?",
        "¬øHay situaciones donde una estrategia es mejor que otra?",
        "¬øQu√© limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "Reflexi√≥n",
      "instrucciones_docenteia": "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
      "preguntas": [
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo cambiar√° tu forma de trabajar despu√©s de esta sesi√≥n?",
        "¬øQu√© m√°s te gustar√≠a aprender sobre prevenci√≥n de incendios?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion03.json

===  src\data\sessions\SSO001_sesion02.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion02",
  "nombre": "Procedimientos de Seguridad en el Trabajo",
  "objetivo": "El estudiante aplica procedimientos de seguridad en situaciones espec√≠ficas del trabajo",
  "momentos": [
    {
      "momento": "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesi√≥n sobre procedimientos de seguridad",
      "preguntas": [
        "¬øQu√© procedimientos de seguridad conoces?",
        "¬øHas seguido alg√∫n protocolo de seguridad en tu trabajo?",
        "¬øQu√© esperas aprender sobre procedimientos de seguridad?"
      ]
    },
    {
      "momento": "Conexi√≥n",
      "instrucciones_docenteia": "Narrar una situaci√≥n de trabajo para conectar con experiencias previas",
      "historia": "En una obra de construcci√≥n, un trabajador debe realizar trabajos en altura. ¬øQu√© procedimientos de seguridad deber√≠a seguir? ¬øQu√© equipos de protecci√≥n necesitar√≠a?",
      "preguntas": [
        "¬øQu√© elementos de seguridad identificas en esta situaci√≥n?",
        "¬øQu√© podr√≠a salir mal si no se siguen los procedimientos?",
        "¬øHas presenciado alguna situaci√≥n similar?"
      ]
    },
    {
      "momento": "Adquisici√≥n",
      "instrucciones_docenteia": "Explicar los procedimientos de seguridad b√°sicos",
      "contenido_tecnico": [
        "PROCEDIMIENTO: secuencia de pasos para realizar una tarea de forma segura",
        "EQUIPOS DE PROTECCI√ìN PERSONAL (EPP): elementos que protegen al trabajador",
        "SE√ëALIZACI√ìN: indicadores visuales que advierten sobre peligros",
        "PROTOCOLOS DE EMERGENCIA: pasos a seguir en caso de accidente"
      ],
      "preguntas": [
        "¬øQu√© elementos debe tener un procedimiento de seguridad?",
        "¬øC√≥mo se selecciona el EPP adecuado?",
        "¬øQu√© tipos de se√±alizaci√≥n conoces?"
      ]
    },
    {
      "momento": "Aplicaci√≥n",
      "instrucciones_docenteia": "Presentar un caso pr√°ctico para aplicar procedimientos",
      "caso": "En un laboratorio qu√≠mico, un trabajador debe manipular sustancias peligrosas. ¬øQu√© procedimientos deber√≠a seguir?",
      "preguntas": [
        "¬øQu√© procedimientos espec√≠ficos aplicar√≠as?",
        "¬øQu√© EPP necesitar√≠a el trabajador?",
        "¬øQu√© medidas de emergencia deber√≠an estar disponibles?"
      ]
    },
    {
      "momento": "Discusi√≥n",
      "instrucciones_docenteia": "Facilitar la comparaci√≥n de diferentes procedimientos",
      "preguntas": [
        "¬øQu√© procedimiento prefieres y por qu√©?",
        "¬øHay situaciones donde un procedimiento es mejor que otro?",
        "¬øQu√© limitaciones tienen los procedimientos?"
      ]
    },
    {
      "momento": "Reflexi√≥n",
      "instrucciones_docenteia": "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
      "preguntas": [
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo aplicar√°s estos procedimientos en tu trabajo?",
        "¬øQu√© m√°s te gustar√≠a aprender sobre seguridad?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion02.json

===  src\data\sessions\SSO001_sesion01.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion01",
  "nombre": "IPERC - Identificaci√≥n de Peligros, Evaluaci√≥n de Riesgos y Controles",
  "objetivo": "El estudiante identifica peligros en una situaci√≥n laboral, eval√∫a los riesgos asociados y propone controles adecuados para prevenir accidentes",
  "momentos": [
    {
      "momento": "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesi√≥n IPERC y los puntos clave a desarrollar",
      "preguntas": [
        "¬øQu√© sabes sobre identificaci√≥n de peligros en el trabajo?",
        "¬øHas identificado alg√∫n peligro en tu entorno laboral?",
        "¬øQu√© esperas aprender sobre evaluaci√≥n de riesgos?"
      ]
    },
    {
      "momento": "Conexi√≥n",
      "instrucciones_docenteia": "Narrar una situaci√≥n laboral para conectar con experiencias previas",
      "historia": "En una f√°brica de producci√≥n, un trabajador est√° operando una m√°quina sin las protecciones adecuadas. ¬øQu√© peligros identificas en esta situaci√≥n? ¬øQu√© riesgos podr√≠an existir?",
      "preguntas": [
        "¬øQu√© elementos de riesgo identificas en esta situaci√≥n?",
        "¬øQu√© podr√≠a salir mal en este escenario?",
        "¬øC√≥mo se relaciona esto con tu experiencia laboral?"
      ]
    },
    {
      "momento": "Adquisici√≥n",
      "instrucciones_docenteia": "Explicar los conceptos de IPERC",
      "contenido_tecnico": [
        "IPERC significa: Identificaci√≥n de Peligros, Evaluaci√≥n de Riesgos y Controles",
        "PELIGRO: fuente, situaci√≥n o acto con potencial de causar da√±o",
        "RIESGO: combinaci√≥n de la probabilidad de ocurrencia y la severidad del da√±o",
        "CONTROL: medida implementada para eliminar o reducir el riesgo"
      ],
      "preguntas": [
        "¬øQu√© diferencia hay entre peligro y riesgo?",
        "¬øC√≥mo se eval√∫a la probabilidad de un riesgo?",
        "¬øQu√© tipos de controles conoces?"
      ]
    },
    {
      "momento": "Aplicaci√≥n",
      "instrucciones_docenteia": "Presentar un caso pr√°ctico para aplicar IPERC",
      "caso": "En un taller de mantenimiento, un trabajador debe cambiar una l√°mpara en altura. ¬øC√≥mo aplicar√≠as el m√©todo IPERC en esta situaci√≥n?",
      "preguntas": [
        "¬øQu√© peligros identificas en este caso?",
        "¬øC√≥mo evaluar√≠as los riesgos?",
        "¬øQu√© controles propondr√≠as?"
      ]
    },
    {
      "momento": "Discusi√≥n",
      "instrucciones_docenteia": "Facilitar la comparaci√≥n de diferentes enfoques de control",
      "preguntas": [
        "¬øQu√© estrategia de control prefieres y por qu√©?",
        "¬øHay situaciones donde una estrategia es mejor que otra?",
        "¬øQu√© limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "Reflexi√≥n",
      "instrucciones_docenteia": "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
      "preguntas": [
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo aplicar√°s IPERC en tu trabajo?",
        "¬øQu√© m√°s te gustar√≠a aprender sobre evaluaci√≥n de riesgos?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion01.json

===  src\app\api\chat\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { sendChatMessage, ChatMessage } from '@/lib/openai';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { messages, model = 'gpt-3.5-turbo' } = body;

    // Validar que se proporcionen mensajes
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Se requieren mensajes v√°lidos' },
        { status: 400 }
      );
    }

    // Validar que cada mensaje tenga la estructura correcta
    const validMessages: ChatMessage[] = messages.map((msg: any) => ({
      role: msg.role,
      content: msg.content,
    }));

    // Enviar mensaje a OpenAI
    const response = await sendChatMessage(validMessages, model);

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error en API chat:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\chat\route.ts

