---
repository:
  name: docenteia
  owner: unknown
  url: ""
generated:
  timestamp: 2025-07-30T13:39:49.329Z
  tool: FlatRepo
statistics:
  totalFiles: 29
  totalLines: 2582
  languages:
    json: 5
    markdown: 2
    javascript: 5
    typescript: 10
    tsx: 4
    css: 1
  fileTypes:
    .json: 5
    .md: 2
    .js: 5
    .mjs: 1
    .example: 1
    .ts: 10
    .tsx: 4
    .css: 1
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```
=== EOF: tsconfig.json

===  TECHNICAL_DOCS.md
```markdown
# Documentación Técnica - DocenteIA

## Arquitectura del Sistema

### Stack Tecnológico
- **Framework**: Next.js 15 con App Router
- **Lenguaje**: TypeScript 5.x
- **Estilos**: Tailwind CSS 4.x
- **Linting**: ESLint con reglas estrictas
- **Build**: SWC (Rust-based compiler)

### Estructura de Carpetas
```
src/
├── app/                    # App Router (Next.js 15)
│   ├── layout.tsx         # Layout principal
│   ├── page.tsx           # Página principal
│   └── globals.css        # Estilos globales
├── components/             # Componentes reutilizables
│   └── ui/                # Componentes de UI base
├── lib/                   # Utilidades y helpers
│   ├── utils.ts           # Funciones utilitarias
│   ├── constants.ts       # Constantes del sistema
│   └── config.ts          # Configuración centralizada
└── types/                 # Tipos TypeScript
    └── global.d.ts        # Tipos globales
```

## Configuraciones Clave

### TypeScript (tsconfig.json)
- **Target**: ES2022 para mejor rendimiento
- **Strict Mode**: Habilitado completamente
- **No Unused**: Variables y parámetros no utilizados
- **No Implicit Returns**: Requiere returns explícitos
- **Force Consistent Casing**: Consistencia en nombres de archivos

### ESLint (eslint.config.mjs)
- **Next.js Core Web Vitals**: Optimización de rendimiento
- **TypeScript Rules**: Verificaciones estrictas
- **No Unused Variables**: Error para variables no utilizadas
- **No Explicit Any**: Advertencia para tipos `any`
- **Prefer Const**: Forzar uso de `const`

### Next.js (next.config.ts)
- **React Strict Mode**: Detección de efectos secundarios
- **Optimize Package Imports**: Optimización de imports
- **Modern Image Formats**: WebP y AVIF
- **Console Removal**: Eliminar console.log en producción

## Componentes del Sistema

### Button Component
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}
```

**Características**:
- Variantes múltiples con `class-variance-authority`
- Tipos estrictos de TypeScript
- Accesibilidad integrada
- Reutilizable y extensible

### Utilidades (lib/utils.ts)
```typescript
// Combinación de clases CSS
cn("class1", "class2")

// Formateo de fechas
formatDate(new Date())

// Generación de IDs únicos
generateId()
```

## Optimizaciones de Rendimiento

### Build Optimizations
- **SWC Compiler**: Compilación rápida en Rust
- **Tree Shaking**: Eliminación de código no utilizado
- **Code Splitting**: División automática de bundles
- **Image Optimization**: Formatos modernos (WebP, AVIF)

### Runtime Optimizations
- **React Strict Mode**: Detección de problemas
- **Turbopack**: Bundler rápido en desarrollo
- **Incremental Static Regeneration**: Páginas estáticas dinámicas

## Seguridad

### TypeScript Strict Mode
- Verificación de tipos en tiempo de compilación
- Prevención de errores de runtime
- Mejor autocompletado y refactoring

### ESLint Security Rules
- Detección de código vulnerable
- Prevención de XSS
- Buenas prácticas de seguridad

## Escalabilidad

### Estructura Modular
- Componentes reutilizables
- Utilidades centralizadas
- Configuración tipada
- Separación de responsabilidades

### Configuración Flexible
- Variables de entorno tipadas
- Configuración centralizada
- Constantes organizadas
- Tipos exportables

## Mantenimiento

### Código Limpio
- ESLint con reglas estrictas
- TypeScript con verificaciones exhaustivas
- Documentación integrada
- Convenciones consistentes

### Testing Ready
- Estructura preparada para tests
- Componentes aislados
- Utilidades testables
- Configuración de testing

## Despliegue

### Optimizaciones de Producción
- Minificación automática
- Compresión de assets
- CDN ready
- PWA compatible

### Monitoreo
- Error boundaries preparados
- Analytics integrado
- Performance monitoring
- Logging estructurado 
```
=== EOF: TECHNICAL_DOCS.md

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
} 
```
=== EOF: tailwind.config.js

===  README.md
```markdown
# DocenteIA - Sistema Estable con Next.js y TypeScript

Un sistema robusto y estable construido con Next.js 15, TypeScript estricto y Tailwind CSS.

## 🚀 Características

- **Next.js 15**: La versión más reciente con App Router
- **TypeScript Estricto**: Configuración robusta con verificaciones exhaustivas
- **Tailwind CSS 4**: Estilos modernos y optimizados
- **ESLint Configurado**: Reglas estrictas para código limpio
- **Componentes Reutilizables**: Sistema de componentes con TypeScript
- **Utilidades Optimizadas**: Funciones helper para desarrollo eficiente
- **OpenAI Integrado**: Chat inteligente con GPT-3.5-turbo
- **API Routes Seguras**: Endpoints protegidos para comunicación con IA

## 📦 Instalación

```bash
# Clonar el repositorio
git clone <tu-repositorio>
cd docenteia

# Instalar dependencias
npm install

# Configurar variables de entorno
cp env.example .env.local
# Editar .env.local y agregar tu OPENAI_API_KEY

# Ejecutar en desarrollo
npm run dev
```

## 🛠️ Scripts Disponibles

```bash
npm run dev          # Servidor de desarrollo
npm run build        # Construcción para producción
npm run start        # Servidor de producción
npm run lint         # Verificación de código con ESLint
npm run chat         # Chat terminal con IA y vector store
```

## 🏗️ Estructura del Proyecto

```
src/
├── app/                 # App Router de Next.js
│   ├── layout.tsx      # Layout principal
│   ├── page.tsx        # Página principal
│   └── globals.css     # Estilos globales
├── components/          # Componentes reutilizables
│   └── ui/             # Componentes de UI
│       └── Button.tsx  # Componente Button
├── lib/                # Utilidades y helpers
│   ├── utils.ts        # Funciones utilitarias
│   ├── openai.ts       # Configuración de OpenAI
│   ├── vector-store.ts # Configuración de vector store
│   ├── constants.ts    # Constantes del sistema
│   └── config.ts       # Configuración centralizada
├── components/         # Componentes reutilizables
│   ├── ui/            # Componentes de UI
│   └── ChatInterface.tsx # Chat con IA
└── types/              # Tipos TypeScript
    └── global.d.ts     # Tipos globales
```

## ⚙️ Configuraciones

### TypeScript
- Target: ES2022
- Strict mode habilitado
- Verificaciones estrictas de tipos
- No unused locals/parameters

### ESLint
- Reglas estrictas para TypeScript
- Prevención de código no utilizado
- Advertencias para `any` types

### Next.js
- React Strict Mode
- SWC Minify
- Optimización de imports
- Soporte para imágenes modernas

## 🎨 Componentes

### Button Component
Componente reutilizable con múltiples variantes:

```tsx
import { Button } from "@/components/ui/Button";

<Button variant="default" size="lg">
  Comenzar
</Button>
```

### ChatInterface Component
Chat inteligente con OpenAI:

```tsx
import { ChatInterface } from "@/components/ChatInterface";

<ChatInterface />
```

## 💻 Chat Terminal

```bash
npm run chat
```

**Comandos disponibles:**
- `/help` - Mostrar ayuda
- `/history` - Mostrar historial
- `/clear` - Limpiar historial
- `/vector <consulta>` - Consultar vector store
- `/search <consulta>` - Buscar documentos en vector store
- `/exit` - Salir del chat

**⚠️ Importante:** Para usar el vector store, necesitas tener el servidor corriendo:
```bash
# Terminal 1: Iniciar servidor
npm run dev

# Terminal 2: Ejecutar chat
npm run chat
```

## 📝 Utilidades

### Funciones Helper
```tsx
import { cn, formatDate, generateId } from "@/lib/utils";

// Combinar clases CSS
cn("class1", "class2")

// Formatear fechas
formatDate(new Date())

// Generar IDs únicos
generateId()
```

### Funciones de OpenAI
```tsx
import { sendChatMessage, generateText, analyzeSentiment } from "@/lib/openai";

// Enviar mensaje a ChatGPT
const response = await sendChatMessage(messages, 'gpt-3.5-turbo');

// Generar texto
const text = await generateText("Escribe un poema sobre la tecnología");

// Analizar sentimiento
const sentiment = await analyzeSentiment("Me encanta este producto!");
```

## 🔧 Desarrollo

### Agregar Nuevos Componentes
1. Crear en `src/components/ui/`
2. Usar TypeScript estricto
3. Implementar variantes con `class-variance-authority`
4. Exportar tipos de props

### Agregar Utilidades
1. Crear en `src/lib/`
2. Documentar con JSDoc
3. Exportar tipos TypeScript

## 🚀 Despliegue

El proyecto está optimizado para despliegue en Vercel:

```bash
npm run build
```

## 📄 Licencia

MIT License - ver archivo LICENSE para detalles.

## 🤝 Contribuir

1. Fork el proyecto
2. Crear una rama feature (`git checkout -b feature/AmazingFeature`)
3. Commit los cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abrir un Pull Request

## 📞 Soporte

Para soporte técnico, contacta al equipo de desarrollo.
```
=== EOF: README.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "chat": "node src/scripts/terminal-chat.js"
  },
  "dependencies": {
    "@openai/agents": "^0.0.13",
    "autoprefixer": "^10.4.21",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.532.0",
    "next": "^14.2.0",
    "openai": "^5.10.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20.19.9",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "eslint": "^9",
    "eslint-config-next": "15.4.4",
    "flatrepo": "^1.2.0",
    "typescript": "^5"
  }
}
```
=== EOF: package.json

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    optimizePackageImports: ["lucide-react"],
  },
  images: {
    formats: ["image/webp", "image/avif"],
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
};

module.exports = nextConfig;
```
=== EOF: next.config.js

===  eslint.config.mjs
```
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "prefer-const": "error",
      "no-var": "error",
      "no-console": "warn",
    },
  },
];

export default eslintConfig;
```
=== EOF: eslint.config.mjs

===  env.example
```
# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here

# App Configuration
NEXT_PUBLIC_APP_NAME=DocenteIA
NEXT_PUBLIC_APP_VERSION=1.0.0

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3000/api 
```
=== EOF: env.example

===  src\types\global.d.ts
```typescript
declare global {
  interface Window {
    __NEXT_DATA__: unknown;
  }
}

export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
} 
```
=== EOF: src\types\global.d.ts

===  src\scripts\terminal-chat.js
```javascript
#!/usr/bin/env node

const readline = require('readline');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configurar readline
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Colores simples
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
};

function print(color, text) {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// Función para consultar OpenAI
// Función para detectar el puerto del servidor Next.js
async function detectServerPort() {
  const ports = [3000, 3001, 3002, 3003, 3004, 3005];
  
  for (const port of ports) {
    try {
      const response = await axios.get(`http://localhost:${port}`, { timeout: 1000 });
      if (response.status === 200) {
        return port;
      }
    } catch (error) {
      // Continuar con el siguiente puerto
    }
  }
  
  // Si no encuentra ningún puerto, usar 3000 por defecto
  return 3000;
}

async function queryVectorStore(query, sessionId = null, courseId = null) {
  try {
    print('yellow', '🔍 Consultando OpenAI...');
    
    // Detectar puerto automáticamente
    const port = await detectServerPort();
    print('cyan', `🌐 Conectando al servidor en puerto ${port}...`);
    
    const requestBody = {
      query,
      ...(sessionId && { sessionId }),
      ...(courseId && { courseId })
    };
    
    const response = await axios.post(`http://localhost:${port}/api/openai-vector`, requestBody, {
      headers: {
        'Content-Type': 'application/json',
      },
    });

    print('green', '\n🤖 Respuesta:');
    console.log(response.data.response);
    console.log('');
    
    return response.data.response;
    
  } catch (error) {
    if (error.code === 'ECONNREFUSED') {
      print('red', '❌ Error: El servidor Next.js no está corriendo.');
      print('yellow', '💡 Ejecuta: npm run dev');
    } else {
      print('red', `Error: ${error.message}`);
    }
    return null;
  }
}

// Función para mostrar sesiones disponibles
function showSessions() {
  print('cyan', '\n🎯 Cursos Disponibles:');
  print('white', '1. SSO001 - Seguridad y Salud Ocupacional');
  print('white', '2. PER001 - Operación de Equipos de Perforación');
  print('cyan', '\n💡 Usa: /select <curso> <sesión> para seleccionar');
  print('cyan', '   Ejemplos:');
  print('cyan', '   /select SSO001 1 - SSO, sesión 1 (IPERC)');
  print('cyan', '   /select PER001 1 - Perforación, sesión 1 (Fundamentos)\n');
}

// Variables globales
let currentCourse = null;
let currentSession = null;
let loadedMoments = null;
let isClassActive = false;
let currentMoment = 0;
let conversationHistory = [];
let isInConversation = false;
let studentName = null;

// Función para limpiar variables globales
function clearGlobalState() {
  currentCourse = null;
  currentSession = null;
  loadedMoments = null;
  isClassActive = false;
  currentMoment = 0;
  conversationHistory = [];
  isInConversation = false;
  studentName = null;
}

// Función para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const coursesPath = path.join(__dirname, '../data/courses-database.json');
    const coursesData = fs.readFileSync(coursesPath, 'utf8');
    return JSON.parse(coursesData).courses;
  } catch (error) {
    print('red', '❌ Error al cargar la base de datos de cursos');
    return [];
  }
}

// Función para seleccionar curso y sesión
async function selectSession(courseId, sessionNumber) {
  const courses = loadCoursesDatabase();
  
  // Buscar el curso
  const course = courses.find(c => c.id === courseId);
  if (!course) {
    print('red', `❌ Curso ${courseId} no encontrado. Cursos disponibles: SSO001, PER001\n`);
    return null;
  }
  
  // Buscar la sesión
  const sessionIndex = parseInt(sessionNumber) - 1;
  if (sessionIndex < 0 || sessionIndex >= course.sessions.length) {
    print('red', `❌ Número de sesión inválido. Sesiones disponibles: 1-${course.sessions.length}\n`);
    return null;
  }
  
  const session = course.sessions[sessionIndex];
  
  // Establecer curso y sesión actuales
  currentCourse = course;
  currentSession = session;
  
  print('green', `✅ Curso seleccionado: ${currentCourse.id}`);
  print('cyan', `👨‍🏫 Especialista: ${currentCourse.specialist_role}`);
  print('green', `✅ Sesión seleccionada: ${currentSession.id}`);
  print('cyan', `📚 Tema: ${currentSession.name}`);
  print('cyan', `🎯 Objetivo: ${currentSession.learning_objective}`);
  
  // Cargar momentos automáticamente
  print('yellow', '🔄 Cargando momentos automáticamente...');
  await loadAllMoments();
  
  // Iniciar conversación automáticamente
  print('green', '🚀 Iniciando conversación automáticamente...\n');
  await startConversation();
  
  return { course: currentCourse, session: currentSession };
}

// Función para cargar todos los momentos de una sesión
async function loadAllMoments() {
  if (!currentSession) {
    print('red', '❌ No hay sesión seleccionada. Usa /select primero.\n');
    return;
  }

  print('yellow', `🔄 Cargando todos los momentos de ${currentSession.id}...`);
  
  // Cargar guía de enseñanza para obtener títulos precisos
  const teachingGuide = loadTeachingGuide();
  
  if (teachingGuide) {
    loadedMoments = teachingGuide.momentos.map(moment => ({
      id: moment.momento,
      title: moment.titulo
    }));
    print('green', `📖 Usando guía de enseñanza: ${teachingGuide.rol_docente_ia}`);
  } else {
    // Fallback a títulos básicos si no se puede cargar la guía
    loadedMoments = [
      { id: 'MOMENTO_0', title: 'SALUDO Y ENCENDIDO DEL AULA' },
      { id: 'MOMENTO_1', title: 'CONEXIÓN CON SABERES PREVIOS Y RELEVANCIA' },
      { id: 'MOMENTO_2', title: 'ADQUISICIÓN DE CONOCIMIENTOS BÁSICOS' },
      { id: 'MOMENTO_3', title: 'APLICACIÓN PRÁCTICA' },
      { id: 'MOMENTO_4', title: 'DISCUSIÓN Y CONTRASTE' },
      { id: 'MOMENTO_5', title: 'REFLEXIÓN FINAL Y CIERRE' }
    ];
  }

  print('green', `✅ Momentos de ${currentSession.id} cargados exitosamente\n`);
}

// Función para cargar la guía de enseñanza
function loadTeachingGuide() {
  try {
    const guidePath = path.join(__dirname, '../data/teaching-guide.json');
    const guideData = fs.readFileSync(guidePath, 'utf8');
    return JSON.parse(guideData);
  } catch {
    print('red', '❌ Error al cargar la guía de enseñanza');
    return null;
  }
}

// Función para generar prompt específico de un momento
function generateMomentPrompt(momentoId, sessionContent, teachingGuide) {
  const moment = teachingGuide.momentos.find(m => m.momento === momentoId);
  if (!moment) {
    return `¿Qué dice el ${momentoId} del contenido ${sessionContent}?`;
  }

  const randomExample = moment.ejemplos[Math.floor(Math.random() * moment.ejemplos.length)];
  
  return `Actúa como un ${teachingGuide.rol_docente_ia} en modalidad ${teachingGuide.modalidad}.

${moment.titulo}: ${moment.descripcion}

Ejemplo de interacción: "${randomExample}"

Ahora, basándote en el contenido del ${momentoId} del archivo ${sessionContent}, desarrolla este momento de la clase de manera natural y pedagógica. Incluye:
1. Una introducción al contenido específico del momento
2. Preguntas interactivas basadas en el material
3. Ejemplos prácticos relacionados
4. Verificación de comprensión

Contenido a consultar: ¿Qué dice el ${momentoId} del contenido ${sessionContent}?`;
}

// Función para comenzar la clase automática
async function startClass() {
  if (!currentSession) {
    print('red', '❌ No hay sesión seleccionada. Usa /select primero.\n');
    return;
  }

  if (!loadedMoments) {
    print('red', '❌ No hay momentos cargados. Usa /load primero.\n');
    return;
  }

  // Cargar guía de enseñanza
  const teachingGuide = loadTeachingGuide();
  if (!teachingGuide) {
    print('red', '❌ No se pudo cargar la guía de enseñanza. Continuando sin ella...\n');
  } else {
    print('green', `📖 Guía de enseñanza cargada: ${teachingGuide.rol_docente_ia}`);
  }

  isClassActive = true;
  print('green', `🎓 ¡Bienvenidos a la clase de ${currentSession.name}!`);
  print('cyan', '🚀 Iniciando clase automática con Docente-IA...\n');

  for (let i = 0; i < loadedMoments.length; i++) {
    if (!isClassActive) break; // Permitir pausar la clase
    
    const moment = loadedMoments[i];
    print('yellow', `\n📚 ${moment.id}: ${moment.title}`);
    print('cyan', '🔄 Docente-IA preparando el momento...');
    
    // Generar prompt específico del momento
    const sessionContent = `contenido_sso_${currentSession.id}_MSEII`;
    const query = teachingGuide 
      ? generateMomentPrompt(moment.id, sessionContent, teachingGuide)
      : `¿Qué dice el ${moment.id} del contenido ${sessionContent}?`;
    
    await queryVectorStore(query);
    
    if (i < loadedMoments.length - 1) {
      print('yellow', '⏸️  Presiona Enter para continuar al siguiente momento...');
      await new Promise(resolve => {
        rl.question('', () => resolve());
      });
    }
  }

  if (isClassActive) {
    print('green', '\n🎉 ¡Clase completada exitosamente!');
    print('cyan', '📝 Gracias por participar en la sesión.\n');
  }
  
  isClassActive = false;
}

// Función para esperar respuesta del estudiante
async function waitForStudentResponse() {
  return new Promise((resolve) => {
    // Usar readline de forma más controlada
    const tempRl = require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    tempRl.question(`${colors.green}👤 Tú: ${colors.reset}`, (input) => {
      tempRl.close();
      resolve(input.trim());
    });
  });
}



// Función para guiar conversación por momentos
async function guideThroughMoments() {
  if (!loadedMoments) {
    print('red', '❌ No hay momentos cargados. Usa /load primero.');
    return;
  }

  print('green', `🎓 ¡Bienvenido a la clase de ${currentSession.name}!`);
  print('cyan', '🚀 Iniciando conversación guiada...\n');

  for (let i = 0; i < loadedMoments.length; i++) {
    if (!isInConversation) break; // Permitir pausar
    
    currentMoment = i;
    const moment = loadedMoments[i];
    
    print('yellow', `\n📚 ${moment.id}: ${moment.title}`);
    
    // 1. Obtener contenido real del momento
    const contentQuery = `¿Qué dice el ${moment.id} del ${currentSession.file_name}?`;
    print('cyan', '🔄 Obteniendo contenido del momento...');
    print('cyan', `📁 Archivo: ${currentSession.file_name}`);
    print('cyan', `🎯 Curso: ${currentCourse?.id} - ${currentCourse?.name}`);
    
    const momentContent = await queryVectorStore(contentQuery, currentSession.id, currentCourse?.id);
    
    // 2. Obtener estructura del momento desde teaching-guide.json
    const teachingGuide = loadTeachingGuide();
    const momentGuide = teachingGuide?.momentos.find(m => m.momento === moment.id);
    
    if (momentGuide) {
      print('green', `📖 Usando guía: ${momentGuide.titulo}`);
      
      // 3. Seguir estructura específica del momento
      if (moment.id === 'MOMENTO_0') {
        // MOMENTO_0: Saludo específico
        const saludo = momentGuide.ejemplos[0].replace('[nombre]', studentName || 'estudiante');
        print('cyan', `\n🎓 ${saludo}`);
        
        // Esperar respuesta del estudiante
        const respuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${saludo}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Segunda pregunta del MOMENTO_0
        const segundaPregunta = momentGuide.ejemplos[1];
        print('cyan', `\n🎓 ${segundaPregunta}`);
        const segundaRespuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${segundaPregunta}`);
        conversationHistory.push(`Estudiante: ${segundaRespuesta}`);
        
      } else if (moment.id === 'MOMENTO_1') {
        // MOMENTO_1: Historia/caso específico sobre el contenido
        print('cyan', `\n📚 ${momentGuide.titulo}:`);
        print('cyan', momentGuide.descripcion);
        
        // Mostrar contenido específico
        print('cyan', '\n📖 Contenido del tema:');
        console.log(momentContent);
        
        // Generar historia/caso específico sobre el contenido
        const historiaPrompt = `Basándote en este contenido específico del ${moment.id}:

${momentContent}

Genera una historia o caso breve relacionado con este contenido sobre prevención de incendios que:
- Esté directamente relacionada con el material mostrado
- Sea realista y relevante
- Active el pensamiento crítico
- Termine con una pregunta que invite a opinar

Responde SOLO con la historia y pregunta, sin explicaciones adicionales.`;
        
        print('yellow', '🔄 Generando historia específica del momento...');
        const historiaEspecifica = await queryVectorStore(historiaPrompt, currentSession.id, currentCourse?.id);
        
        print('cyan', `\n🎓 ${historiaEspecifica}`);
        print('yellow', '⏳ Escribe tu respuesta y presiona Enter...');
        const respuesta = await waitForStudentResponse();
        print('green', `✅ Respuesta capturada: "${respuesta}"`);
        conversationHistory.push(`Docente: ${historiaEspecifica}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Generar respuesta del docente basada en la respuesta del estudiante
        const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empática y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue información relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesión
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
        
        print('yellow', '🔄 Generando respuesta del docente...');
        const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
        print('cyan', `\n👨‍🏫 ${respuestaDocente}`);
        conversationHistory.push(`Docente: ${respuestaDocente}`);
        
        // Pausa para que el estudiante lea la respuesta
        print('yellow', '\n⏸️  Presiona Enter para continuar...');
        await waitForStudentResponse();
        
      } else if (moment.id === 'MOMENTO_2') {
        // MOMENTO_2: Explicación de conceptos
        print('cyan', `\n📚 ${momentGuide.titulo}:`);
        print('cyan', momentGuide.descripcion);
        
                 // Explicar contenido del file_id
         print('cyan', '\n📖 Contenido específico:');
         console.log(momentContent);
        
        // Hacer pregunta de verificación
        const preguntaVerificacion = momentGuide.ejemplos[0];
        print('cyan', `\n🎓 ${preguntaVerificacion}`);
        const respuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${preguntaVerificacion}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Generar respuesta del docente basada en la respuesta del estudiante
        const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empática y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue información relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesión
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
        
        print('yellow', '🔄 Generando respuesta del docente...');
        const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
        print('cyan', `\n👨‍🏫 ${respuestaDocente}`);
        conversationHistory.push(`Docente: ${respuestaDocente}`);
        
             } else {
         // Otros momentos: Combinar contenido con estructura de la guía
         print('cyan', `\n📚 ${momentGuide.titulo}:`);
         print('cyan', momentGuide.descripcion);
         
         // Mostrar contenido específico
         print('cyan', '\n📖 Contenido del tema:');
         console.log(momentContent);
         
         // Generar pregunta específica sobre el contenido del momento
         const preguntaPrompt = `Basándote en este contenido específico del ${moment.id}:

${momentContent}

Y siguiendo la estructura del momento: ${momentGuide.titulo}
${momentGuide.descripcion}

Genera UNA SOLA pregunta específica sobre este contenido que:
- Esté directamente relacionada con el material mostrado
- Siga el propósito del momento (${momentGuide.titulo})
- Sea conversacional y empática
- Invite a la reflexión sobre el contenido específico

Responde SOLO con la pregunta, sin explicaciones.`;
         
         print('yellow', '🔄 Generando pregunta específica del momento...');
         const preguntaEspecifica = await queryVectorStore(preguntaPrompt, currentSession.id, currentCourse?.id);
         
         print('cyan', `\n🎓 ${preguntaEspecifica}`);
         const respuesta = await waitForStudentResponse();
         conversationHistory.push(`Docente: ${preguntaEspecifica}`);
         conversationHistory.push(`Estudiante: ${respuesta}`);
         
         // Generar respuesta del docente basada en la respuesta del estudiante
         const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empática y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue información relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesión
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
         
         print('yellow', '🔄 Generando respuesta del docente...');
         const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
         print('cyan', `\n👨‍🏫 ${respuestaDocente}`);
         conversationHistory.push(`Docente: ${respuestaDocente}`);
       }
    } else {
      // Fallback si no se encuentra la guía
      print('yellow', '⚠️ No se encontró guía específica para este momento');
      
      // Hacer pregunta genérica
      const preguntaPrompt = `Basándote en este contenido del ${moment.id}:

${momentContent}

Genera UNA SOLA pregunta específica y conversacional sobre este contenido. Responde SOLO con la pregunta.`;
      
      const pregunta = await queryVectorStore(preguntaPrompt, currentSession.id, currentCourse?.id);
      print('cyan', `\n🎓 ${pregunta}`);
      const respuesta = await waitForStudentResponse();
      conversationHistory.push(`Docente: ${pregunta}`);
      conversationHistory.push(`Estudiante: ${respuesta}`);
      
      // Generar respuesta del docente basada en la respuesta del estudiante
      const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empática y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue información relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesión
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
      
      print('yellow', '🔄 Generando respuesta del docente...');
      const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
      print('cyan', `\n👨‍🏫 ${respuestaDocente}`);
      conversationHistory.push(`Docente: ${respuestaDocente}`);
    }
    
    // 5. Transicionar al siguiente momento
    if (i < loadedMoments.length - 1) {
      print('yellow', '\n⏸️  Presiona Enter para continuar al siguiente momento...');
      await new Promise(resolve => {
        rl.question('', () => resolve());
      });
    }
  }

  if (isInConversation) {
    print('green', '\n🎉 ¡Conversación completada exitosamente!');
    print('cyan', '📝 Gracias por participar en la sesión.\n');
  }
  
  isInConversation = false;
}

// Función para iniciar conversación
async function startConversation() {
  if (!currentSession) {
    print('red', '❌ No hay sesión seleccionada. Usa /select primero.\n');
    return;
  }

  if (!loadedMoments) {
    print('red', '❌ No hay momentos cargados. Usa /load primero.\n');
    return;
  }

  isInConversation = true;
  currentMoment = 0;
  conversationHistory = [];
  
  // Preguntar nombre del estudiante
  print('cyan', '👋 ¡Hola! Soy tu docente virtual. ¿Cómo te llamas?');
  studentName = await waitForStudentResponse();
  
  if (studentName) {
    print('green', `¡Hola ${studentName}! Es un placer conocerte.`);
  }
  
  // Iniciar conversación guiada por momentos
  await guideThroughMoments();
}

// Función para mostrar ayuda
function showHelp() {
  print('cyan', '\n=== COMANDOS ===');
  print('white', '/vector <consulta> - Consultar contenido del curso');
  print('white', '/sessions - Mostrar sesiones disponibles');
  print('white', '/select <curso> <sesión> - Seleccionar curso y sesión (ej: /select SSO001 1)');
  print('white', '/start - Comenzar clase automática');
  print('white', '/conversar - Iniciar conversación guiada con Docente-IA');
  print('white', '/clear - Limpiar estado y variables globales');
  print('white', '/help - Mostrar ayuda');
  print('white', '/exit - Salir');
  print('cyan', '================\n');
}

// Función principal
async function startChat() {
  print('cyan', '🤖 Chat Terminal - Docente-IA');
  print('yellow', 'Escribe /help para ver comandos\n');
  
  // Mostrar sesiones disponibles automáticamente
  showSessions();

  const askQuestion = () => {
    rl.question(`${colors.green}👤 Tú: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();

      if (trimmedInput === '') {
        askQuestion();
        return;
      }

      if (trimmedInput === '/exit') {
        print('yellow', '¡Hasta luego! 👋');
        rl.close();
        return;
      }

      if (trimmedInput === '/help') {
        showHelp();
        askQuestion();
        return;
      }

      if (trimmedInput === '/sessions') {
        showSessions();
        askQuestion();
        return;
      }

      if (trimmedInput.startsWith('/select ')) {
        const parts = trimmedInput.substring(8).trim().split(' ');
        if (parts.length >= 2) {
          const courseId = parts[0];
          const sessionNumber = parts[1];
          await selectSession(courseId, sessionNumber);
        } else {
          print('red', '❌ Formato incorrecto. Usa: /select <curso> <sesión>');
          print('cyan', '   Ejemplo: /select SSO001 1');
        }
        askQuestion();
        return;
      }

      if (trimmedInput === '/load') {
        await loadAllMoments();
        askQuestion();
        return;
      }

      if (trimmedInput === '/start') {
        await startClass();
        askQuestion();
        return;
      }

      if (trimmedInput === '/clear') {
        clearGlobalState();
        print('green', '✅ Estado limpiado. Variables globales reiniciadas.');
        askQuestion();
        return;
      }

      if (trimmedInput === '/conversar') {
        await startConversation();
        askQuestion();
        return;
      }

      if (trimmedInput.startsWith('/vector ')) {
        const query = trimmedInput.substring(8);
        await queryVectorStore(query);
        askQuestion();
        return;
      }

      print('red', '❌ Comando no reconocido. Usa /help para ver comandos disponibles.');
      askQuestion();
    });
  };

  askQuestion();
}

// Manejar salida
rl.on('close', () => {
  process.exit(0);
});

// Iniciar
startChat().catch(console.error); 
```
=== EOF: src\scripts\terminal-chat.js

===  src\scripts\package.json
```json
{
  "type": "commonjs"
} 
```
=== EOF: src\scripts\package.json

===  src\scripts\chat-v2.js
```javascript
const readline = require('readline');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Colores para la terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Estado global de la conversación
let conversationState = {
  currentCourse: null,
  currentSession: null,
  isInClass: false,
  studentName: 'estudiante',
  messages: [], // Historial de mensajes en formato OpenAI
  serverPort: 3000
};

// Función para imprimir con colores
function print(color, text) {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// Función para detectar el puerto del servidor
async function detectServerPort() {
  for (let port = 3000; port <= 3005; port++) {
    try {
      const response = await axios.get(`http://localhost:${port}`, { timeout: 1000 });
      if (response.status === 200) {
        conversationState.serverPort = port;
        return port;
      }
    } catch (error) {
      continue;
    }
  }
  return 3000; // Puerto por defecto
}

// Función para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const filePath = path.join(__dirname, '../data/courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    print('red', '❌ Error cargando la base de datos de cursos');
    return null;
  }
}

// Función para cargar la guía de enseñanza
function loadTeachingGuide() {
  try {
    const filePath = path.join(__dirname, '../data/teaching-guide.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    print('red', '❌ Error cargando la guía de enseñanza');
    return null;
  }
}

// Función para consultar OpenAI
async function queryOpenAI(query, sessionId, courseId) {
  try {
    const response = await axios.post(`http://localhost:${conversationState.serverPort}/api/openai-vector`, {
      query,
      sessionId,
      courseId
    }, {
      timeout: 30000
    });
    
    return response.data.response;
  } catch (error) {
    print('red', `❌ Error consultando OpenAI: ${error.message}`);
    return null;
  }
}

// Función para mostrar cursos disponibles
function showCourses() {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return;
  
  print('cyan', '\n📚 Cursos Disponibles:');
  data.courses.forEach((course, index) => {
    print('white', `${index + 1}. ${course.id} - ${course.name}`);
  });
  print('yellow', '\n💡 Usa: /select <curso> <sesión> para seleccionar');
  print('yellow', '   Ejemplo: /select SSO001 1');
}

// Función para seleccionar curso y sesión
async function selectCourse(courseId, sessionNumber) {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return false;
  
  const course = data.courses.find(c => c.id === courseId);
  if (!course) {
    print('red', `❌ Curso ${courseId} no encontrado`);
    return false;
  }
  
  const session = course.sessions[sessionNumber - 1];
  if (!session) {
    print('red', `❌ Sesión ${sessionNumber} no encontrada`);
    return false;
  }
  
  conversationState.currentCourse = course;
  conversationState.currentSession = session;
  
  print('green', `✅ Curso seleccionado: ${course.name}`);
  print('green', `✅ Sesión seleccionada: ${session.name}`);
  print('green', `✅ Especialista: ${course.specialist_role}`);
  print('green', `✅ Objetivo: ${session.learning_objective}`);
  
  return true;
}

// Función para iniciar la clase
async function startClass() {
  if (!conversationState.currentCourse || !conversationState.currentSession) {
    print('red', '❌ Debes seleccionar un curso y sesión primero');
    return;
  }
  
  conversationState.isInClass = true;
  conversationState.messages = []; // Limpiar historial
  
  // Configurar el system prompt
  const systemPrompt = `Eres un ${conversationState.currentCourse.specialist_role}.
  
CURSO: ${conversationState.currentCourse.name}
SESIÓN: ${conversationState.currentSession.name}
OBJETIVO DE APRENDIZAJE: ${conversationState.currentSession.learning_objective}
PUNTOS CLAVE:
${conversationState.currentSession.key_points.map((point, index) => `${index + 1}. ${point}`).join('\n')}

INSTRUCCIONES:
- Actúa como un docente conversacional y empático
- Guía al estudiante paso a paso
- Basa tus respuestas en el contenido del archivo: ${conversationState.currentSession.file_name}
- Haz preguntas específicas sobre el contenido
- Valida y construye sobre las respuestas del estudiante
- Mantén el enfoque en los puntos clave de la sesión`;

  // Agregar mensaje del sistema
  conversationState.messages.push({
    role: 'system',
    content: systemPrompt
  });
  
  print('green', `🎓 ¡Bienvenido a la clase de ${conversationState.currentSession.name}!`);
  print('cyan', '🚀 Iniciando conversación guiada...\n');
  
  // Generar saludo inicial
  const greeting = await generateAIResponse("Genera un saludo cálido y empático para iniciar la clase. Pregunta cómo está el estudiante y presenta brevemente el tema de la sesión.");
  
  if (greeting) {
    print('cyan', `👨‍🏫 ${greeting}`);
    conversationState.messages.push({
      role: 'assistant',
      content: greeting
    });
  }
}

// Función para generar respuesta de la IA
async function generateAIResponse(userMessage) {
  // Agregar mensaje del usuario al historial
  conversationState.messages.push({
    role: 'user',
    content: userMessage
  });
  
  // Crear el prompt completo con el historial
  const fullPrompt = conversationState.messages.map(msg => 
    `${msg.role === 'system' ? 'SISTEMA' : msg.role === 'user' ? 'ESTUDIANTE' : 'DOCENTE'}: ${msg.content}`
  ).join('\n\n');
  
  // Consultar OpenAI
  const response = await queryOpenAI(fullPrompt, conversationState.currentSession?.id, conversationState.currentCourse?.id);
  
  if (response) {
    // Agregar respuesta de la IA al historial
    conversationState.messages.push({
      role: 'assistant',
      content: response
    });
    
    return response;
  }
  
  return null;
}

// Función para procesar comandos
async function processCommand(input) {
  const parts = input.trim().split(' ');
  const command = parts[0].toLowerCase();
  
  switch (command) {
    case '/help':
      showHelp();
      break;
      
    case '/courses':
      showCourses();
      break;
      
    case '/select':
      if (parts.length >= 3) {
        const courseId = parts[1];
        const sessionNumber = parseInt(parts[2]);
        await selectCourse(courseId, sessionNumber);
      } else {
        print('red', '❌ Uso: /select <curso> <sesión>');
      }
      break;
      
    case '/start':
      await startClass();
      break;
      
    case '/clear':
      conversationState.messages = [];
      conversationState.isInClass = false;
      print('green', '✅ Estado de conversación limpiado');
      break;
      
    case '/quit':
    case '/exit':
      print('yellow', '👋 ¡Hasta luego!');
      process.exit(0);
      break;
      
    default:
      print('red', `❌ Comando no reconocido: ${command}`);
      showHelp();
      break;
  }
}

// Función para mostrar ayuda
function showHelp() {
  print('cyan', '\n📖 Comandos disponibles:');
  print('white', '/help - Mostrar esta ayuda');
  print('white', '/courses - Mostrar cursos disponibles');
  print('white', '/select <curso> <sesión> - Seleccionar curso y sesión');
  print('white', '/start - Iniciar la clase');
  print('white', '/clear - Limpiar estado de conversación');
  print('white', '/quit o /exit - Salir del chat');
  print('yellow', '\n💡 Una vez iniciada la clase, simplemente escribe tus respuestas');
}

// Función principal del chat
async function startChat() {
  // Detectar puerto del servidor
  await detectServerPort();
  print('green', `🌐 Servidor detectado en puerto ${conversationState.serverPort}`);
  
  // Crear interfaz de readline
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });
  
  print('cyan', '🤖 Chat Terminal - DocenteIA v2.0');
  print('cyan', 'Escribe /help para ver comandos\n');
  
  // Mostrar cursos disponibles
  showCourses();
  
  // Loop principal de conversación
  const askQuestion = () => {
    rl.question(`${colors.green}👤 Tú: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();
      
      if (!trimmedInput) {
        askQuestion();
        return;
      }
      
      // Procesar comandos
      if (trimmedInput.startsWith('/')) {
        await processCommand(trimmedInput);
        askQuestion();
        return;
      }
      
      // Si estamos en clase, procesar como respuesta del estudiante
      if (conversationState.isInClass) {
        print('yellow', '🔄 Generando respuesta del docente...');
        
        const aiResponse = await generateAIResponse(trimmedInput);
        
        if (aiResponse) {
          print('cyan', `\n👨‍🏫 ${aiResponse}\n`);
        } else {
          print('red', '❌ Error generando respuesta');
        }
      } else {
        print('yellow', '💡 Usa /start para iniciar una clase primero');
      }
      
      askQuestion();
    });
  };
  
  askQuestion();
}

// Manejar señales de salida
process.on('SIGINT', () => {
  print('\n👋 ¡Hasta luego!');
  process.exit(0);
});

// Iniciar el chat
startChat().catch(console.error); 
```
=== EOF: src\scripts\chat-v2.js

===  src\lib\vector-store.ts
```typescript
import OpenAI from 'openai';
import fs from 'fs';
import path from 'path';

// Configurar cliente OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Función para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const filePath = path.join(process.cwd(), 'src', 'data', 'courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data).courses;
  } catch (error) {
    console.error('Error al cargar la base de datos de cursos:', error);
    return [];
  }
}

// Función para obtener información completa del curso
function getCourseInfo(courseId: string) {
  const courses = loadCoursesDatabase();
  const course = courses.find((c: any) => c.id === courseId);
  return course;
}

// Función para obtener información completa de la sesión con datos del curso
function getSessionInfoWithCourse(sessionId: string, courseId?: string) {
  const courses = loadCoursesDatabase();
  let course;
  
  if (courseId) {
    course = getCourseInfo(courseId);
  } else {
    // Buscar en todos los cursos
    course = courses.find((c: any) => 
      c.sessions.some((s: any) => s.id === sessionId)
    );
  }
  
  if (!course) return null;
  
  const session = course.sessions.find((s: any) => s.id === sessionId);
  if (!session) return null;
  
  return {
    ...session,
    course: {
      id: course.id,
      name: course.name,
      specialist_role: course.specialist_role
    }
  };
}

// Función para consultar el vector store de OpenAI usando el SDK oficial
export async function queryOpenAIVectorStore(
  query: string,
  sessionId?: string,
  courseId?: string
): Promise<string> {
  try {
    // Obtener información completa de la sesión
    const sessionInfo = getSessionInfoWithCourse(sessionId || '', courseId);
    
    if (!sessionInfo) {
      return 'No se encontró la sesión especificada.';
    }

    // Construir prompt dinámico con información del curso
    const systemPrompt = `Eres un ${sessionInfo.course.specialist_role}.

CURSO: ${sessionInfo.course.name}
SESIÓN: ${sessionInfo.name}
OBJETIVO DE APRENDIZAJE: ${sessionInfo.learning_objective}

PUNTOS CLAVE DE LA SESIÓN:
${sessionInfo.key_points.map((point: string, index: number) => `${index + 1}. ${point}`).join('\n')}

ARCHIVO: ${sessionInfo.file_name}

INSTRUCCIONES:
- Si la consulta pide "¿Qué dice el MOMENTO_X...?" responde SOLO con el contenido específico de ese momento.
- Si la consulta pide generar preguntas, actúa como docente conversacional y empático.
- Basarte ÚNICAMENTE en el contenido específico del archivo.
- Orientar las preguntas hacia los puntos clave de la sesión.
- No inventes información que no esté en el archivo.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4.1-mini",
      messages: [
        {
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: query
        }
      ],
      max_tokens: 1500,
      temperature: 0.3
    });

    return completion.choices[0]?.message?.content || 'No se pudo generar una respuesta.';
  } catch (error) {
    console.error('Error al consultar vector store de OpenAI:', error);
    return `Error al consultar el vector store de OpenAI: ${error instanceof Error ? error.message : 'Error desconocido'}`;
  }
} 
```
=== EOF: src\lib\vector-store.ts

===  src\lib\utils.ts
```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("es-ES", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date)
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
} 
```
=== EOF: src\lib\utils.ts

===  src\lib\teaching-guide.ts
```typescript
import teachingGuide from '../data/teaching-guide.json';

export interface TeachingMoment {
  momento: string;
  titulo: string;
  descripcion: string;
  ejemplos: string[];
}

export interface TeachingGuide {
  rol_docente_ia: string;
  tipo_sesion: string;
  modalidad: string;
  momentos: TeachingMoment[];
}

// Cargar la guía de enseñanza
export function getTeachingGuide(): TeachingGuide {
  return teachingGuide as TeachingGuide;
}

// Obtener un momento específico
export function getTeachingMoment(momentoId: string): TeachingMoment | null {
  const guide = getTeachingGuide();
  return guide.momentos.find(m => m.momento === momentoId) || null;
}

// Obtener todos los momentos
export function getAllTeachingMoments(): TeachingMoment[] {
  const guide = getTeachingGuide();
  return guide.momentos;
}

// Generar prompt específico para un momento
export function generateMomentPrompt(momentoId: string, sessionContent: string): string {
  const moment = getTeachingMoment(momentoId);
  if (!moment) {
    return `¿Qué dice el ${momentoId} del contenido ${sessionContent}?`;
  }

  const randomExample = moment.ejemplos[Math.floor(Math.random() * moment.ejemplos.length)];
  
  return `Actúa como un ${getTeachingGuide().rol_docente_ia} en modalidad ${getTeachingGuide().modalidad}.

${moment.titulo}: ${moment.descripcion}

Ejemplo de interacción: "${randomExample}"

Ahora, basándote en el contenido del ${momentoId} del archivo ${sessionContent}, desarrolla este momento de la clase de manera natural y pedagógica. Incluye:
1. Una introducción al contenido específico del momento
2. Preguntas interactivas basadas en el material
3. Ejemplos prácticos relacionados
4. Verificación de comprensión

Contenido a consultar: ¿Qué dice el ${momentoId} del contenido ${sessionContent}?`;
} 
```
=== EOF: src\lib\teaching-guide.ts

===  src\lib\openai.ts
```typescript
import OpenAI from 'openai';

// Configuración de OpenAI
export const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
  dangerouslyAllowBrowser: false, // Solo para servidor
});

// Tipos para las respuestas de OpenAI
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// Función para enviar mensaje a ChatGPT
export async function sendChatMessage(
  messages: ChatMessage[],
  model: string = 'gpt-3.5-turbo'
): Promise<ChatResponse> {
  try {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY no está configurada');
    }

    const completion = await openai.chat.completions.create({
      model,
      messages,
      max_tokens: 1000,
      temperature: 0.7,
    });

    const response = completion.choices[0]?.message?.content || '';
    
    return {
      content: response,
      usage: completion.usage ? {
        prompt_tokens: completion.usage.prompt_tokens,
        completion_tokens: completion.usage.completion_tokens,
        total_tokens: completion.usage.total_tokens,
      } : undefined,
    };
  } catch (error) {
    console.error('Error al comunicarse con OpenAI:', error);
    throw new Error('Error al procesar la solicitud');
  }
}

// Función para generar texto con GPT
export async function generateText(
  prompt: string,
  model: string = 'gpt-3.5-turbo'
): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 500,
      temperature: 0.7,
    });

    return completion.choices[0]?.message?.content || '';
  } catch (error) {
    console.error('Error al generar texto:', error);
    throw new Error('Error al generar texto');
  }
}

// Función para analizar sentimientos
export async function analyzeSentiment(text: string): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'Analiza el sentimiento del siguiente texto y responde solo con: POSITIVO, NEGATIVO o NEUTRAL.'
        },
        {
          role: 'user',
          content: text
        }
      ],
      max_tokens: 10,
      temperature: 0.3,
    });

    return completion.choices[0]?.message?.content || 'NEUTRAL';
  } catch (error) {
    console.error('Error al analizar sentimiento:', error);
    return 'NEUTRAL';
  }
} 
```
=== EOF: src\lib\openai.ts

===  src\lib\course-database.ts
```typescript

import courseData from '../data/courses-database.json';

export interface Session {
  id: string;
  name: string;
  file_id: string;
  file_name: string;
}

export interface Course {
  id: string;
  name: string;
  description: string;
  sessions: Session[];
  metadata: {
    total_sessions: number;
    total_files: number;
    created_at: string;
    last_updated: string;
  };
}

export interface CourseDatabase {
  courses: Course[];
}

// Función para buscar una sesión basada en la consulta
export function findSessionByQuery(query: string): Session | null {
  const queryLower = query.toLowerCase();
  
  // Buscar en todos los cursos
  for (const course of courseData.courses) {
    for (const session of course.sessions) {
      // Buscar por ID de sesión
      if (queryLower.includes(session.id.toLowerCase())) {
        return session;
      }
      
      // Buscar por nombre de sesión
      if (queryLower.includes(session.name.toLowerCase())) {
        return session;
      }
      
      // Buscar por nombre de archivo
      if (queryLower.includes(session.file_name.toLowerCase())) {
        return session;
      }
    }
  }
  
  return null;
}

// Función para obtener todas las sesiones disponibles
export function getAllSessions(): Session[] {
  const sessions: Session[] = [];
  
  for (const course of courseData.courses) {
    sessions.push(...course.sessions);
  }
  
  return sessions;
}

// Función para obtener información de una sesión específica
export function getSessionInfo(sessionId: string): Session | null {
  for (const course of courseData.courses) {
    const session = course.sessions.find(s => s.id === sessionId);
    if (session) {
      return session;
    }
  }
  
  return null;
} 
```
=== EOF: src\lib\course-database.ts

===  src\lib\constants.ts
```typescript
export const APP_CONFIG = {
  name: "DocenteIA",
  version: "1.0.0",
  description: "Sistema estable con Next.js y TypeScript",
  author: "Tu Nombre",
  repository: "https://github.com/tu-usuario/docenteia",
} as const;

export const API_ENDPOINTS = {
  base: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
  auth: "/auth",
  users: "/users",
  courses: "/courses",
} as const;

export const ROUTES = {
  home: "/",
  about: "/about",
  contact: "/contact",
  dashboard: "/dashboard",
} as const;

export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
} as const; 
```
=== EOF: src\lib\constants.ts

===  src\lib\config.ts
```typescript
export const config = {
  app: {
    name: process.env.NEXT_PUBLIC_APP_NAME || "DocenteIA",
    version: process.env.NEXT_PUBLIC_APP_VERSION || "1.0.0",
    description: "Sistema estable con Next.js y TypeScript",
  },
  api: {
    baseUrl: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
    timeout: 10000,
  },
  auth: {
    secret: process.env.NEXTAUTH_SECRET,
    url: process.env.NEXTAUTH_URL || "http://localhost:3000",
  },
  features: {
    analytics: process.env.NEXT_PUBLIC_GA_ID,
    darkMode: true,
    pwa: false,
  },
} as const;

export type Config = typeof config; 
```
=== EOF: src\lib\config.ts

===  src\data\teaching-guide.json
```json
{
  "rol_docente_ia": "Docente IA - Guía uno a uno",
  "tipo_sesion": "General para curso técnico",
  "modalidad": "Virtual sincrónica individual",
  "momentos": [
    {
      "momento": "MOMENTO_0",
      "titulo": "Saludo y Conexión Inicial",
      "descripcion": "Iniciar la sesión saludando al estudiante por su nombre, mostrando interés genuino. Crear un ambiente de cercanía para que se sienta cómodo. Presentar brevemente el propósito del encuentro.",
      "ejemplos": [
        "Hola [nombre], bienvenido. ¿Cómo estás hoy? ¿Qué palabra usarías para describir tu ánimo?",
        "Hoy trabajaremos un contenido clave que puede ayudarte en tu formación técnica y profesional. ¿Listo para empezar?"
      ]
    },
    {
      "momento": "MOMENTO_1",
      "titulo": "Activación con Historia o Caso",
      "descripcion": "Contar un caso breve o historia relacionada al tema para activar el pensamiento crítico del estudiante. Invitarlo a opinar con libertad, sin juicios, para establecer un vínculo con lo que aprenderá.",
      "ejemplos": [
        "Te cuento algo: Un estudiante olvidó revisar los materiales antes de una práctica y eso generó errores que pudieron evitarse. ¿Qué opinas de esa situación?",
        "Imagínate que alguien ejecuta una tarea sin revisar las instrucciones técnicas. ¿Qué podría pasar en ese caso?"
      ]
    },
    {
      "momento": "MOMENTO_2",
      "titulo": "Adquisición de Conocimientos",
      "descripcion": "Explicar conceptos clave de forma clara y pausada. Después de cada explicación, verificar comprensión solicitando un ejemplo o reformulación. Adaptar el ritmo al estudiante.",
      "ejemplos": [
        "El concepto de 'protocolo' se refiere a un conjunto de pasos que se deben seguir. ¿Puedes darme un ejemplo de protocolo en tu vida diaria?",
        "Cuando hablamos de 'riesgo', nos referimos a la posibilidad de que algo salga mal. ¿Dónde podrías identificar un riesgo en un contexto que conozcas?"
      ]
    },
    {
      "momento": "MOMENTO_3",
      "titulo": "Aplicación Práctica",
      "descripcion": "Plantear una situación realista relacionada al curso. Pedir al estudiante que actúe o analice, guiándolo paso a paso. Observar cómo razona, sin corregir de inmediato.",
      "ejemplos": [
        "Supongamos que estás por realizar una tarea técnica en campo. ¿Qué pasos tomarías antes de comenzar?",
        "Estás en una situación donde debes organizar un procedimiento. ¿Cómo te asegurarías de que todo está listo?"
      ]
    },
    {
      "momento": "MOMENTO_4",
      "titulo": "Discusión y Contraste",
      "descripcion": "Presentar una solución alternativa o modelo. Pedir al estudiante que compare con su propia propuesta. Guiar la reflexión para que reconozca aciertos y posibles mejoras.",
      "ejemplos": [
        "Mira este ejemplo que otros estudiantes han usado. ¿Qué diferencias ves con lo que tú planteaste?",
        "¿Qué cambiarías de tu respuesta ahora que viste otra forma de resolverlo?"
      ]
    },
    {
      "momento": "MOMENTO_5",
      "titulo": "Reflexión Final y Cierre",
      "descripcion": "Invitar al estudiante a reflexionar sobre cómo aplicaría lo aprendido en su realidad. Reforzar el aprendizaje con un cierre positivo y proyectar un posible refuerzo para la próxima sesión.",
      "ejemplos": [
        "¿Cómo podrías aplicar lo aprendido hoy en una situación que te toque enfrentar esta semana?",
        "Hoy avanzaste bastante. ¿Qué parte te gustaría reforzar o practicar más en la siguiente clase?"
      ]
    }
  ]
} 
```
=== EOF: src\data\teaching-guide.json

===  src\data\courses-database.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "Seguridad y Salud Ocupacional",
      "description": "Curso completo de SSO con múltiples sesiones de capacitación",
      "specialist_role": "Especialista en Seguridad y Salud Ocupacional",
      "sessions": [
        {
          "id": "sesion01",
          "name": "IPERC - Identificación de Peligros, Evaluación de Riesgos y Controles",
          "file_id": "file-LtVxVon3svgvNrafJLhbXS",
          "file_name": "contenido_sso_sesion01_MSEII.md",
          "learning_objective": "El estudiante identifica peligros en una situación laboral, evalúa los riesgos asociados y propone controles adecuados para prevenir accidentes",
          "key_points": [
            "Comprende qué es un peligro y cómo se reconoce en el ambiente laboral",
            "Diferencia entre peligro y riesgo en el contexto de SSO",
            "Relaciona la severidad y probabilidad para evaluar un riesgo",
            "Propone controles adecuados según el tipo de peligro identificado"
          ]
        },
        {
          "id": "sesion02", 
          "name": "Sesión 02 de SSO",
          "file_id": "file-MLGFPC2nruo5t5jjC9En1a",
          "file_name": "contenido_sso_sesion02_MSEII.json",
          "learning_objective": "El estudiante aplica procedimientos de seguridad en situaciones específicas del trabajo",
          "key_points": [
            "Identifica procedimientos de seguridad relevantes",
            "Aplica medidas de protección personal",
            "Reconoce señales y señalización de seguridad",
            "Implementa protocolos de emergencia"
          ]
        },
        {
          "id": "sesion03",
          "name": "Prevención de Incendios en el Trabajo", 
          "file_id": "file-MPwrLaMwDkie5yQrymSRqo",
          "file_name": "contenido_sso_sesion03_MSEII.json",
          "learning_objective": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
          "key_points": [
            "Reconoce las causas principales de incendios en el trabajo",
            "Identifica medidas preventivas para evitar incendios",
            "Aplica procedimientos de evacuación en caso de emergencia",
            "Utiliza correctamente equipos contra incendios"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    },
    {
      "id": "PER001",
      "name": "Operación de Equipos de Perforación",
      "description": "Curso completo de perforación con múltiples sesiones de capacitación",
      "specialist_role": "Especialista en operación de equipos de perforación",
      "sessions": [
        {
          "id": "sesion01",
          "name": "Fundamentos de Perforación",
          "file_id": "file-LtVxVon3svgvNrafJLhbXS",
          "file_name": "contenido_perforacion_sesion01.md",
          "learning_objective": "El estudiante identifica los componentes principales de un equipo de perforación y explica su función en el proceso",
          "key_points": [
            "Comprende qué es un equipo de perforación y sus aplicaciones",
            "Identifica los componentes principales del equipo de perforación",
            "Explica la función de cada componente en el proceso",
            "Relaciona el funcionamiento de los componentes para lograr la perforación efectiva"
          ]
        },
        {
          "id": "sesion02",
          "name": "Técnicas de Perforación",
          "file_id": "file-MLGFPC2nruo5t5jjC9En1a",
          "file_name": "contenido_perforacion_sesion02.md",
          "learning_objective": "El estudiante aplica técnicas de perforación según el tipo de terreno y objetivo",
          "key_points": [
            "Reconoce diferentes tipos de técnicas de perforación",
            "Selecciona la técnica apropiada según el terreno",
            "Aplica procedimientos de seguridad en perforación",
            "Evalúa la eficiencia de la técnica utilizada"
          ]
        },
        {
          "id": "sesion03",
          "name": "Mantenimiento de Equipos de Perforación",
          "file_id": "file-MPwrLaMwDkie5yQrymSRqo",
          "file_name": "contenido_perforacion_sesion03.md",
          "learning_objective": "El estudiante realiza mantenimiento preventivo y correctivo en equipos de perforación",
          "key_points": [
            "Identifica componentes que requieren mantenimiento regular",
            "Aplica procedimientos de mantenimiento preventivo",
            "Diagnostica problemas comunes en equipos de perforación",
            "Ejecuta mantenimiento correctivo básico"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    }
  ]
} 
```
=== EOF: src\data\courses-database.json

===  src\components\ChatInterface.tsx
```tsx
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ChatMessage } from '@/lib/openai';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const chatMessages: ChatMessage[] = [
        ...messages.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        { role: 'user', content: input },
      ];

      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: chatMessages,
          model: 'gpt-3.5-turbo',
        }),
      });

      if (!response.ok) {
        throw new Error('Error en la respuesta del servidor');
      }

      const data = await response.json();
      
      const assistantMessage: Message = {
        role: 'assistant',
        content: data.content,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      const errorMessage: Message = {
        role: 'assistant',
        content: 'Lo siento, hubo un error al procesar tu mensaje.',
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        {/* Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 p-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Chat con IA
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Pregunta lo que quieras a la inteligencia artificial
          </p>
        </div>

        {/* Messages */}
        <div className="h-96 overflow-y-auto p-4 space-y-4">
          {messages.length === 0 && (
            <div className="text-center text-gray-500 dark:text-gray-400">
              <p>¡Hola! Soy tu asistente de IA. ¿En qué puedo ayudarte?</p>
            </div>
          )}
          
          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              <div
                className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white'
                }`}
              >
                <p className="text-sm">{message.content}</p>
                <p className="text-xs opacity-70 mt-1">
                  {message.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))}
          
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-gray-100 dark:bg-gray-700 px-4 py-2 rounded-lg">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  Pensando...
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <div className="border-t border-gray-200 dark:border-gray-700 p-4">
          <div className="flex space-x-2">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Escribe tu mensaje..."
              className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white resize-none"
              rows={2}
              disabled={isLoading}
            />
            <Button
              onClick={sendMessage}
              disabled={!input.trim() || isLoading}
              className="px-4 py-2"
            >
              {isLoading ? 'Enviando...' : 'Enviar'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
} 
```
=== EOF: src\components\ChatInterface.tsx

===  src\app\page.tsx
```tsx
import { Button } from "@/components/ui/Button";
import { formatDate } from "@/lib/utils";
import { ChatInterface } from "@/components/ChatInterface";

export default function Home() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800">
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <h1 className="text-4xl md:text-6xl font-bold text-gray-900 dark:text-white mb-4">
            DocenteIA
          </h1>
          <p className="text-xl text-gray-600 dark:text-gray-300 mb-8">
            Sistema estable con Next.js, TypeScript e IA
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button size="lg" className="bg-blue-600 hover:bg-blue-700">
              Comenzar
            </Button>
            <Button variant="outline" size="lg">
              Documentación
            </Button>
          </div>
        </div>

        <div className="grid md:grid-cols-3 gap-8 mt-16 mb-16">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              TypeScript Estricto
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Configuración robusta con verificaciones estrictas de tipos para mayor estabilidad.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Next.js 14
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              La versión más estable con App Router y optimizaciones avanzadas.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              OpenAI Integrado
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Chat inteligente con GPT-3.5-turbo para asistencia automática.
            </p>
          </div>
        </div>

        {/* Chat Interface */}
        <div className="mt-16">
          <ChatInterface />
        </div>

        <div className="mt-12 text-center">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Última actualización: {formatDate(new Date())}
          </p>
        </div>
      </div>
    </div>
  );
}
```
=== EOF: src\app\page.tsx

===  src\app\layout.tsx
```tsx
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "DocenteIA - Sistema Estable",
  description: "Sistema estable con Next.js y TypeScript",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```
=== EOF: src\app\layout.tsx

===  src\app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 0 0% 3.9%;
  --card: 0 0% 100%;
  --card-foreground: 0 0% 3.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 0 0% 3.9%;
  --primary: 0 0% 9%;
  --primary-foreground: 0 0% 98%;
  --secondary: 0 0% 96.1%;
  --secondary-foreground: 0 0% 9%;
  --muted: 0 0% 96.1%;
  --muted-foreground: 0 0% 45.1%;
  --accent: 0 0% 96.1%;
  --accent-foreground: 0 0% 9%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 89.8%;
  --input: 0 0% 89.8%;
  --ring: 0 0% 3.9%;
  --radius: 0.5rem;
}

.dark {
  --background: 0 0% 3.9%;
  --foreground: 0 0% 98%;
  --card: 0 0% 3.9%;
  --card-foreground: 0 0% 98%;
  --popover: 0 0% 3.9%;
  --popover-foreground: 0 0% 98%;
  --primary: 0 0% 98%;
  --primary-foreground: 0 0% 9%;
  --secondary: 0 0% 14.9%;
  --secondary-foreground: 0 0% 98%;
  --muted: 0 0% 14.9%;
  --muted-foreground: 0 0% 63.9%;
  --accent: 0 0% 14.9%;
  --accent-foreground: 0 0% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 14.9%;
  --input: 0 0% 14.9%;
  --ring: 0 0% 83.1%;
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
```
=== EOF: src\app\globals.css

===  src\components\ui\Button.tsx
```tsx
import React from "react";
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants }; 
```
=== EOF: src\components\ui\Button.tsx

===  src\app\api\openai-vector\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { queryOpenAIVectorStore } from '../../../lib/vector-store';

export async function POST(request: NextRequest) {
  try {
    const { query, sessionId, courseId } = await request.json();

    if (!query) {
      return NextResponse.json(
        { error: 'Query es requerida' },
        { status: 400 }
      );
    }

    const response = await queryOpenAIVectorStore(query, sessionId, courseId);

    return NextResponse.json({ response });
  } catch (error) {
    console.error('Error en la ruta OpenAI vector:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\openai-vector\route.ts

===  src\app\api\chat\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { sendChatMessage, ChatMessage } from '@/lib/openai';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { messages, model = 'gpt-3.5-turbo' } = body;

    // Validar que se proporcionen mensajes
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Se requieren mensajes válidos' },
        { status: 400 }
      );
    }

    // Validar que cada mensaje tenga la estructura correcta
    const validMessages: ChatMessage[] = messages.map((msg: any) => ({
      role: msg.role,
      content: msg.content,
    }));

    // Enviar mensaje a OpenAI
    const response = await sendChatMessage(validMessages, model);

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error en API chat:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\chat\route.ts

