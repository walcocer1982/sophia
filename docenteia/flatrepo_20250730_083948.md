---
repository:
  name: docenteia
  owner: unknown
  url: ""
generated:
  timestamp: 2025-07-30T13:39:49.329Z
  tool: FlatRepo
statistics:
  totalFiles: 29
  totalLines: 2582
  languages:
    json: 5
    markdown: 2
    javascript: 5
    typescript: 10
    tsx: 4
    css: 1
  fileTypes:
    .json: 5
    .md: 2
    .js: 5
    .mjs: 1
    .example: 1
    .ts: 10
    .tsx: 4
    .css: 1
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```
=== EOF: tsconfig.json

===  TECHNICAL_DOCS.md
```markdown
# DocumentaciÃ³n TÃ©cnica - DocenteIA

## Arquitectura del Sistema

### Stack TecnolÃ³gico
- **Framework**: Next.js 15 con App Router
- **Lenguaje**: TypeScript 5.x
- **Estilos**: Tailwind CSS 4.x
- **Linting**: ESLint con reglas estrictas
- **Build**: SWC (Rust-based compiler)

### Estructura de Carpetas
```
src/
â”œâ”€â”€ app/                    # App Router (Next.js 15)
â”‚   â”œâ”€â”€ layout.tsx         # Layout principal
â”‚   â”œâ”€â”€ page.tsx           # PÃ¡gina principal
â”‚   â””â”€â”€ globals.css        # Estilos globales
â”œâ”€â”€ components/             # Componentes reutilizables
â”‚   â””â”€â”€ ui/                # Componentes de UI base
â”œâ”€â”€ lib/                   # Utilidades y helpers
â”‚   â”œâ”€â”€ utils.ts           # Funciones utilitarias
â”‚   â”œâ”€â”€ constants.ts       # Constantes del sistema
â”‚   â””â”€â”€ config.ts          # ConfiguraciÃ³n centralizada
â””â”€â”€ types/                 # Tipos TypeScript
    â””â”€â”€ global.d.ts        # Tipos globales
```

## Configuraciones Clave

### TypeScript (tsconfig.json)
- **Target**: ES2022 para mejor rendimiento
- **Strict Mode**: Habilitado completamente
- **No Unused**: Variables y parÃ¡metros no utilizados
- **No Implicit Returns**: Requiere returns explÃ­citos
- **Force Consistent Casing**: Consistencia en nombres de archivos

### ESLint (eslint.config.mjs)
- **Next.js Core Web Vitals**: OptimizaciÃ³n de rendimiento
- **TypeScript Rules**: Verificaciones estrictas
- **No Unused Variables**: Error para variables no utilizadas
- **No Explicit Any**: Advertencia para tipos `any`
- **Prefer Const**: Forzar uso de `const`

### Next.js (next.config.ts)
- **React Strict Mode**: DetecciÃ³n de efectos secundarios
- **Optimize Package Imports**: OptimizaciÃ³n de imports
- **Modern Image Formats**: WebP y AVIF
- **Console Removal**: Eliminar console.log en producciÃ³n

## Componentes del Sistema

### Button Component
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}
```

**CaracterÃ­sticas**:
- Variantes mÃºltiples con `class-variance-authority`
- Tipos estrictos de TypeScript
- Accesibilidad integrada
- Reutilizable y extensible

### Utilidades (lib/utils.ts)
```typescript
// CombinaciÃ³n de clases CSS
cn("class1", "class2")

// Formateo de fechas
formatDate(new Date())

// GeneraciÃ³n de IDs Ãºnicos
generateId()
```

## Optimizaciones de Rendimiento

### Build Optimizations
- **SWC Compiler**: CompilaciÃ³n rÃ¡pida en Rust
- **Tree Shaking**: EliminaciÃ³n de cÃ³digo no utilizado
- **Code Splitting**: DivisiÃ³n automÃ¡tica de bundles
- **Image Optimization**: Formatos modernos (WebP, AVIF)

### Runtime Optimizations
- **React Strict Mode**: DetecciÃ³n de problemas
- **Turbopack**: Bundler rÃ¡pido en desarrollo
- **Incremental Static Regeneration**: PÃ¡ginas estÃ¡ticas dinÃ¡micas

## Seguridad

### TypeScript Strict Mode
- VerificaciÃ³n de tipos en tiempo de compilaciÃ³n
- PrevenciÃ³n de errores de runtime
- Mejor autocompletado y refactoring

### ESLint Security Rules
- DetecciÃ³n de cÃ³digo vulnerable
- PrevenciÃ³n de XSS
- Buenas prÃ¡cticas de seguridad

## Escalabilidad

### Estructura Modular
- Componentes reutilizables
- Utilidades centralizadas
- ConfiguraciÃ³n tipada
- SeparaciÃ³n de responsabilidades

### ConfiguraciÃ³n Flexible
- Variables de entorno tipadas
- ConfiguraciÃ³n centralizada
- Constantes organizadas
- Tipos exportables

## Mantenimiento

### CÃ³digo Limpio
- ESLint con reglas estrictas
- TypeScript con verificaciones exhaustivas
- DocumentaciÃ³n integrada
- Convenciones consistentes

### Testing Ready
- Estructura preparada para tests
- Componentes aislados
- Utilidades testables
- ConfiguraciÃ³n de testing

## Despliegue

### Optimizaciones de ProducciÃ³n
- MinificaciÃ³n automÃ¡tica
- CompresiÃ³n de assets
- CDN ready
- PWA compatible

### Monitoreo
- Error boundaries preparados
- Analytics integrado
- Performance monitoring
- Logging estructurado 
```
=== EOF: TECHNICAL_DOCS.md

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
} 
```
=== EOF: tailwind.config.js

===  README.md
```markdown
# DocenteIA - Sistema Estable con Next.js y TypeScript

Un sistema robusto y estable construido con Next.js 15, TypeScript estricto y Tailwind CSS.

## ğŸš€ CaracterÃ­sticas

- **Next.js 15**: La versiÃ³n mÃ¡s reciente con App Router
- **TypeScript Estricto**: ConfiguraciÃ³n robusta con verificaciones exhaustivas
- **Tailwind CSS 4**: Estilos modernos y optimizados
- **ESLint Configurado**: Reglas estrictas para cÃ³digo limpio
- **Componentes Reutilizables**: Sistema de componentes con TypeScript
- **Utilidades Optimizadas**: Funciones helper para desarrollo eficiente
- **OpenAI Integrado**: Chat inteligente con GPT-3.5-turbo
- **API Routes Seguras**: Endpoints protegidos para comunicaciÃ³n con IA

## ğŸ“¦ InstalaciÃ³n

```bash
# Clonar el repositorio
git clone <tu-repositorio>
cd docenteia

# Instalar dependencias
npm install

# Configurar variables de entorno
cp env.example .env.local
# Editar .env.local y agregar tu OPENAI_API_KEY

# Ejecutar en desarrollo
npm run dev
```

## ğŸ› ï¸ Scripts Disponibles

```bash
npm run dev          # Servidor de desarrollo
npm run build        # ConstrucciÃ³n para producciÃ³n
npm run start        # Servidor de producciÃ³n
npm run lint         # VerificaciÃ³n de cÃ³digo con ESLint
npm run chat         # Chat terminal con IA y vector store
```

## ğŸ—ï¸ Estructura del Proyecto

```
src/
â”œâ”€â”€ app/                 # App Router de Next.js
â”‚   â”œâ”€â”€ layout.tsx      # Layout principal
â”‚   â”œâ”€â”€ page.tsx        # PÃ¡gina principal
â”‚   â””â”€â”€ globals.css     # Estilos globales
â”œâ”€â”€ components/          # Componentes reutilizables
â”‚   â””â”€â”€ ui/             # Componentes de UI
â”‚       â””â”€â”€ Button.tsx  # Componente Button
â”œâ”€â”€ lib/                # Utilidades y helpers
â”‚   â”œâ”€â”€ utils.ts        # Funciones utilitarias
â”‚   â”œâ”€â”€ openai.ts       # ConfiguraciÃ³n de OpenAI
â”‚   â”œâ”€â”€ vector-store.ts # ConfiguraciÃ³n de vector store
â”‚   â”œâ”€â”€ constants.ts    # Constantes del sistema
â”‚   â””â”€â”€ config.ts       # ConfiguraciÃ³n centralizada
â”œâ”€â”€ components/         # Componentes reutilizables
â”‚   â”œâ”€â”€ ui/            # Componentes de UI
â”‚   â””â”€â”€ ChatInterface.tsx # Chat con IA
â””â”€â”€ types/              # Tipos TypeScript
    â””â”€â”€ global.d.ts     # Tipos globales
```

## âš™ï¸ Configuraciones

### TypeScript
- Target: ES2022
- Strict mode habilitado
- Verificaciones estrictas de tipos
- No unused locals/parameters

### ESLint
- Reglas estrictas para TypeScript
- PrevenciÃ³n de cÃ³digo no utilizado
- Advertencias para `any` types

### Next.js
- React Strict Mode
- SWC Minify
- OptimizaciÃ³n de imports
- Soporte para imÃ¡genes modernas

## ğŸ¨ Componentes

### Button Component
Componente reutilizable con mÃºltiples variantes:

```tsx
import { Button } from "@/components/ui/Button";

<Button variant="default" size="lg">
  Comenzar
</Button>
```

### ChatInterface Component
Chat inteligente con OpenAI:

```tsx
import { ChatInterface } from "@/components/ChatInterface";

<ChatInterface />
```

## ğŸ’» Chat Terminal

```bash
npm run chat
```

**Comandos disponibles:**
- `/help` - Mostrar ayuda
- `/history` - Mostrar historial
- `/clear` - Limpiar historial
- `/vector <consulta>` - Consultar vector store
- `/search <consulta>` - Buscar documentos en vector store
- `/exit` - Salir del chat

**âš ï¸ Importante:** Para usar el vector store, necesitas tener el servidor corriendo:
```bash
# Terminal 1: Iniciar servidor
npm run dev

# Terminal 2: Ejecutar chat
npm run chat
```

## ğŸ“ Utilidades

### Funciones Helper
```tsx
import { cn, formatDate, generateId } from "@/lib/utils";

// Combinar clases CSS
cn("class1", "class2")

// Formatear fechas
formatDate(new Date())

// Generar IDs Ãºnicos
generateId()
```

### Funciones de OpenAI
```tsx
import { sendChatMessage, generateText, analyzeSentiment } from "@/lib/openai";

// Enviar mensaje a ChatGPT
const response = await sendChatMessage(messages, 'gpt-3.5-turbo');

// Generar texto
const text = await generateText("Escribe un poema sobre la tecnologÃ­a");

// Analizar sentimiento
const sentiment = await analyzeSentiment("Me encanta este producto!");
```

## ğŸ”§ Desarrollo

### Agregar Nuevos Componentes
1. Crear en `src/components/ui/`
2. Usar TypeScript estricto
3. Implementar variantes con `class-variance-authority`
4. Exportar tipos de props

### Agregar Utilidades
1. Crear en `src/lib/`
2. Documentar con JSDoc
3. Exportar tipos TypeScript

## ğŸš€ Despliegue

El proyecto estÃ¡ optimizado para despliegue en Vercel:

```bash
npm run build
```

## ğŸ“„ Licencia

MIT License - ver archivo LICENSE para detalles.

## ğŸ¤ Contribuir

1. Fork el proyecto
2. Crear una rama feature (`git checkout -b feature/AmazingFeature`)
3. Commit los cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abrir un Pull Request

## ğŸ“ Soporte

Para soporte tÃ©cnico, contacta al equipo de desarrollo.
```
=== EOF: README.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "chat": "node src/scripts/terminal-chat.js"
  },
  "dependencies": {
    "@openai/agents": "^0.0.13",
    "autoprefixer": "^10.4.21",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.532.0",
    "next": "^14.2.0",
    "openai": "^5.10.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20.19.9",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "eslint": "^9",
    "eslint-config-next": "15.4.4",
    "flatrepo": "^1.2.0",
    "typescript": "^5"
  }
}
```
=== EOF: package.json

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    optimizePackageImports: ["lucide-react"],
  },
  images: {
    formats: ["image/webp", "image/avif"],
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
};

module.exports = nextConfig;
```
=== EOF: next.config.js

===  eslint.config.mjs
```
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "prefer-const": "error",
      "no-var": "error",
      "no-console": "warn",
    },
  },
];

export default eslintConfig;
```
=== EOF: eslint.config.mjs

===  env.example
```
# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here

# App Configuration
NEXT_PUBLIC_APP_NAME=DocenteIA
NEXT_PUBLIC_APP_VERSION=1.0.0

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3000/api 
```
=== EOF: env.example

===  src\types\global.d.ts
```typescript
declare global {
  interface Window {
    __NEXT_DATA__: unknown;
  }
}

export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
} 
```
=== EOF: src\types\global.d.ts

===  src\scripts\terminal-chat.js
```javascript
#!/usr/bin/env node

const readline = require('readline');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configurar readline
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Colores simples
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
};

function print(color, text) {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// FunciÃ³n para consultar OpenAI
// FunciÃ³n para detectar el puerto del servidor Next.js
async function detectServerPort() {
  const ports = [3000, 3001, 3002, 3003, 3004, 3005];
  
  for (const port of ports) {
    try {
      const response = await axios.get(`http://localhost:${port}`, { timeout: 1000 });
      if (response.status === 200) {
        return port;
      }
    } catch (error) {
      // Continuar con el siguiente puerto
    }
  }
  
  // Si no encuentra ningÃºn puerto, usar 3000 por defecto
  return 3000;
}

async function queryVectorStore(query, sessionId = null, courseId = null) {
  try {
    print('yellow', 'ğŸ” Consultando OpenAI...');
    
    // Detectar puerto automÃ¡ticamente
    const port = await detectServerPort();
    print('cyan', `ğŸŒ Conectando al servidor en puerto ${port}...`);
    
    const requestBody = {
      query,
      ...(sessionId && { sessionId }),
      ...(courseId && { courseId })
    };
    
    const response = await axios.post(`http://localhost:${port}/api/openai-vector`, requestBody, {
      headers: {
        'Content-Type': 'application/json',
      },
    });

    print('green', '\nğŸ¤– Respuesta:');
    console.log(response.data.response);
    console.log('');
    
    return response.data.response;
    
  } catch (error) {
    if (error.code === 'ECONNREFUSED') {
      print('red', 'âŒ Error: El servidor Next.js no estÃ¡ corriendo.');
      print('yellow', 'ğŸ’¡ Ejecuta: npm run dev');
    } else {
      print('red', `Error: ${error.message}`);
    }
    return null;
  }
}

// FunciÃ³n para mostrar sesiones disponibles
function showSessions() {
  print('cyan', '\nğŸ¯ Cursos Disponibles:');
  print('white', '1. SSO001 - Seguridad y Salud Ocupacional');
  print('white', '2. PER001 - OperaciÃ³n de Equipos de PerforaciÃ³n');
  print('cyan', '\nğŸ’¡ Usa: /select <curso> <sesiÃ³n> para seleccionar');
  print('cyan', '   Ejemplos:');
  print('cyan', '   /select SSO001 1 - SSO, sesiÃ³n 1 (IPERC)');
  print('cyan', '   /select PER001 1 - PerforaciÃ³n, sesiÃ³n 1 (Fundamentos)\n');
}

// Variables globales
let currentCourse = null;
let currentSession = null;
let loadedMoments = null;
let isClassActive = false;
let currentMoment = 0;
let conversationHistory = [];
let isInConversation = false;
let studentName = null;

// FunciÃ³n para limpiar variables globales
function clearGlobalState() {
  currentCourse = null;
  currentSession = null;
  loadedMoments = null;
  isClassActive = false;
  currentMoment = 0;
  conversationHistory = [];
  isInConversation = false;
  studentName = null;
}

// FunciÃ³n para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const coursesPath = path.join(__dirname, '../data/courses-database.json');
    const coursesData = fs.readFileSync(coursesPath, 'utf8');
    return JSON.parse(coursesData).courses;
  } catch (error) {
    print('red', 'âŒ Error al cargar la base de datos de cursos');
    return [];
  }
}

// FunciÃ³n para seleccionar curso y sesiÃ³n
async function selectSession(courseId, sessionNumber) {
  const courses = loadCoursesDatabase();
  
  // Buscar el curso
  const course = courses.find(c => c.id === courseId);
  if (!course) {
    print('red', `âŒ Curso ${courseId} no encontrado. Cursos disponibles: SSO001, PER001\n`);
    return null;
  }
  
  // Buscar la sesiÃ³n
  const sessionIndex = parseInt(sessionNumber) - 1;
  if (sessionIndex < 0 || sessionIndex >= course.sessions.length) {
    print('red', `âŒ NÃºmero de sesiÃ³n invÃ¡lido. Sesiones disponibles: 1-${course.sessions.length}\n`);
    return null;
  }
  
  const session = course.sessions[sessionIndex];
  
  // Establecer curso y sesiÃ³n actuales
  currentCourse = course;
  currentSession = session;
  
  print('green', `âœ… Curso seleccionado: ${currentCourse.id}`);
  print('cyan', `ğŸ‘¨â€ğŸ« Especialista: ${currentCourse.specialist_role}`);
  print('green', `âœ… SesiÃ³n seleccionada: ${currentSession.id}`);
  print('cyan', `ğŸ“š Tema: ${currentSession.name}`);
  print('cyan', `ğŸ¯ Objetivo: ${currentSession.learning_objective}`);
  
  // Cargar momentos automÃ¡ticamente
  print('yellow', 'ğŸ”„ Cargando momentos automÃ¡ticamente...');
  await loadAllMoments();
  
  // Iniciar conversaciÃ³n automÃ¡ticamente
  print('green', 'ğŸš€ Iniciando conversaciÃ³n automÃ¡ticamente...\n');
  await startConversation();
  
  return { course: currentCourse, session: currentSession };
}

// FunciÃ³n para cargar todos los momentos de una sesiÃ³n
async function loadAllMoments() {
  if (!currentSession) {
    print('red', 'âŒ No hay sesiÃ³n seleccionada. Usa /select primero.\n');
    return;
  }

  print('yellow', `ğŸ”„ Cargando todos los momentos de ${currentSession.id}...`);
  
  // Cargar guÃ­a de enseÃ±anza para obtener tÃ­tulos precisos
  const teachingGuide = loadTeachingGuide();
  
  if (teachingGuide) {
    loadedMoments = teachingGuide.momentos.map(moment => ({
      id: moment.momento,
      title: moment.titulo
    }));
    print('green', `ğŸ“– Usando guÃ­a de enseÃ±anza: ${teachingGuide.rol_docente_ia}`);
  } else {
    // Fallback a tÃ­tulos bÃ¡sicos si no se puede cargar la guÃ­a
    loadedMoments = [
      { id: 'MOMENTO_0', title: 'SALUDO Y ENCENDIDO DEL AULA' },
      { id: 'MOMENTO_1', title: 'CONEXIÃ“N CON SABERES PREVIOS Y RELEVANCIA' },
      { id: 'MOMENTO_2', title: 'ADQUISICIÃ“N DE CONOCIMIENTOS BÃSICOS' },
      { id: 'MOMENTO_3', title: 'APLICACIÃ“N PRÃCTICA' },
      { id: 'MOMENTO_4', title: 'DISCUSIÃ“N Y CONTRASTE' },
      { id: 'MOMENTO_5', title: 'REFLEXIÃ“N FINAL Y CIERRE' }
    ];
  }

  print('green', `âœ… Momentos de ${currentSession.id} cargados exitosamente\n`);
}

// FunciÃ³n para cargar la guÃ­a de enseÃ±anza
function loadTeachingGuide() {
  try {
    const guidePath = path.join(__dirname, '../data/teaching-guide.json');
    const guideData = fs.readFileSync(guidePath, 'utf8');
    return JSON.parse(guideData);
  } catch {
    print('red', 'âŒ Error al cargar la guÃ­a de enseÃ±anza');
    return null;
  }
}

// FunciÃ³n para generar prompt especÃ­fico de un momento
function generateMomentPrompt(momentoId, sessionContent, teachingGuide) {
  const moment = teachingGuide.momentos.find(m => m.momento === momentoId);
  if (!moment) {
    return `Â¿QuÃ© dice el ${momentoId} del contenido ${sessionContent}?`;
  }

  const randomExample = moment.ejemplos[Math.floor(Math.random() * moment.ejemplos.length)];
  
  return `ActÃºa como un ${teachingGuide.rol_docente_ia} en modalidad ${teachingGuide.modalidad}.

${moment.titulo}: ${moment.descripcion}

Ejemplo de interacciÃ³n: "${randomExample}"

Ahora, basÃ¡ndote en el contenido del ${momentoId} del archivo ${sessionContent}, desarrolla este momento de la clase de manera natural y pedagÃ³gica. Incluye:
1. Una introducciÃ³n al contenido especÃ­fico del momento
2. Preguntas interactivas basadas en el material
3. Ejemplos prÃ¡cticos relacionados
4. VerificaciÃ³n de comprensiÃ³n

Contenido a consultar: Â¿QuÃ© dice el ${momentoId} del contenido ${sessionContent}?`;
}

// FunciÃ³n para comenzar la clase automÃ¡tica
async function startClass() {
  if (!currentSession) {
    print('red', 'âŒ No hay sesiÃ³n seleccionada. Usa /select primero.\n');
    return;
  }

  if (!loadedMoments) {
    print('red', 'âŒ No hay momentos cargados. Usa /load primero.\n');
    return;
  }

  // Cargar guÃ­a de enseÃ±anza
  const teachingGuide = loadTeachingGuide();
  if (!teachingGuide) {
    print('red', 'âŒ No se pudo cargar la guÃ­a de enseÃ±anza. Continuando sin ella...\n');
  } else {
    print('green', `ğŸ“– GuÃ­a de enseÃ±anza cargada: ${teachingGuide.rol_docente_ia}`);
  }

  isClassActive = true;
  print('green', `ğŸ“ Â¡Bienvenidos a la clase de ${currentSession.name}!`);
  print('cyan', 'ğŸš€ Iniciando clase automÃ¡tica con Docente-IA...\n');

  for (let i = 0; i < loadedMoments.length; i++) {
    if (!isClassActive) break; // Permitir pausar la clase
    
    const moment = loadedMoments[i];
    print('yellow', `\nğŸ“š ${moment.id}: ${moment.title}`);
    print('cyan', 'ğŸ”„ Docente-IA preparando el momento...');
    
    // Generar prompt especÃ­fico del momento
    const sessionContent = `contenido_sso_${currentSession.id}_MSEII`;
    const query = teachingGuide 
      ? generateMomentPrompt(moment.id, sessionContent, teachingGuide)
      : `Â¿QuÃ© dice el ${moment.id} del contenido ${sessionContent}?`;
    
    await queryVectorStore(query);
    
    if (i < loadedMoments.length - 1) {
      print('yellow', 'â¸ï¸  Presiona Enter para continuar al siguiente momento...');
      await new Promise(resolve => {
        rl.question('', () => resolve());
      });
    }
  }

  if (isClassActive) {
    print('green', '\nğŸ‰ Â¡Clase completada exitosamente!');
    print('cyan', 'ğŸ“ Gracias por participar en la sesiÃ³n.\n');
  }
  
  isClassActive = false;
}

// FunciÃ³n para esperar respuesta del estudiante
async function waitForStudentResponse() {
  return new Promise((resolve) => {
    // Usar readline de forma mÃ¡s controlada
    const tempRl = require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    tempRl.question(`${colors.green}ğŸ‘¤ TÃº: ${colors.reset}`, (input) => {
      tempRl.close();
      resolve(input.trim());
    });
  });
}



// FunciÃ³n para guiar conversaciÃ³n por momentos
async function guideThroughMoments() {
  if (!loadedMoments) {
    print('red', 'âŒ No hay momentos cargados. Usa /load primero.');
    return;
  }

  print('green', `ğŸ“ Â¡Bienvenido a la clase de ${currentSession.name}!`);
  print('cyan', 'ğŸš€ Iniciando conversaciÃ³n guiada...\n');

  for (let i = 0; i < loadedMoments.length; i++) {
    if (!isInConversation) break; // Permitir pausar
    
    currentMoment = i;
    const moment = loadedMoments[i];
    
    print('yellow', `\nğŸ“š ${moment.id}: ${moment.title}`);
    
    // 1. Obtener contenido real del momento
    const contentQuery = `Â¿QuÃ© dice el ${moment.id} del ${currentSession.file_name}?`;
    print('cyan', 'ğŸ”„ Obteniendo contenido del momento...');
    print('cyan', `ğŸ“ Archivo: ${currentSession.file_name}`);
    print('cyan', `ğŸ¯ Curso: ${currentCourse?.id} - ${currentCourse?.name}`);
    
    const momentContent = await queryVectorStore(contentQuery, currentSession.id, currentCourse?.id);
    
    // 2. Obtener estructura del momento desde teaching-guide.json
    const teachingGuide = loadTeachingGuide();
    const momentGuide = teachingGuide?.momentos.find(m => m.momento === moment.id);
    
    if (momentGuide) {
      print('green', `ğŸ“– Usando guÃ­a: ${momentGuide.titulo}`);
      
      // 3. Seguir estructura especÃ­fica del momento
      if (moment.id === 'MOMENTO_0') {
        // MOMENTO_0: Saludo especÃ­fico
        const saludo = momentGuide.ejemplos[0].replace('[nombre]', studentName || 'estudiante');
        print('cyan', `\nğŸ“ ${saludo}`);
        
        // Esperar respuesta del estudiante
        const respuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${saludo}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Segunda pregunta del MOMENTO_0
        const segundaPregunta = momentGuide.ejemplos[1];
        print('cyan', `\nğŸ“ ${segundaPregunta}`);
        const segundaRespuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${segundaPregunta}`);
        conversationHistory.push(`Estudiante: ${segundaRespuesta}`);
        
      } else if (moment.id === 'MOMENTO_1') {
        // MOMENTO_1: Historia/caso especÃ­fico sobre el contenido
        print('cyan', `\nğŸ“š ${momentGuide.titulo}:`);
        print('cyan', momentGuide.descripcion);
        
        // Mostrar contenido especÃ­fico
        print('cyan', '\nğŸ“– Contenido del tema:');
        console.log(momentContent);
        
        // Generar historia/caso especÃ­fico sobre el contenido
        const historiaPrompt = `BasÃ¡ndote en este contenido especÃ­fico del ${moment.id}:

${momentContent}

Genera una historia o caso breve relacionado con este contenido sobre prevenciÃ³n de incendios que:
- EstÃ© directamente relacionada con el material mostrado
- Sea realista y relevante
- Active el pensamiento crÃ­tico
- Termine con una pregunta que invite a opinar

Responde SOLO con la historia y pregunta, sin explicaciones adicionales.`;
        
        print('yellow', 'ğŸ”„ Generando historia especÃ­fica del momento...');
        const historiaEspecifica = await queryVectorStore(historiaPrompt, currentSession.id, currentCourse?.id);
        
        print('cyan', `\nğŸ“ ${historiaEspecifica}`);
        print('yellow', 'â³ Escribe tu respuesta y presiona Enter...');
        const respuesta = await waitForStudentResponse();
        print('green', `âœ… Respuesta capturada: "${respuesta}"`);
        conversationHistory.push(`Docente: ${historiaEspecifica}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Generar respuesta del docente basada en la respuesta del estudiante
        const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empÃ¡tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaciÃ³n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesiÃ³n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
        
        print('yellow', 'ğŸ”„ Generando respuesta del docente...');
        const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
        print('cyan', `\nğŸ‘¨â€ğŸ« ${respuestaDocente}`);
        conversationHistory.push(`Docente: ${respuestaDocente}`);
        
        // Pausa para que el estudiante lea la respuesta
        print('yellow', '\nâ¸ï¸  Presiona Enter para continuar...');
        await waitForStudentResponse();
        
      } else if (moment.id === 'MOMENTO_2') {
        // MOMENTO_2: ExplicaciÃ³n de conceptos
        print('cyan', `\nğŸ“š ${momentGuide.titulo}:`);
        print('cyan', momentGuide.descripcion);
        
                 // Explicar contenido del file_id
         print('cyan', '\nğŸ“– Contenido especÃ­fico:');
         console.log(momentContent);
        
        // Hacer pregunta de verificaciÃ³n
        const preguntaVerificacion = momentGuide.ejemplos[0];
        print('cyan', `\nğŸ“ ${preguntaVerificacion}`);
        const respuesta = await waitForStudentResponse();
        conversationHistory.push(`Docente: ${preguntaVerificacion}`);
        conversationHistory.push(`Estudiante: ${respuesta}`);
        
        // Generar respuesta del docente basada en la respuesta del estudiante
        const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empÃ¡tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaciÃ³n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesiÃ³n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
        
        print('yellow', 'ğŸ”„ Generando respuesta del docente...');
        const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
        print('cyan', `\nğŸ‘¨â€ğŸ« ${respuestaDocente}`);
        conversationHistory.push(`Docente: ${respuestaDocente}`);
        
             } else {
         // Otros momentos: Combinar contenido con estructura de la guÃ­a
         print('cyan', `\nğŸ“š ${momentGuide.titulo}:`);
         print('cyan', momentGuide.descripcion);
         
         // Mostrar contenido especÃ­fico
         print('cyan', '\nğŸ“– Contenido del tema:');
         console.log(momentContent);
         
         // Generar pregunta especÃ­fica sobre el contenido del momento
         const preguntaPrompt = `BasÃ¡ndote en este contenido especÃ­fico del ${moment.id}:

${momentContent}

Y siguiendo la estructura del momento: ${momentGuide.titulo}
${momentGuide.descripcion}

Genera UNA SOLA pregunta especÃ­fica sobre este contenido que:
- EstÃ© directamente relacionada con el material mostrado
- Siga el propÃ³sito del momento (${momentGuide.titulo})
- Sea conversacional y empÃ¡tica
- Invite a la reflexiÃ³n sobre el contenido especÃ­fico

Responde SOLO con la pregunta, sin explicaciones.`;
         
         print('yellow', 'ğŸ”„ Generando pregunta especÃ­fica del momento...');
         const preguntaEspecifica = await queryVectorStore(preguntaPrompt, currentSession.id, currentCourse?.id);
         
         print('cyan', `\nğŸ“ ${preguntaEspecifica}`);
         const respuesta = await waitForStudentResponse();
         conversationHistory.push(`Docente: ${preguntaEspecifica}`);
         conversationHistory.push(`Estudiante: ${respuesta}`);
         
         // Generar respuesta del docente basada en la respuesta del estudiante
         const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empÃ¡tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaciÃ³n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesiÃ³n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
         
         print('yellow', 'ğŸ”„ Generando respuesta del docente...');
         const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
         print('cyan', `\nğŸ‘¨â€ğŸ« ${respuestaDocente}`);
         conversationHistory.push(`Docente: ${respuestaDocente}`);
       }
    } else {
      // Fallback si no se encuentra la guÃ­a
      print('yellow', 'âš ï¸ No se encontrÃ³ guÃ­a especÃ­fica para este momento');
      
      // Hacer pregunta genÃ©rica
      const preguntaPrompt = `BasÃ¡ndote en este contenido del ${moment.id}:

${momentContent}

Genera UNA SOLA pregunta especÃ­fica y conversacional sobre este contenido. Responde SOLO con la pregunta.`;
      
      const pregunta = await queryVectorStore(preguntaPrompt, currentSession.id, currentCourse?.id);
      print('cyan', `\nğŸ“ ${pregunta}`);
      const respuesta = await waitForStudentResponse();
      conversationHistory.push(`Docente: ${pregunta}`);
      conversationHistory.push(`Estudiante: ${respuesta}`);
      
      // Generar respuesta del docente basada en la respuesta del estudiante
      const respuestaDocentePrompt = `Como ${currentCourse.specialist_role}, responde de manera empÃ¡tica y constructiva a la respuesta del estudiante:

Respuesta del estudiante: "${respuesta}"

Genera una respuesta que:
- Valide la respuesta del estudiante
- Agregue informaciÃ³n relevante del contenido
- Mantenga el enfoque en los puntos clave de la sesiÃ³n
- Sea conversacional y motivadora

Responde SOLO con tu respuesta, sin explicaciones adicionales.`;
      
      print('yellow', 'ğŸ”„ Generando respuesta del docente...');
      const respuestaDocente = await queryVectorStore(respuestaDocentePrompt, currentSession.id, currentCourse?.id);
      print('cyan', `\nğŸ‘¨â€ğŸ« ${respuestaDocente}`);
      conversationHistory.push(`Docente: ${respuestaDocente}`);
    }
    
    // 5. Transicionar al siguiente momento
    if (i < loadedMoments.length - 1) {
      print('yellow', '\nâ¸ï¸  Presiona Enter para continuar al siguiente momento...');
      await new Promise(resolve => {
        rl.question('', () => resolve());
      });
    }
  }

  if (isInConversation) {
    print('green', '\nğŸ‰ Â¡ConversaciÃ³n completada exitosamente!');
    print('cyan', 'ğŸ“ Gracias por participar en la sesiÃ³n.\n');
  }
  
  isInConversation = false;
}

// FunciÃ³n para iniciar conversaciÃ³n
async function startConversation() {
  if (!currentSession) {
    print('red', 'âŒ No hay sesiÃ³n seleccionada. Usa /select primero.\n');
    return;
  }

  if (!loadedMoments) {
    print('red', 'âŒ No hay momentos cargados. Usa /load primero.\n');
    return;
  }

  isInConversation = true;
  currentMoment = 0;
  conversationHistory = [];
  
  // Preguntar nombre del estudiante
  print('cyan', 'ğŸ‘‹ Â¡Hola! Soy tu docente virtual. Â¿CÃ³mo te llamas?');
  studentName = await waitForStudentResponse();
  
  if (studentName) {
    print('green', `Â¡Hola ${studentName}! Es un placer conocerte.`);
  }
  
  // Iniciar conversaciÃ³n guiada por momentos
  await guideThroughMoments();
}

// FunciÃ³n para mostrar ayuda
function showHelp() {
  print('cyan', '\n=== COMANDOS ===');
  print('white', '/vector <consulta> - Consultar contenido del curso');
  print('white', '/sessions - Mostrar sesiones disponibles');
  print('white', '/select <curso> <sesiÃ³n> - Seleccionar curso y sesiÃ³n (ej: /select SSO001 1)');
  print('white', '/start - Comenzar clase automÃ¡tica');
  print('white', '/conversar - Iniciar conversaciÃ³n guiada con Docente-IA');
  print('white', '/clear - Limpiar estado y variables globales');
  print('white', '/help - Mostrar ayuda');
  print('white', '/exit - Salir');
  print('cyan', '================\n');
}

// FunciÃ³n principal
async function startChat() {
  print('cyan', 'ğŸ¤– Chat Terminal - Docente-IA');
  print('yellow', 'Escribe /help para ver comandos\n');
  
  // Mostrar sesiones disponibles automÃ¡ticamente
  showSessions();

  const askQuestion = () => {
    rl.question(`${colors.green}ğŸ‘¤ TÃº: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();

      if (trimmedInput === '') {
        askQuestion();
        return;
      }

      if (trimmedInput === '/exit') {
        print('yellow', 'Â¡Hasta luego! ğŸ‘‹');
        rl.close();
        return;
      }

      if (trimmedInput === '/help') {
        showHelp();
        askQuestion();
        return;
      }

      if (trimmedInput === '/sessions') {
        showSessions();
        askQuestion();
        return;
      }

      if (trimmedInput.startsWith('/select ')) {
        const parts = trimmedInput.substring(8).trim().split(' ');
        if (parts.length >= 2) {
          const courseId = parts[0];
          const sessionNumber = parts[1];
          await selectSession(courseId, sessionNumber);
        } else {
          print('red', 'âŒ Formato incorrecto. Usa: /select <curso> <sesiÃ³n>');
          print('cyan', '   Ejemplo: /select SSO001 1');
        }
        askQuestion();
        return;
      }

      if (trimmedInput === '/load') {
        await loadAllMoments();
        askQuestion();
        return;
      }

      if (trimmedInput === '/start') {
        await startClass();
        askQuestion();
        return;
      }

      if (trimmedInput === '/clear') {
        clearGlobalState();
        print('green', 'âœ… Estado limpiado. Variables globales reiniciadas.');
        askQuestion();
        return;
      }

      if (trimmedInput === '/conversar') {
        await startConversation();
        askQuestion();
        return;
      }

      if (trimmedInput.startsWith('/vector ')) {
        const query = trimmedInput.substring(8);
        await queryVectorStore(query);
        askQuestion();
        return;
      }

      print('red', 'âŒ Comando no reconocido. Usa /help para ver comandos disponibles.');
      askQuestion();
    });
  };

  askQuestion();
}

// Manejar salida
rl.on('close', () => {
  process.exit(0);
});

// Iniciar
startChat().catch(console.error); 
```
=== EOF: src\scripts\terminal-chat.js

===  src\scripts\package.json
```json
{
  "type": "commonjs"
} 
```
=== EOF: src\scripts\package.json

===  src\scripts\chat-v2.js
```javascript
const readline = require('readline');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Colores para la terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Estado global de la conversaciÃ³n
let conversationState = {
  currentCourse: null,
  currentSession: null,
  isInClass: false,
  studentName: 'estudiante',
  messages: [], // Historial de mensajes en formato OpenAI
  serverPort: 3000
};

// FunciÃ³n para imprimir con colores
function print(color, text) {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// FunciÃ³n para detectar el puerto del servidor
async function detectServerPort() {
  for (let port = 3000; port <= 3005; port++) {
    try {
      const response = await axios.get(`http://localhost:${port}`, { timeout: 1000 });
      if (response.status === 200) {
        conversationState.serverPort = port;
        return port;
      }
    } catch (error) {
      continue;
    }
  }
  return 3000; // Puerto por defecto
}

// FunciÃ³n para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const filePath = path.join(__dirname, '../data/courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    print('red', 'âŒ Error cargando la base de datos de cursos');
    return null;
  }
}

// FunciÃ³n para cargar la guÃ­a de enseÃ±anza
function loadTeachingGuide() {
  try {
    const filePath = path.join(__dirname, '../data/teaching-guide.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    print('red', 'âŒ Error cargando la guÃ­a de enseÃ±anza');
    return null;
  }
}

// FunciÃ³n para consultar OpenAI
async function queryOpenAI(query, sessionId, courseId) {
  try {
    const response = await axios.post(`http://localhost:${conversationState.serverPort}/api/openai-vector`, {
      query,
      sessionId,
      courseId
    }, {
      timeout: 30000
    });
    
    return response.data.response;
  } catch (error) {
    print('red', `âŒ Error consultando OpenAI: ${error.message}`);
    return null;
  }
}

// FunciÃ³n para mostrar cursos disponibles
function showCourses() {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return;
  
  print('cyan', '\nğŸ“š Cursos Disponibles:');
  data.courses.forEach((course, index) => {
    print('white', `${index + 1}. ${course.id} - ${course.name}`);
  });
  print('yellow', '\nğŸ’¡ Usa: /select <curso> <sesiÃ³n> para seleccionar');
  print('yellow', '   Ejemplo: /select SSO001 1');
}

// FunciÃ³n para seleccionar curso y sesiÃ³n
async function selectCourse(courseId, sessionNumber) {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return false;
  
  const course = data.courses.find(c => c.id === courseId);
  if (!course) {
    print('red', `âŒ Curso ${courseId} no encontrado`);
    return false;
  }
  
  const session = course.sessions[sessionNumber - 1];
  if (!session) {
    print('red', `âŒ SesiÃ³n ${sessionNumber} no encontrada`);
    return false;
  }
  
  conversationState.currentCourse = course;
  conversationState.currentSession = session;
  
  print('green', `âœ… Curso seleccionado: ${course.name}`);
  print('green', `âœ… SesiÃ³n seleccionada: ${session.name}`);
  print('green', `âœ… Especialista: ${course.specialist_role}`);
  print('green', `âœ… Objetivo: ${session.learning_objective}`);
  
  return true;
}

// FunciÃ³n para iniciar la clase
async function startClass() {
  if (!conversationState.currentCourse || !conversationState.currentSession) {
    print('red', 'âŒ Debes seleccionar un curso y sesiÃ³n primero');
    return;
  }
  
  conversationState.isInClass = true;
  conversationState.messages = []; // Limpiar historial
  
  // Configurar el system prompt
  const systemPrompt = `Eres un ${conversationState.currentCourse.specialist_role}.
  
CURSO: ${conversationState.currentCourse.name}
SESIÃ“N: ${conversationState.currentSession.name}
OBJETIVO DE APRENDIZAJE: ${conversationState.currentSession.learning_objective}
PUNTOS CLAVE:
${conversationState.currentSession.key_points.map((point, index) => `${index + 1}. ${point}`).join('\n')}

INSTRUCCIONES:
- ActÃºa como un docente conversacional y empÃ¡tico
- GuÃ­a al estudiante paso a paso
- Basa tus respuestas en el contenido del archivo: ${conversationState.currentSession.file_name}
- Haz preguntas especÃ­ficas sobre el contenido
- Valida y construye sobre las respuestas del estudiante
- MantÃ©n el enfoque en los puntos clave de la sesiÃ³n`;

  // Agregar mensaje del sistema
  conversationState.messages.push({
    role: 'system',
    content: systemPrompt
  });
  
  print('green', `ğŸ“ Â¡Bienvenido a la clase de ${conversationState.currentSession.name}!`);
  print('cyan', 'ğŸš€ Iniciando conversaciÃ³n guiada...\n');
  
  // Generar saludo inicial
  const greeting = await generateAIResponse("Genera un saludo cÃ¡lido y empÃ¡tico para iniciar la clase. Pregunta cÃ³mo estÃ¡ el estudiante y presenta brevemente el tema de la sesiÃ³n.");
  
  if (greeting) {
    print('cyan', `ğŸ‘¨â€ğŸ« ${greeting}`);
    conversationState.messages.push({
      role: 'assistant',
      content: greeting
    });
  }
}

// FunciÃ³n para generar respuesta de la IA
async function generateAIResponse(userMessage) {
  // Agregar mensaje del usuario al historial
  conversationState.messages.push({
    role: 'user',
    content: userMessage
  });
  
  // Crear el prompt completo con el historial
  const fullPrompt = conversationState.messages.map(msg => 
    `${msg.role === 'system' ? 'SISTEMA' : msg.role === 'user' ? 'ESTUDIANTE' : 'DOCENTE'}: ${msg.content}`
  ).join('\n\n');
  
  // Consultar OpenAI
  const response = await queryOpenAI(fullPrompt, conversationState.currentSession?.id, conversationState.currentCourse?.id);
  
  if (response) {
    // Agregar respuesta de la IA al historial
    conversationState.messages.push({
      role: 'assistant',
      content: response
    });
    
    return response;
  }
  
  return null;
}

// FunciÃ³n para procesar comandos
async function processCommand(input) {
  const parts = input.trim().split(' ');
  const command = parts[0].toLowerCase();
  
  switch (command) {
    case '/help':
      showHelp();
      break;
      
    case '/courses':
      showCourses();
      break;
      
    case '/select':
      if (parts.length >= 3) {
        const courseId = parts[1];
        const sessionNumber = parseInt(parts[2]);
        await selectCourse(courseId, sessionNumber);
      } else {
        print('red', 'âŒ Uso: /select <curso> <sesiÃ³n>');
      }
      break;
      
    case '/start':
      await startClass();
      break;
      
    case '/clear':
      conversationState.messages = [];
      conversationState.isInClass = false;
      print('green', 'âœ… Estado de conversaciÃ³n limpiado');
      break;
      
    case '/quit':
    case '/exit':
      print('yellow', 'ğŸ‘‹ Â¡Hasta luego!');
      process.exit(0);
      break;
      
    default:
      print('red', `âŒ Comando no reconocido: ${command}`);
      showHelp();
      break;
  }
}

// FunciÃ³n para mostrar ayuda
function showHelp() {
  print('cyan', '\nğŸ“– Comandos disponibles:');
  print('white', '/help - Mostrar esta ayuda');
  print('white', '/courses - Mostrar cursos disponibles');
  print('white', '/select <curso> <sesiÃ³n> - Seleccionar curso y sesiÃ³n');
  print('white', '/start - Iniciar la clase');
  print('white', '/clear - Limpiar estado de conversaciÃ³n');
  print('white', '/quit o /exit - Salir del chat');
  print('yellow', '\nğŸ’¡ Una vez iniciada la clase, simplemente escribe tus respuestas');
}

// FunciÃ³n principal del chat
async function startChat() {
  // Detectar puerto del servidor
  await detectServerPort();
  print('green', `ğŸŒ Servidor detectado en puerto ${conversationState.serverPort}`);
  
  // Crear interfaz de readline
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });
  
  print('cyan', 'ğŸ¤– Chat Terminal - DocenteIA v2.0');
  print('cyan', 'Escribe /help para ver comandos\n');
  
  // Mostrar cursos disponibles
  showCourses();
  
  // Loop principal de conversaciÃ³n
  const askQuestion = () => {
    rl.question(`${colors.green}ğŸ‘¤ TÃº: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();
      
      if (!trimmedInput) {
        askQuestion();
        return;
      }
      
      // Procesar comandos
      if (trimmedInput.startsWith('/')) {
        await processCommand(trimmedInput);
        askQuestion();
        return;
      }
      
      // Si estamos en clase, procesar como respuesta del estudiante
      if (conversationState.isInClass) {
        print('yellow', 'ğŸ”„ Generando respuesta del docente...');
        
        const aiResponse = await generateAIResponse(trimmedInput);
        
        if (aiResponse) {
          print('cyan', `\nğŸ‘¨â€ğŸ« ${aiResponse}\n`);
        } else {
          print('red', 'âŒ Error generando respuesta');
        }
      } else {
        print('yellow', 'ğŸ’¡ Usa /start para iniciar una clase primero');
      }
      
      askQuestion();
    });
  };
  
  askQuestion();
}

// Manejar seÃ±ales de salida
process.on('SIGINT', () => {
  print('\nğŸ‘‹ Â¡Hasta luego!');
  process.exit(0);
});

// Iniciar el chat
startChat().catch(console.error); 
```
=== EOF: src\scripts\chat-v2.js

===  src\lib\vector-store.ts
```typescript
import OpenAI from 'openai';
import fs from 'fs';
import path from 'path';

// Configurar cliente OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// FunciÃ³n para cargar la base de datos de cursos
function loadCoursesDatabase() {
  try {
    const filePath = path.join(process.cwd(), 'src', 'data', 'courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data).courses;
  } catch (error) {
    console.error('Error al cargar la base de datos de cursos:', error);
    return [];
  }
}

// FunciÃ³n para obtener informaciÃ³n completa del curso
function getCourseInfo(courseId: string) {
  const courses = loadCoursesDatabase();
  const course = courses.find((c: any) => c.id === courseId);
  return course;
}

// FunciÃ³n para obtener informaciÃ³n completa de la sesiÃ³n con datos del curso
function getSessionInfoWithCourse(sessionId: string, courseId?: string) {
  const courses = loadCoursesDatabase();
  let course;
  
  if (courseId) {
    course = getCourseInfo(courseId);
  } else {
    // Buscar en todos los cursos
    course = courses.find((c: any) => 
      c.sessions.some((s: any) => s.id === sessionId)
    );
  }
  
  if (!course) return null;
  
  const session = course.sessions.find((s: any) => s.id === sessionId);
  if (!session) return null;
  
  return {
    ...session,
    course: {
      id: course.id,
      name: course.name,
      specialist_role: course.specialist_role
    }
  };
}

// FunciÃ³n para consultar el vector store de OpenAI usando el SDK oficial
export async function queryOpenAIVectorStore(
  query: string,
  sessionId?: string,
  courseId?: string
): Promise<string> {
  try {
    // Obtener informaciÃ³n completa de la sesiÃ³n
    const sessionInfo = getSessionInfoWithCourse(sessionId || '', courseId);
    
    if (!sessionInfo) {
      return 'No se encontrÃ³ la sesiÃ³n especificada.';
    }

    // Construir prompt dinÃ¡mico con informaciÃ³n del curso
    const systemPrompt = `Eres un ${sessionInfo.course.specialist_role}.

CURSO: ${sessionInfo.course.name}
SESIÃ“N: ${sessionInfo.name}
OBJETIVO DE APRENDIZAJE: ${sessionInfo.learning_objective}

PUNTOS CLAVE DE LA SESIÃ“N:
${sessionInfo.key_points.map((point: string, index: number) => `${index + 1}. ${point}`).join('\n')}

ARCHIVO: ${sessionInfo.file_name}

INSTRUCCIONES:
- Si la consulta pide "Â¿QuÃ© dice el MOMENTO_X...?" responde SOLO con el contenido especÃ­fico de ese momento.
- Si la consulta pide generar preguntas, actÃºa como docente conversacional y empÃ¡tico.
- Basarte ÃšNICAMENTE en el contenido especÃ­fico del archivo.
- Orientar las preguntas hacia los puntos clave de la sesiÃ³n.
- No inventes informaciÃ³n que no estÃ© en el archivo.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4.1-mini",
      messages: [
        {
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: query
        }
      ],
      max_tokens: 1500,
      temperature: 0.3
    });

    return completion.choices[0]?.message?.content || 'No se pudo generar una respuesta.';
  } catch (error) {
    console.error('Error al consultar vector store de OpenAI:', error);
    return `Error al consultar el vector store de OpenAI: ${error instanceof Error ? error.message : 'Error desconocido'}`;
  }
} 
```
=== EOF: src\lib\vector-store.ts

===  src\lib\utils.ts
```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("es-ES", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date)
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
} 
```
=== EOF: src\lib\utils.ts

===  src\lib\teaching-guide.ts
```typescript
import teachingGuide from '../data/teaching-guide.json';

export interface TeachingMoment {
  momento: string;
  titulo: string;
  descripcion: string;
  ejemplos: string[];
}

export interface TeachingGuide {
  rol_docente_ia: string;
  tipo_sesion: string;
  modalidad: string;
  momentos: TeachingMoment[];
}

// Cargar la guÃ­a de enseÃ±anza
export function getTeachingGuide(): TeachingGuide {
  return teachingGuide as TeachingGuide;
}

// Obtener un momento especÃ­fico
export function getTeachingMoment(momentoId: string): TeachingMoment | null {
  const guide = getTeachingGuide();
  return guide.momentos.find(m => m.momento === momentoId) || null;
}

// Obtener todos los momentos
export function getAllTeachingMoments(): TeachingMoment[] {
  const guide = getTeachingGuide();
  return guide.momentos;
}

// Generar prompt especÃ­fico para un momento
export function generateMomentPrompt(momentoId: string, sessionContent: string): string {
  const moment = getTeachingMoment(momentoId);
  if (!moment) {
    return `Â¿QuÃ© dice el ${momentoId} del contenido ${sessionContent}?`;
  }

  const randomExample = moment.ejemplos[Math.floor(Math.random() * moment.ejemplos.length)];
  
  return `ActÃºa como un ${getTeachingGuide().rol_docente_ia} en modalidad ${getTeachingGuide().modalidad}.

${moment.titulo}: ${moment.descripcion}

Ejemplo de interacciÃ³n: "${randomExample}"

Ahora, basÃ¡ndote en el contenido del ${momentoId} del archivo ${sessionContent}, desarrolla este momento de la clase de manera natural y pedagÃ³gica. Incluye:
1. Una introducciÃ³n al contenido especÃ­fico del momento
2. Preguntas interactivas basadas en el material
3. Ejemplos prÃ¡cticos relacionados
4. VerificaciÃ³n de comprensiÃ³n

Contenido a consultar: Â¿QuÃ© dice el ${momentoId} del contenido ${sessionContent}?`;
} 
```
=== EOF: src\lib\teaching-guide.ts

===  src\lib\openai.ts
```typescript
import OpenAI from 'openai';

// ConfiguraciÃ³n de OpenAI
export const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
  dangerouslyAllowBrowser: false, // Solo para servidor
});

// Tipos para las respuestas de OpenAI
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// FunciÃ³n para enviar mensaje a ChatGPT
export async function sendChatMessage(
  messages: ChatMessage[],
  model: string = 'gpt-3.5-turbo'
): Promise<ChatResponse> {
  try {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY no estÃ¡ configurada');
    }

    const completion = await openai.chat.completions.create({
      model,
      messages,
      max_tokens: 1000,
      temperature: 0.7,
    });

    const response = completion.choices[0]?.message?.content || '';
    
    return {
      content: response,
      usage: completion.usage ? {
        prompt_tokens: completion.usage.prompt_tokens,
        completion_tokens: completion.usage.completion_tokens,
        total_tokens: completion.usage.total_tokens,
      } : undefined,
    };
  } catch (error) {
    console.error('Error al comunicarse con OpenAI:', error);
    throw new Error('Error al procesar la solicitud');
  }
}

// FunciÃ³n para generar texto con GPT
export async function generateText(
  prompt: string,
  model: string = 'gpt-3.5-turbo'
): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 500,
      temperature: 0.7,
    });

    return completion.choices[0]?.message?.content || '';
  } catch (error) {
    console.error('Error al generar texto:', error);
    throw new Error('Error al generar texto');
  }
}

// FunciÃ³n para analizar sentimientos
export async function analyzeSentiment(text: string): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'Analiza el sentimiento del siguiente texto y responde solo con: POSITIVO, NEGATIVO o NEUTRAL.'
        },
        {
          role: 'user',
          content: text
        }
      ],
      max_tokens: 10,
      temperature: 0.3,
    });

    return completion.choices[0]?.message?.content || 'NEUTRAL';
  } catch (error) {
    console.error('Error al analizar sentimiento:', error);
    return 'NEUTRAL';
  }
} 
```
=== EOF: src\lib\openai.ts

===  src\lib\course-database.ts
```typescript

import courseData from '../data/courses-database.json';

export interface Session {
  id: string;
  name: string;
  file_id: string;
  file_name: string;
}

export interface Course {
  id: string;
  name: string;
  description: string;
  sessions: Session[];
  metadata: {
    total_sessions: number;
    total_files: number;
    created_at: string;
    last_updated: string;
  };
}

export interface CourseDatabase {
  courses: Course[];
}

// FunciÃ³n para buscar una sesiÃ³n basada en la consulta
export function findSessionByQuery(query: string): Session | null {
  const queryLower = query.toLowerCase();
  
  // Buscar en todos los cursos
  for (const course of courseData.courses) {
    for (const session of course.sessions) {
      // Buscar por ID de sesiÃ³n
      if (queryLower.includes(session.id.toLowerCase())) {
        return session;
      }
      
      // Buscar por nombre de sesiÃ³n
      if (queryLower.includes(session.name.toLowerCase())) {
        return session;
      }
      
      // Buscar por nombre de archivo
      if (queryLower.includes(session.file_name.toLowerCase())) {
        return session;
      }
    }
  }
  
  return null;
}

// FunciÃ³n para obtener todas las sesiones disponibles
export function getAllSessions(): Session[] {
  const sessions: Session[] = [];
  
  for (const course of courseData.courses) {
    sessions.push(...course.sessions);
  }
  
  return sessions;
}

// FunciÃ³n para obtener informaciÃ³n de una sesiÃ³n especÃ­fica
export function getSessionInfo(sessionId: string): Session | null {
  for (const course of courseData.courses) {
    const session = course.sessions.find(s => s.id === sessionId);
    if (session) {
      return session;
    }
  }
  
  return null;
} 
```
=== EOF: src\lib\course-database.ts

===  src\lib\constants.ts
```typescript
export const APP_CONFIG = {
  name: "DocenteIA",
  version: "1.0.0",
  description: "Sistema estable con Next.js y TypeScript",
  author: "Tu Nombre",
  repository: "https://github.com/tu-usuario/docenteia",
} as const;

export const API_ENDPOINTS = {
  base: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
  auth: "/auth",
  users: "/users",
  courses: "/courses",
} as const;

export const ROUTES = {
  home: "/",
  about: "/about",
  contact: "/contact",
  dashboard: "/dashboard",
} as const;

export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
} as const; 
```
=== EOF: src\lib\constants.ts

===  src\lib\config.ts
```typescript
export const config = {
  app: {
    name: process.env.NEXT_PUBLIC_APP_NAME || "DocenteIA",
    version: process.env.NEXT_PUBLIC_APP_VERSION || "1.0.0",
    description: "Sistema estable con Next.js y TypeScript",
  },
  api: {
    baseUrl: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
    timeout: 10000,
  },
  auth: {
    secret: process.env.NEXTAUTH_SECRET,
    url: process.env.NEXTAUTH_URL || "http://localhost:3000",
  },
  features: {
    analytics: process.env.NEXT_PUBLIC_GA_ID,
    darkMode: true,
    pwa: false,
  },
} as const;

export type Config = typeof config; 
```
=== EOF: src\lib\config.ts

===  src\data\teaching-guide.json
```json
{
  "rol_docente_ia": "Docente IA - GuÃ­a uno a uno",
  "tipo_sesion": "General para curso tÃ©cnico",
  "modalidad": "Virtual sincrÃ³nica individual",
  "momentos": [
    {
      "momento": "MOMENTO_0",
      "titulo": "Saludo y ConexiÃ³n Inicial",
      "descripcion": "Iniciar la sesiÃ³n saludando al estudiante por su nombre, mostrando interÃ©s genuino. Crear un ambiente de cercanÃ­a para que se sienta cÃ³modo. Presentar brevemente el propÃ³sito del encuentro.",
      "ejemplos": [
        "Hola [nombre], bienvenido. Â¿CÃ³mo estÃ¡s hoy? Â¿QuÃ© palabra usarÃ­as para describir tu Ã¡nimo?",
        "Hoy trabajaremos un contenido clave que puede ayudarte en tu formaciÃ³n tÃ©cnica y profesional. Â¿Listo para empezar?"
      ]
    },
    {
      "momento": "MOMENTO_1",
      "titulo": "ActivaciÃ³n con Historia o Caso",
      "descripcion": "Contar un caso breve o historia relacionada al tema para activar el pensamiento crÃ­tico del estudiante. Invitarlo a opinar con libertad, sin juicios, para establecer un vÃ­nculo con lo que aprenderÃ¡.",
      "ejemplos": [
        "Te cuento algo: Un estudiante olvidÃ³ revisar los materiales antes de una prÃ¡ctica y eso generÃ³ errores que pudieron evitarse. Â¿QuÃ© opinas de esa situaciÃ³n?",
        "ImagÃ­nate que alguien ejecuta una tarea sin revisar las instrucciones tÃ©cnicas. Â¿QuÃ© podrÃ­a pasar en ese caso?"
      ]
    },
    {
      "momento": "MOMENTO_2",
      "titulo": "AdquisiciÃ³n de Conocimientos",
      "descripcion": "Explicar conceptos clave de forma clara y pausada. DespuÃ©s de cada explicaciÃ³n, verificar comprensiÃ³n solicitando un ejemplo o reformulaciÃ³n. Adaptar el ritmo al estudiante.",
      "ejemplos": [
        "El concepto de 'protocolo' se refiere a un conjunto de pasos que se deben seguir. Â¿Puedes darme un ejemplo de protocolo en tu vida diaria?",
        "Cuando hablamos de 'riesgo', nos referimos a la posibilidad de que algo salga mal. Â¿DÃ³nde podrÃ­as identificar un riesgo en un contexto que conozcas?"
      ]
    },
    {
      "momento": "MOMENTO_3",
      "titulo": "AplicaciÃ³n PrÃ¡ctica",
      "descripcion": "Plantear una situaciÃ³n realista relacionada al curso. Pedir al estudiante que actÃºe o analice, guiÃ¡ndolo paso a paso. Observar cÃ³mo razona, sin corregir de inmediato.",
      "ejemplos": [
        "Supongamos que estÃ¡s por realizar una tarea tÃ©cnica en campo. Â¿QuÃ© pasos tomarÃ­as antes de comenzar?",
        "EstÃ¡s en una situaciÃ³n donde debes organizar un procedimiento. Â¿CÃ³mo te asegurarÃ­as de que todo estÃ¡ listo?"
      ]
    },
    {
      "momento": "MOMENTO_4",
      "titulo": "DiscusiÃ³n y Contraste",
      "descripcion": "Presentar una soluciÃ³n alternativa o modelo. Pedir al estudiante que compare con su propia propuesta. Guiar la reflexiÃ³n para que reconozca aciertos y posibles mejoras.",
      "ejemplos": [
        "Mira este ejemplo que otros estudiantes han usado. Â¿QuÃ© diferencias ves con lo que tÃº planteaste?",
        "Â¿QuÃ© cambiarÃ­as de tu respuesta ahora que viste otra forma de resolverlo?"
      ]
    },
    {
      "momento": "MOMENTO_5",
      "titulo": "ReflexiÃ³n Final y Cierre",
      "descripcion": "Invitar al estudiante a reflexionar sobre cÃ³mo aplicarÃ­a lo aprendido en su realidad. Reforzar el aprendizaje con un cierre positivo y proyectar un posible refuerzo para la prÃ³xima sesiÃ³n.",
      "ejemplos": [
        "Â¿CÃ³mo podrÃ­as aplicar lo aprendido hoy en una situaciÃ³n que te toque enfrentar esta semana?",
        "Hoy avanzaste bastante. Â¿QuÃ© parte te gustarÃ­a reforzar o practicar mÃ¡s en la siguiente clase?"
      ]
    }
  ]
} 
```
=== EOF: src\data\teaching-guide.json

===  src\data\courses-database.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "Seguridad y Salud Ocupacional",
      "description": "Curso completo de SSO con mÃºltiples sesiones de capacitaciÃ³n",
      "specialist_role": "Especialista en Seguridad y Salud Ocupacional",
      "sessions": [
        {
          "id": "sesion01",
          "name": "IPERC - IdentificaciÃ³n de Peligros, EvaluaciÃ³n de Riesgos y Controles",
          "file_id": "file-LtVxVon3svgvNrafJLhbXS",
          "file_name": "contenido_sso_sesion01_MSEII.md",
          "learning_objective": "El estudiante identifica peligros en una situaciÃ³n laboral, evalÃºa los riesgos asociados y propone controles adecuados para prevenir accidentes",
          "key_points": [
            "Comprende quÃ© es un peligro y cÃ³mo se reconoce en el ambiente laboral",
            "Diferencia entre peligro y riesgo en el contexto de SSO",
            "Relaciona la severidad y probabilidad para evaluar un riesgo",
            "Propone controles adecuados segÃºn el tipo de peligro identificado"
          ]
        },
        {
          "id": "sesion02", 
          "name": "SesiÃ³n 02 de SSO",
          "file_id": "file-MLGFPC2nruo5t5jjC9En1a",
          "file_name": "contenido_sso_sesion02_MSEII.json",
          "learning_objective": "El estudiante aplica procedimientos de seguridad en situaciones especÃ­ficas del trabajo",
          "key_points": [
            "Identifica procedimientos de seguridad relevantes",
            "Aplica medidas de protecciÃ³n personal",
            "Reconoce seÃ±ales y seÃ±alizaciÃ³n de seguridad",
            "Implementa protocolos de emergencia"
          ]
        },
        {
          "id": "sesion03",
          "name": "PrevenciÃ³n de Incendios en el Trabajo", 
          "file_id": "file-MPwrLaMwDkie5yQrymSRqo",
          "file_name": "contenido_sso_sesion03_MSEII.json",
          "learning_objective": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
          "key_points": [
            "Reconoce las causas principales de incendios en el trabajo",
            "Identifica medidas preventivas para evitar incendios",
            "Aplica procedimientos de evacuaciÃ³n en caso de emergencia",
            "Utiliza correctamente equipos contra incendios"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    },
    {
      "id": "PER001",
      "name": "OperaciÃ³n de Equipos de PerforaciÃ³n",
      "description": "Curso completo de perforaciÃ³n con mÃºltiples sesiones de capacitaciÃ³n",
      "specialist_role": "Especialista en operaciÃ³n de equipos de perforaciÃ³n",
      "sessions": [
        {
          "id": "sesion01",
          "name": "Fundamentos de PerforaciÃ³n",
          "file_id": "file-LtVxVon3svgvNrafJLhbXS",
          "file_name": "contenido_perforacion_sesion01.md",
          "learning_objective": "El estudiante identifica los componentes principales de un equipo de perforaciÃ³n y explica su funciÃ³n en el proceso",
          "key_points": [
            "Comprende quÃ© es un equipo de perforaciÃ³n y sus aplicaciones",
            "Identifica los componentes principales del equipo de perforaciÃ³n",
            "Explica la funciÃ³n de cada componente en el proceso",
            "Relaciona el funcionamiento de los componentes para lograr la perforaciÃ³n efectiva"
          ]
        },
        {
          "id": "sesion02",
          "name": "TÃ©cnicas de PerforaciÃ³n",
          "file_id": "file-MLGFPC2nruo5t5jjC9En1a",
          "file_name": "contenido_perforacion_sesion02.md",
          "learning_objective": "El estudiante aplica tÃ©cnicas de perforaciÃ³n segÃºn el tipo de terreno y objetivo",
          "key_points": [
            "Reconoce diferentes tipos de tÃ©cnicas de perforaciÃ³n",
            "Selecciona la tÃ©cnica apropiada segÃºn el terreno",
            "Aplica procedimientos de seguridad en perforaciÃ³n",
            "EvalÃºa la eficiencia de la tÃ©cnica utilizada"
          ]
        },
        {
          "id": "sesion03",
          "name": "Mantenimiento de Equipos de PerforaciÃ³n",
          "file_id": "file-MPwrLaMwDkie5yQrymSRqo",
          "file_name": "contenido_perforacion_sesion03.md",
          "learning_objective": "El estudiante realiza mantenimiento preventivo y correctivo en equipos de perforaciÃ³n",
          "key_points": [
            "Identifica componentes que requieren mantenimiento regular",
            "Aplica procedimientos de mantenimiento preventivo",
            "Diagnostica problemas comunes en equipos de perforaciÃ³n",
            "Ejecuta mantenimiento correctivo bÃ¡sico"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    }
  ]
} 
```
=== EOF: src\data\courses-database.json

===  src\components\ChatInterface.tsx
```tsx
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ChatMessage } from '@/lib/openai';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const chatMessages: ChatMessage[] = [
        ...messages.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        { role: 'user', content: input },
      ];

      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: chatMessages,
          model: 'gpt-3.5-turbo',
        }),
      });

      if (!response.ok) {
        throw new Error('Error en la respuesta del servidor');
      }

      const data = await response.json();
      
      const assistantMessage: Message = {
        role: 'assistant',
        content: data.content,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      const errorMessage: Message = {
        role: 'assistant',
        content: 'Lo siento, hubo un error al procesar tu mensaje.',
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        {/* Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 p-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Chat con IA
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Pregunta lo que quieras a la inteligencia artificial
          </p>
        </div>

        {/* Messages */}
        <div className="h-96 overflow-y-auto p-4 space-y-4">
          {messages.length === 0 && (
            <div className="text-center text-gray-500 dark:text-gray-400">
              <p>Â¡Hola! Soy tu asistente de IA. Â¿En quÃ© puedo ayudarte?</p>
            </div>
          )}
          
          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              <div
                className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white'
                }`}
              >
                <p className="text-sm">{message.content}</p>
                <p className="text-xs opacity-70 mt-1">
                  {message.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))}
          
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-gray-100 dark:bg-gray-700 px-4 py-2 rounded-lg">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  Pensando...
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <div className="border-t border-gray-200 dark:border-gray-700 p-4">
          <div className="flex space-x-2">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Escribe tu mensaje..."
              className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white resize-none"
              rows={2}
              disabled={isLoading}
            />
            <Button
              onClick={sendMessage}
              disabled={!input.trim() || isLoading}
              className="px-4 py-2"
            >
              {isLoading ? 'Enviando...' : 'Enviar'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
} 
```
=== EOF: src\components\ChatInterface.tsx

===  src\app\page.tsx
```tsx
import { Button } from "@/components/ui/Button";
import { formatDate } from "@/lib/utils";
import { ChatInterface } from "@/components/ChatInterface";

export default function Home() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800">
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <h1 className="text-4xl md:text-6xl font-bold text-gray-900 dark:text-white mb-4">
            DocenteIA
          </h1>
          <p className="text-xl text-gray-600 dark:text-gray-300 mb-8">
            Sistema estable con Next.js, TypeScript e IA
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button size="lg" className="bg-blue-600 hover:bg-blue-700">
              Comenzar
            </Button>
            <Button variant="outline" size="lg">
              DocumentaciÃ³n
            </Button>
          </div>
        </div>

        <div className="grid md:grid-cols-3 gap-8 mt-16 mb-16">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              TypeScript Estricto
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              ConfiguraciÃ³n robusta con verificaciones estrictas de tipos para mayor estabilidad.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Next.js 14
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              La versiÃ³n mÃ¡s estable con App Router y optimizaciones avanzadas.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              OpenAI Integrado
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Chat inteligente con GPT-3.5-turbo para asistencia automÃ¡tica.
            </p>
          </div>
        </div>

        {/* Chat Interface */}
        <div className="mt-16">
          <ChatInterface />
        </div>

        <div className="mt-12 text-center">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Ãšltima actualizaciÃ³n: {formatDate(new Date())}
          </p>
        </div>
      </div>
    </div>
  );
}
```
=== EOF: src\app\page.tsx

===  src\app\layout.tsx
```tsx
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "DocenteIA - Sistema Estable",
  description: "Sistema estable con Next.js y TypeScript",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```
=== EOF: src\app\layout.tsx

===  src\app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 0 0% 3.9%;
  --card: 0 0% 100%;
  --card-foreground: 0 0% 3.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 0 0% 3.9%;
  --primary: 0 0% 9%;
  --primary-foreground: 0 0% 98%;
  --secondary: 0 0% 96.1%;
  --secondary-foreground: 0 0% 9%;
  --muted: 0 0% 96.1%;
  --muted-foreground: 0 0% 45.1%;
  --accent: 0 0% 96.1%;
  --accent-foreground: 0 0% 9%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 89.8%;
  --input: 0 0% 89.8%;
  --ring: 0 0% 3.9%;
  --radius: 0.5rem;
}

.dark {
  --background: 0 0% 3.9%;
  --foreground: 0 0% 98%;
  --card: 0 0% 3.9%;
  --card-foreground: 0 0% 98%;
  --popover: 0 0% 3.9%;
  --popover-foreground: 0 0% 98%;
  --primary: 0 0% 98%;
  --primary-foreground: 0 0% 9%;
  --secondary: 0 0% 14.9%;
  --secondary-foreground: 0 0% 98%;
  --muted: 0 0% 14.9%;
  --muted-foreground: 0 0% 63.9%;
  --accent: 0 0% 14.9%;
  --accent-foreground: 0 0% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 14.9%;
  --input: 0 0% 14.9%;
  --ring: 0 0% 83.1%;
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
```
=== EOF: src\app\globals.css

===  src\components\ui\Button.tsx
```tsx
import React from "react";
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants }; 
```
=== EOF: src\components\ui\Button.tsx

===  src\app\api\openai-vector\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { queryOpenAIVectorStore } from '../../../lib/vector-store';

export async function POST(request: NextRequest) {
  try {
    const { query, sessionId, courseId } = await request.json();

    if (!query) {
      return NextResponse.json(
        { error: 'Query es requerida' },
        { status: 400 }
      );
    }

    const response = await queryOpenAIVectorStore(query, sessionId, courseId);

    return NextResponse.json({ response });
  } catch (error) {
    console.error('Error en la ruta OpenAI vector:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\openai-vector\route.ts

===  src\app\api\chat\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { sendChatMessage, ChatMessage } from '@/lib/openai';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { messages, model = 'gpt-3.5-turbo' } = body;

    // Validar que se proporcionen mensajes
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Se requieren mensajes vÃ¡lidos' },
        { status: 400 }
      );
    }

    // Validar que cada mensaje tenga la estructura correcta
    const validMessages: ChatMessage[] = messages.map((msg: any) => ({
      role: msg.role,
      content: msg.content,
    }));

    // Enviar mensaje a OpenAI
    const response = await sendChatMessage(validMessages, model);

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error en API chat:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\chat\route.ts

