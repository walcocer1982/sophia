---
repository:
  name: docenteia
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-05T00:51:18.783Z
  tool: FlatRepo
statistics:
  totalFiles: 35
  totalLines: 4831
  languages:
    json: 8
    markdown: 4
    javascript: 3
    typescript: 13
    tsx: 4
    css: 1
  fileTypes:
    .json: 8
    .md: 4
    .js: 3
    .mjs: 1
    .example: 1
    .ts: 13
    .tsx: 4
    .css: 1
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```
=== EOF: tsconfig.json

===  TECHNICAL_DOCS.md
```markdown
# Documentaci√≥n T√©cnica - DocenteIA

## Arquitectura del Sistema

### Stack Tecnol√≥gico
- **Framework**: Next.js 15 con App Router
- **Lenguaje**: TypeScript 5.x
- **Estilos**: Tailwind CSS 4.x
- **Linting**: ESLint con reglas estrictas
- **Build**: SWC (Rust-based compiler)

### Estructura de Carpetas
```
src/
‚îú‚îÄ‚îÄ app/                    # App Router (Next.js 15)
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx         # Layout principal
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # P√°gina principal
‚îÇ   ‚îî‚îÄ‚îÄ globals.css        # Estilos globales
‚îú‚îÄ‚îÄ components/             # Componentes reutilizables
‚îÇ   ‚îî‚îÄ‚îÄ ui/                # Componentes de UI base
‚îú‚îÄ‚îÄ lib/                   # Utilidades y helpers
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           # Funciones utilitarias
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts       # Constantes del sistema
‚îÇ   ‚îî‚îÄ‚îÄ config.ts          # Configuraci√≥n centralizada
‚îî‚îÄ‚îÄ types/                 # Tipos TypeScript
    ‚îî‚îÄ‚îÄ global.d.ts        # Tipos globales
```

## Configuraciones Clave

### TypeScript (tsconfig.json)
- **Target**: ES2022 para mejor rendimiento
- **Strict Mode**: Habilitado completamente
- **No Unused**: Variables y par√°metros no utilizados
- **No Implicit Returns**: Requiere returns expl√≠citos
- **Force Consistent Casing**: Consistencia en nombres de archivos

### ESLint (eslint.config.mjs)
- **Next.js Core Web Vitals**: Optimizaci√≥n de rendimiento
- **TypeScript Rules**: Verificaciones estrictas
- **No Unused Variables**: Error para variables no utilizadas
- **No Explicit Any**: Advertencia para tipos `any`
- **Prefer Const**: Forzar uso de `const`

### Next.js (next.config.ts)
- **React Strict Mode**: Detecci√≥n de efectos secundarios
- **Optimize Package Imports**: Optimizaci√≥n de imports
- **Modern Image Formats**: WebP y AVIF
- **Console Removal**: Eliminar console.log en producci√≥n

## Componentes del Sistema

### Button Component
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}
```

**Caracter√≠sticas**:
- Variantes m√∫ltiples con `class-variance-authority`
- Tipos estrictos de TypeScript
- Accesibilidad integrada
- Reutilizable y extensible

### Utilidades (lib/utils.ts)
```typescript
// Combinaci√≥n de clases CSS
cn("class1", "class2")

// Formateo de fechas
formatDate(new Date())

// Generaci√≥n de IDs √∫nicos
generateId()
```

## Optimizaciones de Rendimiento

### Build Optimizations
- **SWC Compiler**: Compilaci√≥n r√°pida en Rust
- **Tree Shaking**: Eliminaci√≥n de c√≥digo no utilizado
- **Code Splitting**: Divisi√≥n autom√°tica de bundles
- **Image Optimization**: Formatos modernos (WebP, AVIF)

### Runtime Optimizations
- **React Strict Mode**: Detecci√≥n de problemas
- **Turbopack**: Bundler r√°pido en desarrollo
- **Incremental Static Regeneration**: P√°ginas est√°ticas din√°micas

## Seguridad

### TypeScript Strict Mode
- Verificaci√≥n de tipos en tiempo de compilaci√≥n
- Prevenci√≥n de errores de runtime
- Mejor autocompletado y refactoring

### ESLint Security Rules
- Detecci√≥n de c√≥digo vulnerable
- Prevenci√≥n de XSS
- Buenas pr√°cticas de seguridad

## Escalabilidad

### Estructura Modular
- Componentes reutilizables
- Utilidades centralizadas
- Configuraci√≥n tipada
- Separaci√≥n de responsabilidades

### Configuraci√≥n Flexible
- Variables de entorno tipadas
- Configuraci√≥n centralizada
- Constantes organizadas
- Tipos exportables

## Mantenimiento

### C√≥digo Limpio
- ESLint con reglas estrictas
- TypeScript con verificaciones exhaustivas
- Documentaci√≥n integrada
- Convenciones consistentes

### Testing Ready
- Estructura preparada para tests
- Componentes aislados
- Utilidades testables
- Configuraci√≥n de testing

## Despliegue

### Optimizaciones de Producci√≥n
- Minificaci√≥n autom√°tica
- Compresi√≥n de assets
- CDN ready
- PWA compatible

### Monitoreo
- Error boundaries preparados
- Analytics integrado
- Performance monitoring
- Logging estructurado 
```
=== EOF: TECHNICAL_DOCS.md

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
} 
```
=== EOF: tailwind.config.js

===  README.md
```markdown
# DocenteIA - Sistema Estable con Next.js y TypeScript

Un sistema robusto y estable construido con Next.js 14, TypeScript estricto y Tailwind CSS.

## üéØ Prop√≥sito

DocenteIA es un asistente de ense√±anza inteligente que utiliza OpenAI para crear experiencias de aprendizaje personalizadas y conversacionales. El sistema permite a los docentes crear sesiones interactivas con contenido espec√≠fico y gu√≠as de ense√±anza estructuradas.

## üöÄ Caracter√≠sticas

- **Next.js 14**: Versi√≥n estable con App Router
- **TypeScript Estricto**: Configuraci√≥n robusta con verificaciones exhaustivas
- **Tailwind CSS 3**: Estilos modernos y optimizados
- **OpenAI Integration**: Chat conversacional inteligente
- **Teaching Guide System**: Estructura de momentos pedag√≥gicos
- **Course Database**: Gesti√≥n de cursos y sesiones
- **ESLint Configurado**: Reglas estrictas para c√≥digo limpio
- **Componentes Reutilizables**: Sistema de componentes con TypeScript
- **Utilidades Optimizadas**: Funciones helper para desarrollo eficiente
- **OpenAI Integrado**: Chat inteligente con GPT-3.5-turbo
- **API Routes Seguras**: Endpoints protegidos para comunicaci√≥n con IA

## üì¶ Instalaci√≥n

```bash
# Clonar el repositorio
git clone <tu-repositorio>
cd docenteia

# Instalar dependencias
npm install

# Configurar variables de entorno
cp env.example .env.local
# Editar .env.local y agregar tu OPENAI_API_KEY

# Ejecutar en desarrollo
npm run dev
```

## üõ†Ô∏è Scripts Disponibles

```bash
npm run dev          # Servidor de desarrollo
npm run build        # Construcci√≥n para producci√≥n
npm run start        # Servidor de producci√≥n
npm run lint         # Verificaci√≥n de c√≥digo con ESLint
npm run chat         # Chat terminal con IA y vector store
```

## üèóÔ∏è Estructura del Proyecto

```
src/
‚îú‚îÄ‚îÄ app/                 # App Router de Next.js
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx      # Layout principal
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx        # P√°gina principal
‚îÇ   ‚îî‚îÄ‚îÄ globals.css     # Estilos globales
‚îú‚îÄ‚îÄ components/          # Componentes reutilizables
‚îÇ   ‚îî‚îÄ‚îÄ ui/             # Componentes de UI
‚îÇ       ‚îî‚îÄ‚îÄ Button.tsx  # Componente Button
‚îú‚îÄ‚îÄ lib/                # Utilidades y helpers
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts        # Funciones utilitarias
‚îÇ   ‚îú‚îÄ‚îÄ openai.ts       # Configuraci√≥n de OpenAI
‚îÇ   ‚îú‚îÄ‚îÄ vector-store.ts # Configuraci√≥n de vector store
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts    # Constantes del sistema
‚îÇ   ‚îî‚îÄ‚îÄ config.ts       # Configuraci√≥n centralizada
‚îú‚îÄ‚îÄ components/         # Componentes reutilizables
‚îÇ   ‚îú‚îÄ‚îÄ ui/            # Componentes de UI
‚îÇ   ‚îî‚îÄ‚îÄ ChatInterface.tsx # Chat con IA
‚îî‚îÄ‚îÄ types/              # Tipos TypeScript
    ‚îî‚îÄ‚îÄ global.d.ts     # Tipos globales
```

## ‚öôÔ∏è Configuraciones

### TypeScript
- Target: ES2022
- Strict mode habilitado
- Verificaciones estrictas de tipos
- No unused locals/parameters

### ESLint
- Reglas estrictas para TypeScript
- Prevenci√≥n de c√≥digo no utilizado
- Advertencias para `any` types

### Next.js
- React Strict Mode
- SWC Minify
- Optimizaci√≥n de imports
- Soporte para im√°genes modernas

## üé® Componentes

### Button Component
Componente reutilizable con m√∫ltiples variantes:

```tsx
import { Button } from "@/components/ui/Button";

<Button variant="default" size="lg">
  Comenzar
</Button>
```

### ChatInterface Component
Chat inteligente con OpenAI:

```tsx
import { ChatInterface } from "@/components/ChatInterface";

<ChatInterface />
```

## üíª Chat Terminal

```bash
npm run chat
```

**Comandos disponibles:**
- `/help` - Mostrar ayuda
- `/history` - Mostrar historial
- `/clear` - Limpiar historial
- `/vector <consulta>` - Consultar vector store
- `/search <consulta>` - Buscar documentos en vector store
- `/exit` - Salir del chat

**‚ö†Ô∏è Importante:** Para usar el vector store, necesitas tener el servidor corriendo:
```bash
# Terminal 1: Iniciar servidor
npm run dev

# Terminal 2: Ejecutar chat
npm run chat
```

## üìù Utilidades

### Funciones Helper
```tsx
import { cn, formatDate, generateId } from "@/lib/utils";

// Combinar clases CSS
cn("class1", "class2")

// Formatear fechas
formatDate(new Date())

// Generar IDs √∫nicos
generateId()
```

### Funciones de OpenAI
```tsx
import { sendChatMessage, generateText, analyzeSentiment } from "@/lib/openai";

// Enviar mensaje a ChatGPT
const response = await sendChatMessage(messages, 'gpt-3.5-turbo');

// Generar texto
const text = await generateText("Escribe un poema sobre la tecnolog√≠a");

// Analizar sentimiento
const sentiment = await analyzeSentiment("Me encanta este producto!");
```

## üîß Desarrollo

### Agregar Nuevos Componentes
1. Crear en `src/components/ui/`
2. Usar TypeScript estricto
3. Implementar variantes con `class-variance-authority`
4. Exportar tipos de props

### Agregar Utilidades
1. Crear en `src/lib/`
2. Documentar con JSDoc
3. Exportar tipos TypeScript

## üöÄ Despliegue

El proyecto est√° optimizado para despliegue en Vercel:

```bash
npm run build
```

## üìÑ Licencia

MIT License - ver archivo LICENSE para detalles.

## ü§ù Contribuir

1. Fork el proyecto
2. Crear una rama feature (`git checkout -b feature/AmazingFeature`)
3. Commit los cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abrir un Pull Request

## üìû Soporte

Para soporte t√©cnico, contacta al equipo de desarrollo.
```
=== EOF: README.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "chat": "tsc src/scripts/chat-v2.ts --outDir dist && node dist/scripts/chat-v2.js",
    "chat:dev": "tsx src/scripts/chat-v2.ts"
  },
  "dependencies": {
    "@openai/agents": "^0.0.13",
    "autoprefixer": "^10.4.21",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.532.0",
    "next": "^14.2.0",
    "openai": "^5.10.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20.19.9",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "eslint": "^9",
    "eslint-config-next": "15.4.4",
    "flatrepo": "^1.2.0",
    "tsx": "^4.7.0",
    "typescript": "^5"
  }
}
```
=== EOF: package.json

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    optimizePackageImports: ["lucide-react"],
  },
  images: {
    formats: ["image/webp", "image/avif"],
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
};

module.exports = nextConfig;
```
=== EOF: next.config.js

===  instrucciondemejora.md
```markdown
El c√≥digo que utilizas puede optimizarse tanto en su estructura como en la forma en la que interact√∫a con la API de OpenAI. A continuaci√≥n te recomiendo algunas pr√°cticas para mantenerlo limpio y eficiente:

Modularizaci√≥n clara: Divide las funciones en m√≥dulos bien definidos. Por ejemplo, un m√≥dulo para la gesti√≥n de sesiones, otro para la extracci√≥n de momentos y otro para la interacci√≥n con el usuario. Esto facilita el mantenimiento y las pruebas.

Cach√© efectiva: Usa el mapa de cach√© (this.cache) para almacenar resultados frecuentes. Puedes guardar el resultado de b√∫squedas en el vector store o de llamadas a responses.create con prompts similares. Solo deber√≠as volver a llamar a la API si cambia el curso, la sesi√≥n o el momento.

Prompt minimalista: Crea plantillas de prompt reutilizables. Por ejemplo, define un systemMessageBase fuera de las funciones y a√±ade solo la informaci√≥n variable (momento actual, fragmentos) en cada interacci√≥n. Esto evita repetir bloques largos de texto.

Funciones peque√±as y reutilizables: Mant√©n las funciones cortas y con responsabilidad √∫nica. Por ejemplo, validateContentTheme podr√≠a aislar la l√≥gica de filtrado y ser testeada por separado; buildSystemPrompt podr√≠a generar el texto final a partir de par√°metros como la sesi√≥n y los fragmentos.

Modelos escalables: Implementa una capa de abstracci√≥n para elegir el modelo en funci√≥n de la tarea. Si es una extracci√≥n sencilla, utiliza gpt‚Äë3.5‚Äëturbo; si es un feedback pedag√≥gico complejo, usa gpt‚Äë4o. Esto puede ser una funci√≥n getModel(type) o un par√°metro configurable.

Gesti√≥n de sesiones: Aseg√∫rate de limpiar sesiones inactivas y de actualizar correctamente los √≠ndices de momento. Esto evita mantener demasiada informaci√≥n en memoria y hacer llamadas innecesarias.

Control de tokens: Agrega par√°metros opcionales a la llamada de la API para ajustar max_tokens y response_format. Limitar la longitud de la respuesta es una forma directa de reducir costes.

Implementando estas recomendaciones, tendr√°s un c√≥digo m√°s legible, f√°cil de mantener y que te permitir√° controlar mejor el uso y el costo de la API.







T√∫ dijiste:
Respuesta autom√°tica
Continuar
ChatGPT Plus

Trabaj√≥ durante 18 segundos
El usuario ha solicitado continuar, por lo que proporcionar√© m√°s detalles sobre la optimizaci√≥n del c√≥digo y el control de costos. Incluir√© ejemplos espec√≠ficos de mejores pr√°cticas, como la implementaci√≥n de t√©cnicas de almacenamiento en cach√© y modularidad, para ayudar a mejorar la eficiencia y reducir costos.

Listo
Claro, contin√∫o con algunas sugerencias adicionales m√°s concretas:

Uso de variables de entorno y configuraciones: Mant√©n las claves API y par√°metros sensibles en archivos .env y no en el c√≥digo fuente. Adem√°s, define en el .env un par√°metro como OPENAI_MODEL_DEFAULT para poder cambiar de modelo sin modificar cada llamada. Esto te ayuda a probar f√°cilmente distintas combinaciones de modelos y configuraciones para encontrar el equilibrio entre costo y calidad.

Gesti√≥n centralizada de llamadas a la API: Crea un ‚Äúservicio‚Äù dedicado a manejar todas las llamadas a OpenAI. Este servicio puede aplicar patrones como retry en caso de errores transitorios, registrar tiempos de ejecuci√≥n y token usage, e incluso medir costos aproximados. As√≠ tendr√°s un punto √∫nico donde ajustar par√°metros y monitorear el uso.

Manejo de errores robusto: Mejora la captura de errores para evitar reintentos innecesarios. Por ejemplo, si el modelo responde con un JSON malformado, en lugar de volver a hacer una llamada completa, intenta corregir la respuesta o devolver un mensaje predefinido al usuario.

Pruebas unitarias y de integraci√≥n: Al modularizar tu c√≥digo, es m√°s sencillo escribir pruebas. Esto te permite asegurar que cada componente funciona correctamente y que los cambios (como acortar prompts o cambiar modelos) no rompen la funcionalidad existente.

Monitoreo y m√©tricas: Implementa un sistema de logging propio que recoja el n√∫mero de solicitudes, tokens enviados y recibidos, tiempo de respuesta y modelo utilizado. Esta informaci√≥n te dar√° visibilidad en tiempo real de los patrones de uso y te permitir√° ajustar tu c√≥digo bas√°ndote en datos concretos en lugar de suposiciones.

Optimizaci√≥n de b√∫squeda en Vector Store: Si vas a consultar repetidamente los mismos fragmentos, guarda los resultados de vectorStore.search en cach√©. Adem√°s, revisa si puedes indexar documentos de manera que la b√∫squeda sea m√°s espec√≠fica y necesites menos resultados (max_num_results).

Revisi√≥n peri√≥dica de prompts: Lo que funciona al principio puede dejar de ser √≥ptimo conforme cambian los modelos o la cantidad de usuarios. Programa revisiones peri√≥dicas de los prompts y del flujo de conversaci√≥n para eliminar instrucciones redundantes y adaptar tu estrategia a las mejoras de la API.

Seguir estas buenas pr√°cticas te ayudar√° no solo a reducir costes sino tambi√©n a mejorar la mantenibilidad y escalabilidad de tu proyecto docente con IA.







T√∫ dijiste:
Continue


ChatGPT Plus

Trabaj√≥ durante 16 segundos
Por supuesto, aqu√≠ dejo algunas ideas finales con ejemplos concretos de c√≥mo podr√≠as refactorizar y optimizar tu c√≥digo:

1. Crear un generador de prompts reutilizable
En lugar de construir cadenas enormes dentro de cada funci√≥n, define una funci√≥n utilitaria que reciba solo los par√°metros variables. Por ejemplo:

js
Copiar
Editar
function buildSystemPrompt({ specialistRole, sessionName, courseName, learningObjective, keyPoints, momentos, currentIndex, fragmentos }) {
  const momentosContext = momentos.map((m, idx) => {
    const estado = idx < currentIndex ? 'COMPLETADO' : (idx === currentIndex ? 'ACTUAL' : 'PENDIENTE');
    return `${idx + 1}. ${m.momento} (${estado})`;
  }).join('\n');

  const fragmentosContext = fragmentos.map((frag, idx) => `Fragmento ${idx + 1}: ${frag.text.substring(0, 200)}...`).join('\n');

  return `
Eres un ${specialistRole} que est√° ense√±ando la sesi√≥n "${sessionName}" del curso "${courseName}".
OBJETIVO: ${learningObjective}

PUNTOS CLAVE:
${keyPoints.map(p => `- ${p}`).join('\n')}

ESTRUCTURA:
${momentosContext}

MOMENTO ACTUAL: ${momentos[currentIndex].momento}
CONTENIDO DEL MOMENTO: ${momentos[currentIndex].texto}

FRAGMENTOS:
${fragmentosContext}

Instrucciones pedag√≥gicas (resumidas): Usa la metodolog√≠a Teach Like a Champion, corrige de forma constructiva y decide si avanzar al siguiente momento.
`.trim();
}
Este generador concentra toda la l√≥gica de construcci√≥n del prompt. Luego tu funci√≥n handleStudent puede usarla as√≠:

js
Copiar
Editar
const systemPrompt = buildSystemPrompt({
  specialistRole: session.course.specialist_role,
  sessionName: session.session.name,
  courseName: session.course.name,
  learningObjective: session.session.learning_objective,
  keyPoints: session.session.key_points,
  momentos: session.momentos,
  currentIndex: session.currentMomentIndex,
  fragmentos: fragmentosActuales.fragmentos,
});
El texto resultante ser√° m√°s compacto y limpio, adem√°s puedes modificarlo en un solo sitio si cambias de estrategia.

2. A√±adir control de modelo y tokens
Centraliza la llamada a responses.create en una funci√≥n que reciba el nombre del modelo y otros par√°metros configurables:

js
Copiar
Editar
async function callOpenAI({ systemPrompt, userPrompt, model = process.env.OPENAI_MODEL_DEFAULT, maxTokens = 600 }) {
  return await this.client.responses.create({
    model,
    instructions: systemPrompt,
    input: userPrompt,
    max_tokens: maxTokens,
    // response_format: { type: "json_object" }, // Opcional: asegura JSON
    tools: [{
      type: "file_search",
      vector_store_ids: [session.vectorStoreId],
      max_num_results: 3, // Reducido
    }],
  });
}
As√≠ puedes variar f√°cilmente el modelo y el tama√±o de la respuesta sin modificar el flujo principal.

3. Implementar cach√© de fragmentos
Podr√≠as almacenar los fragmentos obtenidos por preCalculateFragmentos en this.cache utilizando como clave una combinaci√≥n de vectorStoreId + momento + expectedTheme. Por ejemplo:

js
Copiar
Editar
const cacheKey = `${vectorStoreId}-${momento.momento}-${expectedTheme}`;
if (this.cache.has(cacheKey)) {
  fragmentos.push({ momento: momento.momento, fragmentos: this.cache.get(cacheKey) });
  continue;
}
// ... ejecutar b√∫squeda ...
this.cache.set(cacheKey, validResults.map(r => ({ texto: r.text, score: r.score })));
Este patr√≥n evita volver a llamar a la API para b√∫squedas id√©nticas.

4. Estimar costes en tiempo de ejecuci√≥n
Dentro de tu servicio de llamadas podr√≠as capturar el recuento de tokens de cada respuesta (OpenAI lo devuelve en la propiedad usage) y sumarizarlo:

js
Copiar
Editar
const response = await callOpenAI({ systemPrompt, userPrompt });
const { prompt_tokens, completion_tokens } = response.usage;
console.log(`Tokens de entrada: ${prompt_tokens}, Tokens de salida: ${completion_tokens}`);
Con esta informaci√≥n puedes registrar consumos por sesi√≥n y ajustar l√≠mites (max_tokens) en funci√≥n de los resultados.

5. Paralelizar pre‚Äëc√°lculo de fragmentos
Si tienes muchas sesiones o momentos, podr√≠as realizar las b√∫squedas en paralelo usando Promise.all, reduciendo el tiempo total:

js
Copiar
Editar
const fragmentos = await Promise.all(momentos.map(async (momento) => {
  // b√∫squeda individual...
}));
Siempre teniendo en cuenta que cada llamada adicional a la API incrementar√° el uso, por lo que debes balancear coste y rapidez.

Implementar estas t√©cnicas te permitir√° mantener un c√≥digo m√°s organizado y con un control fino sobre el gasto asociado a las llamadas de la API. Adem√°s, una vez que tengas m√©tricas claras podr√°s experimentar reduciendo instrucciones o cambiando de modelo y observar c√≥mo var√≠a el coste.







T√∫ dijiste:
Respuesta autom√°tica
Continuar
ChatGPT Plus

Trabaj√≥ durante 15 segundos
Para cerrar con algunas recomendaciones adicionales y consideraciones de organizaci√≥n:

6. Documentaci√≥n y comentarios claros
Un c√≥digo que interact√∫a con modelos de lenguaje y vector stores puede ser complejo para quien no lo desarroll√≥ inicialmente. Aseg√∫rate de documentar cada funci√≥n, describiendo:

Qu√© hace y cu√°l es su entrada/salida.

Por qu√© tomas ciertas decisiones (por ejemplo, ‚Äúlimitamos max_num_results a 3 para reducir tokens‚Äù).

Referencias a la documentaci√≥n de OpenAI para funciones como responses.create o vectorStore.search.

Esto permitir√° que t√∫ o cualquier otro desarrollador entienda la l√≥gica y pueda ajustarla si cambian las APIs o los precios.

7. Separar la l√≥gica de negocio de las llamadas a la API
Actualmente el c√≥digo mezcla la obtenci√≥n de datos (sessions, fragmentos) con la llamada al modelo y la construcci√≥n del prompt. Considera separar las responsabilidades en capas:

Capa de datos: gestiona sesiones, lee el JSON de cursos y se conecta al vector store.

Capa de l√≥gica: decide qu√© informaci√≥n necesita cada interacci√≥n (momento actual, fragmentos) y prepara el prompt.

Capa de servicios: encapsula las llamadas a la API de OpenAI, centralizando par√°metros como modelo, tokens y herramientas.

Al estructurar de este modo, el impacto de cambiar de modelo o ajustar par√°metros se reduce a un √∫nico archivo o m√≥dulo.

8. Monitorizaci√≥n y alertas
Adem√°s del registro de tokens, puedes configurar alertas autom√°ticas cuando se supere cierto umbral de gasto o solicitudes. Por ejemplo, un peque√±o script que lea los datos de la API de OpenAI (si tienes acceso) y env√≠e una notificaci√≥n cuando se acerque a un l√≠mite mensual de presupuesto.

9. Revisi√≥n de la l√≥gica pedag√≥gica
Aunque no est√° directamente relacionado con el costo, repasar la forma en que se gu√≠a al estudiante tambi√©n puede reducir la duraci√≥n de las sesiones y, por tanto, las llamadas. Si logras que el estudiante avance m√°s r√°pido entre momentos con prompts m√°s precisos y preguntas m√°s enfocadas, necesitar√°s menos interacciones para cubrir el contenido.

10. Versionado y pruebas de regresi√≥n
Cuando hagas cambios (por ejemplo, switching de GPT‚Äë4o a GPT‚Äë3.5 para ciertas tareas o reduciendo el tama√±o del prompt), te recomiendo mantener un control de versiones (Git) y, si es posible, un entorno de pruebas. As√≠ podr√°s comparar la calidad de las respuestas y el consumo de tokens entre versiones y revertir si algo no funciona como esperabas.

Ejemplo final de estructura de clases
Podr√≠as reescribir la clase original separando responsabilidades y usando algunas de las optimizaciones mencionadas:

js
Copiar
Editar
class SessionManager {
  // gestiona sesiones, carga cursos, maneja cach√©...
}

class PromptBuilder {
  buildSystemPrompt(args) { /* ... */ }
  buildUserPrompt(studentMsg, context) { /* ... */ }
}

class OpenAIService {
  constructor(apiKey, defaultModel, maxTokens) { /* ... */ }
  async ask(systemPrompt, userPrompt, vectorStoreIds, maxResults) { /* ... */ }
}

class DocenteIA {
  constructor() {
    this.sessionManager = new SessionManager();
    this.promptBuilder = new PromptBuilder();
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY, 'gpt-3.5-turbo', 600);
  }

  async iniciarSesion(courseId, sessionId) { /* usa sessionManager */ }
  async responder(studentMsg, sessionKey) {
    const context = this.sessionManager.getContext(sessionKey);
    const systemPrompt = this.promptBuilder.buildSystemPrompt(context);
    const userPrompt = this.promptBuilder.buildUserPrompt(studentMsg, context);
    return await this.openAIService.ask(systemPrompt, userPrompt, [context.vectorStoreId], 3);
  }
}
Esta estructura facilita el cambio de modelo, la optimizaci√≥n del prompt y la gesti√≥n de sesiones sin tener que editar una √∫nica clase gigante.

Con estas gu√≠as y ejemplos deber√≠as poder refactorizar tu c√≥digo de manera que sea m√°s eficiente, escalable y econ√≥mico.
```
=== EOF: instrucciondemejora.md

===  implementacion2.md
```markdown

1Ô∏è‚É£ Un primer mensaje de ‚Äúesp√≠ritu‚Äù claro y completo
La mejor pr√°ctica en dise√±ar sistemas conversacionales estructurados (como dicen en OpenAI) es definir al inicio un rol y misi√≥n muy claros. Esto:

Crea un prop√≥sito compartido (por ejemplo: seguridad industrial, seguimiento de aprendizaje).

Permite estandarizar el tono y estilo durante toda la sesi√≥n.

Evita que se ‚Äúpierda la intenci√≥n‚Äù cuando avanza al an√°lisis del contenido üîÅ

Por eso, el prompt de sistema debe incluir ese esp√≠ritu pedag√≥gico desde el primer mensaje, antes que cualquier pregunta o memoria.

2Ô∏è‚É£ Luego la memoria conversacional para evaluar clase a clase
Despu√©s del mensaje de esp√≠ritu, cada turno se convierte en c√°psulas de interacci√≥n. En lugar de enviar solo la instrucci√≥n del momento tal como hiciste antes, se recomienda:

Enviar todo el conversationLog (historial) resumido en uno o dos p√°rrafos, o solo las √∫ltimas interacciones relevantes.

Adjuntar las preguntas espec√≠ficas del momento (momento_actual.preguntas).

Pedir al modelo que:

eval√∫e qu√© se cubri√≥,

qu√© falt√≥ por responder,

y si puede pasar al siguiente momento o debe repreguntar.

Esto es coherente con las mejores pr√°cticas para ‚Äúcontext window + role adherence + fact retention‚Äù en conversaciones de LLM 
confident-ai.com
.

üîß Ejemplo de dise√±o de mensajes
jsonc
Copiar
Editar
// SYSTEM MESSAGE (solo una vez al inicio de la sesi√≥n):
‚ÄúYou are a safety‚Äëengineering instructor who leads the session ‚ÄúSeguridad contra incendios‚Äù.
// Here‚Äôs your SPIRIT:
Your purpose: that the student:
 ‚Äì Identifique las causas reales de incendios en el trabajo.
 ‚Äì Relacione la teor√≠a del Tri√°ngulo del Fuego con ejemplos concretos.
 ‚Äì Al final de la sesi√≥n sea capaz de crear un plan de prevenci√≥n paso a paso.

This is your guiding spirit. Always refer back to it. You ARE NOT improvising ‚Äì you are following the ‚Äúguion‚Äù pedag√≥gico concretamente.
‚Äú


// En cada turno (SessionExtractor.handleStudent):
// 1) Enviar como ‚Äúsystem‚Äù:
// Historial de conversaci√≥n (√∫ltimos N turnos):
Estudiante: ‚Äú...‚Äù  
Docente: ‚Äú...‚Äù  

Guion del momento actual (objetivo y preguntas espec√≠ficas, sacadas del JSON).

Instrucciones: responde a EXACTAMENTE una pregunta por turno, en orden, hasta que todas est√©n contestadas; comenta brevemente; luego eval√∫a si puedes pasar al siguiente momento. Si hay dudas o falta informaci√≥n, repregunta y da pistas.

// 2) Enviar como ‚Äúuser‚Äù el mensaje del alumno:
// ‚ÄúEstudiante: {texto del estudiante}‚Äù
‚úÖ Por qu√© funciona mejor
Objetivo	Por qu√© es efectivo
Marcar el esp√≠ritu desde el inicio	Cumple con ‚ÄúUse el rol de sistema para establecer misi√≥n‚Äù (OpenAI dice ser claro al inicio) 
OpenAI Help Center
OpenAI
.
Memoria conversacional antes de cada turno	Ayuda a la fidelidad del modelo a lo que ya ha ocurrido y no repetir preguntas. Alineado con m√©tricas de retenci√≥n de conocimiento en di√°logo AI 
confident-ai.com
.
Evaluaci√≥n y decisi√≥n de avance integradas	El sistema no avanza prematuramente; eval√∫a si el estudiante ha respondido todo o si falta informaci√≥n.

‚úÖ En resumen
S√≠: primero el esp√≠ritu y prop√≥sito de la sesi√≥n, como mensaje general.

Despu√©s: en cada turno, memoria + preguntas espec√≠ficas + evaluaci√≥n de cumplimiento, para evitar repeticiones y asegurar fidelidad al guion.

Esta es la mejor pr√°ctica de ingenier√≠a conversacional actual para chatbots educativos controlados, flexible y de calidad.

¬øQuieres que genere el c√≥digo completo tipo ‚ÄúPromptBuilder.buildSystemPrompt‚Äù y ‚ÄúSessionExtractor.handleStudent‚Äù que implemente esto ya integrado?













Fuentes
T√∫ dijiste:
a ver


ChatGPT Plus
üîß Aqu√≠ tienes una versi√≥n integrada y ‚Äúlista para usar‚Äù del mecanismo de ense√±anza, con los siguientes componentes:

Mensaje de sistema ‚Äúesp√≠ritu‚Äù que se env√≠a solo una vez al comenzar la sesi√≥n.

Funci√≥n buildSystemPrompt que genera un guion literal por momento, incluyendo preguntas espec√≠ficas.

Manejo de memoria conversacional (conversationLog) en SessionManager y SessionExtractor.

Control de avance: se fuerza una evaluaci√≥n del modelo antes de avanzar al siguiente momento.

Te lo explico pieza por pieza y luego te doy el c√≥digo completo.

1Ô∏è‚É£ Mensaje de sistema ‚Äúesp√≠ritu‚Äù ‚Äî se env√≠a solo al inicio
Este mensaje establece el prop√≥sito general de la sesi√≥n, el estilo de docente y el tono humano cercano:

ts
Copiar
Editar
// Solo una vez, al crear la sesi√≥n:
const systemSpirit = `
Eres un **docente experto en seguridad industrial** que imparte la sesi√≥n **"${sessionName}"** del curso **"${courseName}"**.

üß≠ PROP√ìSITO GENERAL:
Tu misi√≥n:  
  ‚Äì que el estudiante **identifique las causas reales** de incendios laborales.  
  ‚Äì que relacione la **teor√≠a del Tri√°ngulo del Fuego** con casos concretos.  
  ‚Äì que al final sea capaz de **crear un plan de prevenci√≥n paso a paso**.

Esta es tu **ense√±anza gu√≠a** para toda la sesi√≥n.  
Desde ahora, act√∫a como si siguieras un guion **pedag√≥gico concreto**, sin improvisar preguntas ni saltarte pasos.  
Usa un tono **cercano, claro y docente**.

No comiences a√∫n con preguntas.**
`.trim();
üìå Esta pr√°ctica est√° alineada con las ‚Äúbest practices‚Äù de OpenAI: usar el prompt del sistema para definir un prop√≥sito claro y rol de manera expl√≠cita desde el inicio 
community.openai.com
community.openai.com
+2
community.openai.com
+2
cookbook.openai.com
+2
.

2Ô∏è‚É£ PromptBuilder.buildSystemPrompt() ‚Äî guion por momento
Aqu√≠ el prompt que se env√≠a antes de cada mensaje excepto el primero:

ts
Copiar
Editar
// PromptBuilder.ts
static buildSystemPrompt(params: PromptParams): string {
  const { sessionName, courseName, learningObjective, momentos, currentMomentIndex } = params;
  const momentoActual = momentos[currentMomentIndex];
  const siguiente = (currentMomentIndex + 1 < momentos.length) ? momentos[currentMomentIndex + 1].momento : 'FIN';

  // Contenido espec√≠fico del momento (historia, caso, etc.)
  const contenido = this.getMomentoContent(momentoActual);

  // Preguntas espec√≠ficas del JSON
  const preguntas = Array.isArray(momentoActual.preguntas) ? momentoActual.preguntas : [];
  const preguntasTexto = preguntas.map((p, i) => `  ${i+1}. ${p}`).join('\n');

  return `
**Guion de momento pedag√≥gico**
Sesi√≥n: "${sessionName}" (curso: ${courseName})

**OBJETIVO DE APRENDIZAJE**  
${learningObjective}

**Momento actual:** ${momentoActual.momento}  
**Siguiente momento:** ${siguiente}

**Contenido del momento:**  
${contenido}

üìã **Instrucciones (obligatorias):**  
1. Haz exactamente TODAS las preguntas listadas a continuaci√≥n, **en ese orden**, sin saltear ni improvisar otras.  
2. Despu√©s de cada respuesta del estudiante, **comenta brevemente** (1 o 2 frases) reconociendo el avance.  
3. No avances al siguiente momento hasta que todas las preguntas est√©n completamente respondidas.  
4. Si la respuesta del estudiante no cubre alg√∫n punto, **repregunta con una pista centr√°ndote en lo que falta**.  
5. Usa un tono **cercano y docente**, como si estuvieras dando clase frente a un estudiante real.  
6. No otorgues informaci√≥n del siguiente momento.

**Preguntas del momento:**  
${preguntasTexto}

üí° Si el estudiante no responde o responde parcialmente, insiste antes de avanzar.
`.trim();
}
‚úÖ En reforche con los principios de prompt engineering: claridad, formato estricto, instrucciones segmentadas por momentos, perfil del modelo definido 
OpenAI Help Center
bridgemind.ai
.

3Ô∏è‚É£ Memoria conversacional: SessionManager y SessionExtractor
Cambios en SessionManager
En el objeto de sesi√≥n (SessionData) a√±ade:

ts
Copiar
Editar
interface SessionData {
  currentMomentIndex: number;
  progress: string;
  // ...
  conversationLog: { role: 'user' | 'assistant'; content: string }[];
}
Inicializaci√≥n:

ts
Copiar
Editar
const session: SessionData = {
  currentMomentIndex: 0,
  progress: '1/6',
  // ...
  conversationLog: [],
};
handleStudent() ‚Äî central del flujo
ts
Copiar
Editar
async handleStudent(studentMessage: string, session: SessionData, promptParams: PromptParams) {
  // Guardar respuesta del estudiante
  session.conversationLog.push({ role: 'user', content: studentMessage });

  // Armar historial: √∫ltimas N interacciones o todas
  const history = session.conversationLog
    .map(m => m.role === 'user' ? `Estudiante: "${m.content}"` : `Docente: "${m.content}"`)
    .join('\n');

  // Generar prompt de sistema + user
  const systemPrompt = this.buildSystemPrompt(promptParams);

  const userPrompt = `
Historial reciente de clase:
${history}

**√öltimo mensaje del estudiante:**
"${studentMessage}"

Sigue el guion del momento actual de forma exacta y estructurada como se indica.`
  .trim();

  // Llamada a OpenAI
  const result = await this.openAI.callChatCompletion([
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ]);

  // Parseo b√°sico (ajusta seg√∫n formato esperado)
  const assistantText: string = result.choices[0].message.content;

  // Guardar salida del docente
  session.conversationLog.push({ role: 'assistant', content: assistantText });

  return assistantText;
}
üìå Con esto, el modelo siempre sabe lo que ya pregunt√≥ y lo que falta por cubrir. Evita preguntas repetidas y salidas fuera del guion.

4Ô∏è‚É£ Justificaci√≥n t√©cnica oficial üß†
Estas pr√°cticas son recomendadas por expertos:

Prompt altamente estructurado y espec√≠fico: evita ambig√ºedad e improvisaci√≥n en las salidas‚Ää‚Äî ideales para clases y flujos repetibles. 
ibm.com
+13
OpenAI Help Center
+13
cookbook.openai.com
+13
community.openai.com

Historial como contexto: copiar los √∫ltimos turnos evita que el modelo pierda la secuencia o vuelva a preguntar lo mismo. Clave en interfaces instructivas. 
bridgemind.ai
community.openai.com

Prompt dividido por etapas o momentos: forma parte de lo que en prompt engineering se conoce como ‚Äústructured prompting‚Äù o ‚Äúconversation routines‚Äù, dise√±adas para sistemas pedag√≥gicos mediante flujos bien definidos. 
community.openai.com
+5
Prompt Engineering Institute
+5
OpenAI Help Center
+5

üöÄ ¬øY ahora qu√©?
Ya tienes el c√≥digo base buildSystemPrompt, handleStudent, conversationLog.

Puedes montar esto directamente en tu aplicaci√≥n y probar con un escenario.

Mejora adicional: resumir hist√≥ricamente el conversationLog si crece mucho, limitando a, por ejemplo, las √∫ltimas 5 interacciones para no saturar tokens.

Con esto tendr√°s un sistema que:

Marca el tono desde el inicio (esp√≠ritu pedag√≥gico).

Pregunta solo lo que debe, con concreci√≥n y control.

Comunica evoluci√≥n y no repite preguntas ya hechas.

Eval√∫a si puede avanzar o debe insistir a√∫n.

¬øQuieres tambi√©n la versi√≥n en JSON del prompt o ejemplo completo de un turno con salida estructurada? Puedo prepar√°rtela.













Fuentes
T√∫ dijiste:
a ver


ChatGPT Plus
Aqu√≠ tienes el prompt completo y un ejemplo de turno listo para integrar:

1Ô∏è‚É£ Mensaje de sistema ‚Äúesp√≠ritu‚Äù ‚Äî solo al inicio de la sesi√≥n
json
Copiar
Editar
{
  "role": "system",
  "content": "Eres un **docente experto en seguridad industrial** que imparte la sesi√≥n **\"Seguridad contra incendios\"** del curso **\"Capacitaci√≥n CETEMIN\".\n\nüß≠ PROP√ìSITO PEDAG√ìGICO:\n‚Äì El estudiante debe **identificar las causas reales** de incendios laborales.\n‚Äì Relacionar la **teor√≠a del Tri√°ngulo del Fuego** con ejemplos concretos.\n‚Äì Al final, crear un **plan de prevenci√≥n paso a paso**.\n\nEste es tu guion pedag√≥gico: **no improvises preguntas ni te saltes pasos**.\nHabla en un tono **cercano y docente**.\n\n‚úã Espera a que empiece el turno del estudiante antes de preguntar cualquier cosa.\n"
}
Esto define el rol y el tono desde el primer mensaje ‚Äî una pr√°ctica recomendada seg√∫n las gu√≠as oficiales de OpenAI: establecer claramente prop√≥sito y tono del sistema desde el principio mejora la fidelidad del modelo a dicho perfil 
OpenAI Community
+8
OpenAI Help Center
+8
orq.ai
+8
.

2Ô∏è‚É£ Sistema por momento ‚Äî buildSystemPrompt() en tiempo de ejecuci√≥n
Este prompt se env√≠a cada vez antes de procesar la respuesta del estudiante en un momento pedag√≥gico (por ejemplo: "Saludo"):

ts
Copiar
Editar
const systemPromptSaludo = `
**Guion del momento: SALUDO**
Sesi√≥n: "Seguridad contra incendios" (CETEMIN)

**OBJETIVO DE APRENDIZAJE:**  
El estudiante identifica causas de incendios laborales y qu√© espera aprender.

---

**Contenido del momento (instrucciones + presentaci√≥n):**  
Objetivo de la sesi√≥n: asegurarte de que el estudiante comprenda los riesgos de incendios y qu√© va a aprender hoy.  
Puntos clave:  
1. Identificaci√≥n del objetivo  
2. Tres preguntas para conocer conocimientos y expectativas

üìã **Instrucciones estrictas:**  
1. Haz exactamente estas 3 preguntas en orden, **sin saltear ni modificar**.  
2. Tras cada respuesta, comenta brevemente (1 o 2 frases) para reconocer el avance.  
3. No pases al siguiente momento hasta que el estudiante responda las tres preguntas por completo.  
4. Si la respuesta es parcial, pregunta de nuevo centrado en la informaci√≥n que falta.  
5. Usa un tono **cercano, claro y docente**, como frente a un estudiante real.

**Preguntas del momento:**  
  1. ¬øQu√© sabes sobre incendios en el trabajo?  
  2. ¬øHas presenciado alguna situaci√≥n de riesgo de incendio? Descr√≠bela.  
  3. ¬øQu√© esperas aprender en esta sesi√≥n?  
`.trim();
Este estilo, con prompts estructurados y guardrails, sigue las mejores pr√°cticas de dise√±o de prompts: claridad, concreci√≥n y formato estricto de salida 
OpenAI Community
.

3Ô∏è‚É£ Ejemplo completo de un turno: integraci√≥n y resultado
üîÑ Env√≠o a la API
jsonc
Copiar
Editar
[
  // Si es el primer turno de la sesi√≥n, incluir el systemSpirit antes del guion
  { "role": "system", "content": systemSpirit },
  
  // Luego, en cada mensaje:
  { "role": "system", "content": systemPromptSaludo },
  { "role": "user", "content": "Estudiante: se muy poco sobre incendios, nunca trabaj√© en f√°bricas y solo espero aprender los elementos b√°sicos." }
]
üßë‚Äçüè´ Ejemplo de respuesta del asistente (formato simulado, modelo debe seguirlo)
txt
Copiar
Editar
Docente: ¬°Perfecto empezar por ah√≠!

**Pregunta 1:** ¬øQu√© sabes sobre incendios en el trabajo?  
‚Üí ‚ÄúS√© muy poco sobre incendios en el trabajo.‚Äù  
**Comentario:** Entiendo, no hay problema: comenzaremos por la base.

**Pregunta 2:** ¬øHas presenciado alguna situaci√≥n de riesgo de incendio? Descr√≠bela.  
‚Üí ‚ÄúNo, nunca he visto algo as√≠.‚Äù  
**Comentario:** Muy bien, eso nos mantiene limpios de preconcepciones. Te comparto que vamos a trabajar con el Tri√°ngulo del Fuego para identificar qu√© riesgos podr√≠an existir.

**Pregunta 3:** ¬øQu√© esperas aprender en esta sesi√≥n?  
‚Üí ‚ÄúQuiero entender qu√© provoca incendios y c√≥mo evitarlos en mi trabajo.‚Äù  
**Comentario:** ¬°Excelente! Ese es justo el objetivo pedag√≥gico principal.

üü¢ Has respondido todas las preguntas del momento SALUDO.  
Cuando est√©s listo, procederemos al siguiente paso: CONEXI√ìN: narrar√© un caso para que lo analicemos juntos.
4Ô∏è‚É£ C√≥mo aplica memoria conversacional
Antes de llamar a la API transporta siempre en el prompt:

El historial de preguntas y respuestas anteriores del propio sistema.

Las preguntas restantes del momento actual.

El prop√≥sito del momento mostrado.

De esta forma, el modelo ‚Äúrecuerda‚Äù qu√© ya pregunt√≥ y no repite.
Este enfoque ‚Äîguardar el historial de conversaci√≥n y reenviarlo cada turno‚Äî es una t√©cnica est√°ndar para asegurar coherencia en di√°logo prolongado con LLMs 
OpenAI Community
stackoverflow.com
.

üìå Por qu√© este enfoque mejora la fidelidad al guion
Evita improvisaci√≥n: el modelo recibe copia exacta de las preguntas.

Estructura pedag√≥gica: valida que todas sean contestadas antes de avanzar.

Uso de memoria conversacional: mantiene coherencia y evita repetir.

Adopta el ‚Äúesp√≠ritu‚Äù desde el principio: el modelo sabe qui√©n debe ser desde la primera l√≠nea.

En conclusi√≥n, usando estas t√©cnicas podr√°s lograr un flujo con:

Control estricto del guion.

Memoria funcional entre preguntas.

Predicci√≥n del avance pedag√≥gico solo cuando el alumno complet√≥ el momento.

¬øQuieres que integre ya la l√≥gica de control de avance (debe_avanzar = true/false) y formato JSON en la salida del asistente? D√≠melo y preparo el c√≥digo tambi√©n.













Fuentes
T√∫ dijiste:
si 


ChatGPT Plus
Aqu√≠ tienes un snippet completo listo para usar, con:

Prompt base que define el esp√≠ritu pedag√≥gico y la estructura base (solo se env√≠a una vez al inicio).

buildSystemPrompt() que solo plantea preguntas del momento, exige formato JSON y controla el avance.

C√≥digo handleStudent() que mantiene la memoria conversacional y gestiona debe_avanzar = true|false seg√∫n las respuestas.

1Ô∏è‚É£ Mensaje inicial (SPIRIT)
ts
Copiar
Editar
const systemSpirit = {
  role: "system",
  content: `
Eres un docente experto en seguridad industrial. Impartes la sesi√≥n ‚ÄúSeguridad contra incendios‚Äù del curso ‚ÄúCETEMIN Capacitaci√≥n‚Äù.

üß≠ ESENCIA PEDAG√ìGICA:
‚Äì Hacer que el estudiante identifique causas reales de incendios.
‚Äì Relacionar el Tri√°ngulo del Fuego con ejemplos concretos.
‚Äì Al final, que pueda proponer un plan de prevenci√≥n paso a paso.

Act√∫as como si siguieras un guion educativo estricto: no improvises, no cambies preguntas.   
Habla de forma cercana y clara.  
No hagas preguntas hasta que comience el turno del estudiante.
  `.trim()
};
Establecer un prop√≥sito y tono claros desde el primer mensaje es una pr√°ctica recomendada por OpenAI: ‚ÄúBe specific ‚Ä¶ Clearly define the desired format, constraints, and role‚Äù 
OpenAI Help Center
.

2Ô∏è‚É£ buildSystemPrompt() para cada momento
ts
Copiar
Editar
static buildSystemPrompt(params: PromptParams): string {
  const m = params.momentos[params.currentMomentIndex];
  const preguntas = Array.isArray(m.preguntas) ? m.preguntas : [];

  const preguntasTexto = preguntas
    .map((p, i) => `  ${i + 1}. ${p}`)
    .join('\n');

  return `
**MOMENTO ACTUAL:** ${m.momento}
Objetivo: ${params.learningObjective}

CONTENIDO: 
${this.getMomentoContent(m)}

üìã Sigue exactamente estas preguntas, en orden, sin modificar ni saltar:
${preguntasTexto}

**Al responder, usa este formato JSON exacto:**

\`\`\`json
{
  "respuesta": "...",              
  "momento_actual": "${m.momento}",
  "progreso": "${params.progress}", 
  "debe_avanzar": true|false,      
  "razon_avance": "‚Ä¶",             
  "siguiente_momento": "‚Ä¶"
}
\`\`\`

Instrucciones:
1. Haz UNA sola pregunta por mensaje. Espera respuesta JSON.
2. Si la respuesta es incompleta, repregunta con una pista clara.
3. Solo avanza (`debe_avanzar=true`) si se respondieron todas las preguntas; en otro caso repregunta.
`.trim();
}
Este enfoque representa una especificaci√≥n rigurosa de formato y guion, alineada con las mejores pr√°cticas de ingenier√≠a de prompts para salidas estructuradas y consistentes 
OpenAI Help Center
.

3Ô∏è‚É£ handleStudent() con control de avance y log conversacional
ts
Copiar
Editar
async handleStudent(studentMsg: string, session: SessionData, params: PromptParams) {
  session.conversationLog.push({ role: 'user', content: studentMsg });

  const history = session.conversationLog
    .slice(-6)
    .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: ${m.content}`)
    .join('\n');

  const systemPrompt = this.buildSystemPrompt(params);

  const messages = [
    ...(session.firstTurn ? [{ role: 'system', content: systemSpirit }] : []),
    { role: 'system', content: `${history}\n\n[Si ya viste esa pregunta, dilo claramente.]` },
    { role: 'system', content: systemPrompt },
    { role: 'user', content: studentMsg }
  ];

  const ml = await this.openAI.callChatCompletion(messages);

  const assistantRaw = ml.choices[0].message.content;
  let assistantJSON;
  try {
    assistantJSON = JSON.parse(assistantRaw);
  } catch (err) {
    // manejar parsing error (p. ej., enviar prompt de resiliencia)
    throw new Error('El modelo no entreg√≥ JSON v√°lido');
  }

  session.conversationLog.push({ role: 'assistant', content: assistantRaw });

  if (assistantJSON.debe_avanzar) {
    params.currentMomentIndex++;
    session.progress = `${params.currentMomentIndex + 1}/${params.momentos.length}`;
  }

  return assistantJSON;
}
Este flujo garantiza que se:

Mantenga el contexto reciente (conversationLog fragmentado si crece mucho).

Se forz√≥ el formato JSON con campos sem√°nticos claros.

Se eval√∫e si seguir o insistir antes de avanzar.

üìä ¬øPor qu√© funciona?
Elemento	Beneficio
Prompt segmentado por momento	Controla el guion y evita improvisaci√≥n
Esquema JSON mandatorio	Hace predecible la respuesta y facilita parsing
Memoria conversacional limitada	Evita repeticiones y mantiene coherencia
Evaluaci√≥n interna de avance	Solo se avanza cuando el bloque actual est√° completo

Es una arquitectura de conversaci√≥n basada en ‚Äúroutines‚Äù y control expl√≠cito del flujo, tal como proponen frameworks modernos para di√°logos educativos con LLM (ver ‚ÄúConversation Routines: task‚Äëoriented dialog systems‚Äù) 
arxiv.org
.

‚úÖ Con este dise√±o, el sistema:

Nunca salta preguntas, solo avanza cuando toca.

Nunca improvisa, solo pregunta lo que est√° en el JSON.

Nunca pierde el hilo, gracias al log conversacional.

Entrega salidas estructuradas con l√≥gica explicativa y control interna.

¬øQuieres tambi√©n una forma de auto-validaci√≥n (e.g., que compruebe si debe_avanzar tiene sentido por conteo de preguntas)? ¬øO ejemplos de prueba con varios momentos? D√≠melo y lo preparo.












Fuentes
T√∫ dijiste:
si 


ChatGPT Plus
Aqu√≠ tienes una versi√≥n completa, integrada y lista para usar, que incluye:

Auto‚Äëvalidaci√≥n autom√°tica del avance (debe_avanzar) basada en cantidad de preguntas respondidas.

Manejo de historia de la clase (conversationLog resumido si crece mucho).

Ejemplo pr√°ctico con dos momentos completos (Saludo ‚Üí Conexi√≥n) mostrando c√≥mo funciona el flujo.

‚úÖ 1. Validaci√≥n autom√°tica: control de debe_avanzar
Usamos el siguiente fragmento dentro de handleStudent(), justo despu√©s de parsear el JSON que devuelve el modelo:

ts
Copiar
Editar
// Ejemplo de JSON parseado
interface MomentoRich {
  preguntas?: string[];
  // ...
}

interface AssistantJSON {
  respuesta: string;
  momento_actual: string;
  progreso: string;
  debe_avanzar: boolean;
  siguiente_momento: string;
  razon_avance?: string;
}

// Auto-validaci√≥n: comparo n√∫mero de respuestas con n√∫mero de preguntas del momento
const m: MomentoRich = params.momentos[params.currentMomentIndex];
const totalPreguntas = m.preguntas?.length ?? 0;

// Encuentro cu√°ntas respuestas mencion√≥ el alumno en su n√∫mero
const answeredCount =
  typeof assistantJSON.respuesta === "string"
    ? 
// Asumo que el modelo repite el n√∫mero de pregunta: "Pregunta‚ÄØ1: ‚Ä¶ ‚Üí ‚Ä¶"
      (assistantJSON.respuesta.match(/^Pregunta\s+\d+/gm) || []).length
    : 0;

if (assistantJSON.debe_avanzar) {
  if (answeredCount !== totalPreguntas) {
    // Advertencia: el modelo dijo avanzar pero no respondi√≥ todo
    // Se fuerza la insistencia
    assistantJSON.debe_avanzar = false;
    assistantJSON.razon_avance =
      `Solo respondi√≥ ${answeredCount} de ${totalPreguntas} preguntas. Por favor termina todas antes de avanzar.`;
  }
} else {
  // Si no dijo avanzar, lo dejamos como est√°
}

if (assistantJSON.debe_avanzar) {
  params.currentMomentIndex++;
  session.progress = `${params.currentMomentIndex + 1}/${params.momentos.length}`;
}
¬øPor qu√© esto es importante?
De esta forma proteges el flujo:

Si el modelo intenta avanzar sin cubrir todas las preguntas, se corrige autom√°ticamente.

Mantienes coherencia con el guion: solo avanza cuando debe.

üß† 2. Memoria conversacional con l√≠mite de tokens
Para evitar saturar el contexto, alargar el prompt y mantener eficiencia, puedes recortar el conversationLog a las √∫ltimas N interacciones. Por ejemplo:

ts
Copiar
Editar
const MAX_HISTORIA = 5;
const recorte = session.conversationLog.length - MAX_HISTORIA * 2; // penaliza por turnos ‚Äúdocente + estudiante‚Äú
if (recorte > 0) {
  session.conversationLog.splice(0, recorte);
}
Esto asegura que env√≠es solo las √∫ltimas 5 interacciones completas (dos mensajes cada interacci√≥n), manteniendo coherencia sin exceder tokens.

üìö 3. Ejemplo pr√°ctico: escenarios en c√≥digo con dos momentos
Supongamos que tienes 2 momentos en tu sesi√≥n: Saludo y Conexi√≥n:

ts
Copiar
Editar
const momentos = [
  {
    momento: "Saludo",
    preguntas: [
      "¬øQu√© sabes sobre incendios en el trabajo?",
      "¬øHas presenciado alguna situaci√≥n de riesgo? Descr√≠bela",
      "¬øQu√© esperas aprender en esta sesi√≥n?"
    ]
  },
  {
    momento: "Conexi√≥n",
    preguntas: [
      "¬øQu√© elementos identificas en esta situaci√≥n?",
      "¬øQu√© podr√≠a haber prevenido este incidente?",
      "¬øC√≥mo se relaciona esto con tu experiencia laboral?",
      "¬øHas presenciado algo similar?"
    ],
    historia: "En una f√°brica textil, un trabajador est√° usando una m√°quina de soldadura cerca de telas inflamables..."
  }
];
üß™ Simulaci√≥n de turno #1: estudiante responde ‚Äúse muy poco‚Äù
Historial enviado al modelo (turno 1):

text
Copiar
Editar
Estudiante: ‚ÄúS√© muy poco sobre incendios‚Ä¶‚Äù
Prompt de sistema para Saludo:

text
Copiar
Editar
Guion del momento: SALUDO
Objetivo: Identificar conocimientos y expectativas.
¬∑¬∑¬∑ (instrucciones y las 3 preguntas del momento)
Respuesta esperada del modelo:

(formato JSON como dijimos)

json
Copiar
Editar
{
  "respuesta": "‚Ä¶",
  "momento_actual": "Saludo",
  "progreso": "1/2",
  "debe_avanzar": false,
  "siguiente_momento": "Saludo"
}
Y se repreguntar√° hasta cubrir todas ‚Äî tal como debe_avanzar=false y continuar√°n.

üîÑ Turno #2: estudiante completa 3 respuestas
Despu√©s de las tres respuestas completas en formato JSON, el sistema detecta:

contando coincidencias con ^Pregunta 3: ‚Üí answeredCount === totalPreguntas ‚Üí debe_avanzar se mantiene true

se avanza autom√°ticamente a Conexi√≥n con currentMomentIndex = 1.

Nuevo systemPrompt para momento ‚ÄúConexi√≥n‚Äù se env√≠a antes del mensaje del siguiente turno.

üìñ 4. Por qu√© esta pr√°ctica es recomendada
Estudios de Prompt Engineering como el art√≠culo Conversation Routines (Robino et al., arXiv 2025) recomiendan justamente el uso de prompts estructurados con l√≥gica de avance integrada y divisi√≥n en momentos bien definidos 
OpenAI Community
+1
OpenAI
+1
arXiv
+1
OpenAI Cookbook
+1
Future Skills Academy
arXiv
+4
arXiv
+4
arXiv
+4
.

La gu√≠a oficial de OpenAI recuerda: ‚ÄúS√© espec√≠fico ‚Ä¶ define claramente el formato de salida, las restricciones, el rol‚Ä¶‚Äù (help.openai.com y el Prompt Engineering Guide, abril 2025) 
OpenAI Help Center
+1
OpenAI Help Center
+1
.

Este enfoque consolida un flujo r√≠gido y pedag√≥gico controlado, donde:

No hay improvisaci√≥n: el modelo solo pregunta lo que debe, cuando debe.

No hay avance prematuro: solo si todas las preguntas fueron respondidas.

Se recuerda lo ya preguntado, evitando repeticiones.

üõ†Ô∏è ¬øQu√© puedes hacer ahora?
Copia estas funciones en tu flujo: buildSystemPrompt(), auto-validaci√≥n, control de conversationLog.

Prueba con una sesi√≥n completa de ejemplo (como el de dos momentos) ‚Äî verifica logs y comportamiento.

Ajusta el n√∫mero MAX_HISTORIA seg√∫n tu l√≠mite de tokens.

Opcional: incluye una l√≥gica de ‚Äúfallback‚Äù si el modelo no entrega JSON v√°lido ‚Äî puedes enviar un prompt de rescate para forzarlo a repetir el formato.

Con esta arquitectura tendr√°s un sistema educativo con:

Memoria de clase

Control pedag√≥gico estricto

Evaluaci√≥n autom√°tica de avance
```
=== EOF: implementacion2.md

===  eslint.config.mjs
```
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "prefer-const": "error",
      "no-var": "error",
      "no-console": "warn",
    },
  },
];

export default eslintConfig;
```
=== EOF: eslint.config.mjs

===  env.example
```
# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here

# App Configuration
NEXT_PUBLIC_APP_NAME=DocenteIA
NEXT_PUBLIC_APP_VERSION=1.0.0

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3000/api 
```
=== EOF: env.example

===  src\types\index.ts
```typescript
// Tipos e interfaces para DocenteIA
export interface Course {
  id: string;
  name: string;
  specialist_role: string;
  sessions: Session[];
}

export interface Session {
  id: string;
  name: string;
  session_file?: string; // Archivo JSON de la sesi√≥n (opcional)
  learning_objective: string;
  key_points: string[];
  theme_keywords: string[];
}

export interface Moment {
  momento: string;
  instrucciones_docenteia?: string;
  contenido_tecnico?: string[];
  historia?: string;
  caso?: string;
  preguntas?: string[];
}

export interface SessionData {
  courseId: string;
  sessionId: string;
  sessionFile: string;
  course: Course;
  session: Session;
  expectedTheme: string;
  momentos: Moment[];
  currentMomentIndex: number;
  startTime: Date;
  lastActivity: Date;
  sessionContent?: any; // Contenido completo de la sesi√≥n desde JSON
  conversationLog: Array<{ role: 'user' | 'assistant'; content: string; timestamp: Date }>; // Memoria conversacional
  isFirstTurn: boolean; // Para enviar el mensaje de "esp√≠ritu" solo una vez
  preguntasPendientes: string[]; // Preguntas pendientes del momento actual
  preguntasRespondidas: string[]; // Preguntas ya respondidas del momento actual
}

export interface AIResponse {
  respuesta: string;
  momento_actual: string;
  progreso: number;
  total_momentos: number;
  debe_avanzar: boolean;
  razon_avance: string;
  siguiente_momento: string;
  momentos?: Moment[];
  sessionKey?: string;
  pregunta_actual?: string;
  preguntas_pendientes?: number;
  preguntas_respondidas?: number;
}

export interface CostMetrics {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
  estimated_cost: number;
  model_used: string;
}

export interface SessionInfo {
  sessionKey: string;
  course: string;
  session: string;
  currentMoment: string;
  progress: string;
  startTime: Date;
  lastActivity: Date;
}

export interface CacheStats {
  cacheSize: number;
  sessionsSize: number;
  activeSessions: number;
}

export interface PromptParams {
  specialistRole: string;
  sessionName: string;
  courseName: string;
  learningObjective: string;
  keyPoints: string[];
  momentos: Moment[];
  currentIndex: number;
}

export interface UserPromptContext {
  currentMoment: string;
  progress: string;
}

export interface OpenAICallParams {
  systemPrompt: string;
  userPrompt: string;
  model?: string;
  maxTokens?: number;
}

export interface OpenAICallResult {
  response: any;
  metrics: CostMetrics;
}

 
```
=== EOF: src\types\index.ts

===  src\types\global.d.ts
```typescript
declare global {
  interface Window {
    __NEXT_DATA__: unknown;
  }
}

export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
} 
```
=== EOF: src\types\global.d.ts

===  src\services\SessionManager.ts
```typescript
// src/services/SessionManager.ts

import * as fs from 'fs';
import * as path from 'path';
import { SessionData, Course, Session } from '../types';

export class SessionManager {
  private sessions: Map<string, SessionData> = new Map();
  private cache: Map<string, any> = new Map();

  constructor() {
    // Limpiar sesiones al iniciar
    this.sessions.clear();
    this.cache.clear();
  }

  /**
   * Inicia una nueva sesi√≥n
   */
  async startSession(courseId: string, sessionId: string): Promise<string> {
    try {
      const sessionKey = `${courseId}-${sessionId}`;
      
      // Cargar datos del curso
      const courseData = await this.loadCourseData(courseId);
      const course = courseData.courses.find((c: Course) => c.id === courseId);
      
      if (!course) {
        throw new Error(`Curso ${courseId} no encontrado`);
      }

      const session = course.sessions.find((s: Session) => s.id === sessionId);
      if (!session) {
        throw new Error(`Sesi√≥n ${sessionId} no encontrada`);
      }

      // Cargar contenido de la sesi√≥n
      const sessionContent = await this.loadSessionContent(courseId, sessionId);
      
      // Crear datos de sesi√≥n
      const sessionData: SessionData = {
        courseId,
        sessionId,
        sessionFile: `${courseId}_${sessionId}.json`,
        course,
        session,
        expectedTheme: this.extractThemeFromSession(session.name),
        momentos: sessionContent.momentos || [],
        currentMomentIndex: 0,
        startTime: new Date(),
        lastActivity: new Date(),
        sessionContent,
        conversationLog: [],
        isFirstTurn: true,
        preguntasPendientes: sessionContent.momentos?.[0]?.preguntas || [],
        preguntasRespondidas: []
      };

      // Guardar sesi√≥n
      this.sessions.set(sessionKey, sessionData);
      
      console.log(`üöÄ Iniciando nueva sesi√≥n: ${sessionKey}`);
      console.log(`‚úÖ Contenido cargado desde: ${this.getSessionFilePath(courseId, sessionId)}`);
      
      return sessionKey;

    } catch (error) {
      console.error('Error iniciando sesi√≥n:', error);
      throw error;
    }
  }

  /**
   * Obtiene una sesi√≥n por clave
   */
  getSession(sessionKey: string): SessionData | undefined {
    return this.sessions.get(sessionKey);
  }

  /**
   * Actualiza una sesi√≥n
   */
  updateSession(sessionKey: string, updates: Partial<SessionData>): boolean {
    const session = this.sessions.get(sessionKey);
    if (!session) return false;

    Object.assign(session, updates);
    return true;
  }

  /**
   * Lista todas las sesiones activas
   */
  listActiveSessions(): Array<{
    sessionKey: string;
    course: string;
    session: string;
    progress: string;
  }> {
    return Array.from(this.sessions.entries()).map(([key, data]) => ({
      sessionKey: key,
      course: data.course.name,
      session: data.session.name,
      progress: `${data.currentMomentIndex + 1}/${data.momentos.length}`
    }));
  }

  /**
   * Limpia una sesi√≥n espec√≠fica
   */
  clearSession(sessionKey: string): boolean {
    return this.sessions.delete(sessionKey);
  }

  /**
   * Limpia todas las sesiones
   */
  clearAllSessions(): void {
    this.sessions.clear();
  }

  /**
   * Obtiene estad√≠sticas del cache
   */
  getCacheStats(): {
    activeSessions: number;
    cacheSize: number;
    sessionsSize: number;
  } {
    return {
      activeSessions: this.sessions.size,
      cacheSize: this.cache.size,
      sessionsSize: this.sessions.size
    };
  }

  /**
   * Limpia el cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Carga datos del curso desde la base de datos
   */
  private async loadCourseData(courseId: string): Promise<any> {
    const cacheKey = `course_${courseId}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    try {
      const filePath = path.join(__dirname, '../data/courses-database.json');
      const data = fs.readFileSync(filePath, 'utf8');
      const parsedData = JSON.parse(data);
      
      this.cache.set(cacheKey, parsedData);
      return parsedData;
    } catch (error) {
      console.error('Error cargando datos del curso:', error);
      throw error;
    }
  }

  /**
   * Carga contenido de la sesi√≥n desde archivo JSON
   */
  private async loadSessionContent(courseId: string, sessionId: string): Promise<any> {
    const cacheKey = `session_${courseId}_${sessionId}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    try {
      // Intentar m√∫ltiples rutas posibles
      const possiblePaths = [
        path.join(__dirname, '../data/sessions', `${courseId}_${sessionId}.json`),
        path.join(__dirname, '../data/sessions', `${sessionId}.json`),
        path.join(__dirname, '../data/sessions', `${courseId}_${sessionId.replace('sesion', 'sesion0')}.json`)
      ];

      let sessionData = null;
      let loadedPath = '';

      for (const filePath of possiblePaths) {
        if (fs.existsSync(filePath)) {
          const data = fs.readFileSync(filePath, 'utf8');
          sessionData = JSON.parse(data);
          loadedPath = filePath;
          break;
        }
      }

      if (!sessionData) {
        throw new Error(`No se pudo cargar el contenido de la sesi√≥n ${courseId}_${sessionId}`);
      }

      this.cache.set(cacheKey, sessionData);
      console.log(`‚úÖ Contenido cargado desde: ${loadedPath}`);
      
      return sessionData;

    } catch (error) {
      console.error('Error cargando contenido de sesi√≥n:', error);
      throw error;
    }
  }

  /**
   * Obtiene la ruta del archivo de sesi√≥n
   */
  private getSessionFilePath(courseId: string, sessionId: string): string {
    return path.join(__dirname, '../data/sessions', `${courseId}_${sessionId}.json`);
  }

  /**
   * Extrae el tema de una sesi√≥n
   */
  private extractThemeFromSession(sessionName: string): string {
    const sessionNameLower = sessionName.toLowerCase();
    if (sessionNameLower.includes('iperc')) return 'IPERC';
    if (sessionNameLower.includes('incendio')) return 'Incendios';
    return 'Seguridad';
  }
} 
```
=== EOF: src\services\SessionManager.ts

===  src\services\PromptBuilderUniversal.ts
```typescript
// src/services/PromptBuilderUniversal.ts - Versi√≥n Universal

import { PromptParams } from '../types';

export class PromptBuilderUniversal {
  
  /**
   * Construye el prompt del esp√≠ritu (solo se env√≠a una vez al inicio)
   */
  static buildSpiritPrompt(params: { 
    specialistRole: string; 
    sessionName: string; 
    courseName: string; 
    learningObjective: string 
  }): string {
    return `üéì **ROL DEL DOCENTE IA:**
Eres un ${params.specialistRole} especializado en guiar el aprendizaje de manera inductiva y participativa.

**PROP√ìSITO PEDAG√ìGICO:**
- Guiar al estudiante a trav√©s de momentos estructurados de aprendizaje
- Hacer preguntas espec√≠ficas que lleven al descubrimiento
- Validar cada respuesta antes de avanzar
- Proporcionar pistas cuando el estudiante no sabe o responde parcialmente
- Mantener engagement constante terminando siempre con una pregunta

**OBJETIVO DE LA SESI√ìN:**
${params.learningObjective}

**ESTILO DE COMUNICACI√ìN:**
- Tono cercano pero profesional
- Preguntas claras y espec√≠ficas
- Reconocimiento de avances
- Pistas constructivas cuando sea necesario
- Nunca dar respuestas directas, guiar hacia el descubrimiento

**REGLAS FUNDAMENTALES:**
1. SIEMPRE termina tu respuesta con una pregunta (excepto en el cierre final)
2. NO avances al siguiente momento hasta que todas las preguntas est√©n completamente respondidas
3. Si el estudiante dice "no s√©" o responde parcialmente, da pistas y repregunta
4. Valida cada respuesta antes de considerar que la pregunta est√° respondida
5. Mant√©n el foco en el momento actual, no adelantes informaci√≥n del siguiente`.trim();
  }

  /**
   * Construye el prompt espec√≠fico para un momento - UNIVERSAL
   */
  static buildMomentPrompt(params: PromptParams & { 
    preguntasPendientes: string[];
    preguntasRespondidas: string[];
  }): string {
    const momentoActual = params.momentos[params.currentIndex];
    
    const siguiente = params.currentIndex < params.momentos.length - 1
      ? params.momentos[params.currentIndex + 1].momento
      : 'FIN';

    // Contenido espec√≠fico del momento
    const contenido = this.getMomentoContent(momentoActual);
    
    // Preguntas pendientes del momento
    const preguntasPendientes = params.preguntasPendientes;
    const primeraPregunta = preguntasPendientes[0] || 'N/A';

    // üëà NUEVO: Generar instrucciones din√°micas basadas en el tema
    const instruccionesEspecificas = this.generateDynamicInstructions(momentoActual, params);

    return `**MOMENTO ACTUAL: ${momentoActual?.momento || 'N/A'}**
**SIGUIENTE MOMENTO: ${siguiente}**

**INSTRUCCIONES PEDAG√ìGICAS:**
${instruccionesEspecificas}

**CONTENIDO DEL MOMENTO:**
${contenido}

**PREGUNTAS PENDIENTES:**
${preguntasPendientes.map((p: string, idx: number) => `${idx + 1}. ${p}`).join('\n')}

üìã **INSTRUCCIONES ESTRICTAS:**
1. **SIEMPRE** comienza mostrando el contenido del momento con la frase apropiada:
   - Conexi√≥n: "Te cuento una historia: [historia]"
   - Adquisici√≥n: "Ahora vamos a aprender: [contenido t√©cnico]"
   - Aplicaci√≥n: "Te presento un caso: [caso]"
   - Otros: "[instrucciones]"

2. **DESPU√âS** haz la primera pregunta pendiente: "${primeraPregunta}"

3. **SI** el estudiante dice "no s√©", "no recuerdo", "no tengo idea", etc., usa pistas relacionadas con el tema y repregunta.

4. **NO** avances al siguiente momento hasta que todas las preguntas est√©n completamente respondidas.

5. **SIEMPRE** termina tu respuesta con una pregunta (excepto en el cierre final).

**FORMATO DE RESPUESTA OBLIGATORIO:**
\`\`\`json
{
  "respuesta": "Tu respuesta como docente aqu√≠",
  "momento_actual": "${momentoActual?.momento || 'N/A'}",
  "progreso": ${params.currentIndex + 1},
  "total_momentos": ${params.momentos.length},
  "debe_avanzar": false,
  "razon_avance": "Raz√≥n del avance o por qu√© no avanza",
  "siguiente_momento": "${siguiente}",
  "pregunta_actual": "${primeraPregunta}",
  "preguntas_pendientes": ${preguntasPendientes.length},
  "preguntas_respondidas": ${params.preguntasRespondidas.length}
}
\`\`\`

**REGLAS PARA debe_avanzar:**
- **debe_avanzar: true** ‚Üí SOLO si preguntas_pendientes = 0 (todas respondidas)
- **debe_avanzar: false** ‚Üí Si hay preguntas pendientes o respuestas incompletas

**NO incluyas texto fuera del JSON. NO uses markdown. SOLO el JSON.**`.trim();
  }

  /**
   * üëà NUEVO: Genera instrucciones din√°micas basadas en el momento y tema
   */
  private static generateDynamicInstructions(momento: any, params: PromptParams): string {
    const momentoName = momento?.momento?.toLowerCase() || '';
    const tema = this.extractTemaFromParams(params);
    
    // Instrucciones base por tipo de momento
    let instruccionesBase = '';
    
    if (momentoName.includes('saludo')) {
      instruccionesBase = `Presenta el objetivo de la sesi√≥n sobre ${tema} y establece conexi√≥n con el estudiante`;
    } else if (momentoName.includes('conexi√≥n')) {
      instruccionesBase = `Conecta el tema de ${tema} con experiencias previas del estudiante usando la historia proporcionada`;
    } else if (momentoName.includes('adquisici√≥n')) {
      instruccionesBase = `Ense√±a los conceptos fundamentales de ${tema} de manera inductiva, guiando al descubrimiento`;
    } else if (momentoName.includes('aplicaci√≥n')) {
      instruccionesBase = `Facilita la aplicaci√≥n pr√°ctica de los conceptos de ${tema} usando el caso proporcionado`;
    } else if (momentoName.includes('discusi√≥n')) {
      instruccionesBase = `Facilita la comparaci√≥n y an√°lisis cr√≠tico de diferentes enfoques en ${tema}`;
    } else if (momentoName.includes('reflexi√≥n')) {
      instruccionesBase = `Gu√≠a la reflexi√≥n sobre el aprendizaje de ${tema} y su aplicaci√≥n pr√°ctica`;
    } else {
      instruccionesBase = `Gu√≠a el aprendizaje del estudiante en el tema de ${tema}`;
    }

    // Agregar contexto espec√≠fico del tema
    const contextoTema = this.getContextoTema(tema);
    
    return `${instruccionesBase}\n\n**CONTEXTO DEL TEMA:**\n${contextoTema}`;
  }

  /**
   * üëà NUEVO: Extrae el tema principal de los par√°metros
   */
  private static extractTemaFromParams(params: PromptParams): string {
    const sessionName = params.sessionName.toLowerCase();
    const courseName = params.courseName.toLowerCase();
    
    // Detectar tema basado en nombres
    if (sessionName.includes('incendio') || sessionName.includes('fuego')) {
      return 'prevenci√≥n de incendios';
    } else if (sessionName.includes('iperc')) {
      return 'identificaci√≥n de peligros y evaluaci√≥n de riesgos (IPERC)';
    } else if (courseName.includes('perforaci√≥n') || sessionName.includes('perforaci√≥n')) {
      return 'operaci√≥n de equipos de perforaci√≥n';
    } else if (sessionName.includes('procedimiento') || sessionName.includes('seguridad')) {
      return 'procedimientos de seguridad';
    } else if (courseName.includes('seguridad')) {
      return 'seguridad y salud ocupacional';
    }
    
    // Tema gen√©rico basado en el objetivo
    return params.learningObjective.split(' ').slice(0, 3).join(' ').toLowerCase();
  }

  /**
   * üëà NUEVO: Obtiene contexto espec√≠fico del tema
   */
  private static getContextoTema(tema: string): string {
    const contextualInfo = {
      'prevenci√≥n de incendios': 'Enf√≥cate en el Tri√°ngulo del Fuego, tipos de extintores, causas comunes de incendios laborales, y medidas preventivas.',
      'identificaci√≥n de peligros y evaluaci√≥n de riesgos (iperc)': 'Enf√≥cate en la diferencia entre peligro y riesgo, evaluaci√≥n de probabilidad y severidad, y jerarqu√≠a de controles.',
      'operaci√≥n de equipos de perforaci√≥n': 'Enf√≥cate en componentes de equipos, t√©cnicas de perforaci√≥n, tipos de terreno, y procedimientos operativos.',
      'procedimientos de seguridad': 'Enf√≥cate en equipos de protecci√≥n personal (EPP), se√±alizaci√≥n, protocolos de emergencia, y buenas pr√°cticas.',
      'seguridad y salud ocupacional': 'Enf√≥cate en identificaci√≥n de riesgos, medidas preventivas, normativas de seguridad, y cultura de seguridad.'
    };
    
    // Buscar contexto espec√≠fico o usar gen√©rico
    for (const [key, value] of Object.entries(contextualInfo)) {
      if (tema.includes(key) || key.includes(tema)) {
        return value;
      }
    }
    
    return 'Enf√≥cate en conceptos pr√°cticos, aplicaciones reales, y la conexi√≥n con la experiencia laboral del estudiante.';
  }

  /**
   * Extrae el contenido espec√≠fico del momento
   */
  private static getMomentoContent(momento: any): string {
    if (!momento) return 'N/A';

    const momentoName = momento.momento?.toLowerCase() || '';

    // Para Conexi√≥n, mostrar la historia
    if (momentoName.includes('conexi√≥n') && momento.historia) {
      return `HISTORIA: ${momento.historia}`;
    }

    // Para Adquisici√≥n, mostrar el contenido t√©cnico
    if (momentoName.includes('adquisici√≥n') && momento.contenido_tecnico) {
      const contenido = Array.isArray(momento.contenido_tecnico)
        ? momento.contenido_tecnico.join('\n')
        : momento.contenido_tecnico;
      return `CONTENIDO T√âCNICO:\n${contenido}`;
    }

    // Para Aplicaci√≥n, mostrar el caso
    if (momentoName.includes('aplicaci√≥n') && momento.caso) {
      return `CASO PR√ÅCTICO: ${momento.caso}`;
    }

    // Para otros momentos, mostrar las instrucciones
    const instruccionesDocente = (momento as any)["instrucciones docenteia"] 
      ?? momento.instrucciones_docenteia;
    
    if (typeof instruccionesDocente === 'string' && instruccionesDocente.trim().length > 0) {
      return `INSTRUCCIONES: ${instruccionesDocente}`;
    }

    return 'N/A';
  }

  /**
   * Valida si una respuesta es completa o evasiva - MEJORADO
   */
  static isEvasionResponse(response: string): boolean {
    const evasions = [
      'no s√©', 'no se', 'no recuerdo', 'no tengo idea', 'no estoy seguro',
      'ok', 's√≠', 'si', 'aj√°', 'mmm', 'eh', 'bueno', 'hola', 'hi'
    ];
    
    const cleanResponse = response.toLowerCase().trim();
    
    // Detectar evasiones exactas muy cortas
    const isExactEvasion = evasions.some(evasion => cleanResponse === evasion);
    if (isExactEvasion) return true;
    
    // üëà MEJORADO: Respuestas que indican falta de experiencia pero son honestas
    const honestResponses = [
      'no tengo experiencia', 'es nuevo para mi', 'nunca he trabajado',
      'no he visto', 'no conozco', 'es la primera vez', 'no he estado'
    ];
    
    const isHonestResponse = honestResponses.some(honest => cleanResponse.includes(honest));
    if (isHonestResponse && cleanResponse.length > 15) {
      return false; // üëà Estas son respuestas v√°lidas, no evasivas
    }
    
    // Detectar t√©rminos t√©cnicos que indican conocimiento
    const technicalIndicators = [
      'incendio', 'fuego', 'extintor', 'co2', 'abc', 'agua', 'polvo', 
      'peligro', 'riesgo', 'iperc', 'control', 'prevenci√≥n',
      'perforaci√≥n', 'equipo', 'm√°quina', 'terreno', 'broca',
      'seguridad', 'epp', 'casco', 'guantes', 'procedimiento'
    ];
    
    const hasTechnicalContent = technicalIndicators.some(term => cleanResponse.includes(term));
    
    if (hasTechnicalContent && cleanResponse.length > 10) {
      return false; // No es evasiva si contiene t√©rminos t√©cnicos
    }
    
    // Respuestas muy cortas sin contenido t√©cnico
    const isTooShort = cleanResponse.length < 8;
    
    return isTooShort;
  }

  /**
   * Genera una pista basada en el momento y la pregunta - UNIVERSAL
   */
  static generateHint(momentoName: string, pregunta: string, tema?: string): string {
    const preguntaLower = pregunta.toLowerCase();
    
    // Pistas espec√≠ficas por tipo de pregunta
    if (preguntaLower.includes('elementos') || preguntaLower.includes('identificas')) {
      return "Piensa en los componentes o elementos que observas en la situaci√≥n...";
    }
    if (preguntaLower.includes('experiencia') || preguntaLower.includes('relaciona')) {
      return "Reflexiona sobre tu experiencia personal o situaciones similares que hayas visto...";
    }
    if (preguntaLower.includes('conceptos') || preguntaLower.includes('significa')) {
      return "Piensa en las ideas b√°sicas que podr√≠an estar relacionadas con este tema...";
    }
    if (preguntaLower.includes('prevenido') || preguntaLower.includes('evitar')) {
      return "Considera qu√© medidas o acciones podr√≠an haber cambiado el resultado...";
    }
    if (preguntaLower.includes('aplicar√≠as') || preguntaLower.includes('har√≠as')) {
      return "Piensa en los pasos concretos que seguir√≠as usando lo que hemos aprendido...";
    }
    
    // Pista gen√©rica contextualizada
    const temaContext = tema ? ` sobre ${tema}` : '';
    return `Reflexiona sobre lo que sabes${temaContext} y comp√°rteme tus ideas, aunque sean b√°sicas...`;
  }
} 
```
=== EOF: src\services\PromptBuilderUniversal.ts

===  src\services\OpenAIService.ts
```typescript
import { OpenAI } from 'openai';
import { OpenAICallParams, OpenAICallResult } from '../types';
import { CostMonitor } from './CostMonitor';

export class OpenAIService {
  private client: OpenAI;
  private costMonitor: CostMonitor;

  constructor(apiKey: string) {
    this.client = new OpenAI({ apiKey });
    this.costMonitor = new CostMonitor();
  }

  /**
   * Llama a la API de OpenAI con par√°metros optimizados
   */
  async callOpenAI(params: OpenAICallParams): Promise<OpenAICallResult> {
    const model = params.model || this.getOptimalModel(params.systemPrompt);
    const maxTokens = Math.floor(params.maxTokens || this.calculateOptimalTokens(params.systemPrompt));

    try {
      const response = await this.client.responses.create({
        model,
        instructions: params.systemPrompt,
        input: params.userPrompt,
        max_output_tokens: maxTokens
      });

      const metrics = this.costMonitor.calculateMetrics(
        { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }, // OpenAI no devuelve usage en responses API
        model
      );
      this.costMonitor.logUsage(metrics);

      return { response, metrics };
    } catch (error) {
      console.error('Error en llamada a OpenAI:', error);
      throw error;
    }
  }

  /**
   * Selecciona el modelo √≥ptimo basado en la complejidad del prompt
   */
  private getOptimalModel(systemPrompt: string): string {
    const tokenCount = systemPrompt.length / 4; // Estimaci√≥n aproximada
    
    // Para prompts simples, usar gpt-3.5-turbo
    if (tokenCount < 800) {
      return 'gpt-3.5-turbo';
    }
    
    // Para prompts complejos, usar gpt-4o
    return 'gpt-4o';
  }

  /**
   * Calcula tokens √≥ptimos basado en la complejidad
   */
  private calculateOptimalTokens(systemPrompt: string): number {
    const baseTokens = 600;
    const complexity = systemPrompt.length / 1000;
    
    // Limitar entre 400 y 1000 tokens y convertir a entero
    return Math.floor(Math.min(Math.max(baseTokens + (complexity * 100), 400), 1000));
  }



  /**
   * Obtiene estad√≠sticas de costo
   */
  getCostStats() {
    return this.costMonitor.getCostStats();
  }

  /**
   * Limpia costos de una sesi√≥n
   */
  clearSessionCost(sessionKey: string): void {
    this.costMonitor.clearSessionCost(sessionKey);
  }

  /**
   * Limpia todos los costos
   */
  clearAllCosts(): void {
    this.costMonitor.clearAllCosts();
  }

  /**
   * Agrega costo a una sesi√≥n espec√≠fica
   */
  addSessionCost(sessionKey: string, cost: number): void {
    this.costMonitor.addSessionCost(sessionKey, cost);
  }

  /**
   * Obtiene el cliente OpenAI (para uso interno)
   */
  getClient(): OpenAI {
    return this.client;
  }
} 
```
=== EOF: src\services\OpenAIService.ts

===  src\services\CostMonitor.ts
```typescript
import { CostMetrics } from '../types';

export class CostMonitor {
  private static readonly COSTS = {
    'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 },
    'gpt-4o': { input: 0.005, output: 0.015 },
    'gpt-4o-mini': { input: 0.00015, output: 0.0006 }
  };

  private sessionCosts = new Map<string, number>();
  private totalCost = 0;
  private totalTokens = 0;

  /**
   * Calcula m√©tricas de costo basadas en el uso de tokens
   */
  calculateMetrics(usage: any, model: string): CostMetrics {
    const costs = CostMonitor.COSTS[model as keyof typeof CostMonitor.COSTS];
    if (!costs) {
      console.warn(`Modelo ${model} no encontrado en costos, usando gpt-3.5-turbo`);
      return this.calculateMetrics(usage, 'gpt-3.5-turbo');
    }

    const estimatedCost = (usage.prompt_tokens * costs.input + usage.completion_tokens * costs.output) / 1000;

    return {
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
      total_tokens: usage.total_tokens,
      estimated_cost: estimatedCost,
      model_used: model
    };
  }

  /**
   * Registra el uso de tokens y costo
   */
  logUsage(metrics: CostMetrics, sessionKey?: string): void {
    console.log(`üí∞ Costo estimado: $${metrics.estimated_cost.toFixed(4)}`);
    console.log(`üìä Tokens: ${metrics.prompt_tokens} + ${metrics.completion_tokens} = ${metrics.total_tokens}`);
    console.log(`ü§ñ Modelo: ${metrics.model_used}`);

    // Actualizar totales
    this.totalCost += metrics.estimated_cost;
    this.totalTokens += metrics.total_tokens;

    // Actualizar costo por sesi√≥n
    if (sessionKey) {
      this.addSessionCost(sessionKey, metrics.estimated_cost);
    }
  }

  /**
   * Obtiene el costo total de una sesi√≥n
   */
  getSessionCost(sessionKey: string): number {
    return this.sessionCosts.get(sessionKey) || 0;
  }

  /**
   * Agrega costo a una sesi√≥n espec√≠fica
   */
  addSessionCost(sessionKey: string, cost: number): void {
    const current = this.sessionCosts.get(sessionKey) || 0;
    this.sessionCosts.set(sessionKey, current + cost);
  }

  /**
   * Obtiene estad√≠sticas de costo
   */
  getCostStats(): { totalCost: number; totalTokens: number; sessionCosts: Map<string, number> } {
    return {
      totalCost: this.totalCost,
      totalTokens: this.totalTokens,
      sessionCosts: this.sessionCosts
    };
  }

  /**
   * Limpia los costos de una sesi√≥n
   */
  clearSessionCost(sessionKey: string): void {
    this.sessionCosts.delete(sessionKey);
  }

  /**
   * Limpia todos los costos
   */
  clearAllCosts(): void {
    this.sessionCosts.clear();
    this.totalCost = 0;
    this.totalTokens = 0;
  }

  /**
   * Obtiene el costo promedio por sesi√≥n
   */
  getAverageSessionCost(): number {
    if (this.sessionCosts.size === 0) return 0;
    const totalSessionCost = Array.from(this.sessionCosts.values()).reduce((sum, cost) => sum + cost, 0);
    return totalSessionCost / this.sessionCosts.size;
  }
} 
```
=== EOF: src\services\CostMonitor.ts

===  src\scripts\package.json
```json
{
  "type": "commonjs"
} 
```
=== EOF: src\scripts\package.json

===  src\scripts\chat-v2.ts
```typescript
import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import { SessionExtractorUniversal } from '../lib/SessionExtractorUniversal';
import { Course, Session } from '../types';
import * as dotenv from 'dotenv';

// Configurar variables de entorno
dotenv.config({ path: path.join(__dirname, '../../.env.local') });

// Colores para la terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Estado global de la conversaci√≥n
interface ConversationState {
  selectedCourse: Course | null;
  selectedSession: Session | null;
  sessionExtractor: SessionExtractorUniversal | null;
  currentSessionKey: string | null;
  momentoActual: number;
  momentos: any[];
  messages: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp: Date;
  }>;
  isInClass: boolean;
}

const conversationState: ConversationState = {
  selectedCourse: null,
  selectedSession: null,
  sessionExtractor: null,
  currentSessionKey: null,
  momentoActual: 0,
  momentos: [],
  messages: [],
  isInClass: false
};

// Funci√≥n para imprimir con colores
function print(color: keyof typeof colors, text: string): void {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// Funci√≥n para cargar la base de datos de cursos
function loadCoursesDatabase(): any {
  try {
    const filePath = path.join(__dirname, '../data/courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch {
    print('red', '‚ùå Error cargando la base de datos de cursos');
    return null;
  }
}

// Funci√≥n para mostrar cursos disponibles
function showCourses(): void {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return;
  
  print('cyan', '\nüìö Cursos Disponibles:');
  data.courses.forEach((course: Course, index: number) => {
    print('white', `${index + 1}. ${course.id} - ${course.name}`);
    print('yellow', `   üë®‚Äçüè´ ${course.specialist_role}`);
    print('yellow', `   üìä ${course.sessions.length} sesiones disponibles`);
  });
  print('yellow', '\nüí° Usa: /select <curso> <sesi√≥n> para seleccionar');
  print('yellow', '   Ejemplo: /select SSO001 1');
}

// Funci√≥n para seleccionar curso y sesi√≥n
async function selectCourse(courseId: string, sessionNumber: number): Promise<void> {
  try {
    const sessionId = `sesion0${sessionNumber}`;
    
    // Cargar datos del curso desde la base de datos
    const data = loadCoursesDatabase();
    if (!data || !data.courses) {
      console.error('‚ùå No se pudo cargar la base de datos de cursos');
      return;
    }
  
    const course = data.courses.find((c: Course) => c.id === courseId);
    if (!course) {
      console.error(`‚ùå Curso ${courseId} no encontrado`);
      return;
    }
  
    // Validar que el n√∫mero de sesi√≥n sea v√°lido
    if (sessionNumber < 1 || sessionNumber > course.sessions.length) {
      console.error(`‚ùå Sesi√≥n ${sessionNumber} no encontrada. Sesiones disponibles: 1-${course.sessions.length}`);
      return;
    }
  
    const session = course.sessions[sessionNumber - 1];
    if (!session) {
      console.error(`‚ùå Sesi√≥n ${sessionNumber} no encontrada`);
      return;
    }
    
    // Actualizar estado de la conversaci√≥n
    conversationState.selectedCourse = course;
    conversationState.selectedSession = session;
    
    console.log(`‚úÖ Curso seleccionado: ${course.name}`);
    console.log(`‚úÖ Sesi√≥n seleccionada: ${session.name}`);
    console.log(`‚úÖ Especialista: ${course.specialist_role}`);
    console.log(`‚úÖ Objetivo: ${session.learning_objective}`);
    console.log(`üìÅ Archivo de sesi√≥n: ${courseId}_${sessionId}.json`);

    // Inicializar el extractor universal
    conversationState.sessionExtractor = new SessionExtractorUniversal();
    
    console.log(`üöÄ Iniciando sesi√≥n...`);
    
    // üëà CAMBIADO: Usar startSession que devuelve mensaje inicial
    const sessionInfo = await conversationState.sessionExtractor.startSession(courseId, sessionId);
    conversationState.currentSessionKey = sessionInfo.sessionKey;
    
    console.log(`‚úÖ Sesi√≥n iniciada: ${sessionInfo.momentos} momentos`);
    console.log(`‚úÖ Clave de sesi√≥n: ${sessionInfo.sessionKey}`);
    console.log(`‚úÖ Momento actual: ${sessionInfo.currentMoment}`);

    // üëà NUEVO: Mostrar mensaje inicial del docente
    print('green', `\nüéì ${course.specialist_role}:`);
    print('white', sessionInfo.initialMessage);

    // Obtener momentos para mostrar estructura
    const sessionData = conversationState.sessionExtractor.getSessionInfo(sessionInfo.sessionKey);
    conversationState.momentos = sessionData?.momentos || [];
    conversationState.momentoActual = 0;

    console.log(`üìÑ Momentos extra√≠dos: ${conversationState.momentos.length}`);
    console.log(`üîó Estructura de la clase:`);
    conversationState.momentos.forEach((momento: any, index: number) => {
      console.log(`   ${index + 1}. ${momento.momento}`);
    });

    // üëà NUEVO: Marcar que ya estamos en clase
    conversationState.isInClass = true;
    print('cyan', `\n‚úÖ ¬°Clase iniciada! Puedes responder directamente al docente.`);

  } catch (error) {
    console.error(`‚ùå Error seleccionando curso: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

// Funci√≥n para procesar mensajes del estudiante
async function processStudentMessage(message: string): Promise<void> {
  if (!conversationState.selectedCourse || !conversationState.selectedSession || !conversationState.currentSessionKey) {
    print('red', '‚ùå Debes seleccionar un curso y sesi√≥n primero con /select');
    return;
  }

  try {
    print('cyan', `\nüë§ Estudiante: ${message}`);

    // Usar el m√©todo simplificado
    const respuesta = await conversationState.sessionExtractor!.handleStudent(
      conversationState.currentSessionKey, 
      message
    );

    // Actualizar estado de la conversaci√≥n
    conversationState.momentoActual = respuesta.progreso - 1; // Convertir progreso a √≠ndice

    // Agregar mensajes al historial
    conversationState.messages.push({
      role: 'user',
      content: message,
      timestamp: new Date()
    });
    conversationState.messages.push({
      role: 'assistant',
      content: respuesta.respuesta,
      timestamp: new Date()
    });

    // Mostrar respuesta del docente
    print('green', `\nüìÅ ${conversationState.selectedCourse.specialist_role}:`);
    print('white', respuesta.respuesta);
    print('cyan', `üöÄ Progreso: ${respuesta.progreso}/${respuesta.total_momentos}`);
    print('cyan', `üìÅ Momento actual: ${respuesta.momento_actual}`);
    print('cyan', `üìÅ ${respuesta.razon_avance}`);
    print('yellow', `‚è≠Ô∏è Siguiente: ${respuesta.siguiente_momento}`);

  } catch (error) {
    print('red', `‚ùå Error procesando mensaje: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

// Funci√≥n para mostrar el progreso actual
function showProgress(): void {
  if (!conversationState.selectedCourse || !conversationState.selectedSession) {
    print('red', '‚ùå No est√°s en una clase');
    return;
  }

  print('cyan', '\nüìä PROGRESO DE LA SESI√ìN:');
  print('white', `üìÅ Curso: ${conversationState.selectedCourse.name}`);
  print('white', `üìö Sesi√≥n: ${conversationState.selectedSession.name}`);
  print('white', `üë®‚Äçüè´ Especialista: ${conversationState.selectedCourse.specialist_role}`);
  print('white', `   Sesi√≥n activa: ${conversationState.currentSessionKey || 'N/A'}`);
  
  // Mostrar estad√≠sticas del sistema si hay extractor
  if (conversationState.sessionExtractor) {
    const stats = conversationState.sessionExtractor.getCacheStats();
    print('cyan', `\nüìä ESTAD√çSTICAS DEL SISTEMA:`);
    print('white', `   üéì Sesiones activas: ${stats.activeSessions}`);
    print('white', `   üíæ Cache: ${stats.cacheSize} elementos`);
    print('white', `   üéì Tama√±o de sesiones: ${stats.sessionsSize}`);
  } else {
    print('red', '‚ùå No hay extractor inicializado');
  }
  
  if (conversationState.messages && conversationState.messages.length > 0) {
    print('cyan', `\nüí¨ Mensajes intercambiados: ${conversationState.messages.length}`);
  }
}

// Funci√≥n para procesar comandos
async function processCommand(input: string): Promise<void> {
  const parts = input.trim().split(' ');
  const command = parts[0];
  
  switch (command) {
    case '/select':
      if (parts.length < 3) {
        print('red', '‚ùå Uso: /select <courseId> <sessionNumber>');
        print('yellow', '   Ejemplo: /select SSO001 1');
        return;
      }
      const courseId = parts[1];
      const sessionNumber = parseInt(parts[2]);
      await selectCourse(courseId, sessionNumber);
      break;
      
    case '/start':
      if (!conversationState.selectedCourse || !conversationState.selectedSession) {
        print('red', '‚ùå Debes seleccionar un curso y sesi√≥n primero con /select');
        return;
      }
      conversationState.isInClass = true;
      print('green', `üíæ ¬°Bienvenido a la clase de ${conversationState.selectedSession.name}!`);
      print('cyan', `üß† Docente IA especializado cargado`);
      print('cyan', `üìÅ Contenido cargado desde archivo JSON`);
      print('cyan', `‚ö° Interfaz interactiva lista`);
      print('cyan', `üîóüè´üè´ ¬°Hola! Soy tu ${conversationState.selectedCourse.specialist_role}`);
      print('cyan', `üöÄ Hoy aprenderemos sobre: ${conversationState.selectedSession.name}`);
      print('cyan', `üöÄ Objetivo: ${conversationState.selectedSession.learning_objective}`);
      print('cyan', `üìÅ Empezaremos con: MOMENTO_0`);
      print('cyan', `üë§ ¬°Escribe tu mensaje para comenzar la interacci√≥n!`);
      break;
      
    case '/sessions':
          if (conversationState.sessionExtractor) {
      const sessions = conversationState.sessionExtractor.listActiveSessions();
        if (sessions.length === 0) {
          print('yellow', 'üìã No hay sesiones activas');
        } else {
          print('cyan', 'üìã Sesiones activas:');
          sessions.forEach(session => {
            print('white', `   ${session.sessionKey}: ${session.course} - ${session.session} (${session.progress})`);
          });
        }
      } else {
        print('red', '‚ùå No hay extractor inicializado');
      }
      break;

    case '/clear-session':
      if (parts.length < 2) {
        print('red', '‚ùå Uso: /clear-session <sessionKey>');
        return;
      }
      if (conversationState.sessionExtractor) {
        const sessionKey = parts[1];
        const cleared = conversationState.sessionExtractor.clearSession(sessionKey);
        print(cleared ? 'green' : 'red', `‚úÖ Sesi√≥n ${sessionKey} eliminada`);
      }
      break;

    case '/clear-all-sessions':
      if (conversationState.sessionExtractor) {
        conversationState.sessionExtractor.clearAllSessions();
        print('green', '‚úÖ Todas las sesiones eliminadas');
      }
      break;
      
    case '/progress':
      showProgress();
      break;
      
    case '/stats':
      if (conversationState.sessionExtractor) {
        const stats = conversationState.sessionExtractor.getCacheStats();
        print('cyan', '\nüìä ESTAD√çSTICAS DEL SISTEMA:');
        print('white', `   üéì Sesiones activas: ${stats.activeSessions}`);
        print('white', `   üíæ Tama√±o del cache: ${stats.cacheSize}`);
        print('white', `   üéì Tama√±o de sesiones: ${stats.sessionsSize}`);
      } else {
        print('red', '‚ùå No hay extractor inicializado');
      }
      break;
      
    case '/reset':
      conversationState.selectedCourse = null;
      conversationState.selectedSession = null;
      conversationState.sessionExtractor = null;
      conversationState.currentSessionKey = null;
      conversationState.momentoActual = 0;
      conversationState.momentos = [];
      conversationState.messages = [];
      conversationState.isInClass = false;
      print('green', '‚úÖ Estado de conversaci√≥n reiniciado');
      break;
      
    case '/help':
      showHelp();
      break;
      
    case '/exit':
      print('yellow', 'üëã ¬°Hasta luego!');
      process.exit(0);
      break;
      
    default:
      print('red', `‚ùå Comando no reconocido. Usa /help para ver comandos disponibles.`);
  }
}

// Funci√≥n para mostrar ayuda
function showHelp(): void {
  print('cyan', '\nüìö DOCENTEIA - COMANDOS DISPONIBLES:');
  print('white', '\nüéØ SELECCI√ìN Y CONTROL:');
  print('yellow', '   /select <courseId> <sessionNumber>  - Seleccionar curso y sesi√≥n');
  print('yellow', '   /start                              - Iniciar la clase interactiva');
  print('yellow', '   /reset                              - Reiniciar estado de conversaci√≥n');

  print('white', '\nüìã GESTI√ìN DE SESIONES:');
  print('yellow', '   /sessions                           - Listar sesiones activas');
  print('yellow', '   /clear-session <sessionKey>         - Eliminar sesi√≥n espec√≠fica');
  print('yellow', '   /clear-all-sessions                 - Eliminar todas las sesiones');

  print('white', '\nüìä INFORMACI√ìN:');
  print('yellow', '   /progress                           - Mostrar progreso actual');
  print('yellow', '   /stats                              - Estad√≠sticas del sistema');
  print('yellow', '   /help                               - Mostrar esta ayuda');

  print('white', '\nüí¨ INTERACCI√ìN:');
  print('yellow', '   Escribe cualquier mensaje para interactuar con el docente IA');
  print('yellow', '   El sistema avanzar√° autom√°ticamente entre momentos seg√∫n tu progreso');

  print('cyan', '\n‚ö° CARACTER√çSTICAS OPTIMIZADAS:');
  print('white', '   ‚Ä¢ Fragmentos pre-calculados para respuestas m√°s r√°pidas');
  print('white', '   ‚Ä¢ Gesti√≥n inteligente de sesiones');
  print('white', '   ‚Ä¢ Coordinaci√≥n autom√°tica del avance de la clase');
  print('white', '   ‚Ä¢ Cache optimizado para mejor rendimiento');
  print('white', '   ‚Ä¢ Control de costos en tiempo real');
  print('white', '   ‚Ä¢ Selecci√≥n din√°mica de modelos');
}

// Funci√≥n principal del chat
function startChat(): void {
  // Crear interfaz de readline
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });
  
  print('cyan', 'ü§ñ Chat Terminal - DocenteIA v3.0 (TypeScript + Optimizaciones)');
  print('cyan', 'Escribe /help para ver comandos\n');
  
  // Mostrar cursos disponibles
  showCourses();
  
  // Loop principal de conversaci√≥n
  const askQuestion = () => {
    rl.question(`${colors.green}üë§ T√∫: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();
      
      if (!trimmedInput) {
        askQuestion();
        return;
      }
      
      // Procesar comandos
      if (trimmedInput.startsWith('/')) {
        await processCommand(trimmedInput);
        askQuestion();
        return;
      }
      
      // Si estamos en clase, procesar como mensaje del estudiante
      if (conversationState.isInClass) {
        await processStudentMessage(trimmedInput);
      } else {
        print('yellow', 'üí° Usa /select para elegir un curso y sesi√≥n, luego /start para iniciar la clase');
      }
      
      askQuestion();
    });
  };
  
  askQuestion();
}

// Manejar se√±ales de salida
process.on('SIGINT', () => {
  print('green', '\nüëã ¬°Hasta luego!');
  process.exit(0);
});

// Iniciar el chat
startChat(); 
```
=== EOF: src\scripts\chat-v2.ts

===  src\lib\utils.ts
```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("es-ES", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date)
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
} 
```
=== EOF: src\lib\utils.ts

===  src\lib\SessionExtractorUniversal.ts
```typescript
// src/lib/SessionExtractorUniversal.ts - Versi√≥n Corregida

import { AIResponse } from '../types';
import { OpenAIService } from '../services/OpenAIService';
import { SessionManager } from '../services/SessionManager';
import { PromptBuilderUniversal } from '../services/PromptBuilderUniversal';

export class SessionExtractorUniversal {
  private openAIService: OpenAIService;
  private sessionManager: SessionManager;
  private intentosEvasion: Map<string, number> = new Map();

  constructor() {
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY!);
    this.sessionManager = new SessionManager();
  }

  /**
   * Inicia una sesi√≥n y GENERA EL PRIMER MENSAJE DEL DOCENTE
   */
  async startSession(courseId: string, sessionId: string): Promise<{
    sessionKey: string;
    momentos: number;
    currentMoment: string;
    initialMessage: string; // üëà NUEVO: mensaje inicial del docente
  }> {
    try {
      const sessionKey = await this.sessionManager.startSession(courseId, sessionId);
      const session = this.sessionManager.getSession(sessionKey);
      
      if (!session) {
        throw new Error('Error iniciando sesi√≥n');
      }

      console.log(`üöÄ Iniciando sesi√≥n: ${session.course.name} - ${session.session.name}`);

      // üëà NUEVO: Generar mensaje inicial del docente
      const initialMessage = await this.generateInitialMessage(sessionKey);

      return {
        sessionKey,
        momentos: session.momentos.length,
        currentMoment: session.momentos[0]?.momento || 'N/A',
        initialMessage // üëà Incluir mensaje inicial
      };

    } catch (error) {
      console.error('Error iniciando sesi√≥n:', error);
      throw error;
    }
  }

  /**
   * üëà NUEVO: Genera el mensaje inicial del docente
   */
  private async generateInitialMessage(sessionKey: string): Promise<string> {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) return "Error cargando sesi√≥n";
    
    // Construir prompt inicial
    const spiritPrompt = PromptBuilderUniversal.buildSpiritPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective
    });

    const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective,
      keyPoints: session.session.key_points,
      momentos: session.momentos,
      currentIndex: 0,
      preguntasPendientes: session.preguntasPendientes,
      preguntasRespondidas: session.preguntasRespondidas
    });

    const systemPrompt = `${spiritPrompt}\n\n${momentPrompt}`;
    
    const { response } = await this.openAIService.callOpenAI({
      systemPrompt,
      userPrompt: "Inicia la clase con el saludo pedag√≥gico apropiado",
      model: 'gpt-3.5-turbo'
    });

    const parsedResponse = this.parseAIResponse(response.output_text);
    
    // Marcar que ya no es el primer turno
    this.sessionManager.updateSession(sessionKey, { isFirstTurn: false });

    // Guardar mensaje inicial en conversationLog
    session.conversationLog.push({
      role: 'assistant',
      content: parsedResponse?.respuesta || response.output_text,
      timestamp: new Date()
    });

    return parsedResponse?.respuesta || response.output_text;
  }

  /**
   * Maneja la interacci√≥n del estudiante con l√≥gica mejorada
   */
  async handleStudent(sessionKey: string, studentMessage: string): Promise<AIResponse> {
    try {
      const session = this.sessionManager.getSession(sessionKey);
      if (!session) {
        throw new Error(`Sesi√≥n ${sessionKey} no encontrada`);
      }

      this.sessionManager.updateSession(sessionKey, { lastActivity: new Date() });

      console.log(`üéì ${session.course.specialist_role} respondiendo...`);

      // Guardar mensaje del estudiante
      session.conversationLog.push({
        role: 'user',
        content: studentMessage,
        timestamp: new Date()
      });

      // Obtener el momento actual
      const momentoActual = session.momentos[session.currentMomentIndex] || null;
      const siguienteMomento = session.momentos[session.currentMomentIndex + 1] || null;

      // Construir historial (√∫ltimas 6 interacciones)
      const MAX_HISTORIA = 6;
      const historialRecortado = session.conversationLog
        .slice(-MAX_HISTORIA)
        .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: "${m.content}"`)
        .join('\n');

      // Construir prompt del momento
      const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
        specialistRole: session.course.specialist_role,
        sessionName: session.session.name,
        courseName: session.course.name,
        learningObjective: session.session.learning_objective,
        keyPoints: session.session.key_points,
        momentos: session.momentos,
        currentIndex: session.currentMomentIndex,
        preguntasPendientes: session.preguntasPendientes,
        preguntasRespondidas: session.preguntasRespondidas
      });

      let finalSystemPrompt = '';
      
      // Agregar historial si existe
      if (historialRecortado.trim()) {
        finalSystemPrompt += `HISTORIAL RECIENTE DE LA CLASE:\n${historialRecortado}\n\n`;
      }

      finalSystemPrompt += momentPrompt;

      // Llamar a OpenAI
      const { response, metrics } = await this.openAIService.callOpenAI({
        systemPrompt: finalSystemPrompt,
        userPrompt: studentMessage,
        model: 'gpt-3.5-turbo'
      });

      this.openAIService.clearSessionCost(sessionKey);
      this.openAIService.addSessionCost(sessionKey, metrics.estimated_cost);

      // Parsear respuesta
      let parsedResponse = this.parseAIResponse(response.output_text);
      
      if (!parsedResponse || typeof parsedResponse !== 'object') {
        parsedResponse = {
          respuesta: response.output_text,
          momento_actual: momentoActual ? momentoActual.momento : 'N/A',
          progreso: session.currentMomentIndex + 1,
          total_momentos: session.momentos.length,
          debe_avanzar: false,
          razon_avance: "Respuesta no estructurada",
          siguiente_momento: siguienteMomento ? siguienteMomento.momento : 'FIN',
          pregunta_actual: session.preguntasPendientes[0] || 'N/A',
          preguntas_pendientes: session.preguntasPendientes.length,
          preguntas_respondidas: session.preguntasRespondidas.length
        };
      }

      // üëà MEJORAR: Procesar respuesta del estudiante con l√≥gica m√°s inteligente
      this.processStudentResponseImproved(sessionKey, studentMessage, parsedResponse);

      // Asegurar que termina con pregunta (excepto en cierre final)
      const siguienteMomentoCheck = session.momentos[session.currentMomentIndex + 1];
      const isLastMoment = !siguienteMomentoCheck;
      
      if (!isLastMoment && !parsedResponse.respuesta.trim().endsWith("?")) {
        const nextQuestion = session.preguntasPendientes[0] || "¬øPuedes elaborar m√°s tu respuesta?";
        parsedResponse.respuesta = `${parsedResponse.respuesta.trim()} ${nextQuestion}`;
        console.log(`‚ùì Forzando pregunta al final: "${nextQuestion}"`);
      }

      // Guardar respuesta del docente
      session.conversationLog.push({
        role: 'assistant',
        content: parsedResponse.respuesta,
        timestamp: new Date()
      });

      // Control de avance: Solo avanza si no hay preguntas pendientes
      if (session.preguntasPendientes.length > 0) {
        parsedResponse.debe_avanzar = false;
        parsedResponse.razon_avance = `A√∫n hay ${session.preguntasPendientes.length} pregunta(s) pendiente(s)`;
        console.log(`üö´ Bloqueando avance: ${session.preguntasPendientes.length} preguntas pendientes`);
      }

      // Avanzar si debe avanzar
      if (parsedResponse.debe_avanzar && session.currentMomentIndex < session.momentos.length - 1) {
        const nuevoIndice = session.currentMomentIndex + 1;
        const nuevoMomento = session.momentos[nuevoIndice];
        
        this.sessionManager.updateSession(sessionKey, {
          currentMomentIndex: nuevoIndice,
          preguntasPendientes: nuevoMomento?.preguntas || [],
          preguntasRespondidas: []
        });
        
        console.log(`üíæ Avanzando al momento ${nuevoIndice + 1}: ${nuevoMomento?.momento}`);
        
        return await this.generateNewMomentResponse(sessionKey, nuevoIndice);
      } else if (parsedResponse.debe_avanzar) {
        console.log(`üéâ ¬°Clase completada! Todos los momentos han sido cubiertos.`);
      }

      return {
        ...parsedResponse,
        momentos: session.momentos,
        sessionKey
      };

    } catch (error) {
      console.error('Error en respuesta del docente:', error);
      return {
        respuesta: "Lo siento, tuve un problema generando la respuesta. ¬øPodr√≠as reformular tu pregunta?",
        momento_actual: 'ERROR',
        progreso: 0,
        total_momentos: 0,
        debe_avanzar: false,
        razon_avance: "Error en el sistema",
        siguiente_momento: 'ERROR',
        momentos: [],
        sessionKey
      };
    }
  }

  /**
   * üëà MEJORADO: Procesa la respuesta del estudiante con mejor l√≥gica
   */
  private processStudentResponseImproved(sessionKey: string, studentMessage: string, aiResponse: any): void {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) return;

    const preguntaActual = session.preguntasPendientes[0];
    if (!preguntaActual) return;

    // üëà MEJORADO: Verificar si la respuesta es v√°lida (menos estricto)
    const isValidResponse = this.isValidResponse(studentMessage);
    
    if (isValidResponse) {
      // Respuesta v√°lida - mover pregunta de pendiente a respondida
      const nuevasPendientes = session.preguntasPendientes.slice(1);
      const nuevasRespondidas = [...session.preguntasRespondidas, preguntaActual];
      
      this.sessionManager.updateSession(sessionKey, {
        preguntasPendientes: nuevasPendientes,
        preguntasRespondidas: nuevasRespondidas
      });
      
      console.log(`‚úÖ Pregunta respondida: "${preguntaActual}"`);
      console.log(`üìã Preguntas pendientes: ${nuevasPendientes.length}`);
      
      // Si no hay m√°s preguntas pendientes, preparar transici√≥n
      if (nuevasPendientes.length === 0) {
        console.log(`üéØ ¬°Todas las preguntas del momento respondidas! Preparando transici√≥n...`);
        aiResponse.debe_avanzar = true;
        aiResponse.razon_avance = "Todas las preguntas del momento han sido respondidas completamente";
      }
    } else {
      console.log(`‚ö†Ô∏è Respuesta que necesita ayuda: "${studentMessage}"`);
      
      // Ayudar al estudiante a resolver la pregunta
      const momentoActual = session.momentos[session.currentMomentIndex];
      const momentoKey = momentoActual?.momento || '';
      const intentosActuales = this.intentosEvasion.get(momentoKey) || 0;
      this.intentosEvasion.set(momentoKey, intentosActuales + 1);
      
      const ayudaRespuesta = this.buildHelpfulResponseImproved(studentMessage, preguntaActual, momentoKey);
      
      aiResponse.respuesta = ayudaRespuesta;
      aiResponse.debe_avanzar = false;
      aiResponse.razon_avance = "Ayudando al estudiante a resolver la pregunta";
      
      console.log(`üîÑ Ayudando al estudiante (intento ${intentosActuales + 1}): "${ayudaRespuesta.substring(0, 50)}..."`);
    }
  }

  /**
   * üëà MEJORADO: Detecta si una respuesta es v√°lida (menos estricto)
   */
  private isValidResponse(response: string): boolean {
    const cleanResponse = response.toLowerCase().trim();
    
    // Respuestas claramente evasivas
    const obvioussEvasions = [
      'no s√©', 'no se', 'no recuerdo', 'no tengo idea',
      'ok', 's√≠', 'si', 'aj√°', 'mmm', 'eh', 'bueno', 
      'hola', 'hi', 'otra vez', 'la misma pregunta'
    ];
    
    // Si es una evasi√≥n obvia y muy corta
    if (obvioussEvasions.includes(cleanResponse) && cleanResponse.length < 10) {
      return false;
    }
    
    // Si la respuesta tiene m√°s de 15 caracteres, probablemente es v√°lida
    if (cleanResponse.length > 15) {
      return true;
    }
    
    // Detectar respuestas que indican falta de experiencia pero son honestas
    const honestResponses = [
      'no tengo experiencia', 'es nuevo para mi', 'nunca he trabajado',
      'no he visto', 'no conozco', 'es la primera vez'
    ];
    
    const isHonestResponse = honestResponses.some(honest => cleanResponse.includes(honest));
    if (isHonestResponse) {
      return true; // üëà Estas son respuestas v√°lidas, no evasivas
    }
    
    // Para respuestas muy cortas, considerar evasivas
    return cleanResponse.length >= 8;
  }

  /**
   * üëà MEJORADO: Construye respuesta de ayuda m√°s inteligente
   */
  private buildHelpfulResponseImproved(studentMessage: string, preguntaActual: string, momentoName: string): string {
    const cleanMessage = studentMessage.toLowerCase();
    
    // Si el estudiante dice que no tiene experiencia, eso es v√°lido
    if (cleanMessage.includes('no tengo experiencia') || cleanMessage.includes('es nuevo para mi')) {
      return `Perfecto, no hay problema en no tener experiencia previa. Te ayudo a pensar: ${preguntaActual}`;
    }
    
    // Si dice que no sabe algo espec√≠fico
    if (cleanMessage.includes('no s√©') || cleanMessage.includes('no se')) {
      return this.buildUniversalHelpResponse(preguntaActual, momentoName);
    }
    
    // Si es una respuesta muy corta
    if (cleanMessage.length < 10) {
      return `Entiendo. Te ayudo a pensar m√°s espec√≠ficamente: ${preguntaActual}`;
    }
    
    // Respuesta por defecto
    return `Veo que tienes algunas ideas. ¬øPuedes contarme m√°s espec√≠ficamente sobre ${preguntaActual.toLowerCase()}?`;
  }

  /**
   * üëà NUEVO: Construye respuesta de ayuda universal para cualquier curso/tema
   */
  private buildUniversalHelpResponse(preguntaActual: string, momentoName: string): string {
    const session = this.sessionManager.getSession(Array.from(this.sessionManager['sessions'].keys())[0]);
    if (!session) return `Te ayudo a pensar: ${preguntaActual}`;
    
    const intentos = this.intentosEvasion.get(momentoName) || 0;
    const tema = this.extractTemaFromSession(session);
    
    // Generar pistas din√°micas basadas en el tema del curso
    const pistasGenericas = this.generateDynamicHints(preguntaActual, tema, momentoName, intentos);
    
    return pistasGenericas;
  }

  /**
   * üëà NUEVO: Extrae el tema principal del curso din√°micamente
   */
  private extractTemaFromSession(session: any): string {
    // Extraer tema de keywords de la sesi√≥n
    const keywords = session.session.theme_keywords || [];
    const temaFromKeywords = keywords.join(' ').toLowerCase();
    
    // Extraer tema del nombre del curso y sesi√≥n
    const courseName = session.course.name.toLowerCase();
    const sessionName = session.session.name.toLowerCase();
    
    // Determinar tema principal
    if (temaFromKeywords.includes('incendio') || sessionName.includes('incendio')) {
      return 'incendios';
    } else if (temaFromKeywords.includes('iperc') || sessionName.includes('iperc')) {
      return 'iperc';
    } else if (temaFromKeywords.includes('perforaci√≥n') || courseName.includes('perforaci√≥n')) {
      return 'perforaci√≥n';
    } else if (courseName.includes('seguridad')) {
      return 'seguridad';
    } else if (temaFromKeywords.includes('procedimiento') || sessionName.includes('procedimiento')) {
      return 'procedimientos';
    }
    
    return 'general'; // Tema por defecto
  }

  /**
   * üëà NUEVO: Genera pistas din√°micas basadas en el tema y momento
   */
  private generateDynamicHints(pregunta: string, tema: string, momentoName: string, intentos: number): string {
    const momentoLower = momentoName.toLowerCase();
    
    // Pistas espec√≠ficas por tema
    const temaHints = this.getHintsByTema();
    
    // Pistas espec√≠ficas por momento
    const momentoHints = this.getHintsByMomento(momentoLower, tema);
    
    // Combinar y rotar pistas
    const allHints = [...temaHints, ...momentoHints];
    const hintIndex = intentos % allHints.length;
    
    return allHints[hintIndex] || `Te ayudo a pensar: ${pregunta}`;
  }

  /**
   * üëà NUEVO: Obtiene pistas espec√≠ficas por tema del curso
   */
  private getHintsByTema(): string[] {
    // Hints universales que funcionan para cualquier curso o tema
    const universalHints = [
      "Piensa en tu experiencia personal relacionada con este tema...",
      "Considera situaciones similares que hayas visto o escuchado...",
      "Reflexiona sobre lo que sabes del tema aunque sea b√°sico...",
      "Recuerda ejemplos pr√°cticos de tu vida cotidiana o trabajo...",
      "Piensa en casos o situaciones que hayas observado...",
      "Considera qu√© has aprendido anteriormente sobre este tema...",
      "Reflexiona sobre aplicaciones pr√°cticas de este conocimiento...",
      "Recuerda situaciones donde este tema ha sido relevante..."
    ];
    
        return universalHints;
  }

  /**
   * üëà NUEVO: Obtiene pistas espec√≠ficas por momento pedag√≥gico
   */
  private getHintsByMomento(momento: string, tema: string): string[] {
    if (momento.includes('saludo')) {
      return [
        `No te preocupes si no sabes mucho sobre ${tema}, empezaremos desde lo b√°sico.`,
        `Es normal no tener experiencia previa. ¬øHas escuchado algo sobre ${tema}?`,
        `Vamos a explorar juntos este tema. ¬øQu√© te viene a la mente cuando escuchas ${tema}?`
      ];
    } else if (momento.includes('conexi√≥n')) {
      return [
        "Piensa en situaciones de tu vida diaria que podr√≠an relacionarse...",
        "¬øHas estado en lugares donde esto podr√≠a ser relevante?",
        "Considera experiencias de familiares, amigos o conocidos..."
      ];
    } else if (momento.includes('adquisici√≥n')) {
      return [
        "Te ayudo con los conceptos b√°sicos. ¬øQu√© crees que significa...?",
        "Vamos a descubrir esto paso a paso. ¬øPuedes imaginar qu√© elementos est√°n involucrados?",
        "Piensa en los componentes principales que podr√≠an estar relacionados..."
      ];
    } else if (momento.includes('aplicaci√≥n')) {
      return [
        "Usando lo que acabamos de aprender, ¬øqu√© har√≠as en esta situaci√≥n?",
        "Apliquemos los conceptos al caso. ¬øQu√© pasos seguir√≠as?",
        "¬øC√≥mo utilizar√≠as lo que aprendimos para resolver esto?"
      ];
    } else if (momento.includes('discusi√≥n')) {
      return [
        "¬øQu√© ventajas y desventajas ves en cada opci√≥n?",
        "¬øEn qu√© situaciones preferir√≠as un enfoque sobre otro?",
        "¬øQu√© factores consideras m√°s importantes para decidir?"
      ];
    } else if (momento.includes('reflexi√≥n')) {
      return [
        "¬øQu√© fue lo que m√°s te llam√≥ la atenci√≥n de lo que vimos?",
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo crees que podr√≠as aplicar esto en tu contexto?"
      ];
    }

    return [
      "Te ayudo a pensar sobre esto de manera m√°s espec√≠fica...",
      "¬øPuedes contarme m√°s sobre tu perspectiva?",
      "Vamos a explorar esto juntos paso a paso..."
    ];
  }

  /**
   * Parsea la respuesta de la IA para extraer JSON
   */
  private parseAIResponse(responseText: string): any {
    try {
      const cleanedText = responseText.trim();
      const jsonMatch = cleanedText.match(/```(?:json|js)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1].trim());
      }
      const jsonObjectMatch = cleanedText.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/);
      if (jsonObjectMatch) {
        return JSON.parse(jsonObjectMatch[0]);
      }
      return JSON.parse(cleanedText);
    } catch (error) {
      console.error('Error parseando JSON:', error);
      return null;
    }
  }

  /**
   * Genera respuesta para el nuevo momento cuando se avanza
   */
  private async generateNewMomentResponse(sessionKey: string, nuevoIndice: number): Promise<AIResponse> {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) {
      throw new Error('Sesi√≥n no encontrada');
    }

    const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective,
      keyPoints: session.session.key_points,
      momentos: session.momentos,
      currentIndex: nuevoIndice,
      preguntasPendientes: session.preguntasPendientes,
      preguntasRespondidas: session.preguntasRespondidas
    });

    const { response } = await this.openAIService.callOpenAI({
      systemPrompt: momentPrompt,
      userPrompt: "Contin√∫a con el siguiente momento",
      model: 'gpt-3.5-turbo'
    });

    const nuevaRespuesta = this.parseAIResponse(response.output_text);
    
    return {
      ...nuevaRespuesta,
      momentos: session.momentos,
      sessionKey
    };
  }

  // M√âTODOS DE GESTI√ìN DE SESIONES (delegados al SessionManager)
  getSessionInfo(sessionKey: string) {
    return this.sessionManager.getSession(sessionKey);
  }

  listActiveSessions() {
    return this.sessionManager.listActiveSessions();
  }

  clearSession(sessionKey: string) {
    return this.sessionManager.clearSession(sessionKey);
  }

  clearAllSessions() {
    this.sessionManager.clearAllSessions();
  }

  getCacheStats() {
    return this.sessionManager.getCacheStats();
  }

  clearCache() {
    this.sessionManager.clearCache();
  }
} 
```
=== EOF: src\lib\SessionExtractorUniversal.ts

===  src\lib\openai.ts
```typescript
import OpenAI from 'openai';

// Configuraci√≥n de OpenAI
export const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
  dangerouslyAllowBrowser: false, // Solo para servidor
});

// Tipos para las respuestas de OpenAI
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// Funci√≥n para enviar mensaje a ChatGPT
export async function sendChatMessage(
  messages: ChatMessage[],
  model: string = 'gpt-3.5-turbo'
): Promise<ChatResponse> {
  try {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY no est√° configurada');
    }

    const completion = await openai.chat.completions.create({
      model,
      messages,
      max_tokens: 1000,
      temperature: 0.7,
    });

    const response = completion.choices[0]?.message?.content || '';
    
    return {
      content: response,
      usage: completion.usage ? {
        prompt_tokens: completion.usage.prompt_tokens,
        completion_tokens: completion.usage.completion_tokens,
        total_tokens: completion.usage.total_tokens,
      } : undefined,
    };
  } catch (error) {
    console.error('Error al comunicarse con OpenAI:', error);
    throw new Error('Error al procesar la solicitud');
  }
}

// Funci√≥n para generar texto con GPT
export async function generateText(
  prompt: string,
  model: string = 'gpt-3.5-turbo'
): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 500,
      temperature: 0.7,
    });

    return completion.choices[0]?.message?.content || '';
  } catch (error) {
    console.error('Error al generar texto:', error);
    throw new Error('Error al generar texto');
  }
}

// Funci√≥n para analizar sentimientos
export async function analyzeSentiment(text: string): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'Analiza el sentimiento del siguiente texto y responde solo con: POSITIVO, NEGATIVO o NEUTRAL.'
        },
        {
          role: 'user',
          content: text
        }
      ],
      max_tokens: 10,
      temperature: 0.3,
    });

    return completion.choices[0]?.message?.content || 'NEUTRAL';
  } catch (error) {
    console.error('Error al analizar sentimiento:', error);
    return 'NEUTRAL';
  }
} 
```
=== EOF: src\lib\openai.ts

===  src\lib\constants.ts
```typescript
export const APP_CONFIG = {
  name: "DocenteIA",
  version: "1.0.0",
  description: "Sistema estable con Next.js y TypeScript",
  author: "Tu Nombre",
  repository: "https://github.com/tu-usuario/docenteia",
} as const;

export const API_ENDPOINTS = {
  base: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
  auth: "/auth",
  users: "/users",
  courses: "/courses",
} as const;

export const ROUTES = {
  home: "/",
  about: "/about",
  contact: "/contact",
  dashboard: "/dashboard",
} as const;

export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
} as const; 
```
=== EOF: src\lib\constants.ts

===  src\lib\config.ts
```typescript
export const config = {
  app: {
    name: process.env.NEXT_PUBLIC_APP_NAME || "DocenteIA",
    version: process.env.NEXT_PUBLIC_APP_VERSION || "1.0.0",
    description: "Sistema estable con Next.js y TypeScript",
  },
  api: {
    baseUrl: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
    timeout: 10000,
  },
  auth: {
    secret: process.env.NEXTAUTH_SECRET,
    url: process.env.NEXTAUTH_URL || "http://localhost:3000",
  },
  features: {
    analytics: process.env.NEXT_PUBLIC_GA_ID,
    darkMode: true,
    pwa: false,
  },
} as const;

export type Config = typeof config; 
```
=== EOF: src\lib\config.ts

===  src\data\pedagogia-universal.json
```json
{
  "pedagogia_universal": {
    "metadatos": {
      "nombre": "Sistema Pedag√≥gico por Momentos",
      "basado_en": "Teach Like a Champion (Doug Lemov)",
      "version": "1.0",
      "aplicable_a": "Todas las materias y niveles educativos",
      "enfoque": "Docente IA con metodolog√≠a inductiva",
      "fecha_creacion": "2025-07-30"
    },
    "principios_fundamentales": {
      "filosofia_base": "Aprendizaje activo a trav√©s de descubrimiento guiado",
      "enfoque_respuestas": "Construcci√≥n sobre respuestas parciales, nunca descarte total",
      "manejo_errores": "Errores como oportunidades de aprendizaje, no fallas",
      "validacion": "Verificaci√≥n constante de comprensi√≥n antes de avanzar",
      "personalizacion": "Adaptaci√≥n al ritmo y estilo del estudiante individual"
    },
    "momentos_pedagogicos": {
      "momento_saludo": {
        "objetivo_pedagogico": "Establecer conexi√≥n emocional y ambiente propicio para el aprendizaje",
        "tecnicas_teach_like_champion": [
          "Warm/Strict (C√°lido pero con altas expectativas)",
          "Joy Factor (Generar entusiasmo genuino por el aprendizaje)",
          "Strong Start (Comenzar con energ√≠a positiva)"
        ],
        "instrucciones_ia": [
          "Aplica t√©cnica 'Warm/Strict': ser genuinamente c√°lido mientras mantienes altas expectativas",
          "Usa 'Joy Factor': transmite entusiasmo real por el tema y el proceso de aprendizaje",
          "Implementa 'Strong Start': comenzar con energ√≠a y prop√≥sito claro",
          "Personaliza el saludo seg√∫n informaci√≥n disponible del estudiante",
          "Establece tono de confianza pero profesional desde el primer momento",
          "Genera expectativa positiva hacia la sesi√≥n sin revelar contenido espec√≠fico"
        ],
        "estrategias_conexion": [
          "Mostrar inter√©s genuino por el bienestar del estudiante",
          "Usar lenguaje inclusivo y cercano apropiado para el nivel educativo",
          "Crear atmosfera de seguridad psicol√≥gica para el aprendizaje",
          "Establecer que el error es parte natural del proceso de aprendizaje"
        ],
        "validacion_momento": [
          "Confirmar que el estudiante responde de manera receptiva",
          "Verificar que se establece ambiente de confianza mutua",
          "Asegurar que hay apertura para el di√°logo y participaci√≥n",
          "Observar indicadores de engagement inicial"
        ],
        "errores_evitar": [
          "Ser demasiado formal o distante",
          "Adelantar contenido acad√©mico en este momento",
          "Ignorar se√±ales de resistencia o desconfort del estudiante",
          "Saltar directamente a objetivos sin conexi√≥n humana"
        ]
      },
      "momento_presentacion_aprendizajes": {
        "objetivo_pedagogico": "Crear claridad de prop√≥sito y motivaci√≥n intr√≠nseca hacia los objetivos",
        "tecnicas_teach_like_champion": [
          "Begin with the End (Empezar con el resultado final claro)",
          "Hook (Capturar inter√©s desde el inicio)",
          "Champion's Clarity (Claridad absoluta en expectativas)"
        ],
        "instrucciones_ia": [
          "Aplica 'Begin with the End': presenta claramente qu√© lograr√° el estudiante al finalizar",
          "Usa t√©cnica 'Hook': crea inter√©s genuino mostrando la relevancia pr√°ctica",
          "Implementa 'Champion's Clarity': ser absolutamente espec√≠fico sobre resultados esperados",
          "Conecta objetivos con beneficios tangibles para el estudiante",
          "Usa lenguaje de acci√≥n y resultado, no de proceso pasivo",
          "Verifica que el estudiante ve el valor de lo que aprender√°"
        ],
        "estructura_presentacion": [
          "Resultado espec√≠fico que lograr√° (qu√© podr√° hacer)",
          "Beneficio tangible en su vida/carrera (para qu√© le sirve)",
          "Relevancia inmediata (cu√°ndo lo aplicar√°)",
          "Confirmaci√≥n de comprensi√≥n y aceptaci√≥n del objetivo"
        ],
        "frases_potentes": [
          "Al terminar esta sesi√≥n, t√∫ ser√°s capaz de...",
          "Esto te permitir√°... en tu trabajo/estudios",
          "Imag√≠nate poder... despu√©s de hoy",
          "Esta habilidad te dar√° la confianza para..."
        ],
        "validacion_momento": [
          "El estudiante puede reformular el objetivo con sus palabras",
          "Expresa inter√©s o motivaci√≥n hacia el resultado prometido",
          "Hace preguntas relacionadas con la aplicaci√≥n pr√°ctica",
          "Muestra compromiso con el proceso de aprendizaje"
        ]
      },
      "momento_puntos_clave": {
        "objetivo_pedagogico": "Crear organizadores previos y mapa mental de la ruta de aprendizaje",
        "tecnicas_teach_like_champion": [
          "Name the Steps (Nombrar pasos espec√≠ficos)",
          "Batch Process (Agrupar informaci√≥n l√≥gicamente)",
          "Foreshadowing (Anticipar lo que viene)"
        ],
        "instrucciones_ia": [
          "Aplica 'Name the Steps': presenta cada punto clave como paso espec√≠fico y medible",
          "Usa 'Batch Process': agrupa contenidos relacionados de manera l√≥gica y secuencial",
          "Implementa 'Foreshadowing': crea anticipaci√≥n sobre cada punto sin revelarlo completamente",
          "Presenta estructura visual/mental clara del recorrido de aprendizaje",
          "Explica la l√≥gica de la secuencia para que tenga sentido",
          "Genera curiosidad sobre cada punto sin dar informaci√≥n detallada"
        ],
        "estrategias_organizacion": [
          "Usar numeraci√≥n clara y secuencial",
          "Mostrar conexiones l√≥gicas entre puntos",
          "Crear expectativa creciente hacia cada punto",
          "Usar analog√≠as de viaje/construcci√≥n para la estructura"
        ],
        "tecnicas_anticipacion": [
          "Usar frases como 'Primero descubriremos...', 'Luego exploraremos...'",
          "Crear intriga: 'Algo fascinante que aprender√°s en el punto 3 es...'",
          "Conectar cada punto con el resultado final",
          "Mostrar c√≥mo cada punto construye sobre el anterior"
        ],
        "validacion_momento": [
          "El estudiante puede repetir la secuencia de puntos",
          "Entiende la l√≥gica de la progresi√≥n",
          "Muestra curiosidad por puntos espec√≠ficos",
          "Ve la conexi√≥n entre estructura y objetivo final"
        ]
      },
      "momento_conexion": {
        "objetivo_pedagogico": "Activar conocimientos previos y crear puentes cognitivos hacia nuevos aprendizajes",
        "tecnicas_teach_like_champion": [
          "Retrieval Practice (Pr√°ctica de recuperaci√≥n)",
          "Bridge the Gap (Conectar lo conocido con lo nuevo)",
          "Universal Prompt (Preguntas que todos pueden responder)"
        ],
        "instrucciones_ia": [
          "Aplica 'Retrieval Practice': ayuda al estudiante a recordar conocimientos relacionados",
          "Usa 'Bridge the Gap': conecta expl√≠citamente experiencias previas con nuevos conceptos",
          "Implementa 'Universal Prompt': haz preguntas que el estudiante definitivamente puede responder",
          "Explora experiencias personales relacionadas con el tema",
          "Valida conocimientos previos como base v√°lida para construir",
          "Identifica conceptos err√≥neos para abordarlos durante la sesi√≥n"
        ],
        "estrategias_activacion": [
          "Preguntas abiertas sobre experiencias relacionadas",
          "Analog√≠as con situaciones familiares del estudiante",
          "Recuperaci√≥n de aprendizajes previos relevantes",
          "Conexi√≥n emocional con el tema a trav√©s de experiencias personales"
        ],
        "tipos_preguntas": [
          "Experienciales: '¬øHas vivido alguna situaci√≥n donde...?'",
          "Observacionales: '¬øQu√© has notado cuando...?'",
          "Comparativas: '¬øEn qu√© se parece esto a...?'",
          "Reflexivas: '¬øQu√© piensas sobre...?'"
        ],
        "manejo_respuestas": [
          "Validar todas las experiencias como valiosas",
          "Construir sobre respuestas parciales o incompletas",
          "Conectar respuestas individuales con conceptos generales",
          "Usar respuestas como trampol√≠n hacia nuevos aprendizajes"
        ],
        "validacion_momento": [
          "El estudiante comparte experiencias relacionadas",
          "Se activan recuerdos y conocimientos previos relevantes",
          "Hay conexi√≥n emocional evidente con el tema",
          "Se establece base s√≥lida para nuevos aprendizajes"
        ]
      },
      "momento_adquisicion": {
        "objetivo_pedagogico": "Facilitar construcci√≥n activa de conocimientos mediante descubrimiento guiado",
        "tecnicas_teach_like_champion": [
          "Cold Call (Preguntar sin avisar para mantener participaci√≥n)",
          "No Opt Out (No permitir que estudiantes se desconecten)",
          "Right is Right (Solo respuestas completamente correctas)",
          "Stretch It (Extender pensamiento m√°s all√° de respuesta inicial)",
          "Turn and Talk (Tiempo para procesar antes de responder)"
        ],
        "instrucciones_ia": [
          "Aplica metodolog√≠a INDUCTIVA PURA: NUNCA dar definiciones directas",
          "Usa 'Cold Call': mant√©n al estudiante participando activamente con preguntas constantes",
          "Implementa 'No Opt Out': no aceptes 'no s√©' como respuesta final, gu√≠a hacia descubrimiento",
          "Aplica 'Right is Right': no apruebes respuestas parciales como completas",
          "Usa 'Stretch It': cuando respuesta es correcta, profundiza con '¬øPor qu√©?' o '¬øQu√© m√°s?'",
          "Implementa secuencia: Observaci√≥n ‚Üí Pregunta ‚Üí Deducci√≥n ‚Üí Confirmaci√≥n",
          "Construye sobre cada respuesta parcial para llegar a comprensi√≥n completa"
        ],
        "metodologia_inductiva": [
          "Presentar ejemplos/casos antes que definiciones",
          "Hacer preguntas que lleven al estudiante a deducir conceptos",
          "Esperar respuesta del estudiante antes de confirmar o corregir",
          "Usar m√∫ltiples ejemplos para que el estudiante vea patrones",
          "Permitir que el estudiante 'descubra' la regla o principio"
        ],
        "manejo_respuestas": {
          "respuesta_correcta_completa": [
            "Confirmar con entusiasmo genuino",
            "Aplicar 'Stretch It' para profundizar",
            "Conectar con ejemplos adicionales",
            "Usar como base para siguiente concepto"
          ],
          "respuesta_parcialmente_correcta": [
            "Reconocer la parte correcta espec√≠ficamente",
            "Hacer pregunta que gu√≠e hacia completar la respuesta",
            "No descartar, sino construir sobre lo correcto",
            "Dar pista orientadora hacia aspecto faltante"
          ],
          "respuesta_incorrecta": [
            "No decir simplemente 'incorrecto'",
            "Identificar el punto exacto donde se desv√≠a el razonamiento",
            "Hacer pregunta que redirija el pensamiento",
            "Proporcionar contraejemplo si es necesario"
          ],
          "no_respuesta": [
            "Reformular pregunta de manera m√°s simple",
            "Proporcionar ejemplo adicional",
            "Hacer pregunta m√°s espec√≠fica",
            "Dar pista que active conocimiento previo"
          ]
        },
        "validacion_comprension": [
          "Pedir al estudiante que explique con sus propias palabras",
          "Solicitar ejemplos diferentes a los presentados",
          "Hacer preguntas de aplicaci√≥n en contexto ligeramente diferente",
          "Verificar que puede distinguir ejemplos de contra-ejemplos"
        ],
        "errores_criticos_evitar": [
          "Dar definici√≥n directa antes que el estudiante deduzca",
          "Aceptar respuestas vagas o incompletas",
          "Avanzar sin confirmar comprensi√≥n s√≥lida",
          "Corregir sin explicar por qu√© la respuesta es incorrecta"
        ]
      },
      "momento_aplicacion": {
        "objetivo_pedagogico": "Transferir conocimientos a situaciones pr√°cticas mediante pr√°ctica guiada",
        "tecnicas_teach_like_champion": [
          "I Do, We Do, You Do (Modelamiento gradual)",
          "Check for Understanding (Verificaci√≥n constante)",
          "Circulate (Monitorear progreso individual)",
          "Show Me (Evidencia visible de comprensi√≥n)"
        ],
        "instrucciones_ia": [
          "Aplica 'I Do, We Do, You Do': modela, practica guiada, pr√°ctica independiente",
          "Usa 'Check for Understanding': verifica comprensi√≥n antes de aumentar complejidad",
          "Implementa 'Show Me': solicita evidencia espec√≠fica de aplicaci√≥n correcta",
          "Comienza con casos simples y aumenta complejidad gradualmente",
          "Solicita verbalizaci√≥n del proceso de pensamiento en cada paso",
          "Conecta constantemente aplicaci√≥n pr√°ctica con conceptos te√≥ricos aprendidos"
        ],
        "secuencia_aplicacion": [
          "Modelamiento: Demostrar aplicaci√≥n paso a paso",
          "Pr√°ctica guiada: Estudiante aplica con soporte",
          "Pr√°ctica independiente: Estudiante aplica solo",
          "Transferencia: Aplicar en contexto ligeramente diferente"
        ],
        "estrategias_scaffolding": [
          "Proporcionar estructura inicial y retirarla gradualmente",
          "Dar pistas espec√≠ficas cuando el estudiante se atasca",
          "Permitir errores como oportunidades de aprendizaje",
          "Celebrar aproximaciones correctas antes de perfeccionar"
        ],
        "preguntas_guia": [
          "¬øQu√© har√≠as primero en esta situaci√≥n?",
          "¬øQu√© concepto aplicar√≠as aqu√≠?",
          "¬øPor qu√© elegiste esa opci√≥n?",
          "¬øQu√© pasar√≠a si...?",
          "¬øC√≥mo sabes que tu respuesta es correcta?"
        ],
        "validacion_aplicacion": [
          "Estudiante puede aplicar proceso sin ayuda",
          "Explica su razonamiento claramente",
          "Transfiere habilidad a contextos similares",
          "Identifica errores y los corrige independientemente"
        ]
      },
      "momento_discusion": {
        "objetivo_pedagogico": "Profundizar comprensi√≥n mediante an√°lisis cr√≠tico y metacognici√≥n",
        "tecnicas_teach_like_champion": [
          "Turn and Talk (Reflexi√≥n antes de compartir)",
          "Think Ratio (Maximizar tiempo de pensamiento del estudiante)",
          "Wait Time (Tiempo suficiente para procesar)",
          "Pepper (Discusi√≥n din√°mica y participativa)"
        ],
        "instrucciones_ia": [
          "Aplica 'Think Ratio': el estudiante debe hablar/pensar m√°s que t√∫",
          "Usa 'Wait Time': da tiempo suficiente para que procese preguntas complejas",
          "Implementa preguntas abiertas que no tengan una sola respuesta correcta",
          "Facilita an√°lisis cr√≠tico de decisiones tomadas durante aplicaci√≥n",
          "Promueve metacognici√≥n: que el estudiante reflexione sobre su propio proceso de aprendizaje",
          "Explora m√∫ltiples perspectivas y enfoques del mismo problema"
        ],
        "tipos_preguntas": [
          "An√°lisis: '¬øPor qu√© crees que...?'",
          "S√≠ntesis: '¬øC√≥mo conectar√≠as...?'",
          "Evaluaci√≥n: '¬øCu√°l ser√≠a la mejor opci√≥n y por qu√©?'",
          "Metacognici√≥n: '¬øC√≥mo llegaste a esa conclusi√≥n?'",
          "Perspectiva: '¬øQu√© otros enfoques podr√≠an funcionar?'"
        ],
        "facilitacion_dialogica": [
          "Hacer preguntas que generen m√°s preguntas",
          "Desafiar suposiciones de manera constructiva",
          "Ayudar a examinar implicaciones de diferentes decisiones",
          "Promover argumentaci√≥n fundamentada en evidencia"
        ],
        "manejo_perspectivas": [
          "Validar m√∫ltiples enfoques cuando sean correctos",
          "Ayudar a evaluar pros y contras de cada opci√≥n",
          "Facilitar s√≠ntesis de ideas aparentemente contradictorias",
          "Mantener enfoque en aprendizaje, no en 'ganar' la discusi√≥n"
        ],
        "validacion_momento": [
          "El estudiante reflexiona profundamente sobre su aprendizaje",
          "Puede articular su proceso de pensamiento",
          "Considera m√∫ltiples perspectivas de un problema",
          "Demuestra pensamiento cr√≠tico y anal√≠tico"
        ]
      },
      "momento_retroalimentacion": {
        "objetivo_pedagogico": "Consolidar aprendizajes y orientar mejora continua mediante feedback espec√≠fico",
        "tecnicas_teach_like_champion": [
          "Precise Praise (Elogio espec√≠fico y merecido)",
          "Challenge (Desaf√≠o apropiado para crecimiento)",
          "Culture of Error (Normalizar error como parte del aprendizaje)",
          "Normalize Error (Hacer que el error sea esperado y valioso)"
        ],
        "instrucciones_ia": [
          "Aplica 'Precise Praise': elogia aspectos espec√≠ficos del desempe√±o, no generalidades",
          "Usa 'Challenge': establece expectativas altas y espec√≠ficas para mejora",
          "Implementa 'Culture of Error': trata errores como informaci√≥n valiosa sobre el aprendizaje",
          "Aplica modelo: Fortaleza espec√≠fica ‚Üí √Årea de crecimiento ‚Üí Pasos concretos",
          "Balancea reconocimiento genuino con orientaci√≥n para mejora",
          "Facilita autorreflexi√≥n antes de proporcionar feedback externo"
        ],
        "estructura_feedback": {
          "reconocimiento_especifico": [
            "Identifica logro espec√≠fico y observable",
            "Explica por qu√© ese logro es significativo",
            "Conecta logro con esfuerzo o estrategia utilizada"
          ],
          "area_crecimiento": [
            "Se√±ala aspecto espec√≠fico para mejorar",
            "Explica por qu√© esa mejora es importante",
            "Proporciona criterio claro para el √©xito"
          ],
          "pasos_siguientes": [
            "Da acci√≥n espec√≠fica y realizable",
            "Establece expectativa clara de mejora",
            "Conecta con aplicaci√≥n futura"
          ]
        },
        "preguntas_autoreflexion": [
          "¬øQu√© fue lo que m√°s te desafi√≥ en esta sesi√≥n?",
          "¬øCu√°l fue tu mayor logro hoy?",
          "¬øQu√© har√≠as diferente la pr√≥xima vez?",
          "¬øC√≥mo aplicar√≠as esto en tu contexto real?",
          "¬øQu√© necesitas practicar m√°s?"
        ],
        "proyeccion_futura": [
          "Conectar aprendizajes con situaciones reales del estudiante",
          "Sugerir pr√≥ximos pasos espec√≠ficos para profundizar",
          "Generar compromiso personal con la pr√°ctica continua",
          "Inspirar confianza en capacidades desarrolladas"
        ],
        "errores_evitar_feedback": [
          "Elogios vagos como 'buen trabajo' sin especificidad",
          "Criticar a la persona en lugar del desempe√±o",
          "Dar demasiada informaci√≥n correctiva a la vez",
          "Terminar solo con √°reas de mejora sin reconocimiento"
        ]
      }
    },
    "principios_transversales": {
      "adaptacion_ritmo": [
        "Acelerar cuando el estudiante domina r√°pidamente",
        "Desacelerar cuando hay confusi√≥n o resistencia",
        "Proporcionar refuerzo adicional cuando sea necesario",
        "Ajustar complejidad seg√∫n respuestas del estudiante"
      ],
      "mantenimiento_engagement": [
        "Variar tipos de preguntas para mantener inter√©s",
        "Usar ejemplos relevantes al contexto del estudiante",
        "Celebrar progreso incremental regularmente",
        "Mantener expectativas altas pero alcanzables"
      ],
      "construccion_confianza": [
        "Estructurar experiencias de √©xito frecuentes",
        "Reconocer esfuerzo y estrategias efectivas",
        "Normalizar la dificultad como parte natural del aprendizaje",
        "Proporcionar soporte suficiente para prevenir frustraci√≥n"
      ]
    }
  }
} 
```
=== EOF: src\data\pedagogia-universal.json

===  src\data\courses-database.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "Seguridad y Salud Ocupacional",
      "description": "Curso completo de SSO con m√∫ltiples sesiones de capacitaci√≥n",
      "specialist_role": "Especialista en Seguridad y Salud Ocupacional",
      "vector_store_id": "vs_68823f69d9f08191889fed8f8edd891c",
      "sessions": [
        {
          "id": "sesion01",
          "name": "IPERC - Identificaci√≥n de Peligros, Evaluaci√≥n de Riesgos y Controles",
          "session_file": "SSO001_sesion01.json",
          "learning_objective": "El estudiante identifica peligros en una situaci√≥n laboral, eval√∫a los riesgos asociados y propone controles adecuados para prevenir accidentes",
          "key_points": [
            "Comprende qu√© es un peligro y c√≥mo se reconoce en el ambiente laboral",
            "Diferencia entre peligro y riesgo en el contexto de SSO",
            "Relaciona la severidad y probabilidad para evaluar un riesgo",
            "Propone controles adecuados seg√∫n el tipo de peligro identificado"
          ],
          "theme_keywords": [
            "iperc",
            "identificaci√≥n",
            "peligros",
            "evaluaci√≥n",
            "riesgos",
            "control",
            "seguridad",
            "prevenci√≥n",
            "accidente"
          ]
        },
        {
          "id": "sesion02", 
          "name": "Sesi√≥n 02 de SSO",
          "session_file": "SSO001_sesion02.json",
          "learning_objective": "El estudiante aplica procedimientos de seguridad en situaciones espec√≠ficas del trabajo",
          "key_points": [
            "Identifica procedimientos de seguridad relevantes",
            "Aplica medidas de protecci√≥n personal",
            "Reconoce se√±ales y se√±alizaci√≥n de seguridad",
            "Implementa protocolos de emergencia"
          ],
          "theme_keywords": [
            "procedimientos",
            "seguridad",
            "protecci√≥n",
            "personal",
            "se√±ales",
            "se√±alizaci√≥n",
            "protocolos",
            "emergencia",
            "medidas"
          ]
        },
        {
          "id": "sesion03",
          "name": "Prevenci√≥n de Incendios en el Trabajo", 
          "session_file": "SSO001_sesion03.json",
          "learning_objective": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
          "key_points": [
            "Reconoce las causas principales de incendios en el trabajo",
            "Identifica medidas preventivas para evitar incendios",
            "Aplica procedimientos de evacuaci√≥n en caso de emergencia",
            "Utiliza correctamente equipos contra incendios"
          ],
          "theme_keywords": [
            "incendio",
            "fuego",
            "extintor",
            "prevenci√≥n",
            "combusti√≥n",
            "tri√°ngulo del fuego",
            "evacuaci√≥n",
            "emergencia",
            "equipos"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    },
    {
      "id": "PER001",
      "name": "Operaci√≥n de Equipos de Perforaci√≥n",
      "description": "Curso completo de perforaci√≥n con m√∫ltiples sesiones de capacitaci√≥n",
      "specialist_role": "Especialista en operaci√≥n de equipos de perforaci√≥n",
      "vector_store_id": "vs_perforacion_equipos_2025",
      "sessions": [
        {
          "id": "sesion01",
          "name": "Fundamentos de Perforaci√≥n",
          "learning_objective": "El estudiante identifica los componentes principales de un equipo de perforaci√≥n y explica su funci√≥n en el proceso",
          "key_points": [
            "Comprende qu√© es un equipo de perforaci√≥n y sus aplicaciones",
            "Identifica los componentes principales del equipo de perforaci√≥n",
            "Explica la funci√≥n de cada componente en el proceso",
            "Relaciona el funcionamiento de los componentes para lograr la perforaci√≥n efectiva"
          ],
          "theme_keywords": [
            "perforaci√≥n",
            "equipo",
            "componentes",
            "fundamentos",
            "mecanismo",
            "funcionamiento",
            "aplicaciones",
            "proceso"
          ]
        },
        {
          "id": "sesion02",
          "name": "T√©cnicas de Perforaci√≥n",
          "learning_objective": "El estudiante aplica t√©cnicas de perforaci√≥n seg√∫n el tipo de terreno y objetivo",
          "key_points": [
            "Reconoce diferentes tipos de t√©cnicas de perforaci√≥n",
            "Selecciona la t√©cnica apropiada seg√∫n el terreno",
            "Aplica procedimientos de seguridad en perforaci√≥n",
            "Eval√∫a la eficiencia de la t√©cnica utilizada"
          ],
          "theme_keywords": [
            "t√©cnicas",
            "perforaci√≥n",
            "terreno",
            "m√©todos",
            "selecci√≥n",
            "eficiencia",
            "procedimientos",
            "seguridad"
          ]
        },
        {
          "id": "sesion03",
          "name": "Mantenimiento de Equipos de Perforaci√≥n",
          "learning_objective": "El estudiante realiza mantenimiento preventivo y correctivo en equipos de perforaci√≥n",
          "key_points": [
            "Identifica componentes que requieren mantenimiento regular",
            "Aplica procedimientos de mantenimiento preventivo",
            "Diagnostica problemas comunes en equipos de perforaci√≥n",
            "Ejecuta mantenimiento correctivo b√°sico"
          ],
          "theme_keywords": [
            "mantenimiento",
            "preventivo",
            "correctivo",
            "equipos",
            "perforaci√≥n",
            "diagn√≥stico",
            "componentes",
            "procedimientos",
            "problemas"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    }
  ]
} 
```
=== EOF: src\data\courses-database.json

===  src\components\ChatInterface.tsx
```tsx
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ChatMessage } from '@/lib/openai';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const chatMessages: ChatMessage[] = [
        ...messages.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        { role: 'user', content: input },
      ];

      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: chatMessages,
          model: 'gpt-3.5-turbo',
        }),
      });

      if (!response.ok) {
        throw new Error('Error en la respuesta del servidor');
      }

      const data = await response.json();
      
      const assistantMessage: Message = {
        role: 'assistant',
        content: data.content,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      const errorMessage: Message = {
        role: 'assistant',
        content: 'Lo siento, hubo un error al procesar tu mensaje.',
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        {/* Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 p-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Chat con IA
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Pregunta lo que quieras a la inteligencia artificial
          </p>
        </div>

        {/* Messages */}
        <div className="h-96 overflow-y-auto p-4 space-y-4">
          {messages.length === 0 && (
            <div className="text-center text-gray-500 dark:text-gray-400">
              <p>¬°Hola! Soy tu asistente de IA. ¬øEn qu√© puedo ayudarte?</p>
            </div>
          )}
          
          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              <div
                className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white'
                }`}
              >
                <p className="text-sm">{message.content}</p>
                <p className="text-xs opacity-70 mt-1">
                  {message.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))}
          
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-gray-100 dark:bg-gray-700 px-4 py-2 rounded-lg">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  Pensando...
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <div className="border-t border-gray-200 dark:border-gray-700 p-4">
          <div className="flex space-x-2">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Escribe tu mensaje..."
              className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white resize-none"
              rows={2}
              disabled={isLoading}
            />
            <Button
              onClick={sendMessage}
              disabled={!input.trim() || isLoading}
              className="px-4 py-2"
            >
              {isLoading ? 'Enviando...' : 'Enviar'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
} 
```
=== EOF: src\components\ChatInterface.tsx

===  src\app\page.tsx
```tsx
import { Button } from "@/components/ui/Button";
import { formatDate } from "@/lib/utils";
import { ChatInterface } from "@/components/ChatInterface";

export default function Home() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800">
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <h1 className="text-4xl md:text-6xl font-bold text-gray-900 dark:text-white mb-4">
            DocenteIA
          </h1>
          <p className="text-xl text-gray-600 dark:text-gray-300 mb-8">
            Sistema estable con Next.js, TypeScript e IA
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button size="lg" className="bg-blue-600 hover:bg-blue-700">
              Comenzar
            </Button>
            <Button variant="outline" size="lg">
              Documentaci√≥n
            </Button>
          </div>
        </div>

        <div className="grid md:grid-cols-3 gap-8 mt-16 mb-16">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              TypeScript Estricto
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Configuraci√≥n robusta con verificaciones estrictas de tipos para mayor estabilidad.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Next.js 14
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              La versi√≥n m√°s estable con App Router y optimizaciones avanzadas.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              OpenAI Integrado
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Chat inteligente con GPT-3.5-turbo para asistencia autom√°tica.
            </p>
          </div>
        </div>

        {/* Chat Interface */}
        <div className="mt-16">
          <ChatInterface />
        </div>

        <div className="mt-12 text-center">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            √öltima actualizaci√≥n: {formatDate(new Date())}
          </p>
        </div>
      </div>
    </div>
  );
}
```
=== EOF: src\app\page.tsx

===  src\app\layout.tsx
```tsx
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "DocenteIA - Sistema Estable",
  description: "Sistema estable con Next.js y TypeScript",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```
=== EOF: src\app\layout.tsx

===  src\app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 0 0% 3.9%;
  --card: 0 0% 100%;
  --card-foreground: 0 0% 3.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 0 0% 3.9%;
  --primary: 0 0% 9%;
  --primary-foreground: 0 0% 98%;
  --secondary: 0 0% 96.1%;
  --secondary-foreground: 0 0% 9%;
  --muted: 0 0% 96.1%;
  --muted-foreground: 0 0% 45.1%;
  --accent: 0 0% 96.1%;
  --accent-foreground: 0 0% 9%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 89.8%;
  --input: 0 0% 89.8%;
  --ring: 0 0% 3.9%;
  --radius: 0.5rem;
}

.dark {
  --background: 0 0% 3.9%;
  --foreground: 0 0% 98%;
  --card: 0 0% 3.9%;
  --card-foreground: 0 0% 98%;
  --popover: 0 0% 3.9%;
  --popover-foreground: 0 0% 98%;
  --primary: 0 0% 98%;
  --primary-foreground: 0 0% 9%;
  --secondary: 0 0% 14.9%;
  --secondary-foreground: 0 0% 98%;
  --muted: 0 0% 14.9%;
  --muted-foreground: 0 0% 63.9%;
  --accent: 0 0% 14.9%;
  --accent-foreground: 0 0% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 14.9%;
  --input: 0 0% 14.9%;
  --ring: 0 0% 83.1%;
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
```
=== EOF: src\app\globals.css

===  src\data\sessions\SSO001_sesion03.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion03",
  "nombre": "Prevenci√≥n de Incendios en el Trabajo",
  "objetivo": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
  "momentos": [
    {
      "momento": "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesi√≥n y los puntos clave a desarrollar",
      "preguntas": [
        "¬øQu√© sabes sobre incendios en el trabajo?",
        "¬øHas presenciado alguna situaci√≥n de riesgo de incendio?",
        "¬øQu√© esperas aprender en esta sesi√≥n?"
      ]
    },
    {
      "momento": "Conexi√≥n",
      "instrucciones_docenteia": "Narrar la historia de la f√°brica textil para conectar con experiencias previas",
      "historia": "En una f√°brica textil, un trabajador est√° usando una m√°quina de soldadura cerca de telas almacenadas. De repente, una chispa salta hacia las telas y comienza un peque√±o fuego. ¬øQu√© crees que pas√≥? ¬øPor qu√© se inici√≥ el incendio? ¬øTe ha pasado algo parecido o has escuchado de un caso similar?",
      "preguntas": [
        "¬øQu√© elementos identificas en esta situaci√≥n?",
        "¬øQu√© podr√≠a haber prevenido este incidente?",
        "¬øC√≥mo se relaciona esto con tu experiencia laboral?",
        "¬øHas presenciado alguna situaci√≥n similar?"
      ]
    },
    {
      "momento": "Adquisici√≥n",
      "instrucciones_docenteia": "Explicar el Tri√°ngulo del Fuego y los tipos de extintores",
      "contenido_tecnico": [
        "El Tri√°ngulo del Fuego est√° compuesto por tres elementos esenciales",
        "COMBUSTIBLE: cualquier material que puede arder (madera, papel, telas, gasolina, etc.)",
        "OX√çGENO: presente en el aire que respiramos",
        "CALOR: la energ√≠a que inicia la reacci√≥n de combusti√≥n",
        "Si eliminamos cualquiera de estos tres elementos, el fuego NO puede existir",
        "Extintor de agua: para combustibles s√≥lidos (clase A)",
        "Extintor de CO‚ÇÇ: para equipos el√©ctricos (clase C)",
        "Extintor de polvo: para m√∫ltiples tipos de fuego (clase ABC)"
      ],
      "preguntas": [
        "¬øQu√© crees que necesita el fuego para existir?",
        "¬øHas o√≠do hablar del Tri√°ngulo del Fuego?",
        "¬øPuedes identificar los tres elementos b√°sicos del fuego?",
        "¬øQu√© tipos de extintores conoces y para qu√© se usan?",
        "¬øPor qu√© es importante eliminar al menos uno de los elementos del Tri√°ngulo del Fuego?",
        "¬øC√≥mo se relaciona esto con la prevenci√≥n de incendios?"
      ]
    },
    {
      "momento": "Aplicaci√≥n",
      "instrucciones_docenteia": "Presentar el caso de la carpinter√≠a para aplicar los conocimientos",
      "caso": "En una carpinter√≠a donde trabajan 10 personas, hay madera, barnices, equipos el√©ctricos, y una estufa para calentar el ambiente. Un d√≠a, un trabajador est√° barnizando una pieza cerca de la estufa cuando se derrama barniz sobre la estufa caliente y se inicia un incendio. Usando el Tri√°ngulo del Fuego, analicemos este caso: ¬øCu√°les son los tres elementos presentes? ¬øQu√© tipo de extintor ser√≠a el m√°s adecuado? ¬øQu√© medidas preventivas se podr√≠an haber implementado?",
      "preguntas": [
        "En este caso de la carpinter√≠a, ¬øcu√°les son los tres elementos del Tri√°ngulo del Fuego?",
        "¬øQu√© tipo de extintor ser√≠a el m√°s adecuado para este incendio y por qu√©?",
        "¬øQu√© medidas preventivas se podr√≠an haber implementado para evitar este incidente?",
        "¬øC√≥mo se podr√≠a haber roto el Tri√°ngulo del Fuego antes de que ocurriera el incendio?",
        "Si t√∫ fueras el responsable de seguridad, ¬øqu√© protocolos establecer√≠as?"
      ]
    },
    {
      "momento": "Discusi√≥n",
      "instrucciones_docenteia": "Facilitar la comparaci√≥n de diferentes enfoques de prevenci√≥n",
      "preguntas": [
        "¬øQu√© estrategia prefieres y por qu√©?",
        "¬øHay situaciones donde una estrategia es mejor que otra?",
        "¬øQu√© limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "Reflexi√≥n",
      "instrucciones_docenteia": "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
      "preguntas": [
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo cambiar√° tu forma de trabajar despu√©s de esta sesi√≥n?",
        "¬øQu√© m√°s te gustar√≠a aprender sobre prevenci√≥n de incendios?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion03.json

===  src\data\sessions\SSO001_sesion02.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion02",
  "nombre": "Procedimientos de Seguridad en el Trabajo",
  "objetivo": "El estudiante aplica procedimientos de seguridad en situaciones espec√≠ficas del trabajo",
  "momentos": [
    {
      "momento": "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesi√≥n sobre procedimientos de seguridad",
      "preguntas": [
        "¬øQu√© procedimientos de seguridad conoces?",
        "¬øHas seguido alg√∫n protocolo de seguridad en tu trabajo?",
        "¬øQu√© esperas aprender sobre procedimientos de seguridad?"
      ]
    },
    {
      "momento": "Conexi√≥n",
      "instrucciones_docenteia": "Narrar una situaci√≥n de trabajo para conectar con experiencias previas",
      "historia": "En una obra de construcci√≥n, un trabajador debe realizar trabajos en altura. ¬øQu√© procedimientos de seguridad deber√≠a seguir? ¬øQu√© equipos de protecci√≥n necesitar√≠a?",
      "preguntas": [
        "¬øQu√© elementos de seguridad identificas en esta situaci√≥n?",
        "¬øQu√© podr√≠a salir mal si no se siguen los procedimientos?",
        "¬øHas presenciado alguna situaci√≥n similar?"
      ]
    },
    {
      "momento": "Adquisici√≥n",
      "instrucciones_docenteia": "Explicar los procedimientos de seguridad b√°sicos",
      "contenido_tecnico": [
        "PROCEDIMIENTO: secuencia de pasos para realizar una tarea de forma segura",
        "EQUIPOS DE PROTECCI√ìN PERSONAL (EPP): elementos que protegen al trabajador",
        "SE√ëALIZACI√ìN: indicadores visuales que advierten sobre peligros",
        "PROTOCOLOS DE EMERGENCIA: pasos a seguir en caso de accidente"
      ],
      "preguntas": [
        "¬øQu√© elementos debe tener un procedimiento de seguridad?",
        "¬øC√≥mo se selecciona el EPP adecuado?",
        "¬øQu√© tipos de se√±alizaci√≥n conoces?"
      ]
    },
    {
      "momento": "Aplicaci√≥n",
      "instrucciones_docenteia": "Presentar un caso pr√°ctico para aplicar procedimientos",
      "caso": "En un laboratorio qu√≠mico, un trabajador debe manipular sustancias peligrosas. ¬øQu√© procedimientos deber√≠a seguir?",
      "preguntas": [
        "¬øQu√© procedimientos espec√≠ficos aplicar√≠as?",
        "¬øQu√© EPP necesitar√≠a el trabajador?",
        "¬øQu√© medidas de emergencia deber√≠an estar disponibles?"
      ]
    },
    {
      "momento": "Discusi√≥n",
      "instrucciones_docenteia": "Facilitar la comparaci√≥n de diferentes procedimientos",
      "preguntas": [
        "¬øQu√© procedimiento prefieres y por qu√©?",
        "¬øHay situaciones donde un procedimiento es mejor que otro?",
        "¬øQu√© limitaciones tienen los procedimientos?"
      ]
    },
    {
      "momento": "Reflexi√≥n",
      "instrucciones_docenteia": "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
      "preguntas": [
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo aplicar√°s estos procedimientos en tu trabajo?",
        "¬øQu√© m√°s te gustar√≠a aprender sobre seguridad?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion02.json

===  src\data\sessions\SSO001_sesion01.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion01",
  "nombre": "IPERC - Identificaci√≥n de Peligros, Evaluaci√≥n de Riesgos y Controles",
  "objetivo": "El estudiante identifica peligros en una situaci√≥n laboral, eval√∫a los riesgos asociados y propone controles adecuados para prevenir accidentes",
  "momentos": [
    {
      "momento": "Saludo (exposici√≥n del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesi√≥n IPERC y los puntos clave a desarrollar",
      "preguntas": [
        "¬øQu√© sabes sobre identificaci√≥n de peligros en el trabajo?",
        "¬øHas identificado alg√∫n peligro en tu entorno laboral?",
        "¬øQu√© esperas aprender sobre evaluaci√≥n de riesgos?"
      ]
    },
    {
      "momento": "Conexi√≥n",
      "instrucciones_docenteia": "Narrar una situaci√≥n laboral para conectar con experiencias previas",
      "historia": "En una f√°brica de producci√≥n, un trabajador est√° operando una m√°quina sin las protecciones adecuadas. ¬øQu√© peligros identificas en esta situaci√≥n? ¬øQu√© riesgos podr√≠an existir?",
      "preguntas": [
        "¬øQu√© elementos de riesgo identificas en esta situaci√≥n?",
        "¬øQu√© podr√≠a salir mal en este escenario?",
        "¬øC√≥mo se relaciona esto con tu experiencia laboral?"
      ]
    },
    {
      "momento": "Adquisici√≥n",
      "instrucciones_docenteia": "Explicar los conceptos de IPERC",
      "contenido_tecnico": [
        "IPERC significa: Identificaci√≥n de Peligros, Evaluaci√≥n de Riesgos y Controles",
        "PELIGRO: fuente, situaci√≥n o acto con potencial de causar da√±o",
        "RIESGO: combinaci√≥n de la probabilidad de ocurrencia y la severidad del da√±o",
        "CONTROL: medida implementada para eliminar o reducir el riesgo"
      ],
      "preguntas": [
        "¬øQu√© diferencia hay entre peligro y riesgo?",
        "¬øC√≥mo se eval√∫a la probabilidad de un riesgo?",
        "¬øQu√© tipos de controles conoces?"
      ]
    },
    {
      "momento": "Aplicaci√≥n",
      "instrucciones_docenteia": "Presentar un caso pr√°ctico para aplicar IPERC",
      "caso": "En un taller de mantenimiento, un trabajador debe cambiar una l√°mpara en altura. ¬øC√≥mo aplicar√≠as el m√©todo IPERC en esta situaci√≥n?",
      "preguntas": [
        "¬øQu√© peligros identificas en este caso?",
        "¬øC√≥mo evaluar√≠as los riesgos?",
        "¬øQu√© controles propondr√≠as?"
      ]
    },
    {
      "momento": "Discusi√≥n",
      "instrucciones_docenteia": "Facilitar la comparaci√≥n de diferentes enfoques de control",
      "preguntas": [
        "¬øQu√© estrategia de control prefieres y por qu√©?",
        "¬øHay situaciones donde una estrategia es mejor que otra?",
        "¬øQu√© limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "Reflexi√≥n",
      "instrucciones_docenteia": "Guiar la reflexi√≥n sobre lo aprendido y su aplicaci√≥n pr√°ctica",
      "preguntas": [
        "¬øQu√© concepto te qued√≥ m√°s claro?",
        "¬øC√≥mo aplicar√°s IPERC en tu trabajo?",
        "¬øQu√© m√°s te gustar√≠a aprender sobre evaluaci√≥n de riesgos?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion01.json

===  src\components\ui\Button.tsx
```tsx
import React from "react";
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants }; 
```
=== EOF: src\components\ui\Button.tsx

===  src\app\api\chat\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { sendChatMessage, ChatMessage } from '@/lib/openai';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { messages, model = 'gpt-3.5-turbo' } = body;

    // Validar que se proporcionen mensajes
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Se requieren mensajes v√°lidos' },
        { status: 400 }
      );
    }

    // Validar que cada mensaje tenga la estructura correcta
    const validMessages: ChatMessage[] = messages.map((msg: any) => ({
      role: msg.role,
      content: msg.content,
    }));

    // Enviar mensaje a OpenAI
    const response = await sendChatMessage(validMessages, model);

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error en API chat:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\chat\route.ts

