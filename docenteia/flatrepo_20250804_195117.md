---
repository:
  name: docenteia
  owner: unknown
  url: ""
generated:
  timestamp: 2025-08-05T00:51:18.783Z
  tool: FlatRepo
statistics:
  totalFiles: 35
  totalLines: 4831
  languages:
    json: 8
    markdown: 4
    javascript: 3
    typescript: 13
    tsx: 4
    css: 1
  fileTypes:
    .json: 8
    .md: 4
    .js: 3
    .mjs: 1
    .example: 1
    .ts: 13
    .tsx: 4
    .css: 1
---

===  tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```
=== EOF: tsconfig.json

===  TECHNICAL_DOCS.md
```markdown
# Documentación Técnica - DocenteIA

## Arquitectura del Sistema

### Stack Tecnológico
- **Framework**: Next.js 15 con App Router
- **Lenguaje**: TypeScript 5.x
- **Estilos**: Tailwind CSS 4.x
- **Linting**: ESLint con reglas estrictas
- **Build**: SWC (Rust-based compiler)

### Estructura de Carpetas
```
src/
├── app/                    # App Router (Next.js 15)
│   ├── layout.tsx         # Layout principal
│   ├── page.tsx           # Página principal
│   └── globals.css        # Estilos globales
├── components/             # Componentes reutilizables
│   └── ui/                # Componentes de UI base
├── lib/                   # Utilidades y helpers
│   ├── utils.ts           # Funciones utilitarias
│   ├── constants.ts       # Constantes del sistema
│   └── config.ts          # Configuración centralizada
└── types/                 # Tipos TypeScript
    └── global.d.ts        # Tipos globales
```

## Configuraciones Clave

### TypeScript (tsconfig.json)
- **Target**: ES2022 para mejor rendimiento
- **Strict Mode**: Habilitado completamente
- **No Unused**: Variables y parámetros no utilizados
- **No Implicit Returns**: Requiere returns explícitos
- **Force Consistent Casing**: Consistencia en nombres de archivos

### ESLint (eslint.config.mjs)
- **Next.js Core Web Vitals**: Optimización de rendimiento
- **TypeScript Rules**: Verificaciones estrictas
- **No Unused Variables**: Error para variables no utilizadas
- **No Explicit Any**: Advertencia para tipos `any`
- **Prefer Const**: Forzar uso de `const`

### Next.js (next.config.ts)
- **React Strict Mode**: Detección de efectos secundarios
- **Optimize Package Imports**: Optimización de imports
- **Modern Image Formats**: WebP y AVIF
- **Console Removal**: Eliminar console.log en producción

## Componentes del Sistema

### Button Component
```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}
```

**Características**:
- Variantes múltiples con `class-variance-authority`
- Tipos estrictos de TypeScript
- Accesibilidad integrada
- Reutilizable y extensible

### Utilidades (lib/utils.ts)
```typescript
// Combinación de clases CSS
cn("class1", "class2")

// Formateo de fechas
formatDate(new Date())

// Generación de IDs únicos
generateId()
```

## Optimizaciones de Rendimiento

### Build Optimizations
- **SWC Compiler**: Compilación rápida en Rust
- **Tree Shaking**: Eliminación de código no utilizado
- **Code Splitting**: División automática de bundles
- **Image Optimization**: Formatos modernos (WebP, AVIF)

### Runtime Optimizations
- **React Strict Mode**: Detección de problemas
- **Turbopack**: Bundler rápido en desarrollo
- **Incremental Static Regeneration**: Páginas estáticas dinámicas

## Seguridad

### TypeScript Strict Mode
- Verificación de tipos en tiempo de compilación
- Prevención de errores de runtime
- Mejor autocompletado y refactoring

### ESLint Security Rules
- Detección de código vulnerable
- Prevención de XSS
- Buenas prácticas de seguridad

## Escalabilidad

### Estructura Modular
- Componentes reutilizables
- Utilidades centralizadas
- Configuración tipada
- Separación de responsabilidades

### Configuración Flexible
- Variables de entorno tipadas
- Configuración centralizada
- Constantes organizadas
- Tipos exportables

## Mantenimiento

### Código Limpio
- ESLint con reglas estrictas
- TypeScript con verificaciones exhaustivas
- Documentación integrada
- Convenciones consistentes

### Testing Ready
- Estructura preparada para tests
- Componentes aislados
- Utilidades testables
- Configuración de testing

## Despliegue

### Optimizaciones de Producción
- Minificación automática
- Compresión de assets
- CDN ready
- PWA compatible

### Monitoreo
- Error boundaries preparados
- Analytics integrado
- Performance monitoring
- Logging estructurado 
```
=== EOF: TECHNICAL_DOCS.md

===  tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
} 
```
=== EOF: tailwind.config.js

===  README.md
```markdown
# DocenteIA - Sistema Estable con Next.js y TypeScript

Un sistema robusto y estable construido con Next.js 14, TypeScript estricto y Tailwind CSS.

## 🎯 Propósito

DocenteIA es un asistente de enseñanza inteligente que utiliza OpenAI para crear experiencias de aprendizaje personalizadas y conversacionales. El sistema permite a los docentes crear sesiones interactivas con contenido específico y guías de enseñanza estructuradas.

## 🚀 Características

- **Next.js 14**: Versión estable con App Router
- **TypeScript Estricto**: Configuración robusta con verificaciones exhaustivas
- **Tailwind CSS 3**: Estilos modernos y optimizados
- **OpenAI Integration**: Chat conversacional inteligente
- **Teaching Guide System**: Estructura de momentos pedagógicos
- **Course Database**: Gestión de cursos y sesiones
- **ESLint Configurado**: Reglas estrictas para código limpio
- **Componentes Reutilizables**: Sistema de componentes con TypeScript
- **Utilidades Optimizadas**: Funciones helper para desarrollo eficiente
- **OpenAI Integrado**: Chat inteligente con GPT-3.5-turbo
- **API Routes Seguras**: Endpoints protegidos para comunicación con IA

## 📦 Instalación

```bash
# Clonar el repositorio
git clone <tu-repositorio>
cd docenteia

# Instalar dependencias
npm install

# Configurar variables de entorno
cp env.example .env.local
# Editar .env.local y agregar tu OPENAI_API_KEY

# Ejecutar en desarrollo
npm run dev
```

## 🛠️ Scripts Disponibles

```bash
npm run dev          # Servidor de desarrollo
npm run build        # Construcción para producción
npm run start        # Servidor de producción
npm run lint         # Verificación de código con ESLint
npm run chat         # Chat terminal con IA y vector store
```

## 🏗️ Estructura del Proyecto

```
src/
├── app/                 # App Router de Next.js
│   ├── layout.tsx      # Layout principal
│   ├── page.tsx        # Página principal
│   └── globals.css     # Estilos globales
├── components/          # Componentes reutilizables
│   └── ui/             # Componentes de UI
│       └── Button.tsx  # Componente Button
├── lib/                # Utilidades y helpers
│   ├── utils.ts        # Funciones utilitarias
│   ├── openai.ts       # Configuración de OpenAI
│   ├── vector-store.ts # Configuración de vector store
│   ├── constants.ts    # Constantes del sistema
│   └── config.ts       # Configuración centralizada
├── components/         # Componentes reutilizables
│   ├── ui/            # Componentes de UI
│   └── ChatInterface.tsx # Chat con IA
└── types/              # Tipos TypeScript
    └── global.d.ts     # Tipos globales
```

## ⚙️ Configuraciones

### TypeScript
- Target: ES2022
- Strict mode habilitado
- Verificaciones estrictas de tipos
- No unused locals/parameters

### ESLint
- Reglas estrictas para TypeScript
- Prevención de código no utilizado
- Advertencias para `any` types

### Next.js
- React Strict Mode
- SWC Minify
- Optimización de imports
- Soporte para imágenes modernas

## 🎨 Componentes

### Button Component
Componente reutilizable con múltiples variantes:

```tsx
import { Button } from "@/components/ui/Button";

<Button variant="default" size="lg">
  Comenzar
</Button>
```

### ChatInterface Component
Chat inteligente con OpenAI:

```tsx
import { ChatInterface } from "@/components/ChatInterface";

<ChatInterface />
```

## 💻 Chat Terminal

```bash
npm run chat
```

**Comandos disponibles:**
- `/help` - Mostrar ayuda
- `/history` - Mostrar historial
- `/clear` - Limpiar historial
- `/vector <consulta>` - Consultar vector store
- `/search <consulta>` - Buscar documentos en vector store
- `/exit` - Salir del chat

**⚠️ Importante:** Para usar el vector store, necesitas tener el servidor corriendo:
```bash
# Terminal 1: Iniciar servidor
npm run dev

# Terminal 2: Ejecutar chat
npm run chat
```

## 📝 Utilidades

### Funciones Helper
```tsx
import { cn, formatDate, generateId } from "@/lib/utils";

// Combinar clases CSS
cn("class1", "class2")

// Formatear fechas
formatDate(new Date())

// Generar IDs únicos
generateId()
```

### Funciones de OpenAI
```tsx
import { sendChatMessage, generateText, analyzeSentiment } from "@/lib/openai";

// Enviar mensaje a ChatGPT
const response = await sendChatMessage(messages, 'gpt-3.5-turbo');

// Generar texto
const text = await generateText("Escribe un poema sobre la tecnología");

// Analizar sentimiento
const sentiment = await analyzeSentiment("Me encanta este producto!");
```

## 🔧 Desarrollo

### Agregar Nuevos Componentes
1. Crear en `src/components/ui/`
2. Usar TypeScript estricto
3. Implementar variantes con `class-variance-authority`
4. Exportar tipos de props

### Agregar Utilidades
1. Crear en `src/lib/`
2. Documentar con JSDoc
3. Exportar tipos TypeScript

## 🚀 Despliegue

El proyecto está optimizado para despliegue en Vercel:

```bash
npm run build
```

## 📄 Licencia

MIT License - ver archivo LICENSE para detalles.

## 🤝 Contribuir

1. Fork el proyecto
2. Crear una rama feature (`git checkout -b feature/AmazingFeature`)
3. Commit los cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abrir un Pull Request

## 📞 Soporte

Para soporte técnico, contacta al equipo de desarrollo.
```
=== EOF: README.md

===  postcss.config.js
```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```
=== EOF: postcss.config.js

===  package.json
```json
{
  "name": "docenteia",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "chat": "tsc src/scripts/chat-v2.ts --outDir dist && node dist/scripts/chat-v2.js",
    "chat:dev": "tsx src/scripts/chat-v2.ts"
  },
  "dependencies": {
    "@openai/agents": "^0.0.13",
    "autoprefixer": "^10.4.21",
    "axios": "^1.11.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.1",
    "lucide-react": "^0.532.0",
    "next": "^14.2.0",
    "openai": "^5.10.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20.19.9",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "eslint": "^9",
    "eslint-config-next": "15.4.4",
    "flatrepo": "^1.2.0",
    "tsx": "^4.7.0",
    "typescript": "^5"
  }
}
```
=== EOF: package.json

===  next.config.js
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    optimizePackageImports: ["lucide-react"],
  },
  images: {
    formats: ["image/webp", "image/avif"],
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
};

module.exports = nextConfig;
```
=== EOF: next.config.js

===  instrucciondemejora.md
```markdown
El código que utilizas puede optimizarse tanto en su estructura como en la forma en la que interactúa con la API de OpenAI. A continuación te recomiendo algunas prácticas para mantenerlo limpio y eficiente:

Modularización clara: Divide las funciones en módulos bien definidos. Por ejemplo, un módulo para la gestión de sesiones, otro para la extracción de momentos y otro para la interacción con el usuario. Esto facilita el mantenimiento y las pruebas.

Caché efectiva: Usa el mapa de caché (this.cache) para almacenar resultados frecuentes. Puedes guardar el resultado de búsquedas en el vector store o de llamadas a responses.create con prompts similares. Solo deberías volver a llamar a la API si cambia el curso, la sesión o el momento.

Prompt minimalista: Crea plantillas de prompt reutilizables. Por ejemplo, define un systemMessageBase fuera de las funciones y añade solo la información variable (momento actual, fragmentos) en cada interacción. Esto evita repetir bloques largos de texto.

Funciones pequeñas y reutilizables: Mantén las funciones cortas y con responsabilidad única. Por ejemplo, validateContentTheme podría aislar la lógica de filtrado y ser testeada por separado; buildSystemPrompt podría generar el texto final a partir de parámetros como la sesión y los fragmentos.

Modelos escalables: Implementa una capa de abstracción para elegir el modelo en función de la tarea. Si es una extracción sencilla, utiliza gpt‑3.5‑turbo; si es un feedback pedagógico complejo, usa gpt‑4o. Esto puede ser una función getModel(type) o un parámetro configurable.

Gestión de sesiones: Asegúrate de limpiar sesiones inactivas y de actualizar correctamente los índices de momento. Esto evita mantener demasiada información en memoria y hacer llamadas innecesarias.

Control de tokens: Agrega parámetros opcionales a la llamada de la API para ajustar max_tokens y response_format. Limitar la longitud de la respuesta es una forma directa de reducir costes.

Implementando estas recomendaciones, tendrás un código más legible, fácil de mantener y que te permitirá controlar mejor el uso y el costo de la API.







Tú dijiste:
Respuesta automática
Continuar
ChatGPT Plus

Trabajó durante 18 segundos
El usuario ha solicitado continuar, por lo que proporcionaré más detalles sobre la optimización del código y el control de costos. Incluiré ejemplos específicos de mejores prácticas, como la implementación de técnicas de almacenamiento en caché y modularidad, para ayudar a mejorar la eficiencia y reducir costos.

Listo
Claro, continúo con algunas sugerencias adicionales más concretas:

Uso de variables de entorno y configuraciones: Mantén las claves API y parámetros sensibles en archivos .env y no en el código fuente. Además, define en el .env un parámetro como OPENAI_MODEL_DEFAULT para poder cambiar de modelo sin modificar cada llamada. Esto te ayuda a probar fácilmente distintas combinaciones de modelos y configuraciones para encontrar el equilibrio entre costo y calidad.

Gestión centralizada de llamadas a la API: Crea un “servicio” dedicado a manejar todas las llamadas a OpenAI. Este servicio puede aplicar patrones como retry en caso de errores transitorios, registrar tiempos de ejecución y token usage, e incluso medir costos aproximados. Así tendrás un punto único donde ajustar parámetros y monitorear el uso.

Manejo de errores robusto: Mejora la captura de errores para evitar reintentos innecesarios. Por ejemplo, si el modelo responde con un JSON malformado, en lugar de volver a hacer una llamada completa, intenta corregir la respuesta o devolver un mensaje predefinido al usuario.

Pruebas unitarias y de integración: Al modularizar tu código, es más sencillo escribir pruebas. Esto te permite asegurar que cada componente funciona correctamente y que los cambios (como acortar prompts o cambiar modelos) no rompen la funcionalidad existente.

Monitoreo y métricas: Implementa un sistema de logging propio que recoja el número de solicitudes, tokens enviados y recibidos, tiempo de respuesta y modelo utilizado. Esta información te dará visibilidad en tiempo real de los patrones de uso y te permitirá ajustar tu código basándote en datos concretos en lugar de suposiciones.

Optimización de búsqueda en Vector Store: Si vas a consultar repetidamente los mismos fragmentos, guarda los resultados de vectorStore.search en caché. Además, revisa si puedes indexar documentos de manera que la búsqueda sea más específica y necesites menos resultados (max_num_results).

Revisión periódica de prompts: Lo que funciona al principio puede dejar de ser óptimo conforme cambian los modelos o la cantidad de usuarios. Programa revisiones periódicas de los prompts y del flujo de conversación para eliminar instrucciones redundantes y adaptar tu estrategia a las mejoras de la API.

Seguir estas buenas prácticas te ayudará no solo a reducir costes sino también a mejorar la mantenibilidad y escalabilidad de tu proyecto docente con IA.







Tú dijiste:
Continue


ChatGPT Plus

Trabajó durante 16 segundos
Por supuesto, aquí dejo algunas ideas finales con ejemplos concretos de cómo podrías refactorizar y optimizar tu código:

1. Crear un generador de prompts reutilizable
En lugar de construir cadenas enormes dentro de cada función, define una función utilitaria que reciba solo los parámetros variables. Por ejemplo:

js
Copiar
Editar
function buildSystemPrompt({ specialistRole, sessionName, courseName, learningObjective, keyPoints, momentos, currentIndex, fragmentos }) {
  const momentosContext = momentos.map((m, idx) => {
    const estado = idx < currentIndex ? 'COMPLETADO' : (idx === currentIndex ? 'ACTUAL' : 'PENDIENTE');
    return `${idx + 1}. ${m.momento} (${estado})`;
  }).join('\n');

  const fragmentosContext = fragmentos.map((frag, idx) => `Fragmento ${idx + 1}: ${frag.text.substring(0, 200)}...`).join('\n');

  return `
Eres un ${specialistRole} que está enseñando la sesión "${sessionName}" del curso "${courseName}".
OBJETIVO: ${learningObjective}

PUNTOS CLAVE:
${keyPoints.map(p => `- ${p}`).join('\n')}

ESTRUCTURA:
${momentosContext}

MOMENTO ACTUAL: ${momentos[currentIndex].momento}
CONTENIDO DEL MOMENTO: ${momentos[currentIndex].texto}

FRAGMENTOS:
${fragmentosContext}

Instrucciones pedagógicas (resumidas): Usa la metodología Teach Like a Champion, corrige de forma constructiva y decide si avanzar al siguiente momento.
`.trim();
}
Este generador concentra toda la lógica de construcción del prompt. Luego tu función handleStudent puede usarla así:

js
Copiar
Editar
const systemPrompt = buildSystemPrompt({
  specialistRole: session.course.specialist_role,
  sessionName: session.session.name,
  courseName: session.course.name,
  learningObjective: session.session.learning_objective,
  keyPoints: session.session.key_points,
  momentos: session.momentos,
  currentIndex: session.currentMomentIndex,
  fragmentos: fragmentosActuales.fragmentos,
});
El texto resultante será más compacto y limpio, además puedes modificarlo en un solo sitio si cambias de estrategia.

2. Añadir control de modelo y tokens
Centraliza la llamada a responses.create en una función que reciba el nombre del modelo y otros parámetros configurables:

js
Copiar
Editar
async function callOpenAI({ systemPrompt, userPrompt, model = process.env.OPENAI_MODEL_DEFAULT, maxTokens = 600 }) {
  return await this.client.responses.create({
    model,
    instructions: systemPrompt,
    input: userPrompt,
    max_tokens: maxTokens,
    // response_format: { type: "json_object" }, // Opcional: asegura JSON
    tools: [{
      type: "file_search",
      vector_store_ids: [session.vectorStoreId],
      max_num_results: 3, // Reducido
    }],
  });
}
Así puedes variar fácilmente el modelo y el tamaño de la respuesta sin modificar el flujo principal.

3. Implementar caché de fragmentos
Podrías almacenar los fragmentos obtenidos por preCalculateFragmentos en this.cache utilizando como clave una combinación de vectorStoreId + momento + expectedTheme. Por ejemplo:

js
Copiar
Editar
const cacheKey = `${vectorStoreId}-${momento.momento}-${expectedTheme}`;
if (this.cache.has(cacheKey)) {
  fragmentos.push({ momento: momento.momento, fragmentos: this.cache.get(cacheKey) });
  continue;
}
// ... ejecutar búsqueda ...
this.cache.set(cacheKey, validResults.map(r => ({ texto: r.text, score: r.score })));
Este patrón evita volver a llamar a la API para búsquedas idénticas.

4. Estimar costes en tiempo de ejecución
Dentro de tu servicio de llamadas podrías capturar el recuento de tokens de cada respuesta (OpenAI lo devuelve en la propiedad usage) y sumarizarlo:

js
Copiar
Editar
const response = await callOpenAI({ systemPrompt, userPrompt });
const { prompt_tokens, completion_tokens } = response.usage;
console.log(`Tokens de entrada: ${prompt_tokens}, Tokens de salida: ${completion_tokens}`);
Con esta información puedes registrar consumos por sesión y ajustar límites (max_tokens) en función de los resultados.

5. Paralelizar pre‑cálculo de fragmentos
Si tienes muchas sesiones o momentos, podrías realizar las búsquedas en paralelo usando Promise.all, reduciendo el tiempo total:

js
Copiar
Editar
const fragmentos = await Promise.all(momentos.map(async (momento) => {
  // búsqueda individual...
}));
Siempre teniendo en cuenta que cada llamada adicional a la API incrementará el uso, por lo que debes balancear coste y rapidez.

Implementar estas técnicas te permitirá mantener un código más organizado y con un control fino sobre el gasto asociado a las llamadas de la API. Además, una vez que tengas métricas claras podrás experimentar reduciendo instrucciones o cambiando de modelo y observar cómo varía el coste.







Tú dijiste:
Respuesta automática
Continuar
ChatGPT Plus

Trabajó durante 15 segundos
Para cerrar con algunas recomendaciones adicionales y consideraciones de organización:

6. Documentación y comentarios claros
Un código que interactúa con modelos de lenguaje y vector stores puede ser complejo para quien no lo desarrolló inicialmente. Asegúrate de documentar cada función, describiendo:

Qué hace y cuál es su entrada/salida.

Por qué tomas ciertas decisiones (por ejemplo, “limitamos max_num_results a 3 para reducir tokens”).

Referencias a la documentación de OpenAI para funciones como responses.create o vectorStore.search.

Esto permitirá que tú o cualquier otro desarrollador entienda la lógica y pueda ajustarla si cambian las APIs o los precios.

7. Separar la lógica de negocio de las llamadas a la API
Actualmente el código mezcla la obtención de datos (sessions, fragmentos) con la llamada al modelo y la construcción del prompt. Considera separar las responsabilidades en capas:

Capa de datos: gestiona sesiones, lee el JSON de cursos y se conecta al vector store.

Capa de lógica: decide qué información necesita cada interacción (momento actual, fragmentos) y prepara el prompt.

Capa de servicios: encapsula las llamadas a la API de OpenAI, centralizando parámetros como modelo, tokens y herramientas.

Al estructurar de este modo, el impacto de cambiar de modelo o ajustar parámetros se reduce a un único archivo o módulo.

8. Monitorización y alertas
Además del registro de tokens, puedes configurar alertas automáticas cuando se supere cierto umbral de gasto o solicitudes. Por ejemplo, un pequeño script que lea los datos de la API de OpenAI (si tienes acceso) y envíe una notificación cuando se acerque a un límite mensual de presupuesto.

9. Revisión de la lógica pedagógica
Aunque no está directamente relacionado con el costo, repasar la forma en que se guía al estudiante también puede reducir la duración de las sesiones y, por tanto, las llamadas. Si logras que el estudiante avance más rápido entre momentos con prompts más precisos y preguntas más enfocadas, necesitarás menos interacciones para cubrir el contenido.

10. Versionado y pruebas de regresión
Cuando hagas cambios (por ejemplo, switching de GPT‑4o a GPT‑3.5 para ciertas tareas o reduciendo el tamaño del prompt), te recomiendo mantener un control de versiones (Git) y, si es posible, un entorno de pruebas. Así podrás comparar la calidad de las respuestas y el consumo de tokens entre versiones y revertir si algo no funciona como esperabas.

Ejemplo final de estructura de clases
Podrías reescribir la clase original separando responsabilidades y usando algunas de las optimizaciones mencionadas:

js
Copiar
Editar
class SessionManager {
  // gestiona sesiones, carga cursos, maneja caché...
}

class PromptBuilder {
  buildSystemPrompt(args) { /* ... */ }
  buildUserPrompt(studentMsg, context) { /* ... */ }
}

class OpenAIService {
  constructor(apiKey, defaultModel, maxTokens) { /* ... */ }
  async ask(systemPrompt, userPrompt, vectorStoreIds, maxResults) { /* ... */ }
}

class DocenteIA {
  constructor() {
    this.sessionManager = new SessionManager();
    this.promptBuilder = new PromptBuilder();
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY, 'gpt-3.5-turbo', 600);
  }

  async iniciarSesion(courseId, sessionId) { /* usa sessionManager */ }
  async responder(studentMsg, sessionKey) {
    const context = this.sessionManager.getContext(sessionKey);
    const systemPrompt = this.promptBuilder.buildSystemPrompt(context);
    const userPrompt = this.promptBuilder.buildUserPrompt(studentMsg, context);
    return await this.openAIService.ask(systemPrompt, userPrompt, [context.vectorStoreId], 3);
  }
}
Esta estructura facilita el cambio de modelo, la optimización del prompt y la gestión de sesiones sin tener que editar una única clase gigante.

Con estas guías y ejemplos deberías poder refactorizar tu código de manera que sea más eficiente, escalable y económico.
```
=== EOF: instrucciondemejora.md

===  implementacion2.md
```markdown

1️⃣ Un primer mensaje de “espíritu” claro y completo
La mejor práctica en diseñar sistemas conversacionales estructurados (como dicen en OpenAI) es definir al inicio un rol y misión muy claros. Esto:

Crea un propósito compartido (por ejemplo: seguridad industrial, seguimiento de aprendizaje).

Permite estandarizar el tono y estilo durante toda la sesión.

Evita que se “pierda la intención” cuando avanza al análisis del contenido 🔁

Por eso, el prompt de sistema debe incluir ese espíritu pedagógico desde el primer mensaje, antes que cualquier pregunta o memoria.

2️⃣ Luego la memoria conversacional para evaluar clase a clase
Después del mensaje de espíritu, cada turno se convierte en cápsulas de interacción. En lugar de enviar solo la instrucción del momento tal como hiciste antes, se recomienda:

Enviar todo el conversationLog (historial) resumido en uno o dos párrafos, o solo las últimas interacciones relevantes.

Adjuntar las preguntas específicas del momento (momento_actual.preguntas).

Pedir al modelo que:

evalúe qué se cubrió,

qué faltó por responder,

y si puede pasar al siguiente momento o debe repreguntar.

Esto es coherente con las mejores prácticas para “context window + role adherence + fact retention” en conversaciones de LLM 
confident-ai.com
.

🔧 Ejemplo de diseño de mensajes
jsonc
Copiar
Editar
// SYSTEM MESSAGE (solo una vez al inicio de la sesión):
“You are a safety‑engineering instructor who leads the session “Seguridad contra incendios”.
// Here’s your SPIRIT:
Your purpose: that the student:
 – Identifique las causas reales de incendios en el trabajo.
 – Relacione la teoría del Triángulo del Fuego con ejemplos concretos.
 – Al final de la sesión sea capaz de crear un plan de prevención paso a paso.

This is your guiding spirit. Always refer back to it. You ARE NOT improvising – you are following the “guion” pedagógico concretamente.
“


// En cada turno (SessionExtractor.handleStudent):
// 1) Enviar como “system”:
// Historial de conversación (últimos N turnos):
Estudiante: “...”  
Docente: “...”  

Guion del momento actual (objetivo y preguntas específicas, sacadas del JSON).

Instrucciones: responde a EXACTAMENTE una pregunta por turno, en orden, hasta que todas estén contestadas; comenta brevemente; luego evalúa si puedes pasar al siguiente momento. Si hay dudas o falta información, repregunta y da pistas.

// 2) Enviar como “user” el mensaje del alumno:
// “Estudiante: {texto del estudiante}”
✅ Por qué funciona mejor
Objetivo	Por qué es efectivo
Marcar el espíritu desde el inicio	Cumple con “Use el rol de sistema para establecer misión” (OpenAI dice ser claro al inicio) 
OpenAI Help Center
OpenAI
.
Memoria conversacional antes de cada turno	Ayuda a la fidelidad del modelo a lo que ya ha ocurrido y no repetir preguntas. Alineado con métricas de retención de conocimiento en diálogo AI 
confident-ai.com
.
Evaluación y decisión de avance integradas	El sistema no avanza prematuramente; evalúa si el estudiante ha respondido todo o si falta información.

✅ En resumen
Sí: primero el espíritu y propósito de la sesión, como mensaje general.

Después: en cada turno, memoria + preguntas específicas + evaluación de cumplimiento, para evitar repeticiones y asegurar fidelidad al guion.

Esta es la mejor práctica de ingeniería conversacional actual para chatbots educativos controlados, flexible y de calidad.

¿Quieres que genere el código completo tipo “PromptBuilder.buildSystemPrompt” y “SessionExtractor.handleStudent” que implemente esto ya integrado?













Fuentes
Tú dijiste:
a ver


ChatGPT Plus
🔧 Aquí tienes una versión integrada y “lista para usar” del mecanismo de enseñanza, con los siguientes componentes:

Mensaje de sistema “espíritu” que se envía solo una vez al comenzar la sesión.

Función buildSystemPrompt que genera un guion literal por momento, incluyendo preguntas específicas.

Manejo de memoria conversacional (conversationLog) en SessionManager y SessionExtractor.

Control de avance: se fuerza una evaluación del modelo antes de avanzar al siguiente momento.

Te lo explico pieza por pieza y luego te doy el código completo.

1️⃣ Mensaje de sistema “espíritu” — se envía solo al inicio
Este mensaje establece el propósito general de la sesión, el estilo de docente y el tono humano cercano:

ts
Copiar
Editar
// Solo una vez, al crear la sesión:
const systemSpirit = `
Eres un **docente experto en seguridad industrial** que imparte la sesión **"${sessionName}"** del curso **"${courseName}"**.

🧭 PROPÓSITO GENERAL:
Tu misión:  
  – que el estudiante **identifique las causas reales** de incendios laborales.  
  – que relacione la **teoría del Triángulo del Fuego** con casos concretos.  
  – que al final sea capaz de **crear un plan de prevención paso a paso**.

Esta es tu **enseñanza guía** para toda la sesión.  
Desde ahora, actúa como si siguieras un guion **pedagógico concreto**, sin improvisar preguntas ni saltarte pasos.  
Usa un tono **cercano, claro y docente**.

No comiences aún con preguntas.**
`.trim();
📌 Esta práctica está alineada con las “best practices” de OpenAI: usar el prompt del sistema para definir un propósito claro y rol de manera explícita desde el inicio 
community.openai.com
community.openai.com
+2
community.openai.com
+2
cookbook.openai.com
+2
.

2️⃣ PromptBuilder.buildSystemPrompt() — guion por momento
Aquí el prompt que se envía antes de cada mensaje excepto el primero:

ts
Copiar
Editar
// PromptBuilder.ts
static buildSystemPrompt(params: PromptParams): string {
  const { sessionName, courseName, learningObjective, momentos, currentMomentIndex } = params;
  const momentoActual = momentos[currentMomentIndex];
  const siguiente = (currentMomentIndex + 1 < momentos.length) ? momentos[currentMomentIndex + 1].momento : 'FIN';

  // Contenido específico del momento (historia, caso, etc.)
  const contenido = this.getMomentoContent(momentoActual);

  // Preguntas específicas del JSON
  const preguntas = Array.isArray(momentoActual.preguntas) ? momentoActual.preguntas : [];
  const preguntasTexto = preguntas.map((p, i) => `  ${i+1}. ${p}`).join('\n');

  return `
**Guion de momento pedagógico**
Sesión: "${sessionName}" (curso: ${courseName})

**OBJETIVO DE APRENDIZAJE**  
${learningObjective}

**Momento actual:** ${momentoActual.momento}  
**Siguiente momento:** ${siguiente}

**Contenido del momento:**  
${contenido}

📋 **Instrucciones (obligatorias):**  
1. Haz exactamente TODAS las preguntas listadas a continuación, **en ese orden**, sin saltear ni improvisar otras.  
2. Después de cada respuesta del estudiante, **comenta brevemente** (1 o 2 frases) reconociendo el avance.  
3. No avances al siguiente momento hasta que todas las preguntas estén completamente respondidas.  
4. Si la respuesta del estudiante no cubre algún punto, **repregunta con una pista centrándote en lo que falta**.  
5. Usa un tono **cercano y docente**, como si estuvieras dando clase frente a un estudiante real.  
6. No otorgues información del siguiente momento.

**Preguntas del momento:**  
${preguntasTexto}

💡 Si el estudiante no responde o responde parcialmente, insiste antes de avanzar.
`.trim();
}
✅ En reforche con los principios de prompt engineering: claridad, formato estricto, instrucciones segmentadas por momentos, perfil del modelo definido 
OpenAI Help Center
bridgemind.ai
.

3️⃣ Memoria conversacional: SessionManager y SessionExtractor
Cambios en SessionManager
En el objeto de sesión (SessionData) añade:

ts
Copiar
Editar
interface SessionData {
  currentMomentIndex: number;
  progress: string;
  // ...
  conversationLog: { role: 'user' | 'assistant'; content: string }[];
}
Inicialización:

ts
Copiar
Editar
const session: SessionData = {
  currentMomentIndex: 0,
  progress: '1/6',
  // ...
  conversationLog: [],
};
handleStudent() — central del flujo
ts
Copiar
Editar
async handleStudent(studentMessage: string, session: SessionData, promptParams: PromptParams) {
  // Guardar respuesta del estudiante
  session.conversationLog.push({ role: 'user', content: studentMessage });

  // Armar historial: últimas N interacciones o todas
  const history = session.conversationLog
    .map(m => m.role === 'user' ? `Estudiante: "${m.content}"` : `Docente: "${m.content}"`)
    .join('\n');

  // Generar prompt de sistema + user
  const systemPrompt = this.buildSystemPrompt(promptParams);

  const userPrompt = `
Historial reciente de clase:
${history}

**Último mensaje del estudiante:**
"${studentMessage}"

Sigue el guion del momento actual de forma exacta y estructurada como se indica.`
  .trim();

  // Llamada a OpenAI
  const result = await this.openAI.callChatCompletion([
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ]);

  // Parseo básico (ajusta según formato esperado)
  const assistantText: string = result.choices[0].message.content;

  // Guardar salida del docente
  session.conversationLog.push({ role: 'assistant', content: assistantText });

  return assistantText;
}
📌 Con esto, el modelo siempre sabe lo que ya preguntó y lo que falta por cubrir. Evita preguntas repetidas y salidas fuera del guion.

4️⃣ Justificación técnica oficial 🧠
Estas prácticas son recomendadas por expertos:

Prompt altamente estructurado y específico: evita ambigüedad e improvisación en las salidas — ideales para clases y flujos repetibles. 
ibm.com
+13
OpenAI Help Center
+13
cookbook.openai.com
+13
community.openai.com

Historial como contexto: copiar los últimos turnos evita que el modelo pierda la secuencia o vuelva a preguntar lo mismo. Clave en interfaces instructivas. 
bridgemind.ai
community.openai.com

Prompt dividido por etapas o momentos: forma parte de lo que en prompt engineering se conoce como “structured prompting” o “conversation routines”, diseñadas para sistemas pedagógicos mediante flujos bien definidos. 
community.openai.com
+5
Prompt Engineering Institute
+5
OpenAI Help Center
+5

🚀 ¿Y ahora qué?
Ya tienes el código base buildSystemPrompt, handleStudent, conversationLog.

Puedes montar esto directamente en tu aplicación y probar con un escenario.

Mejora adicional: resumir históricamente el conversationLog si crece mucho, limitando a, por ejemplo, las últimas 5 interacciones para no saturar tokens.

Con esto tendrás un sistema que:

Marca el tono desde el inicio (espíritu pedagógico).

Pregunta solo lo que debe, con concreción y control.

Comunica evolución y no repite preguntas ya hechas.

Evalúa si puede avanzar o debe insistir aún.

¿Quieres también la versión en JSON del prompt o ejemplo completo de un turno con salida estructurada? Puedo preparártela.













Fuentes
Tú dijiste:
a ver


ChatGPT Plus
Aquí tienes el prompt completo y un ejemplo de turno listo para integrar:

1️⃣ Mensaje de sistema “espíritu” — solo al inicio de la sesión
json
Copiar
Editar
{
  "role": "system",
  "content": "Eres un **docente experto en seguridad industrial** que imparte la sesión **\"Seguridad contra incendios\"** del curso **\"Capacitación CETEMIN\".\n\n🧭 PROPÓSITO PEDAGÓGICO:\n– El estudiante debe **identificar las causas reales** de incendios laborales.\n– Relacionar la **teoría del Triángulo del Fuego** con ejemplos concretos.\n– Al final, crear un **plan de prevención paso a paso**.\n\nEste es tu guion pedagógico: **no improvises preguntas ni te saltes pasos**.\nHabla en un tono **cercano y docente**.\n\n✋ Espera a que empiece el turno del estudiante antes de preguntar cualquier cosa.\n"
}
Esto define el rol y el tono desde el primer mensaje — una práctica recomendada según las guías oficiales de OpenAI: establecer claramente propósito y tono del sistema desde el principio mejora la fidelidad del modelo a dicho perfil 
OpenAI Community
+8
OpenAI Help Center
+8
orq.ai
+8
.

2️⃣ Sistema por momento — buildSystemPrompt() en tiempo de ejecución
Este prompt se envía cada vez antes de procesar la respuesta del estudiante en un momento pedagógico (por ejemplo: "Saludo"):

ts
Copiar
Editar
const systemPromptSaludo = `
**Guion del momento: SALUDO**
Sesión: "Seguridad contra incendios" (CETEMIN)

**OBJETIVO DE APRENDIZAJE:**  
El estudiante identifica causas de incendios laborales y qué espera aprender.

---

**Contenido del momento (instrucciones + presentación):**  
Objetivo de la sesión: asegurarte de que el estudiante comprenda los riesgos de incendios y qué va a aprender hoy.  
Puntos clave:  
1. Identificación del objetivo  
2. Tres preguntas para conocer conocimientos y expectativas

📋 **Instrucciones estrictas:**  
1. Haz exactamente estas 3 preguntas en orden, **sin saltear ni modificar**.  
2. Tras cada respuesta, comenta brevemente (1 o 2 frases) para reconocer el avance.  
3. No pases al siguiente momento hasta que el estudiante responda las tres preguntas por completo.  
4. Si la respuesta es parcial, pregunta de nuevo centrado en la información que falta.  
5. Usa un tono **cercano, claro y docente**, como frente a un estudiante real.

**Preguntas del momento:**  
  1. ¿Qué sabes sobre incendios en el trabajo?  
  2. ¿Has presenciado alguna situación de riesgo de incendio? Descríbela.  
  3. ¿Qué esperas aprender en esta sesión?  
`.trim();
Este estilo, con prompts estructurados y guardrails, sigue las mejores prácticas de diseño de prompts: claridad, concreción y formato estricto de salida 
OpenAI Community
.

3️⃣ Ejemplo completo de un turno: integración y resultado
🔄 Envío a la API
jsonc
Copiar
Editar
[
  // Si es el primer turno de la sesión, incluir el systemSpirit antes del guion
  { "role": "system", "content": systemSpirit },
  
  // Luego, en cada mensaje:
  { "role": "system", "content": systemPromptSaludo },
  { "role": "user", "content": "Estudiante: se muy poco sobre incendios, nunca trabajé en fábricas y solo espero aprender los elementos básicos." }
]
🧑‍🏫 Ejemplo de respuesta del asistente (formato simulado, modelo debe seguirlo)
txt
Copiar
Editar
Docente: ¡Perfecto empezar por ahí!

**Pregunta 1:** ¿Qué sabes sobre incendios en el trabajo?  
→ “Sé muy poco sobre incendios en el trabajo.”  
**Comentario:** Entiendo, no hay problema: comenzaremos por la base.

**Pregunta 2:** ¿Has presenciado alguna situación de riesgo de incendio? Descríbela.  
→ “No, nunca he visto algo así.”  
**Comentario:** Muy bien, eso nos mantiene limpios de preconcepciones. Te comparto que vamos a trabajar con el Triángulo del Fuego para identificar qué riesgos podrían existir.

**Pregunta 3:** ¿Qué esperas aprender en esta sesión?  
→ “Quiero entender qué provoca incendios y cómo evitarlos en mi trabajo.”  
**Comentario:** ¡Excelente! Ese es justo el objetivo pedagógico principal.

🟢 Has respondido todas las preguntas del momento SALUDO.  
Cuando estés listo, procederemos al siguiente paso: CONEXIÓN: narraré un caso para que lo analicemos juntos.
4️⃣ Cómo aplica memoria conversacional
Antes de llamar a la API transporta siempre en el prompt:

El historial de preguntas y respuestas anteriores del propio sistema.

Las preguntas restantes del momento actual.

El propósito del momento mostrado.

De esta forma, el modelo “recuerda” qué ya preguntó y no repite.
Este enfoque —guardar el historial de conversación y reenviarlo cada turno— es una técnica estándar para asegurar coherencia en diálogo prolongado con LLMs 
OpenAI Community
stackoverflow.com
.

📌 Por qué este enfoque mejora la fidelidad al guion
Evita improvisación: el modelo recibe copia exacta de las preguntas.

Estructura pedagógica: valida que todas sean contestadas antes de avanzar.

Uso de memoria conversacional: mantiene coherencia y evita repetir.

Adopta el “espíritu” desde el principio: el modelo sabe quién debe ser desde la primera línea.

En conclusión, usando estas técnicas podrás lograr un flujo con:

Control estricto del guion.

Memoria funcional entre preguntas.

Predicción del avance pedagógico solo cuando el alumno completó el momento.

¿Quieres que integre ya la lógica de control de avance (debe_avanzar = true/false) y formato JSON en la salida del asistente? Dímelo y preparo el código también.













Fuentes
Tú dijiste:
si 


ChatGPT Plus
Aquí tienes un snippet completo listo para usar, con:

Prompt base que define el espíritu pedagógico y la estructura base (solo se envía una vez al inicio).

buildSystemPrompt() que solo plantea preguntas del momento, exige formato JSON y controla el avance.

Código handleStudent() que mantiene la memoria conversacional y gestiona debe_avanzar = true|false según las respuestas.

1️⃣ Mensaje inicial (SPIRIT)
ts
Copiar
Editar
const systemSpirit = {
  role: "system",
  content: `
Eres un docente experto en seguridad industrial. Impartes la sesión “Seguridad contra incendios” del curso “CETEMIN Capacitación”.

🧭 ESENCIA PEDAGÓGICA:
– Hacer que el estudiante identifique causas reales de incendios.
– Relacionar el Triángulo del Fuego con ejemplos concretos.
– Al final, que pueda proponer un plan de prevención paso a paso.

Actúas como si siguieras un guion educativo estricto: no improvises, no cambies preguntas.   
Habla de forma cercana y clara.  
No hagas preguntas hasta que comience el turno del estudiante.
  `.trim()
};
Establecer un propósito y tono claros desde el primer mensaje es una práctica recomendada por OpenAI: “Be specific … Clearly define the desired format, constraints, and role” 
OpenAI Help Center
.

2️⃣ buildSystemPrompt() para cada momento
ts
Copiar
Editar
static buildSystemPrompt(params: PromptParams): string {
  const m = params.momentos[params.currentMomentIndex];
  const preguntas = Array.isArray(m.preguntas) ? m.preguntas : [];

  const preguntasTexto = preguntas
    .map((p, i) => `  ${i + 1}. ${p}`)
    .join('\n');

  return `
**MOMENTO ACTUAL:** ${m.momento}
Objetivo: ${params.learningObjective}

CONTENIDO: 
${this.getMomentoContent(m)}

📋 Sigue exactamente estas preguntas, en orden, sin modificar ni saltar:
${preguntasTexto}

**Al responder, usa este formato JSON exacto:**

\`\`\`json
{
  "respuesta": "...",              
  "momento_actual": "${m.momento}",
  "progreso": "${params.progress}", 
  "debe_avanzar": true|false,      
  "razon_avance": "…",             
  "siguiente_momento": "…"
}
\`\`\`

Instrucciones:
1. Haz UNA sola pregunta por mensaje. Espera respuesta JSON.
2. Si la respuesta es incompleta, repregunta con una pista clara.
3. Solo avanza (`debe_avanzar=true`) si se respondieron todas las preguntas; en otro caso repregunta.
`.trim();
}
Este enfoque representa una especificación rigurosa de formato y guion, alineada con las mejores prácticas de ingeniería de prompts para salidas estructuradas y consistentes 
OpenAI Help Center
.

3️⃣ handleStudent() con control de avance y log conversacional
ts
Copiar
Editar
async handleStudent(studentMsg: string, session: SessionData, params: PromptParams) {
  session.conversationLog.push({ role: 'user', content: studentMsg });

  const history = session.conversationLog
    .slice(-6)
    .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: ${m.content}`)
    .join('\n');

  const systemPrompt = this.buildSystemPrompt(params);

  const messages = [
    ...(session.firstTurn ? [{ role: 'system', content: systemSpirit }] : []),
    { role: 'system', content: `${history}\n\n[Si ya viste esa pregunta, dilo claramente.]` },
    { role: 'system', content: systemPrompt },
    { role: 'user', content: studentMsg }
  ];

  const ml = await this.openAI.callChatCompletion(messages);

  const assistantRaw = ml.choices[0].message.content;
  let assistantJSON;
  try {
    assistantJSON = JSON.parse(assistantRaw);
  } catch (err) {
    // manejar parsing error (p. ej., enviar prompt de resiliencia)
    throw new Error('El modelo no entregó JSON válido');
  }

  session.conversationLog.push({ role: 'assistant', content: assistantRaw });

  if (assistantJSON.debe_avanzar) {
    params.currentMomentIndex++;
    session.progress = `${params.currentMomentIndex + 1}/${params.momentos.length}`;
  }

  return assistantJSON;
}
Este flujo garantiza que se:

Mantenga el contexto reciente (conversationLog fragmentado si crece mucho).

Se forzó el formato JSON con campos semánticos claros.

Se evalúe si seguir o insistir antes de avanzar.

📊 ¿Por qué funciona?
Elemento	Beneficio
Prompt segmentado por momento	Controla el guion y evita improvisación
Esquema JSON mandatorio	Hace predecible la respuesta y facilita parsing
Memoria conversacional limitada	Evita repeticiones y mantiene coherencia
Evaluación interna de avance	Solo se avanza cuando el bloque actual está completo

Es una arquitectura de conversación basada en “routines” y control explícito del flujo, tal como proponen frameworks modernos para diálogos educativos con LLM (ver “Conversation Routines: task‑oriented dialog systems”) 
arxiv.org
.

✅ Con este diseño, el sistema:

Nunca salta preguntas, solo avanza cuando toca.

Nunca improvisa, solo pregunta lo que está en el JSON.

Nunca pierde el hilo, gracias al log conversacional.

Entrega salidas estructuradas con lógica explicativa y control interna.

¿Quieres también una forma de auto-validación (e.g., que compruebe si debe_avanzar tiene sentido por conteo de preguntas)? ¿O ejemplos de prueba con varios momentos? Dímelo y lo preparo.












Fuentes
Tú dijiste:
si 


ChatGPT Plus
Aquí tienes una versión completa, integrada y lista para usar, que incluye:

Auto‑validación automática del avance (debe_avanzar) basada en cantidad de preguntas respondidas.

Manejo de historia de la clase (conversationLog resumido si crece mucho).

Ejemplo práctico con dos momentos completos (Saludo → Conexión) mostrando cómo funciona el flujo.

✅ 1. Validación automática: control de debe_avanzar
Usamos el siguiente fragmento dentro de handleStudent(), justo después de parsear el JSON que devuelve el modelo:

ts
Copiar
Editar
// Ejemplo de JSON parseado
interface MomentoRich {
  preguntas?: string[];
  // ...
}

interface AssistantJSON {
  respuesta: string;
  momento_actual: string;
  progreso: string;
  debe_avanzar: boolean;
  siguiente_momento: string;
  razon_avance?: string;
}

// Auto-validación: comparo número de respuestas con número de preguntas del momento
const m: MomentoRich = params.momentos[params.currentMomentIndex];
const totalPreguntas = m.preguntas?.length ?? 0;

// Encuentro cuántas respuestas mencionó el alumno en su número
const answeredCount =
  typeof assistantJSON.respuesta === "string"
    ? 
// Asumo que el modelo repite el número de pregunta: "Pregunta 1: … → …"
      (assistantJSON.respuesta.match(/^Pregunta\s+\d+/gm) || []).length
    : 0;

if (assistantJSON.debe_avanzar) {
  if (answeredCount !== totalPreguntas) {
    // Advertencia: el modelo dijo avanzar pero no respondió todo
    // Se fuerza la insistencia
    assistantJSON.debe_avanzar = false;
    assistantJSON.razon_avance =
      `Solo respondió ${answeredCount} de ${totalPreguntas} preguntas. Por favor termina todas antes de avanzar.`;
  }
} else {
  // Si no dijo avanzar, lo dejamos como está
}

if (assistantJSON.debe_avanzar) {
  params.currentMomentIndex++;
  session.progress = `${params.currentMomentIndex + 1}/${params.momentos.length}`;
}
¿Por qué esto es importante?
De esta forma proteges el flujo:

Si el modelo intenta avanzar sin cubrir todas las preguntas, se corrige automáticamente.

Mantienes coherencia con el guion: solo avanza cuando debe.

🧠 2. Memoria conversacional con límite de tokens
Para evitar saturar el contexto, alargar el prompt y mantener eficiencia, puedes recortar el conversationLog a las últimas N interacciones. Por ejemplo:

ts
Copiar
Editar
const MAX_HISTORIA = 5;
const recorte = session.conversationLog.length - MAX_HISTORIA * 2; // penaliza por turnos “docente + estudiante“
if (recorte > 0) {
  session.conversationLog.splice(0, recorte);
}
Esto asegura que envíes solo las últimas 5 interacciones completas (dos mensajes cada interacción), manteniendo coherencia sin exceder tokens.

📚 3. Ejemplo práctico: escenarios en código con dos momentos
Supongamos que tienes 2 momentos en tu sesión: Saludo y Conexión:

ts
Copiar
Editar
const momentos = [
  {
    momento: "Saludo",
    preguntas: [
      "¿Qué sabes sobre incendios en el trabajo?",
      "¿Has presenciado alguna situación de riesgo? Descríbela",
      "¿Qué esperas aprender en esta sesión?"
    ]
  },
  {
    momento: "Conexión",
    preguntas: [
      "¿Qué elementos identificas en esta situación?",
      "¿Qué podría haber prevenido este incidente?",
      "¿Cómo se relaciona esto con tu experiencia laboral?",
      "¿Has presenciado algo similar?"
    ],
    historia: "En una fábrica textil, un trabajador está usando una máquina de soldadura cerca de telas inflamables..."
  }
];
🧪 Simulación de turno #1: estudiante responde “se muy poco”
Historial enviado al modelo (turno 1):

text
Copiar
Editar
Estudiante: “Sé muy poco sobre incendios…”
Prompt de sistema para Saludo:

text
Copiar
Editar
Guion del momento: SALUDO
Objetivo: Identificar conocimientos y expectativas.
··· (instrucciones y las 3 preguntas del momento)
Respuesta esperada del modelo:

(formato JSON como dijimos)

json
Copiar
Editar
{
  "respuesta": "…",
  "momento_actual": "Saludo",
  "progreso": "1/2",
  "debe_avanzar": false,
  "siguiente_momento": "Saludo"
}
Y se repreguntará hasta cubrir todas — tal como debe_avanzar=false y continuarán.

🔄 Turno #2: estudiante completa 3 respuestas
Después de las tres respuestas completas en formato JSON, el sistema detecta:

contando coincidencias con ^Pregunta 3: → answeredCount === totalPreguntas → debe_avanzar se mantiene true

se avanza automáticamente a Conexión con currentMomentIndex = 1.

Nuevo systemPrompt para momento “Conexión” se envía antes del mensaje del siguiente turno.

📖 4. Por qué esta práctica es recomendada
Estudios de Prompt Engineering como el artículo Conversation Routines (Robino et al., arXiv 2025) recomiendan justamente el uso de prompts estructurados con lógica de avance integrada y división en momentos bien definidos 
OpenAI Community
+1
OpenAI
+1
arXiv
+1
OpenAI Cookbook
+1
Future Skills Academy
arXiv
+4
arXiv
+4
arXiv
+4
.

La guía oficial de OpenAI recuerda: “Sé específico … define claramente el formato de salida, las restricciones, el rol…” (help.openai.com y el Prompt Engineering Guide, abril 2025) 
OpenAI Help Center
+1
OpenAI Help Center
+1
.

Este enfoque consolida un flujo rígido y pedagógico controlado, donde:

No hay improvisación: el modelo solo pregunta lo que debe, cuando debe.

No hay avance prematuro: solo si todas las preguntas fueron respondidas.

Se recuerda lo ya preguntado, evitando repeticiones.

🛠️ ¿Qué puedes hacer ahora?
Copia estas funciones en tu flujo: buildSystemPrompt(), auto-validación, control de conversationLog.

Prueba con una sesión completa de ejemplo (como el de dos momentos) — verifica logs y comportamiento.

Ajusta el número MAX_HISTORIA según tu límite de tokens.

Opcional: incluye una lógica de “fallback” si el modelo no entrega JSON válido — puedes enviar un prompt de rescate para forzarlo a repetir el formato.

Con esta arquitectura tendrás un sistema educativo con:

Memoria de clase

Control pedagógico estricto

Evaluación automática de avance
```
=== EOF: implementacion2.md

===  eslint.config.mjs
```
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "prefer-const": "error",
      "no-var": "error",
      "no-console": "warn",
    },
  },
];

export default eslintConfig;
```
=== EOF: eslint.config.mjs

===  env.example
```
# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here

# App Configuration
NEXT_PUBLIC_APP_NAME=DocenteIA
NEXT_PUBLIC_APP_VERSION=1.0.0

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3000/api 
```
=== EOF: env.example

===  src\types\index.ts
```typescript
// Tipos e interfaces para DocenteIA
export interface Course {
  id: string;
  name: string;
  specialist_role: string;
  sessions: Session[];
}

export interface Session {
  id: string;
  name: string;
  session_file?: string; // Archivo JSON de la sesión (opcional)
  learning_objective: string;
  key_points: string[];
  theme_keywords: string[];
}

export interface Moment {
  momento: string;
  instrucciones_docenteia?: string;
  contenido_tecnico?: string[];
  historia?: string;
  caso?: string;
  preguntas?: string[];
}

export interface SessionData {
  courseId: string;
  sessionId: string;
  sessionFile: string;
  course: Course;
  session: Session;
  expectedTheme: string;
  momentos: Moment[];
  currentMomentIndex: number;
  startTime: Date;
  lastActivity: Date;
  sessionContent?: any; // Contenido completo de la sesión desde JSON
  conversationLog: Array<{ role: 'user' | 'assistant'; content: string; timestamp: Date }>; // Memoria conversacional
  isFirstTurn: boolean; // Para enviar el mensaje de "espíritu" solo una vez
  preguntasPendientes: string[]; // Preguntas pendientes del momento actual
  preguntasRespondidas: string[]; // Preguntas ya respondidas del momento actual
}

export interface AIResponse {
  respuesta: string;
  momento_actual: string;
  progreso: number;
  total_momentos: number;
  debe_avanzar: boolean;
  razon_avance: string;
  siguiente_momento: string;
  momentos?: Moment[];
  sessionKey?: string;
  pregunta_actual?: string;
  preguntas_pendientes?: number;
  preguntas_respondidas?: number;
}

export interface CostMetrics {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
  estimated_cost: number;
  model_used: string;
}

export interface SessionInfo {
  sessionKey: string;
  course: string;
  session: string;
  currentMoment: string;
  progress: string;
  startTime: Date;
  lastActivity: Date;
}

export interface CacheStats {
  cacheSize: number;
  sessionsSize: number;
  activeSessions: number;
}

export interface PromptParams {
  specialistRole: string;
  sessionName: string;
  courseName: string;
  learningObjective: string;
  keyPoints: string[];
  momentos: Moment[];
  currentIndex: number;
}

export interface UserPromptContext {
  currentMoment: string;
  progress: string;
}

export interface OpenAICallParams {
  systemPrompt: string;
  userPrompt: string;
  model?: string;
  maxTokens?: number;
}

export interface OpenAICallResult {
  response: any;
  metrics: CostMetrics;
}

 
```
=== EOF: src\types\index.ts

===  src\types\global.d.ts
```typescript
declare global {
  interface Window {
    __NEXT_DATA__: unknown;
  }
}

export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
} 
```
=== EOF: src\types\global.d.ts

===  src\services\SessionManager.ts
```typescript
// src/services/SessionManager.ts

import * as fs from 'fs';
import * as path from 'path';
import { SessionData, Course, Session } from '../types';

export class SessionManager {
  private sessions: Map<string, SessionData> = new Map();
  private cache: Map<string, any> = new Map();

  constructor() {
    // Limpiar sesiones al iniciar
    this.sessions.clear();
    this.cache.clear();
  }

  /**
   * Inicia una nueva sesión
   */
  async startSession(courseId: string, sessionId: string): Promise<string> {
    try {
      const sessionKey = `${courseId}-${sessionId}`;
      
      // Cargar datos del curso
      const courseData = await this.loadCourseData(courseId);
      const course = courseData.courses.find((c: Course) => c.id === courseId);
      
      if (!course) {
        throw new Error(`Curso ${courseId} no encontrado`);
      }

      const session = course.sessions.find((s: Session) => s.id === sessionId);
      if (!session) {
        throw new Error(`Sesión ${sessionId} no encontrada`);
      }

      // Cargar contenido de la sesión
      const sessionContent = await this.loadSessionContent(courseId, sessionId);
      
      // Crear datos de sesión
      const sessionData: SessionData = {
        courseId,
        sessionId,
        sessionFile: `${courseId}_${sessionId}.json`,
        course,
        session,
        expectedTheme: this.extractThemeFromSession(session.name),
        momentos: sessionContent.momentos || [],
        currentMomentIndex: 0,
        startTime: new Date(),
        lastActivity: new Date(),
        sessionContent,
        conversationLog: [],
        isFirstTurn: true,
        preguntasPendientes: sessionContent.momentos?.[0]?.preguntas || [],
        preguntasRespondidas: []
      };

      // Guardar sesión
      this.sessions.set(sessionKey, sessionData);
      
      console.log(`🚀 Iniciando nueva sesión: ${sessionKey}`);
      console.log(`✅ Contenido cargado desde: ${this.getSessionFilePath(courseId, sessionId)}`);
      
      return sessionKey;

    } catch (error) {
      console.error('Error iniciando sesión:', error);
      throw error;
    }
  }

  /**
   * Obtiene una sesión por clave
   */
  getSession(sessionKey: string): SessionData | undefined {
    return this.sessions.get(sessionKey);
  }

  /**
   * Actualiza una sesión
   */
  updateSession(sessionKey: string, updates: Partial<SessionData>): boolean {
    const session = this.sessions.get(sessionKey);
    if (!session) return false;

    Object.assign(session, updates);
    return true;
  }

  /**
   * Lista todas las sesiones activas
   */
  listActiveSessions(): Array<{
    sessionKey: string;
    course: string;
    session: string;
    progress: string;
  }> {
    return Array.from(this.sessions.entries()).map(([key, data]) => ({
      sessionKey: key,
      course: data.course.name,
      session: data.session.name,
      progress: `${data.currentMomentIndex + 1}/${data.momentos.length}`
    }));
  }

  /**
   * Limpia una sesión específica
   */
  clearSession(sessionKey: string): boolean {
    return this.sessions.delete(sessionKey);
  }

  /**
   * Limpia todas las sesiones
   */
  clearAllSessions(): void {
    this.sessions.clear();
  }

  /**
   * Obtiene estadísticas del cache
   */
  getCacheStats(): {
    activeSessions: number;
    cacheSize: number;
    sessionsSize: number;
  } {
    return {
      activeSessions: this.sessions.size,
      cacheSize: this.cache.size,
      sessionsSize: this.sessions.size
    };
  }

  /**
   * Limpia el cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Carga datos del curso desde la base de datos
   */
  private async loadCourseData(courseId: string): Promise<any> {
    const cacheKey = `course_${courseId}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    try {
      const filePath = path.join(__dirname, '../data/courses-database.json');
      const data = fs.readFileSync(filePath, 'utf8');
      const parsedData = JSON.parse(data);
      
      this.cache.set(cacheKey, parsedData);
      return parsedData;
    } catch (error) {
      console.error('Error cargando datos del curso:', error);
      throw error;
    }
  }

  /**
   * Carga contenido de la sesión desde archivo JSON
   */
  private async loadSessionContent(courseId: string, sessionId: string): Promise<any> {
    const cacheKey = `session_${courseId}_${sessionId}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    try {
      // Intentar múltiples rutas posibles
      const possiblePaths = [
        path.join(__dirname, '../data/sessions', `${courseId}_${sessionId}.json`),
        path.join(__dirname, '../data/sessions', `${sessionId}.json`),
        path.join(__dirname, '../data/sessions', `${courseId}_${sessionId.replace('sesion', 'sesion0')}.json`)
      ];

      let sessionData = null;
      let loadedPath = '';

      for (const filePath of possiblePaths) {
        if (fs.existsSync(filePath)) {
          const data = fs.readFileSync(filePath, 'utf8');
          sessionData = JSON.parse(data);
          loadedPath = filePath;
          break;
        }
      }

      if (!sessionData) {
        throw new Error(`No se pudo cargar el contenido de la sesión ${courseId}_${sessionId}`);
      }

      this.cache.set(cacheKey, sessionData);
      console.log(`✅ Contenido cargado desde: ${loadedPath}`);
      
      return sessionData;

    } catch (error) {
      console.error('Error cargando contenido de sesión:', error);
      throw error;
    }
  }

  /**
   * Obtiene la ruta del archivo de sesión
   */
  private getSessionFilePath(courseId: string, sessionId: string): string {
    return path.join(__dirname, '../data/sessions', `${courseId}_${sessionId}.json`);
  }

  /**
   * Extrae el tema de una sesión
   */
  private extractThemeFromSession(sessionName: string): string {
    const sessionNameLower = sessionName.toLowerCase();
    if (sessionNameLower.includes('iperc')) return 'IPERC';
    if (sessionNameLower.includes('incendio')) return 'Incendios';
    return 'Seguridad';
  }
} 
```
=== EOF: src\services\SessionManager.ts

===  src\services\PromptBuilderUniversal.ts
```typescript
// src/services/PromptBuilderUniversal.ts - Versión Universal

import { PromptParams } from '../types';

export class PromptBuilderUniversal {
  
  /**
   * Construye el prompt del espíritu (solo se envía una vez al inicio)
   */
  static buildSpiritPrompt(params: { 
    specialistRole: string; 
    sessionName: string; 
    courseName: string; 
    learningObjective: string 
  }): string {
    return `🎓 **ROL DEL DOCENTE IA:**
Eres un ${params.specialistRole} especializado en guiar el aprendizaje de manera inductiva y participativa.

**PROPÓSITO PEDAGÓGICO:**
- Guiar al estudiante a través de momentos estructurados de aprendizaje
- Hacer preguntas específicas que lleven al descubrimiento
- Validar cada respuesta antes de avanzar
- Proporcionar pistas cuando el estudiante no sabe o responde parcialmente
- Mantener engagement constante terminando siempre con una pregunta

**OBJETIVO DE LA SESIÓN:**
${params.learningObjective}

**ESTILO DE COMUNICACIÓN:**
- Tono cercano pero profesional
- Preguntas claras y específicas
- Reconocimiento de avances
- Pistas constructivas cuando sea necesario
- Nunca dar respuestas directas, guiar hacia el descubrimiento

**REGLAS FUNDAMENTALES:**
1. SIEMPRE termina tu respuesta con una pregunta (excepto en el cierre final)
2. NO avances al siguiente momento hasta que todas las preguntas estén completamente respondidas
3. Si el estudiante dice "no sé" o responde parcialmente, da pistas y repregunta
4. Valida cada respuesta antes de considerar que la pregunta está respondida
5. Mantén el foco en el momento actual, no adelantes información del siguiente`.trim();
  }

  /**
   * Construye el prompt específico para un momento - UNIVERSAL
   */
  static buildMomentPrompt(params: PromptParams & { 
    preguntasPendientes: string[];
    preguntasRespondidas: string[];
  }): string {
    const momentoActual = params.momentos[params.currentIndex];
    
    const siguiente = params.currentIndex < params.momentos.length - 1
      ? params.momentos[params.currentIndex + 1].momento
      : 'FIN';

    // Contenido específico del momento
    const contenido = this.getMomentoContent(momentoActual);
    
    // Preguntas pendientes del momento
    const preguntasPendientes = params.preguntasPendientes;
    const primeraPregunta = preguntasPendientes[0] || 'N/A';

    // 👈 NUEVO: Generar instrucciones dinámicas basadas en el tema
    const instruccionesEspecificas = this.generateDynamicInstructions(momentoActual, params);

    return `**MOMENTO ACTUAL: ${momentoActual?.momento || 'N/A'}**
**SIGUIENTE MOMENTO: ${siguiente}**

**INSTRUCCIONES PEDAGÓGICAS:**
${instruccionesEspecificas}

**CONTENIDO DEL MOMENTO:**
${contenido}

**PREGUNTAS PENDIENTES:**
${preguntasPendientes.map((p: string, idx: number) => `${idx + 1}. ${p}`).join('\n')}

📋 **INSTRUCCIONES ESTRICTAS:**
1. **SIEMPRE** comienza mostrando el contenido del momento con la frase apropiada:
   - Conexión: "Te cuento una historia: [historia]"
   - Adquisición: "Ahora vamos a aprender: [contenido técnico]"
   - Aplicación: "Te presento un caso: [caso]"
   - Otros: "[instrucciones]"

2. **DESPUÉS** haz la primera pregunta pendiente: "${primeraPregunta}"

3. **SI** el estudiante dice "no sé", "no recuerdo", "no tengo idea", etc., usa pistas relacionadas con el tema y repregunta.

4. **NO** avances al siguiente momento hasta que todas las preguntas estén completamente respondidas.

5. **SIEMPRE** termina tu respuesta con una pregunta (excepto en el cierre final).

**FORMATO DE RESPUESTA OBLIGATORIO:**
\`\`\`json
{
  "respuesta": "Tu respuesta como docente aquí",
  "momento_actual": "${momentoActual?.momento || 'N/A'}",
  "progreso": ${params.currentIndex + 1},
  "total_momentos": ${params.momentos.length},
  "debe_avanzar": false,
  "razon_avance": "Razón del avance o por qué no avanza",
  "siguiente_momento": "${siguiente}",
  "pregunta_actual": "${primeraPregunta}",
  "preguntas_pendientes": ${preguntasPendientes.length},
  "preguntas_respondidas": ${params.preguntasRespondidas.length}
}
\`\`\`

**REGLAS PARA debe_avanzar:**
- **debe_avanzar: true** → SOLO si preguntas_pendientes = 0 (todas respondidas)
- **debe_avanzar: false** → Si hay preguntas pendientes o respuestas incompletas

**NO incluyas texto fuera del JSON. NO uses markdown. SOLO el JSON.**`.trim();
  }

  /**
   * 👈 NUEVO: Genera instrucciones dinámicas basadas en el momento y tema
   */
  private static generateDynamicInstructions(momento: any, params: PromptParams): string {
    const momentoName = momento?.momento?.toLowerCase() || '';
    const tema = this.extractTemaFromParams(params);
    
    // Instrucciones base por tipo de momento
    let instruccionesBase = '';
    
    if (momentoName.includes('saludo')) {
      instruccionesBase = `Presenta el objetivo de la sesión sobre ${tema} y establece conexión con el estudiante`;
    } else if (momentoName.includes('conexión')) {
      instruccionesBase = `Conecta el tema de ${tema} con experiencias previas del estudiante usando la historia proporcionada`;
    } else if (momentoName.includes('adquisición')) {
      instruccionesBase = `Enseña los conceptos fundamentales de ${tema} de manera inductiva, guiando al descubrimiento`;
    } else if (momentoName.includes('aplicación')) {
      instruccionesBase = `Facilita la aplicación práctica de los conceptos de ${tema} usando el caso proporcionado`;
    } else if (momentoName.includes('discusión')) {
      instruccionesBase = `Facilita la comparación y análisis crítico de diferentes enfoques en ${tema}`;
    } else if (momentoName.includes('reflexión')) {
      instruccionesBase = `Guía la reflexión sobre el aprendizaje de ${tema} y su aplicación práctica`;
    } else {
      instruccionesBase = `Guía el aprendizaje del estudiante en el tema de ${tema}`;
    }

    // Agregar contexto específico del tema
    const contextoTema = this.getContextoTema(tema);
    
    return `${instruccionesBase}\n\n**CONTEXTO DEL TEMA:**\n${contextoTema}`;
  }

  /**
   * 👈 NUEVO: Extrae el tema principal de los parámetros
   */
  private static extractTemaFromParams(params: PromptParams): string {
    const sessionName = params.sessionName.toLowerCase();
    const courseName = params.courseName.toLowerCase();
    
    // Detectar tema basado en nombres
    if (sessionName.includes('incendio') || sessionName.includes('fuego')) {
      return 'prevención de incendios';
    } else if (sessionName.includes('iperc')) {
      return 'identificación de peligros y evaluación de riesgos (IPERC)';
    } else if (courseName.includes('perforación') || sessionName.includes('perforación')) {
      return 'operación de equipos de perforación';
    } else if (sessionName.includes('procedimiento') || sessionName.includes('seguridad')) {
      return 'procedimientos de seguridad';
    } else if (courseName.includes('seguridad')) {
      return 'seguridad y salud ocupacional';
    }
    
    // Tema genérico basado en el objetivo
    return params.learningObjective.split(' ').slice(0, 3).join(' ').toLowerCase();
  }

  /**
   * 👈 NUEVO: Obtiene contexto específico del tema
   */
  private static getContextoTema(tema: string): string {
    const contextualInfo = {
      'prevención de incendios': 'Enfócate en el Triángulo del Fuego, tipos de extintores, causas comunes de incendios laborales, y medidas preventivas.',
      'identificación de peligros y evaluación de riesgos (iperc)': 'Enfócate en la diferencia entre peligro y riesgo, evaluación de probabilidad y severidad, y jerarquía de controles.',
      'operación de equipos de perforación': 'Enfócate en componentes de equipos, técnicas de perforación, tipos de terreno, y procedimientos operativos.',
      'procedimientos de seguridad': 'Enfócate en equipos de protección personal (EPP), señalización, protocolos de emergencia, y buenas prácticas.',
      'seguridad y salud ocupacional': 'Enfócate en identificación de riesgos, medidas preventivas, normativas de seguridad, y cultura de seguridad.'
    };
    
    // Buscar contexto específico o usar genérico
    for (const [key, value] of Object.entries(contextualInfo)) {
      if (tema.includes(key) || key.includes(tema)) {
        return value;
      }
    }
    
    return 'Enfócate en conceptos prácticos, aplicaciones reales, y la conexión con la experiencia laboral del estudiante.';
  }

  /**
   * Extrae el contenido específico del momento
   */
  private static getMomentoContent(momento: any): string {
    if (!momento) return 'N/A';

    const momentoName = momento.momento?.toLowerCase() || '';

    // Para Conexión, mostrar la historia
    if (momentoName.includes('conexión') && momento.historia) {
      return `HISTORIA: ${momento.historia}`;
    }

    // Para Adquisición, mostrar el contenido técnico
    if (momentoName.includes('adquisición') && momento.contenido_tecnico) {
      const contenido = Array.isArray(momento.contenido_tecnico)
        ? momento.contenido_tecnico.join('\n')
        : momento.contenido_tecnico;
      return `CONTENIDO TÉCNICO:\n${contenido}`;
    }

    // Para Aplicación, mostrar el caso
    if (momentoName.includes('aplicación') && momento.caso) {
      return `CASO PRÁCTICO: ${momento.caso}`;
    }

    // Para otros momentos, mostrar las instrucciones
    const instruccionesDocente = (momento as any)["instrucciones docenteia"] 
      ?? momento.instrucciones_docenteia;
    
    if (typeof instruccionesDocente === 'string' && instruccionesDocente.trim().length > 0) {
      return `INSTRUCCIONES: ${instruccionesDocente}`;
    }

    return 'N/A';
  }

  /**
   * Valida si una respuesta es completa o evasiva - MEJORADO
   */
  static isEvasionResponse(response: string): boolean {
    const evasions = [
      'no sé', 'no se', 'no recuerdo', 'no tengo idea', 'no estoy seguro',
      'ok', 'sí', 'si', 'ajá', 'mmm', 'eh', 'bueno', 'hola', 'hi'
    ];
    
    const cleanResponse = response.toLowerCase().trim();
    
    // Detectar evasiones exactas muy cortas
    const isExactEvasion = evasions.some(evasion => cleanResponse === evasion);
    if (isExactEvasion) return true;
    
    // 👈 MEJORADO: Respuestas que indican falta de experiencia pero son honestas
    const honestResponses = [
      'no tengo experiencia', 'es nuevo para mi', 'nunca he trabajado',
      'no he visto', 'no conozco', 'es la primera vez', 'no he estado'
    ];
    
    const isHonestResponse = honestResponses.some(honest => cleanResponse.includes(honest));
    if (isHonestResponse && cleanResponse.length > 15) {
      return false; // 👈 Estas son respuestas válidas, no evasivas
    }
    
    // Detectar términos técnicos que indican conocimiento
    const technicalIndicators = [
      'incendio', 'fuego', 'extintor', 'co2', 'abc', 'agua', 'polvo', 
      'peligro', 'riesgo', 'iperc', 'control', 'prevención',
      'perforación', 'equipo', 'máquina', 'terreno', 'broca',
      'seguridad', 'epp', 'casco', 'guantes', 'procedimiento'
    ];
    
    const hasTechnicalContent = technicalIndicators.some(term => cleanResponse.includes(term));
    
    if (hasTechnicalContent && cleanResponse.length > 10) {
      return false; // No es evasiva si contiene términos técnicos
    }
    
    // Respuestas muy cortas sin contenido técnico
    const isTooShort = cleanResponse.length < 8;
    
    return isTooShort;
  }

  /**
   * Genera una pista basada en el momento y la pregunta - UNIVERSAL
   */
  static generateHint(momentoName: string, pregunta: string, tema?: string): string {
    const preguntaLower = pregunta.toLowerCase();
    
    // Pistas específicas por tipo de pregunta
    if (preguntaLower.includes('elementos') || preguntaLower.includes('identificas')) {
      return "Piensa en los componentes o elementos que observas en la situación...";
    }
    if (preguntaLower.includes('experiencia') || preguntaLower.includes('relaciona')) {
      return "Reflexiona sobre tu experiencia personal o situaciones similares que hayas visto...";
    }
    if (preguntaLower.includes('conceptos') || preguntaLower.includes('significa')) {
      return "Piensa en las ideas básicas que podrían estar relacionadas con este tema...";
    }
    if (preguntaLower.includes('prevenido') || preguntaLower.includes('evitar')) {
      return "Considera qué medidas o acciones podrían haber cambiado el resultado...";
    }
    if (preguntaLower.includes('aplicarías') || preguntaLower.includes('harías')) {
      return "Piensa en los pasos concretos que seguirías usando lo que hemos aprendido...";
    }
    
    // Pista genérica contextualizada
    const temaContext = tema ? ` sobre ${tema}` : '';
    return `Reflexiona sobre lo que sabes${temaContext} y compárteme tus ideas, aunque sean básicas...`;
  }
} 
```
=== EOF: src\services\PromptBuilderUniversal.ts

===  src\services\OpenAIService.ts
```typescript
import { OpenAI } from 'openai';
import { OpenAICallParams, OpenAICallResult } from '../types';
import { CostMonitor } from './CostMonitor';

export class OpenAIService {
  private client: OpenAI;
  private costMonitor: CostMonitor;

  constructor(apiKey: string) {
    this.client = new OpenAI({ apiKey });
    this.costMonitor = new CostMonitor();
  }

  /**
   * Llama a la API de OpenAI con parámetros optimizados
   */
  async callOpenAI(params: OpenAICallParams): Promise<OpenAICallResult> {
    const model = params.model || this.getOptimalModel(params.systemPrompt);
    const maxTokens = Math.floor(params.maxTokens || this.calculateOptimalTokens(params.systemPrompt));

    try {
      const response = await this.client.responses.create({
        model,
        instructions: params.systemPrompt,
        input: params.userPrompt,
        max_output_tokens: maxTokens
      });

      const metrics = this.costMonitor.calculateMetrics(
        { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }, // OpenAI no devuelve usage en responses API
        model
      );
      this.costMonitor.logUsage(metrics);

      return { response, metrics };
    } catch (error) {
      console.error('Error en llamada a OpenAI:', error);
      throw error;
    }
  }

  /**
   * Selecciona el modelo óptimo basado en la complejidad del prompt
   */
  private getOptimalModel(systemPrompt: string): string {
    const tokenCount = systemPrompt.length / 4; // Estimación aproximada
    
    // Para prompts simples, usar gpt-3.5-turbo
    if (tokenCount < 800) {
      return 'gpt-3.5-turbo';
    }
    
    // Para prompts complejos, usar gpt-4o
    return 'gpt-4o';
  }

  /**
   * Calcula tokens óptimos basado en la complejidad
   */
  private calculateOptimalTokens(systemPrompt: string): number {
    const baseTokens = 600;
    const complexity = systemPrompt.length / 1000;
    
    // Limitar entre 400 y 1000 tokens y convertir a entero
    return Math.floor(Math.min(Math.max(baseTokens + (complexity * 100), 400), 1000));
  }



  /**
   * Obtiene estadísticas de costo
   */
  getCostStats() {
    return this.costMonitor.getCostStats();
  }

  /**
   * Limpia costos de una sesión
   */
  clearSessionCost(sessionKey: string): void {
    this.costMonitor.clearSessionCost(sessionKey);
  }

  /**
   * Limpia todos los costos
   */
  clearAllCosts(): void {
    this.costMonitor.clearAllCosts();
  }

  /**
   * Agrega costo a una sesión específica
   */
  addSessionCost(sessionKey: string, cost: number): void {
    this.costMonitor.addSessionCost(sessionKey, cost);
  }

  /**
   * Obtiene el cliente OpenAI (para uso interno)
   */
  getClient(): OpenAI {
    return this.client;
  }
} 
```
=== EOF: src\services\OpenAIService.ts

===  src\services\CostMonitor.ts
```typescript
import { CostMetrics } from '../types';

export class CostMonitor {
  private static readonly COSTS = {
    'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 },
    'gpt-4o': { input: 0.005, output: 0.015 },
    'gpt-4o-mini': { input: 0.00015, output: 0.0006 }
  };

  private sessionCosts = new Map<string, number>();
  private totalCost = 0;
  private totalTokens = 0;

  /**
   * Calcula métricas de costo basadas en el uso de tokens
   */
  calculateMetrics(usage: any, model: string): CostMetrics {
    const costs = CostMonitor.COSTS[model as keyof typeof CostMonitor.COSTS];
    if (!costs) {
      console.warn(`Modelo ${model} no encontrado en costos, usando gpt-3.5-turbo`);
      return this.calculateMetrics(usage, 'gpt-3.5-turbo');
    }

    const estimatedCost = (usage.prompt_tokens * costs.input + usage.completion_tokens * costs.output) / 1000;

    return {
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
      total_tokens: usage.total_tokens,
      estimated_cost: estimatedCost,
      model_used: model
    };
  }

  /**
   * Registra el uso de tokens y costo
   */
  logUsage(metrics: CostMetrics, sessionKey?: string): void {
    console.log(`💰 Costo estimado: $${metrics.estimated_cost.toFixed(4)}`);
    console.log(`📊 Tokens: ${metrics.prompt_tokens} + ${metrics.completion_tokens} = ${metrics.total_tokens}`);
    console.log(`🤖 Modelo: ${metrics.model_used}`);

    // Actualizar totales
    this.totalCost += metrics.estimated_cost;
    this.totalTokens += metrics.total_tokens;

    // Actualizar costo por sesión
    if (sessionKey) {
      this.addSessionCost(sessionKey, metrics.estimated_cost);
    }
  }

  /**
   * Obtiene el costo total de una sesión
   */
  getSessionCost(sessionKey: string): number {
    return this.sessionCosts.get(sessionKey) || 0;
  }

  /**
   * Agrega costo a una sesión específica
   */
  addSessionCost(sessionKey: string, cost: number): void {
    const current = this.sessionCosts.get(sessionKey) || 0;
    this.sessionCosts.set(sessionKey, current + cost);
  }

  /**
   * Obtiene estadísticas de costo
   */
  getCostStats(): { totalCost: number; totalTokens: number; sessionCosts: Map<string, number> } {
    return {
      totalCost: this.totalCost,
      totalTokens: this.totalTokens,
      sessionCosts: this.sessionCosts
    };
  }

  /**
   * Limpia los costos de una sesión
   */
  clearSessionCost(sessionKey: string): void {
    this.sessionCosts.delete(sessionKey);
  }

  /**
   * Limpia todos los costos
   */
  clearAllCosts(): void {
    this.sessionCosts.clear();
    this.totalCost = 0;
    this.totalTokens = 0;
  }

  /**
   * Obtiene el costo promedio por sesión
   */
  getAverageSessionCost(): number {
    if (this.sessionCosts.size === 0) return 0;
    const totalSessionCost = Array.from(this.sessionCosts.values()).reduce((sum, cost) => sum + cost, 0);
    return totalSessionCost / this.sessionCosts.size;
  }
} 
```
=== EOF: src\services\CostMonitor.ts

===  src\scripts\package.json
```json
{
  "type": "commonjs"
} 
```
=== EOF: src\scripts\package.json

===  src\scripts\chat-v2.ts
```typescript
import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import { SessionExtractorUniversal } from '../lib/SessionExtractorUniversal';
import { Course, Session } from '../types';
import * as dotenv from 'dotenv';

// Configurar variables de entorno
dotenv.config({ path: path.join(__dirname, '../../.env.local') });

// Colores para la terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Estado global de la conversación
interface ConversationState {
  selectedCourse: Course | null;
  selectedSession: Session | null;
  sessionExtractor: SessionExtractorUniversal | null;
  currentSessionKey: string | null;
  momentoActual: number;
  momentos: any[];
  messages: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp: Date;
  }>;
  isInClass: boolean;
}

const conversationState: ConversationState = {
  selectedCourse: null,
  selectedSession: null,
  sessionExtractor: null,
  currentSessionKey: null,
  momentoActual: 0,
  momentos: [],
  messages: [],
  isInClass: false
};

// Función para imprimir con colores
function print(color: keyof typeof colors, text: string): void {
  console.log(`${colors[color]}${text}${colors.reset}`);
}

// Función para cargar la base de datos de cursos
function loadCoursesDatabase(): any {
  try {
    const filePath = path.join(__dirname, '../data/courses-database.json');
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch {
    print('red', '❌ Error cargando la base de datos de cursos');
    return null;
  }
}

// Función para mostrar cursos disponibles
function showCourses(): void {
  const data = loadCoursesDatabase();
  if (!data || !data.courses) return;
  
  print('cyan', '\n📚 Cursos Disponibles:');
  data.courses.forEach((course: Course, index: number) => {
    print('white', `${index + 1}. ${course.id} - ${course.name}`);
    print('yellow', `   👨‍🏫 ${course.specialist_role}`);
    print('yellow', `   📊 ${course.sessions.length} sesiones disponibles`);
  });
  print('yellow', '\n💡 Usa: /select <curso> <sesión> para seleccionar');
  print('yellow', '   Ejemplo: /select SSO001 1');
}

// Función para seleccionar curso y sesión
async function selectCourse(courseId: string, sessionNumber: number): Promise<void> {
  try {
    const sessionId = `sesion0${sessionNumber}`;
    
    // Cargar datos del curso desde la base de datos
    const data = loadCoursesDatabase();
    if (!data || !data.courses) {
      console.error('❌ No se pudo cargar la base de datos de cursos');
      return;
    }
  
    const course = data.courses.find((c: Course) => c.id === courseId);
    if (!course) {
      console.error(`❌ Curso ${courseId} no encontrado`);
      return;
    }
  
    // Validar que el número de sesión sea válido
    if (sessionNumber < 1 || sessionNumber > course.sessions.length) {
      console.error(`❌ Sesión ${sessionNumber} no encontrada. Sesiones disponibles: 1-${course.sessions.length}`);
      return;
    }
  
    const session = course.sessions[sessionNumber - 1];
    if (!session) {
      console.error(`❌ Sesión ${sessionNumber} no encontrada`);
      return;
    }
    
    // Actualizar estado de la conversación
    conversationState.selectedCourse = course;
    conversationState.selectedSession = session;
    
    console.log(`✅ Curso seleccionado: ${course.name}`);
    console.log(`✅ Sesión seleccionada: ${session.name}`);
    console.log(`✅ Especialista: ${course.specialist_role}`);
    console.log(`✅ Objetivo: ${session.learning_objective}`);
    console.log(`📁 Archivo de sesión: ${courseId}_${sessionId}.json`);

    // Inicializar el extractor universal
    conversationState.sessionExtractor = new SessionExtractorUniversal();
    
    console.log(`🚀 Iniciando sesión...`);
    
    // 👈 CAMBIADO: Usar startSession que devuelve mensaje inicial
    const sessionInfo = await conversationState.sessionExtractor.startSession(courseId, sessionId);
    conversationState.currentSessionKey = sessionInfo.sessionKey;
    
    console.log(`✅ Sesión iniciada: ${sessionInfo.momentos} momentos`);
    console.log(`✅ Clave de sesión: ${sessionInfo.sessionKey}`);
    console.log(`✅ Momento actual: ${sessionInfo.currentMoment}`);

    // 👈 NUEVO: Mostrar mensaje inicial del docente
    print('green', `\n🎓 ${course.specialist_role}:`);
    print('white', sessionInfo.initialMessage);

    // Obtener momentos para mostrar estructura
    const sessionData = conversationState.sessionExtractor.getSessionInfo(sessionInfo.sessionKey);
    conversationState.momentos = sessionData?.momentos || [];
    conversationState.momentoActual = 0;

    console.log(`📄 Momentos extraídos: ${conversationState.momentos.length}`);
    console.log(`🔗 Estructura de la clase:`);
    conversationState.momentos.forEach((momento: any, index: number) => {
      console.log(`   ${index + 1}. ${momento.momento}`);
    });

    // 👈 NUEVO: Marcar que ya estamos en clase
    conversationState.isInClass = true;
    print('cyan', `\n✅ ¡Clase iniciada! Puedes responder directamente al docente.`);

  } catch (error) {
    console.error(`❌ Error seleccionando curso: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

// Función para procesar mensajes del estudiante
async function processStudentMessage(message: string): Promise<void> {
  if (!conversationState.selectedCourse || !conversationState.selectedSession || !conversationState.currentSessionKey) {
    print('red', '❌ Debes seleccionar un curso y sesión primero con /select');
    return;
  }

  try {
    print('cyan', `\n👤 Estudiante: ${message}`);

    // Usar el método simplificado
    const respuesta = await conversationState.sessionExtractor!.handleStudent(
      conversationState.currentSessionKey, 
      message
    );

    // Actualizar estado de la conversación
    conversationState.momentoActual = respuesta.progreso - 1; // Convertir progreso a índice

    // Agregar mensajes al historial
    conversationState.messages.push({
      role: 'user',
      content: message,
      timestamp: new Date()
    });
    conversationState.messages.push({
      role: 'assistant',
      content: respuesta.respuesta,
      timestamp: new Date()
    });

    // Mostrar respuesta del docente
    print('green', `\n📁 ${conversationState.selectedCourse.specialist_role}:`);
    print('white', respuesta.respuesta);
    print('cyan', `🚀 Progreso: ${respuesta.progreso}/${respuesta.total_momentos}`);
    print('cyan', `📁 Momento actual: ${respuesta.momento_actual}`);
    print('cyan', `📁 ${respuesta.razon_avance}`);
    print('yellow', `⏭️ Siguiente: ${respuesta.siguiente_momento}`);

  } catch (error) {
    print('red', `❌ Error procesando mensaje: ${error instanceof Error ? error.message : 'Error desconocido'}`);
  }
}

// Función para mostrar el progreso actual
function showProgress(): void {
  if (!conversationState.selectedCourse || !conversationState.selectedSession) {
    print('red', '❌ No estás en una clase');
    return;
  }

  print('cyan', '\n📊 PROGRESO DE LA SESIÓN:');
  print('white', `📁 Curso: ${conversationState.selectedCourse.name}`);
  print('white', `📚 Sesión: ${conversationState.selectedSession.name}`);
  print('white', `👨‍🏫 Especialista: ${conversationState.selectedCourse.specialist_role}`);
  print('white', `   Sesión activa: ${conversationState.currentSessionKey || 'N/A'}`);
  
  // Mostrar estadísticas del sistema si hay extractor
  if (conversationState.sessionExtractor) {
    const stats = conversationState.sessionExtractor.getCacheStats();
    print('cyan', `\n📊 ESTADÍSTICAS DEL SISTEMA:`);
    print('white', `   🎓 Sesiones activas: ${stats.activeSessions}`);
    print('white', `   💾 Cache: ${stats.cacheSize} elementos`);
    print('white', `   🎓 Tamaño de sesiones: ${stats.sessionsSize}`);
  } else {
    print('red', '❌ No hay extractor inicializado');
  }
  
  if (conversationState.messages && conversationState.messages.length > 0) {
    print('cyan', `\n💬 Mensajes intercambiados: ${conversationState.messages.length}`);
  }
}

// Función para procesar comandos
async function processCommand(input: string): Promise<void> {
  const parts = input.trim().split(' ');
  const command = parts[0];
  
  switch (command) {
    case '/select':
      if (parts.length < 3) {
        print('red', '❌ Uso: /select <courseId> <sessionNumber>');
        print('yellow', '   Ejemplo: /select SSO001 1');
        return;
      }
      const courseId = parts[1];
      const sessionNumber = parseInt(parts[2]);
      await selectCourse(courseId, sessionNumber);
      break;
      
    case '/start':
      if (!conversationState.selectedCourse || !conversationState.selectedSession) {
        print('red', '❌ Debes seleccionar un curso y sesión primero con /select');
        return;
      }
      conversationState.isInClass = true;
      print('green', `💾 ¡Bienvenido a la clase de ${conversationState.selectedSession.name}!`);
      print('cyan', `🧠 Docente IA especializado cargado`);
      print('cyan', `📁 Contenido cargado desde archivo JSON`);
      print('cyan', `⚡ Interfaz interactiva lista`);
      print('cyan', `🔗🏫🏫 ¡Hola! Soy tu ${conversationState.selectedCourse.specialist_role}`);
      print('cyan', `🚀 Hoy aprenderemos sobre: ${conversationState.selectedSession.name}`);
      print('cyan', `🚀 Objetivo: ${conversationState.selectedSession.learning_objective}`);
      print('cyan', `📁 Empezaremos con: MOMENTO_0`);
      print('cyan', `👤 ¡Escribe tu mensaje para comenzar la interacción!`);
      break;
      
    case '/sessions':
          if (conversationState.sessionExtractor) {
      const sessions = conversationState.sessionExtractor.listActiveSessions();
        if (sessions.length === 0) {
          print('yellow', '📋 No hay sesiones activas');
        } else {
          print('cyan', '📋 Sesiones activas:');
          sessions.forEach(session => {
            print('white', `   ${session.sessionKey}: ${session.course} - ${session.session} (${session.progress})`);
          });
        }
      } else {
        print('red', '❌ No hay extractor inicializado');
      }
      break;

    case '/clear-session':
      if (parts.length < 2) {
        print('red', '❌ Uso: /clear-session <sessionKey>');
        return;
      }
      if (conversationState.sessionExtractor) {
        const sessionKey = parts[1];
        const cleared = conversationState.sessionExtractor.clearSession(sessionKey);
        print(cleared ? 'green' : 'red', `✅ Sesión ${sessionKey} eliminada`);
      }
      break;

    case '/clear-all-sessions':
      if (conversationState.sessionExtractor) {
        conversationState.sessionExtractor.clearAllSessions();
        print('green', '✅ Todas las sesiones eliminadas');
      }
      break;
      
    case '/progress':
      showProgress();
      break;
      
    case '/stats':
      if (conversationState.sessionExtractor) {
        const stats = conversationState.sessionExtractor.getCacheStats();
        print('cyan', '\n📊 ESTADÍSTICAS DEL SISTEMA:');
        print('white', `   🎓 Sesiones activas: ${stats.activeSessions}`);
        print('white', `   💾 Tamaño del cache: ${stats.cacheSize}`);
        print('white', `   🎓 Tamaño de sesiones: ${stats.sessionsSize}`);
      } else {
        print('red', '❌ No hay extractor inicializado');
      }
      break;
      
    case '/reset':
      conversationState.selectedCourse = null;
      conversationState.selectedSession = null;
      conversationState.sessionExtractor = null;
      conversationState.currentSessionKey = null;
      conversationState.momentoActual = 0;
      conversationState.momentos = [];
      conversationState.messages = [];
      conversationState.isInClass = false;
      print('green', '✅ Estado de conversación reiniciado');
      break;
      
    case '/help':
      showHelp();
      break;
      
    case '/exit':
      print('yellow', '👋 ¡Hasta luego!');
      process.exit(0);
      break;
      
    default:
      print('red', `❌ Comando no reconocido. Usa /help para ver comandos disponibles.`);
  }
}

// Función para mostrar ayuda
function showHelp(): void {
  print('cyan', '\n📚 DOCENTEIA - COMANDOS DISPONIBLES:');
  print('white', '\n🎯 SELECCIÓN Y CONTROL:');
  print('yellow', '   /select <courseId> <sessionNumber>  - Seleccionar curso y sesión');
  print('yellow', '   /start                              - Iniciar la clase interactiva');
  print('yellow', '   /reset                              - Reiniciar estado de conversación');

  print('white', '\n📋 GESTIÓN DE SESIONES:');
  print('yellow', '   /sessions                           - Listar sesiones activas');
  print('yellow', '   /clear-session <sessionKey>         - Eliminar sesión específica');
  print('yellow', '   /clear-all-sessions                 - Eliminar todas las sesiones');

  print('white', '\n📊 INFORMACIÓN:');
  print('yellow', '   /progress                           - Mostrar progreso actual');
  print('yellow', '   /stats                              - Estadísticas del sistema');
  print('yellow', '   /help                               - Mostrar esta ayuda');

  print('white', '\n💬 INTERACCIÓN:');
  print('yellow', '   Escribe cualquier mensaje para interactuar con el docente IA');
  print('yellow', '   El sistema avanzará automáticamente entre momentos según tu progreso');

  print('cyan', '\n⚡ CARACTERÍSTICAS OPTIMIZADAS:');
  print('white', '   • Fragmentos pre-calculados para respuestas más rápidas');
  print('white', '   • Gestión inteligente de sesiones');
  print('white', '   • Coordinación automática del avance de la clase');
  print('white', '   • Cache optimizado para mejor rendimiento');
  print('white', '   • Control de costos en tiempo real');
  print('white', '   • Selección dinámica de modelos');
}

// Función principal del chat
function startChat(): void {
  // Crear interfaz de readline
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });
  
  print('cyan', '🤖 Chat Terminal - DocenteIA v3.0 (TypeScript + Optimizaciones)');
  print('cyan', 'Escribe /help para ver comandos\n');
  
  // Mostrar cursos disponibles
  showCourses();
  
  // Loop principal de conversación
  const askQuestion = () => {
    rl.question(`${colors.green}👤 Tú: ${colors.reset}`, async (input) => {
      const trimmedInput = input.trim();
      
      if (!trimmedInput) {
        askQuestion();
        return;
      }
      
      // Procesar comandos
      if (trimmedInput.startsWith('/')) {
        await processCommand(trimmedInput);
        askQuestion();
        return;
      }
      
      // Si estamos en clase, procesar como mensaje del estudiante
      if (conversationState.isInClass) {
        await processStudentMessage(trimmedInput);
      } else {
        print('yellow', '💡 Usa /select para elegir un curso y sesión, luego /start para iniciar la clase');
      }
      
      askQuestion();
    });
  };
  
  askQuestion();
}

// Manejar señales de salida
process.on('SIGINT', () => {
  print('green', '\n👋 ¡Hasta luego!');
  process.exit(0);
});

// Iniciar el chat
startChat(); 
```
=== EOF: src\scripts\chat-v2.ts

===  src\lib\utils.ts
```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("es-ES", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date)
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
} 
```
=== EOF: src\lib\utils.ts

===  src\lib\SessionExtractorUniversal.ts
```typescript
// src/lib/SessionExtractorUniversal.ts - Versión Corregida

import { AIResponse } from '../types';
import { OpenAIService } from '../services/OpenAIService';
import { SessionManager } from '../services/SessionManager';
import { PromptBuilderUniversal } from '../services/PromptBuilderUniversal';

export class SessionExtractorUniversal {
  private openAIService: OpenAIService;
  private sessionManager: SessionManager;
  private intentosEvasion: Map<string, number> = new Map();

  constructor() {
    this.openAIService = new OpenAIService(process.env.OPENAI_API_KEY!);
    this.sessionManager = new SessionManager();
  }

  /**
   * Inicia una sesión y GENERA EL PRIMER MENSAJE DEL DOCENTE
   */
  async startSession(courseId: string, sessionId: string): Promise<{
    sessionKey: string;
    momentos: number;
    currentMoment: string;
    initialMessage: string; // 👈 NUEVO: mensaje inicial del docente
  }> {
    try {
      const sessionKey = await this.sessionManager.startSession(courseId, sessionId);
      const session = this.sessionManager.getSession(sessionKey);
      
      if (!session) {
        throw new Error('Error iniciando sesión');
      }

      console.log(`🚀 Iniciando sesión: ${session.course.name} - ${session.session.name}`);

      // 👈 NUEVO: Generar mensaje inicial del docente
      const initialMessage = await this.generateInitialMessage(sessionKey);

      return {
        sessionKey,
        momentos: session.momentos.length,
        currentMoment: session.momentos[0]?.momento || 'N/A',
        initialMessage // 👈 Incluir mensaje inicial
      };

    } catch (error) {
      console.error('Error iniciando sesión:', error);
      throw error;
    }
  }

  /**
   * 👈 NUEVO: Genera el mensaje inicial del docente
   */
  private async generateInitialMessage(sessionKey: string): Promise<string> {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) return "Error cargando sesión";
    
    // Construir prompt inicial
    const spiritPrompt = PromptBuilderUniversal.buildSpiritPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective
    });

    const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective,
      keyPoints: session.session.key_points,
      momentos: session.momentos,
      currentIndex: 0,
      preguntasPendientes: session.preguntasPendientes,
      preguntasRespondidas: session.preguntasRespondidas
    });

    const systemPrompt = `${spiritPrompt}\n\n${momentPrompt}`;
    
    const { response } = await this.openAIService.callOpenAI({
      systemPrompt,
      userPrompt: "Inicia la clase con el saludo pedagógico apropiado",
      model: 'gpt-3.5-turbo'
    });

    const parsedResponse = this.parseAIResponse(response.output_text);
    
    // Marcar que ya no es el primer turno
    this.sessionManager.updateSession(sessionKey, { isFirstTurn: false });

    // Guardar mensaje inicial en conversationLog
    session.conversationLog.push({
      role: 'assistant',
      content: parsedResponse?.respuesta || response.output_text,
      timestamp: new Date()
    });

    return parsedResponse?.respuesta || response.output_text;
  }

  /**
   * Maneja la interacción del estudiante con lógica mejorada
   */
  async handleStudent(sessionKey: string, studentMessage: string): Promise<AIResponse> {
    try {
      const session = this.sessionManager.getSession(sessionKey);
      if (!session) {
        throw new Error(`Sesión ${sessionKey} no encontrada`);
      }

      this.sessionManager.updateSession(sessionKey, { lastActivity: new Date() });

      console.log(`🎓 ${session.course.specialist_role} respondiendo...`);

      // Guardar mensaje del estudiante
      session.conversationLog.push({
        role: 'user',
        content: studentMessage,
        timestamp: new Date()
      });

      // Obtener el momento actual
      const momentoActual = session.momentos[session.currentMomentIndex] || null;
      const siguienteMomento = session.momentos[session.currentMomentIndex + 1] || null;

      // Construir historial (últimas 6 interacciones)
      const MAX_HISTORIA = 6;
      const historialRecortado = session.conversationLog
        .slice(-MAX_HISTORIA)
        .map(m => `${m.role === 'user' ? 'Estudiante' : 'Docente'}: "${m.content}"`)
        .join('\n');

      // Construir prompt del momento
      const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
        specialistRole: session.course.specialist_role,
        sessionName: session.session.name,
        courseName: session.course.name,
        learningObjective: session.session.learning_objective,
        keyPoints: session.session.key_points,
        momentos: session.momentos,
        currentIndex: session.currentMomentIndex,
        preguntasPendientes: session.preguntasPendientes,
        preguntasRespondidas: session.preguntasRespondidas
      });

      let finalSystemPrompt = '';
      
      // Agregar historial si existe
      if (historialRecortado.trim()) {
        finalSystemPrompt += `HISTORIAL RECIENTE DE LA CLASE:\n${historialRecortado}\n\n`;
      }

      finalSystemPrompt += momentPrompt;

      // Llamar a OpenAI
      const { response, metrics } = await this.openAIService.callOpenAI({
        systemPrompt: finalSystemPrompt,
        userPrompt: studentMessage,
        model: 'gpt-3.5-turbo'
      });

      this.openAIService.clearSessionCost(sessionKey);
      this.openAIService.addSessionCost(sessionKey, metrics.estimated_cost);

      // Parsear respuesta
      let parsedResponse = this.parseAIResponse(response.output_text);
      
      if (!parsedResponse || typeof parsedResponse !== 'object') {
        parsedResponse = {
          respuesta: response.output_text,
          momento_actual: momentoActual ? momentoActual.momento : 'N/A',
          progreso: session.currentMomentIndex + 1,
          total_momentos: session.momentos.length,
          debe_avanzar: false,
          razon_avance: "Respuesta no estructurada",
          siguiente_momento: siguienteMomento ? siguienteMomento.momento : 'FIN',
          pregunta_actual: session.preguntasPendientes[0] || 'N/A',
          preguntas_pendientes: session.preguntasPendientes.length,
          preguntas_respondidas: session.preguntasRespondidas.length
        };
      }

      // 👈 MEJORAR: Procesar respuesta del estudiante con lógica más inteligente
      this.processStudentResponseImproved(sessionKey, studentMessage, parsedResponse);

      // Asegurar que termina con pregunta (excepto en cierre final)
      const siguienteMomentoCheck = session.momentos[session.currentMomentIndex + 1];
      const isLastMoment = !siguienteMomentoCheck;
      
      if (!isLastMoment && !parsedResponse.respuesta.trim().endsWith("?")) {
        const nextQuestion = session.preguntasPendientes[0] || "¿Puedes elaborar más tu respuesta?";
        parsedResponse.respuesta = `${parsedResponse.respuesta.trim()} ${nextQuestion}`;
        console.log(`❓ Forzando pregunta al final: "${nextQuestion}"`);
      }

      // Guardar respuesta del docente
      session.conversationLog.push({
        role: 'assistant',
        content: parsedResponse.respuesta,
        timestamp: new Date()
      });

      // Control de avance: Solo avanza si no hay preguntas pendientes
      if (session.preguntasPendientes.length > 0) {
        parsedResponse.debe_avanzar = false;
        parsedResponse.razon_avance = `Aún hay ${session.preguntasPendientes.length} pregunta(s) pendiente(s)`;
        console.log(`🚫 Bloqueando avance: ${session.preguntasPendientes.length} preguntas pendientes`);
      }

      // Avanzar si debe avanzar
      if (parsedResponse.debe_avanzar && session.currentMomentIndex < session.momentos.length - 1) {
        const nuevoIndice = session.currentMomentIndex + 1;
        const nuevoMomento = session.momentos[nuevoIndice];
        
        this.sessionManager.updateSession(sessionKey, {
          currentMomentIndex: nuevoIndice,
          preguntasPendientes: nuevoMomento?.preguntas || [],
          preguntasRespondidas: []
        });
        
        console.log(`💾 Avanzando al momento ${nuevoIndice + 1}: ${nuevoMomento?.momento}`);
        
        return await this.generateNewMomentResponse(sessionKey, nuevoIndice);
      } else if (parsedResponse.debe_avanzar) {
        console.log(`🎉 ¡Clase completada! Todos los momentos han sido cubiertos.`);
      }

      return {
        ...parsedResponse,
        momentos: session.momentos,
        sessionKey
      };

    } catch (error) {
      console.error('Error en respuesta del docente:', error);
      return {
        respuesta: "Lo siento, tuve un problema generando la respuesta. ¿Podrías reformular tu pregunta?",
        momento_actual: 'ERROR',
        progreso: 0,
        total_momentos: 0,
        debe_avanzar: false,
        razon_avance: "Error en el sistema",
        siguiente_momento: 'ERROR',
        momentos: [],
        sessionKey
      };
    }
  }

  /**
   * 👈 MEJORADO: Procesa la respuesta del estudiante con mejor lógica
   */
  private processStudentResponseImproved(sessionKey: string, studentMessage: string, aiResponse: any): void {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) return;

    const preguntaActual = session.preguntasPendientes[0];
    if (!preguntaActual) return;

    // 👈 MEJORADO: Verificar si la respuesta es válida (menos estricto)
    const isValidResponse = this.isValidResponse(studentMessage);
    
    if (isValidResponse) {
      // Respuesta válida - mover pregunta de pendiente a respondida
      const nuevasPendientes = session.preguntasPendientes.slice(1);
      const nuevasRespondidas = [...session.preguntasRespondidas, preguntaActual];
      
      this.sessionManager.updateSession(sessionKey, {
        preguntasPendientes: nuevasPendientes,
        preguntasRespondidas: nuevasRespondidas
      });
      
      console.log(`✅ Pregunta respondida: "${preguntaActual}"`);
      console.log(`📋 Preguntas pendientes: ${nuevasPendientes.length}`);
      
      // Si no hay más preguntas pendientes, preparar transición
      if (nuevasPendientes.length === 0) {
        console.log(`🎯 ¡Todas las preguntas del momento respondidas! Preparando transición...`);
        aiResponse.debe_avanzar = true;
        aiResponse.razon_avance = "Todas las preguntas del momento han sido respondidas completamente";
      }
    } else {
      console.log(`⚠️ Respuesta que necesita ayuda: "${studentMessage}"`);
      
      // Ayudar al estudiante a resolver la pregunta
      const momentoActual = session.momentos[session.currentMomentIndex];
      const momentoKey = momentoActual?.momento || '';
      const intentosActuales = this.intentosEvasion.get(momentoKey) || 0;
      this.intentosEvasion.set(momentoKey, intentosActuales + 1);
      
      const ayudaRespuesta = this.buildHelpfulResponseImproved(studentMessage, preguntaActual, momentoKey);
      
      aiResponse.respuesta = ayudaRespuesta;
      aiResponse.debe_avanzar = false;
      aiResponse.razon_avance = "Ayudando al estudiante a resolver la pregunta";
      
      console.log(`🔄 Ayudando al estudiante (intento ${intentosActuales + 1}): "${ayudaRespuesta.substring(0, 50)}..."`);
    }
  }

  /**
   * 👈 MEJORADO: Detecta si una respuesta es válida (menos estricto)
   */
  private isValidResponse(response: string): boolean {
    const cleanResponse = response.toLowerCase().trim();
    
    // Respuestas claramente evasivas
    const obvioussEvasions = [
      'no sé', 'no se', 'no recuerdo', 'no tengo idea',
      'ok', 'sí', 'si', 'ajá', 'mmm', 'eh', 'bueno', 
      'hola', 'hi', 'otra vez', 'la misma pregunta'
    ];
    
    // Si es una evasión obvia y muy corta
    if (obvioussEvasions.includes(cleanResponse) && cleanResponse.length < 10) {
      return false;
    }
    
    // Si la respuesta tiene más de 15 caracteres, probablemente es válida
    if (cleanResponse.length > 15) {
      return true;
    }
    
    // Detectar respuestas que indican falta de experiencia pero son honestas
    const honestResponses = [
      'no tengo experiencia', 'es nuevo para mi', 'nunca he trabajado',
      'no he visto', 'no conozco', 'es la primera vez'
    ];
    
    const isHonestResponse = honestResponses.some(honest => cleanResponse.includes(honest));
    if (isHonestResponse) {
      return true; // 👈 Estas son respuestas válidas, no evasivas
    }
    
    // Para respuestas muy cortas, considerar evasivas
    return cleanResponse.length >= 8;
  }

  /**
   * 👈 MEJORADO: Construye respuesta de ayuda más inteligente
   */
  private buildHelpfulResponseImproved(studentMessage: string, preguntaActual: string, momentoName: string): string {
    const cleanMessage = studentMessage.toLowerCase();
    
    // Si el estudiante dice que no tiene experiencia, eso es válido
    if (cleanMessage.includes('no tengo experiencia') || cleanMessage.includes('es nuevo para mi')) {
      return `Perfecto, no hay problema en no tener experiencia previa. Te ayudo a pensar: ${preguntaActual}`;
    }
    
    // Si dice que no sabe algo específico
    if (cleanMessage.includes('no sé') || cleanMessage.includes('no se')) {
      return this.buildUniversalHelpResponse(preguntaActual, momentoName);
    }
    
    // Si es una respuesta muy corta
    if (cleanMessage.length < 10) {
      return `Entiendo. Te ayudo a pensar más específicamente: ${preguntaActual}`;
    }
    
    // Respuesta por defecto
    return `Veo que tienes algunas ideas. ¿Puedes contarme más específicamente sobre ${preguntaActual.toLowerCase()}?`;
  }

  /**
   * 👈 NUEVO: Construye respuesta de ayuda universal para cualquier curso/tema
   */
  private buildUniversalHelpResponse(preguntaActual: string, momentoName: string): string {
    const session = this.sessionManager.getSession(Array.from(this.sessionManager['sessions'].keys())[0]);
    if (!session) return `Te ayudo a pensar: ${preguntaActual}`;
    
    const intentos = this.intentosEvasion.get(momentoName) || 0;
    const tema = this.extractTemaFromSession(session);
    
    // Generar pistas dinámicas basadas en el tema del curso
    const pistasGenericas = this.generateDynamicHints(preguntaActual, tema, momentoName, intentos);
    
    return pistasGenericas;
  }

  /**
   * 👈 NUEVO: Extrae el tema principal del curso dinámicamente
   */
  private extractTemaFromSession(session: any): string {
    // Extraer tema de keywords de la sesión
    const keywords = session.session.theme_keywords || [];
    const temaFromKeywords = keywords.join(' ').toLowerCase();
    
    // Extraer tema del nombre del curso y sesión
    const courseName = session.course.name.toLowerCase();
    const sessionName = session.session.name.toLowerCase();
    
    // Determinar tema principal
    if (temaFromKeywords.includes('incendio') || sessionName.includes('incendio')) {
      return 'incendios';
    } else if (temaFromKeywords.includes('iperc') || sessionName.includes('iperc')) {
      return 'iperc';
    } else if (temaFromKeywords.includes('perforación') || courseName.includes('perforación')) {
      return 'perforación';
    } else if (courseName.includes('seguridad')) {
      return 'seguridad';
    } else if (temaFromKeywords.includes('procedimiento') || sessionName.includes('procedimiento')) {
      return 'procedimientos';
    }
    
    return 'general'; // Tema por defecto
  }

  /**
   * 👈 NUEVO: Genera pistas dinámicas basadas en el tema y momento
   */
  private generateDynamicHints(pregunta: string, tema: string, momentoName: string, intentos: number): string {
    const momentoLower = momentoName.toLowerCase();
    
    // Pistas específicas por tema
    const temaHints = this.getHintsByTema();
    
    // Pistas específicas por momento
    const momentoHints = this.getHintsByMomento(momentoLower, tema);
    
    // Combinar y rotar pistas
    const allHints = [...temaHints, ...momentoHints];
    const hintIndex = intentos % allHints.length;
    
    return allHints[hintIndex] || `Te ayudo a pensar: ${pregunta}`;
  }

  /**
   * 👈 NUEVO: Obtiene pistas específicas por tema del curso
   */
  private getHintsByTema(): string[] {
    // Hints universales que funcionan para cualquier curso o tema
    const universalHints = [
      "Piensa en tu experiencia personal relacionada con este tema...",
      "Considera situaciones similares que hayas visto o escuchado...",
      "Reflexiona sobre lo que sabes del tema aunque sea básico...",
      "Recuerda ejemplos prácticos de tu vida cotidiana o trabajo...",
      "Piensa en casos o situaciones que hayas observado...",
      "Considera qué has aprendido anteriormente sobre este tema...",
      "Reflexiona sobre aplicaciones prácticas de este conocimiento...",
      "Recuerda situaciones donde este tema ha sido relevante..."
    ];
    
        return universalHints;
  }

  /**
   * 👈 NUEVO: Obtiene pistas específicas por momento pedagógico
   */
  private getHintsByMomento(momento: string, tema: string): string[] {
    if (momento.includes('saludo')) {
      return [
        `No te preocupes si no sabes mucho sobre ${tema}, empezaremos desde lo básico.`,
        `Es normal no tener experiencia previa. ¿Has escuchado algo sobre ${tema}?`,
        `Vamos a explorar juntos este tema. ¿Qué te viene a la mente cuando escuchas ${tema}?`
      ];
    } else if (momento.includes('conexión')) {
      return [
        "Piensa en situaciones de tu vida diaria que podrían relacionarse...",
        "¿Has estado en lugares donde esto podría ser relevante?",
        "Considera experiencias de familiares, amigos o conocidos..."
      ];
    } else if (momento.includes('adquisición')) {
      return [
        "Te ayudo con los conceptos básicos. ¿Qué crees que significa...?",
        "Vamos a descubrir esto paso a paso. ¿Puedes imaginar qué elementos están involucrados?",
        "Piensa en los componentes principales que podrían estar relacionados..."
      ];
    } else if (momento.includes('aplicación')) {
      return [
        "Usando lo que acabamos de aprender, ¿qué harías en esta situación?",
        "Apliquemos los conceptos al caso. ¿Qué pasos seguirías?",
        "¿Cómo utilizarías lo que aprendimos para resolver esto?"
      ];
    } else if (momento.includes('discusión')) {
      return [
        "¿Qué ventajas y desventajas ves en cada opción?",
        "¿En qué situaciones preferirías un enfoque sobre otro?",
        "¿Qué factores consideras más importantes para decidir?"
      ];
    } else if (momento.includes('reflexión')) {
      return [
        "¿Qué fue lo que más te llamó la atención de lo que vimos?",
        "¿Qué concepto te quedó más claro?",
        "¿Cómo crees que podrías aplicar esto en tu contexto?"
      ];
    }

    return [
      "Te ayudo a pensar sobre esto de manera más específica...",
      "¿Puedes contarme más sobre tu perspectiva?",
      "Vamos a explorar esto juntos paso a paso..."
    ];
  }

  /**
   * Parsea la respuesta de la IA para extraer JSON
   */
  private parseAIResponse(responseText: string): any {
    try {
      const cleanedText = responseText.trim();
      const jsonMatch = cleanedText.match(/```(?:json|js)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1].trim());
      }
      const jsonObjectMatch = cleanedText.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/);
      if (jsonObjectMatch) {
        return JSON.parse(jsonObjectMatch[0]);
      }
      return JSON.parse(cleanedText);
    } catch (error) {
      console.error('Error parseando JSON:', error);
      return null;
    }
  }

  /**
   * Genera respuesta para el nuevo momento cuando se avanza
   */
  private async generateNewMomentResponse(sessionKey: string, nuevoIndice: number): Promise<AIResponse> {
    const session = this.sessionManager.getSession(sessionKey);
    if (!session) {
      throw new Error('Sesión no encontrada');
    }

    const momentPrompt = PromptBuilderUniversal.buildMomentPrompt({
      specialistRole: session.course.specialist_role,
      sessionName: session.session.name,
      courseName: session.course.name,
      learningObjective: session.session.learning_objective,
      keyPoints: session.session.key_points,
      momentos: session.momentos,
      currentIndex: nuevoIndice,
      preguntasPendientes: session.preguntasPendientes,
      preguntasRespondidas: session.preguntasRespondidas
    });

    const { response } = await this.openAIService.callOpenAI({
      systemPrompt: momentPrompt,
      userPrompt: "Continúa con el siguiente momento",
      model: 'gpt-3.5-turbo'
    });

    const nuevaRespuesta = this.parseAIResponse(response.output_text);
    
    return {
      ...nuevaRespuesta,
      momentos: session.momentos,
      sessionKey
    };
  }

  // MÉTODOS DE GESTIÓN DE SESIONES (delegados al SessionManager)
  getSessionInfo(sessionKey: string) {
    return this.sessionManager.getSession(sessionKey);
  }

  listActiveSessions() {
    return this.sessionManager.listActiveSessions();
  }

  clearSession(sessionKey: string) {
    return this.sessionManager.clearSession(sessionKey);
  }

  clearAllSessions() {
    this.sessionManager.clearAllSessions();
  }

  getCacheStats() {
    return this.sessionManager.getCacheStats();
  }

  clearCache() {
    this.sessionManager.clearCache();
  }
} 
```
=== EOF: src\lib\SessionExtractorUniversal.ts

===  src\lib\openai.ts
```typescript
import OpenAI from 'openai';

// Configuración de OpenAI
export const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
  dangerouslyAllowBrowser: false, // Solo para servidor
});

// Tipos para las respuestas de OpenAI
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// Función para enviar mensaje a ChatGPT
export async function sendChatMessage(
  messages: ChatMessage[],
  model: string = 'gpt-3.5-turbo'
): Promise<ChatResponse> {
  try {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY no está configurada');
    }

    const completion = await openai.chat.completions.create({
      model,
      messages,
      max_tokens: 1000,
      temperature: 0.7,
    });

    const response = completion.choices[0]?.message?.content || '';
    
    return {
      content: response,
      usage: completion.usage ? {
        prompt_tokens: completion.usage.prompt_tokens,
        completion_tokens: completion.usage.completion_tokens,
        total_tokens: completion.usage.total_tokens,
      } : undefined,
    };
  } catch (error) {
    console.error('Error al comunicarse con OpenAI:', error);
    throw new Error('Error al procesar la solicitud');
  }
}

// Función para generar texto con GPT
export async function generateText(
  prompt: string,
  model: string = 'gpt-3.5-turbo'
): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 500,
      temperature: 0.7,
    });

    return completion.choices[0]?.message?.content || '';
  } catch (error) {
    console.error('Error al generar texto:', error);
    throw new Error('Error al generar texto');
  }
}

// Función para analizar sentimientos
export async function analyzeSentiment(text: string): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'Analiza el sentimiento del siguiente texto y responde solo con: POSITIVO, NEGATIVO o NEUTRAL.'
        },
        {
          role: 'user',
          content: text
        }
      ],
      max_tokens: 10,
      temperature: 0.3,
    });

    return completion.choices[0]?.message?.content || 'NEUTRAL';
  } catch (error) {
    console.error('Error al analizar sentimiento:', error);
    return 'NEUTRAL';
  }
} 
```
=== EOF: src\lib\openai.ts

===  src\lib\constants.ts
```typescript
export const APP_CONFIG = {
  name: "DocenteIA",
  version: "1.0.0",
  description: "Sistema estable con Next.js y TypeScript",
  author: "Tu Nombre",
  repository: "https://github.com/tu-usuario/docenteia",
} as const;

export const API_ENDPOINTS = {
  base: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
  auth: "/auth",
  users: "/users",
  courses: "/courses",
} as const;

export const ROUTES = {
  home: "/",
  about: "/about",
  contact: "/contact",
  dashboard: "/dashboard",
} as const;

export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
} as const; 
```
=== EOF: src\lib\constants.ts

===  src\lib\config.ts
```typescript
export const config = {
  app: {
    name: process.env.NEXT_PUBLIC_APP_NAME || "DocenteIA",
    version: process.env.NEXT_PUBLIC_APP_VERSION || "1.0.0",
    description: "Sistema estable con Next.js y TypeScript",
  },
  api: {
    baseUrl: process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api",
    timeout: 10000,
  },
  auth: {
    secret: process.env.NEXTAUTH_SECRET,
    url: process.env.NEXTAUTH_URL || "http://localhost:3000",
  },
  features: {
    analytics: process.env.NEXT_PUBLIC_GA_ID,
    darkMode: true,
    pwa: false,
  },
} as const;

export type Config = typeof config; 
```
=== EOF: src\lib\config.ts

===  src\data\pedagogia-universal.json
```json
{
  "pedagogia_universal": {
    "metadatos": {
      "nombre": "Sistema Pedagógico por Momentos",
      "basado_en": "Teach Like a Champion (Doug Lemov)",
      "version": "1.0",
      "aplicable_a": "Todas las materias y niveles educativos",
      "enfoque": "Docente IA con metodología inductiva",
      "fecha_creacion": "2025-07-30"
    },
    "principios_fundamentales": {
      "filosofia_base": "Aprendizaje activo a través de descubrimiento guiado",
      "enfoque_respuestas": "Construcción sobre respuestas parciales, nunca descarte total",
      "manejo_errores": "Errores como oportunidades de aprendizaje, no fallas",
      "validacion": "Verificación constante de comprensión antes de avanzar",
      "personalizacion": "Adaptación al ritmo y estilo del estudiante individual"
    },
    "momentos_pedagogicos": {
      "momento_saludo": {
        "objetivo_pedagogico": "Establecer conexión emocional y ambiente propicio para el aprendizaje",
        "tecnicas_teach_like_champion": [
          "Warm/Strict (Cálido pero con altas expectativas)",
          "Joy Factor (Generar entusiasmo genuino por el aprendizaje)",
          "Strong Start (Comenzar con energía positiva)"
        ],
        "instrucciones_ia": [
          "Aplica técnica 'Warm/Strict': ser genuinamente cálido mientras mantienes altas expectativas",
          "Usa 'Joy Factor': transmite entusiasmo real por el tema y el proceso de aprendizaje",
          "Implementa 'Strong Start': comenzar con energía y propósito claro",
          "Personaliza el saludo según información disponible del estudiante",
          "Establece tono de confianza pero profesional desde el primer momento",
          "Genera expectativa positiva hacia la sesión sin revelar contenido específico"
        ],
        "estrategias_conexion": [
          "Mostrar interés genuino por el bienestar del estudiante",
          "Usar lenguaje inclusivo y cercano apropiado para el nivel educativo",
          "Crear atmosfera de seguridad psicológica para el aprendizaje",
          "Establecer que el error es parte natural del proceso de aprendizaje"
        ],
        "validacion_momento": [
          "Confirmar que el estudiante responde de manera receptiva",
          "Verificar que se establece ambiente de confianza mutua",
          "Asegurar que hay apertura para el diálogo y participación",
          "Observar indicadores de engagement inicial"
        ],
        "errores_evitar": [
          "Ser demasiado formal o distante",
          "Adelantar contenido académico en este momento",
          "Ignorar señales de resistencia o desconfort del estudiante",
          "Saltar directamente a objetivos sin conexión humana"
        ]
      },
      "momento_presentacion_aprendizajes": {
        "objetivo_pedagogico": "Crear claridad de propósito y motivación intrínseca hacia los objetivos",
        "tecnicas_teach_like_champion": [
          "Begin with the End (Empezar con el resultado final claro)",
          "Hook (Capturar interés desde el inicio)",
          "Champion's Clarity (Claridad absoluta en expectativas)"
        ],
        "instrucciones_ia": [
          "Aplica 'Begin with the End': presenta claramente qué logrará el estudiante al finalizar",
          "Usa técnica 'Hook': crea interés genuino mostrando la relevancia práctica",
          "Implementa 'Champion's Clarity': ser absolutamente específico sobre resultados esperados",
          "Conecta objetivos con beneficios tangibles para el estudiante",
          "Usa lenguaje de acción y resultado, no de proceso pasivo",
          "Verifica que el estudiante ve el valor de lo que aprenderá"
        ],
        "estructura_presentacion": [
          "Resultado específico que logrará (qué podrá hacer)",
          "Beneficio tangible en su vida/carrera (para qué le sirve)",
          "Relevancia inmediata (cuándo lo aplicará)",
          "Confirmación de comprensión y aceptación del objetivo"
        ],
        "frases_potentes": [
          "Al terminar esta sesión, tú serás capaz de...",
          "Esto te permitirá... en tu trabajo/estudios",
          "Imagínate poder... después de hoy",
          "Esta habilidad te dará la confianza para..."
        ],
        "validacion_momento": [
          "El estudiante puede reformular el objetivo con sus palabras",
          "Expresa interés o motivación hacia el resultado prometido",
          "Hace preguntas relacionadas con la aplicación práctica",
          "Muestra compromiso con el proceso de aprendizaje"
        ]
      },
      "momento_puntos_clave": {
        "objetivo_pedagogico": "Crear organizadores previos y mapa mental de la ruta de aprendizaje",
        "tecnicas_teach_like_champion": [
          "Name the Steps (Nombrar pasos específicos)",
          "Batch Process (Agrupar información lógicamente)",
          "Foreshadowing (Anticipar lo que viene)"
        ],
        "instrucciones_ia": [
          "Aplica 'Name the Steps': presenta cada punto clave como paso específico y medible",
          "Usa 'Batch Process': agrupa contenidos relacionados de manera lógica y secuencial",
          "Implementa 'Foreshadowing': crea anticipación sobre cada punto sin revelarlo completamente",
          "Presenta estructura visual/mental clara del recorrido de aprendizaje",
          "Explica la lógica de la secuencia para que tenga sentido",
          "Genera curiosidad sobre cada punto sin dar información detallada"
        ],
        "estrategias_organizacion": [
          "Usar numeración clara y secuencial",
          "Mostrar conexiones lógicas entre puntos",
          "Crear expectativa creciente hacia cada punto",
          "Usar analogías de viaje/construcción para la estructura"
        ],
        "tecnicas_anticipacion": [
          "Usar frases como 'Primero descubriremos...', 'Luego exploraremos...'",
          "Crear intriga: 'Algo fascinante que aprenderás en el punto 3 es...'",
          "Conectar cada punto con el resultado final",
          "Mostrar cómo cada punto construye sobre el anterior"
        ],
        "validacion_momento": [
          "El estudiante puede repetir la secuencia de puntos",
          "Entiende la lógica de la progresión",
          "Muestra curiosidad por puntos específicos",
          "Ve la conexión entre estructura y objetivo final"
        ]
      },
      "momento_conexion": {
        "objetivo_pedagogico": "Activar conocimientos previos y crear puentes cognitivos hacia nuevos aprendizajes",
        "tecnicas_teach_like_champion": [
          "Retrieval Practice (Práctica de recuperación)",
          "Bridge the Gap (Conectar lo conocido con lo nuevo)",
          "Universal Prompt (Preguntas que todos pueden responder)"
        ],
        "instrucciones_ia": [
          "Aplica 'Retrieval Practice': ayuda al estudiante a recordar conocimientos relacionados",
          "Usa 'Bridge the Gap': conecta explícitamente experiencias previas con nuevos conceptos",
          "Implementa 'Universal Prompt': haz preguntas que el estudiante definitivamente puede responder",
          "Explora experiencias personales relacionadas con el tema",
          "Valida conocimientos previos como base válida para construir",
          "Identifica conceptos erróneos para abordarlos durante la sesión"
        ],
        "estrategias_activacion": [
          "Preguntas abiertas sobre experiencias relacionadas",
          "Analogías con situaciones familiares del estudiante",
          "Recuperación de aprendizajes previos relevantes",
          "Conexión emocional con el tema a través de experiencias personales"
        ],
        "tipos_preguntas": [
          "Experienciales: '¿Has vivido alguna situación donde...?'",
          "Observacionales: '¿Qué has notado cuando...?'",
          "Comparativas: '¿En qué se parece esto a...?'",
          "Reflexivas: '¿Qué piensas sobre...?'"
        ],
        "manejo_respuestas": [
          "Validar todas las experiencias como valiosas",
          "Construir sobre respuestas parciales o incompletas",
          "Conectar respuestas individuales con conceptos generales",
          "Usar respuestas como trampolín hacia nuevos aprendizajes"
        ],
        "validacion_momento": [
          "El estudiante comparte experiencias relacionadas",
          "Se activan recuerdos y conocimientos previos relevantes",
          "Hay conexión emocional evidente con el tema",
          "Se establece base sólida para nuevos aprendizajes"
        ]
      },
      "momento_adquisicion": {
        "objetivo_pedagogico": "Facilitar construcción activa de conocimientos mediante descubrimiento guiado",
        "tecnicas_teach_like_champion": [
          "Cold Call (Preguntar sin avisar para mantener participación)",
          "No Opt Out (No permitir que estudiantes se desconecten)",
          "Right is Right (Solo respuestas completamente correctas)",
          "Stretch It (Extender pensamiento más allá de respuesta inicial)",
          "Turn and Talk (Tiempo para procesar antes de responder)"
        ],
        "instrucciones_ia": [
          "Aplica metodología INDUCTIVA PURA: NUNCA dar definiciones directas",
          "Usa 'Cold Call': mantén al estudiante participando activamente con preguntas constantes",
          "Implementa 'No Opt Out': no aceptes 'no sé' como respuesta final, guía hacia descubrimiento",
          "Aplica 'Right is Right': no apruebes respuestas parciales como completas",
          "Usa 'Stretch It': cuando respuesta es correcta, profundiza con '¿Por qué?' o '¿Qué más?'",
          "Implementa secuencia: Observación → Pregunta → Deducción → Confirmación",
          "Construye sobre cada respuesta parcial para llegar a comprensión completa"
        ],
        "metodologia_inductiva": [
          "Presentar ejemplos/casos antes que definiciones",
          "Hacer preguntas que lleven al estudiante a deducir conceptos",
          "Esperar respuesta del estudiante antes de confirmar o corregir",
          "Usar múltiples ejemplos para que el estudiante vea patrones",
          "Permitir que el estudiante 'descubra' la regla o principio"
        ],
        "manejo_respuestas": {
          "respuesta_correcta_completa": [
            "Confirmar con entusiasmo genuino",
            "Aplicar 'Stretch It' para profundizar",
            "Conectar con ejemplos adicionales",
            "Usar como base para siguiente concepto"
          ],
          "respuesta_parcialmente_correcta": [
            "Reconocer la parte correcta específicamente",
            "Hacer pregunta que guíe hacia completar la respuesta",
            "No descartar, sino construir sobre lo correcto",
            "Dar pista orientadora hacia aspecto faltante"
          ],
          "respuesta_incorrecta": [
            "No decir simplemente 'incorrecto'",
            "Identificar el punto exacto donde se desvía el razonamiento",
            "Hacer pregunta que redirija el pensamiento",
            "Proporcionar contraejemplo si es necesario"
          ],
          "no_respuesta": [
            "Reformular pregunta de manera más simple",
            "Proporcionar ejemplo adicional",
            "Hacer pregunta más específica",
            "Dar pista que active conocimiento previo"
          ]
        },
        "validacion_comprension": [
          "Pedir al estudiante que explique con sus propias palabras",
          "Solicitar ejemplos diferentes a los presentados",
          "Hacer preguntas de aplicación en contexto ligeramente diferente",
          "Verificar que puede distinguir ejemplos de contra-ejemplos"
        ],
        "errores_criticos_evitar": [
          "Dar definición directa antes que el estudiante deduzca",
          "Aceptar respuestas vagas o incompletas",
          "Avanzar sin confirmar comprensión sólida",
          "Corregir sin explicar por qué la respuesta es incorrecta"
        ]
      },
      "momento_aplicacion": {
        "objetivo_pedagogico": "Transferir conocimientos a situaciones prácticas mediante práctica guiada",
        "tecnicas_teach_like_champion": [
          "I Do, We Do, You Do (Modelamiento gradual)",
          "Check for Understanding (Verificación constante)",
          "Circulate (Monitorear progreso individual)",
          "Show Me (Evidencia visible de comprensión)"
        ],
        "instrucciones_ia": [
          "Aplica 'I Do, We Do, You Do': modela, practica guiada, práctica independiente",
          "Usa 'Check for Understanding': verifica comprensión antes de aumentar complejidad",
          "Implementa 'Show Me': solicita evidencia específica de aplicación correcta",
          "Comienza con casos simples y aumenta complejidad gradualmente",
          "Solicita verbalización del proceso de pensamiento en cada paso",
          "Conecta constantemente aplicación práctica con conceptos teóricos aprendidos"
        ],
        "secuencia_aplicacion": [
          "Modelamiento: Demostrar aplicación paso a paso",
          "Práctica guiada: Estudiante aplica con soporte",
          "Práctica independiente: Estudiante aplica solo",
          "Transferencia: Aplicar en contexto ligeramente diferente"
        ],
        "estrategias_scaffolding": [
          "Proporcionar estructura inicial y retirarla gradualmente",
          "Dar pistas específicas cuando el estudiante se atasca",
          "Permitir errores como oportunidades de aprendizaje",
          "Celebrar aproximaciones correctas antes de perfeccionar"
        ],
        "preguntas_guia": [
          "¿Qué harías primero en esta situación?",
          "¿Qué concepto aplicarías aquí?",
          "¿Por qué elegiste esa opción?",
          "¿Qué pasaría si...?",
          "¿Cómo sabes que tu respuesta es correcta?"
        ],
        "validacion_aplicacion": [
          "Estudiante puede aplicar proceso sin ayuda",
          "Explica su razonamiento claramente",
          "Transfiere habilidad a contextos similares",
          "Identifica errores y los corrige independientemente"
        ]
      },
      "momento_discusion": {
        "objetivo_pedagogico": "Profundizar comprensión mediante análisis crítico y metacognición",
        "tecnicas_teach_like_champion": [
          "Turn and Talk (Reflexión antes de compartir)",
          "Think Ratio (Maximizar tiempo de pensamiento del estudiante)",
          "Wait Time (Tiempo suficiente para procesar)",
          "Pepper (Discusión dinámica y participativa)"
        ],
        "instrucciones_ia": [
          "Aplica 'Think Ratio': el estudiante debe hablar/pensar más que tú",
          "Usa 'Wait Time': da tiempo suficiente para que procese preguntas complejas",
          "Implementa preguntas abiertas que no tengan una sola respuesta correcta",
          "Facilita análisis crítico de decisiones tomadas durante aplicación",
          "Promueve metacognición: que el estudiante reflexione sobre su propio proceso de aprendizaje",
          "Explora múltiples perspectivas y enfoques del mismo problema"
        ],
        "tipos_preguntas": [
          "Análisis: '¿Por qué crees que...?'",
          "Síntesis: '¿Cómo conectarías...?'",
          "Evaluación: '¿Cuál sería la mejor opción y por qué?'",
          "Metacognición: '¿Cómo llegaste a esa conclusión?'",
          "Perspectiva: '¿Qué otros enfoques podrían funcionar?'"
        ],
        "facilitacion_dialogica": [
          "Hacer preguntas que generen más preguntas",
          "Desafiar suposiciones de manera constructiva",
          "Ayudar a examinar implicaciones de diferentes decisiones",
          "Promover argumentación fundamentada en evidencia"
        ],
        "manejo_perspectivas": [
          "Validar múltiples enfoques cuando sean correctos",
          "Ayudar a evaluar pros y contras de cada opción",
          "Facilitar síntesis de ideas aparentemente contradictorias",
          "Mantener enfoque en aprendizaje, no en 'ganar' la discusión"
        ],
        "validacion_momento": [
          "El estudiante reflexiona profundamente sobre su aprendizaje",
          "Puede articular su proceso de pensamiento",
          "Considera múltiples perspectivas de un problema",
          "Demuestra pensamiento crítico y analítico"
        ]
      },
      "momento_retroalimentacion": {
        "objetivo_pedagogico": "Consolidar aprendizajes y orientar mejora continua mediante feedback específico",
        "tecnicas_teach_like_champion": [
          "Precise Praise (Elogio específico y merecido)",
          "Challenge (Desafío apropiado para crecimiento)",
          "Culture of Error (Normalizar error como parte del aprendizaje)",
          "Normalize Error (Hacer que el error sea esperado y valioso)"
        ],
        "instrucciones_ia": [
          "Aplica 'Precise Praise': elogia aspectos específicos del desempeño, no generalidades",
          "Usa 'Challenge': establece expectativas altas y específicas para mejora",
          "Implementa 'Culture of Error': trata errores como información valiosa sobre el aprendizaje",
          "Aplica modelo: Fortaleza específica → Área de crecimiento → Pasos concretos",
          "Balancea reconocimiento genuino con orientación para mejora",
          "Facilita autorreflexión antes de proporcionar feedback externo"
        ],
        "estructura_feedback": {
          "reconocimiento_especifico": [
            "Identifica logro específico y observable",
            "Explica por qué ese logro es significativo",
            "Conecta logro con esfuerzo o estrategia utilizada"
          ],
          "area_crecimiento": [
            "Señala aspecto específico para mejorar",
            "Explica por qué esa mejora es importante",
            "Proporciona criterio claro para el éxito"
          ],
          "pasos_siguientes": [
            "Da acción específica y realizable",
            "Establece expectativa clara de mejora",
            "Conecta con aplicación futura"
          ]
        },
        "preguntas_autoreflexion": [
          "¿Qué fue lo que más te desafió en esta sesión?",
          "¿Cuál fue tu mayor logro hoy?",
          "¿Qué harías diferente la próxima vez?",
          "¿Cómo aplicarías esto en tu contexto real?",
          "¿Qué necesitas practicar más?"
        ],
        "proyeccion_futura": [
          "Conectar aprendizajes con situaciones reales del estudiante",
          "Sugerir próximos pasos específicos para profundizar",
          "Generar compromiso personal con la práctica continua",
          "Inspirar confianza en capacidades desarrolladas"
        ],
        "errores_evitar_feedback": [
          "Elogios vagos como 'buen trabajo' sin especificidad",
          "Criticar a la persona en lugar del desempeño",
          "Dar demasiada información correctiva a la vez",
          "Terminar solo con áreas de mejora sin reconocimiento"
        ]
      }
    },
    "principios_transversales": {
      "adaptacion_ritmo": [
        "Acelerar cuando el estudiante domina rápidamente",
        "Desacelerar cuando hay confusión o resistencia",
        "Proporcionar refuerzo adicional cuando sea necesario",
        "Ajustar complejidad según respuestas del estudiante"
      ],
      "mantenimiento_engagement": [
        "Variar tipos de preguntas para mantener interés",
        "Usar ejemplos relevantes al contexto del estudiante",
        "Celebrar progreso incremental regularmente",
        "Mantener expectativas altas pero alcanzables"
      ],
      "construccion_confianza": [
        "Estructurar experiencias de éxito frecuentes",
        "Reconocer esfuerzo y estrategias efectivas",
        "Normalizar la dificultad como parte natural del aprendizaje",
        "Proporcionar soporte suficiente para prevenir frustración"
      ]
    }
  }
} 
```
=== EOF: src\data\pedagogia-universal.json

===  src\data\courses-database.json
```json
{
  "courses": [
    {
      "id": "SSO001",
      "name": "Seguridad y Salud Ocupacional",
      "description": "Curso completo de SSO con múltiples sesiones de capacitación",
      "specialist_role": "Especialista en Seguridad y Salud Ocupacional",
      "vector_store_id": "vs_68823f69d9f08191889fed8f8edd891c",
      "sessions": [
        {
          "id": "sesion01",
          "name": "IPERC - Identificación de Peligros, Evaluación de Riesgos y Controles",
          "session_file": "SSO001_sesion01.json",
          "learning_objective": "El estudiante identifica peligros en una situación laboral, evalúa los riesgos asociados y propone controles adecuados para prevenir accidentes",
          "key_points": [
            "Comprende qué es un peligro y cómo se reconoce en el ambiente laboral",
            "Diferencia entre peligro y riesgo en el contexto de SSO",
            "Relaciona la severidad y probabilidad para evaluar un riesgo",
            "Propone controles adecuados según el tipo de peligro identificado"
          ],
          "theme_keywords": [
            "iperc",
            "identificación",
            "peligros",
            "evaluación",
            "riesgos",
            "control",
            "seguridad",
            "prevención",
            "accidente"
          ]
        },
        {
          "id": "sesion02", 
          "name": "Sesión 02 de SSO",
          "session_file": "SSO001_sesion02.json",
          "learning_objective": "El estudiante aplica procedimientos de seguridad en situaciones específicas del trabajo",
          "key_points": [
            "Identifica procedimientos de seguridad relevantes",
            "Aplica medidas de protección personal",
            "Reconoce señales y señalización de seguridad",
            "Implementa protocolos de emergencia"
          ],
          "theme_keywords": [
            "procedimientos",
            "seguridad",
            "protección",
            "personal",
            "señales",
            "señalización",
            "protocolos",
            "emergencia",
            "medidas"
          ]
        },
        {
          "id": "sesion03",
          "name": "Prevención de Incendios en el Trabajo", 
          "session_file": "SSO001_sesion03.json",
          "learning_objective": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
          "key_points": [
            "Reconoce las causas principales de incendios en el trabajo",
            "Identifica medidas preventivas para evitar incendios",
            "Aplica procedimientos de evacuación en caso de emergencia",
            "Utiliza correctamente equipos contra incendios"
          ],
          "theme_keywords": [
            "incendio",
            "fuego",
            "extintor",
            "prevención",
            "combustión",
            "triángulo del fuego",
            "evacuación",
            "emergencia",
            "equipos"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    },
    {
      "id": "PER001",
      "name": "Operación de Equipos de Perforación",
      "description": "Curso completo de perforación con múltiples sesiones de capacitación",
      "specialist_role": "Especialista en operación de equipos de perforación",
      "vector_store_id": "vs_perforacion_equipos_2025",
      "sessions": [
        {
          "id": "sesion01",
          "name": "Fundamentos de Perforación",
          "learning_objective": "El estudiante identifica los componentes principales de un equipo de perforación y explica su función en el proceso",
          "key_points": [
            "Comprende qué es un equipo de perforación y sus aplicaciones",
            "Identifica los componentes principales del equipo de perforación",
            "Explica la función de cada componente en el proceso",
            "Relaciona el funcionamiento de los componentes para lograr la perforación efectiva"
          ],
          "theme_keywords": [
            "perforación",
            "equipo",
            "componentes",
            "fundamentos",
            "mecanismo",
            "funcionamiento",
            "aplicaciones",
            "proceso"
          ]
        },
        {
          "id": "sesion02",
          "name": "Técnicas de Perforación",
          "learning_objective": "El estudiante aplica técnicas de perforación según el tipo de terreno y objetivo",
          "key_points": [
            "Reconoce diferentes tipos de técnicas de perforación",
            "Selecciona la técnica apropiada según el terreno",
            "Aplica procedimientos de seguridad en perforación",
            "Evalúa la eficiencia de la técnica utilizada"
          ],
          "theme_keywords": [
            "técnicas",
            "perforación",
            "terreno",
            "métodos",
            "selección",
            "eficiencia",
            "procedimientos",
            "seguridad"
          ]
        },
        {
          "id": "sesion03",
          "name": "Mantenimiento de Equipos de Perforación",
          "learning_objective": "El estudiante realiza mantenimiento preventivo y correctivo en equipos de perforación",
          "key_points": [
            "Identifica componentes que requieren mantenimiento regular",
            "Aplica procedimientos de mantenimiento preventivo",
            "Diagnostica problemas comunes en equipos de perforación",
            "Ejecuta mantenimiento correctivo básico"
          ],
          "theme_keywords": [
            "mantenimiento",
            "preventivo",
            "correctivo",
            "equipos",
            "perforación",
            "diagnóstico",
            "componentes",
            "procedimientos",
            "problemas"
          ]
        }
      ],
      "metadata": {
        "total_sessions": 3,
        "total_files": 3,
        "created_at": "2025-07-28",
        "last_updated": "2025-07-28"
      }
    }
  ]
} 
```
=== EOF: src\data\courses-database.json

===  src\components\ChatInterface.tsx
```tsx
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ChatMessage } from '@/lib/openai';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const chatMessages: ChatMessage[] = [
        ...messages.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        { role: 'user', content: input },
      ];

      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: chatMessages,
          model: 'gpt-3.5-turbo',
        }),
      });

      if (!response.ok) {
        throw new Error('Error en la respuesta del servidor');
      }

      const data = await response.json();
      
      const assistantMessage: Message = {
        role: 'assistant',
        content: data.content,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      const errorMessage: Message = {
        role: 'assistant',
        content: 'Lo siento, hubo un error al procesar tu mensaje.',
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        {/* Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 p-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Chat con IA
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Pregunta lo que quieras a la inteligencia artificial
          </p>
        </div>

        {/* Messages */}
        <div className="h-96 overflow-y-auto p-4 space-y-4">
          {messages.length === 0 && (
            <div className="text-center text-gray-500 dark:text-gray-400">
              <p>¡Hola! Soy tu asistente de IA. ¿En qué puedo ayudarte?</p>
            </div>
          )}
          
          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              <div
                className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white'
                }`}
              >
                <p className="text-sm">{message.content}</p>
                <p className="text-xs opacity-70 mt-1">
                  {message.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))}
          
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-gray-100 dark:bg-gray-700 px-4 py-2 rounded-lg">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  Pensando...
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <div className="border-t border-gray-200 dark:border-gray-700 p-4">
          <div className="flex space-x-2">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Escribe tu mensaje..."
              className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white resize-none"
              rows={2}
              disabled={isLoading}
            />
            <Button
              onClick={sendMessage}
              disabled={!input.trim() || isLoading}
              className="px-4 py-2"
            >
              {isLoading ? 'Enviando...' : 'Enviar'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
} 
```
=== EOF: src\components\ChatInterface.tsx

===  src\app\page.tsx
```tsx
import { Button } from "@/components/ui/Button";
import { formatDate } from "@/lib/utils";
import { ChatInterface } from "@/components/ChatInterface";

export default function Home() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800">
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <h1 className="text-4xl md:text-6xl font-bold text-gray-900 dark:text-white mb-4">
            DocenteIA
          </h1>
          <p className="text-xl text-gray-600 dark:text-gray-300 mb-8">
            Sistema estable con Next.js, TypeScript e IA
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button size="lg" className="bg-blue-600 hover:bg-blue-700">
              Comenzar
            </Button>
            <Button variant="outline" size="lg">
              Documentación
            </Button>
          </div>
        </div>

        <div className="grid md:grid-cols-3 gap-8 mt-16 mb-16">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              TypeScript Estricto
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Configuración robusta con verificaciones estrictas de tipos para mayor estabilidad.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Next.js 14
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              La versión más estable con App Router y optimizaciones avanzadas.
            </p>
          </div>

          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              OpenAI Integrado
            </h3>
            <p className="text-gray-600 dark:text-gray-300">
              Chat inteligente con GPT-3.5-turbo para asistencia automática.
            </p>
          </div>
        </div>

        {/* Chat Interface */}
        <div className="mt-16">
          <ChatInterface />
        </div>

        <div className="mt-12 text-center">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Última actualización: {formatDate(new Date())}
          </p>
        </div>
      </div>
    </div>
  );
}
```
=== EOF: src\app\page.tsx

===  src\app\layout.tsx
```tsx
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "DocenteIA - Sistema Estable",
  description: "Sistema estable con Next.js y TypeScript",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```
=== EOF: src\app\layout.tsx

===  src\app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 0 0% 3.9%;
  --card: 0 0% 100%;
  --card-foreground: 0 0% 3.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 0 0% 3.9%;
  --primary: 0 0% 9%;
  --primary-foreground: 0 0% 98%;
  --secondary: 0 0% 96.1%;
  --secondary-foreground: 0 0% 9%;
  --muted: 0 0% 96.1%;
  --muted-foreground: 0 0% 45.1%;
  --accent: 0 0% 96.1%;
  --accent-foreground: 0 0% 9%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 89.8%;
  --input: 0 0% 89.8%;
  --ring: 0 0% 3.9%;
  --radius: 0.5rem;
}

.dark {
  --background: 0 0% 3.9%;
  --foreground: 0 0% 98%;
  --card: 0 0% 3.9%;
  --card-foreground: 0 0% 98%;
  --popover: 0 0% 3.9%;
  --popover-foreground: 0 0% 98%;
  --primary: 0 0% 98%;
  --primary-foreground: 0 0% 9%;
  --secondary: 0 0% 14.9%;
  --secondary-foreground: 0 0% 98%;
  --muted: 0 0% 14.9%;
  --muted-foreground: 0 0% 63.9%;
  --accent: 0 0% 14.9%;
  --accent-foreground: 0 0% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 14.9%;
  --input: 0 0% 14.9%;
  --ring: 0 0% 83.1%;
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
```
=== EOF: src\app\globals.css

===  src\data\sessions\SSO001_sesion03.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion03",
  "nombre": "Prevención de Incendios en el Trabajo",
  "objetivo": "El estudiante identifica causas de incendios y aplica medidas preventivas y de respuesta",
  "momentos": [
    {
      "momento": "Saludo (exposición del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesión y los puntos clave a desarrollar",
      "preguntas": [
        "¿Qué sabes sobre incendios en el trabajo?",
        "¿Has presenciado alguna situación de riesgo de incendio?",
        "¿Qué esperas aprender en esta sesión?"
      ]
    },
    {
      "momento": "Conexión",
      "instrucciones_docenteia": "Narrar la historia de la fábrica textil para conectar con experiencias previas",
      "historia": "En una fábrica textil, un trabajador está usando una máquina de soldadura cerca de telas almacenadas. De repente, una chispa salta hacia las telas y comienza un pequeño fuego. ¿Qué crees que pasó? ¿Por qué se inició el incendio? ¿Te ha pasado algo parecido o has escuchado de un caso similar?",
      "preguntas": [
        "¿Qué elementos identificas en esta situación?",
        "¿Qué podría haber prevenido este incidente?",
        "¿Cómo se relaciona esto con tu experiencia laboral?",
        "¿Has presenciado alguna situación similar?"
      ]
    },
    {
      "momento": "Adquisición",
      "instrucciones_docenteia": "Explicar el Triángulo del Fuego y los tipos de extintores",
      "contenido_tecnico": [
        "El Triángulo del Fuego está compuesto por tres elementos esenciales",
        "COMBUSTIBLE: cualquier material que puede arder (madera, papel, telas, gasolina, etc.)",
        "OXÍGENO: presente en el aire que respiramos",
        "CALOR: la energía que inicia la reacción de combustión",
        "Si eliminamos cualquiera de estos tres elementos, el fuego NO puede existir",
        "Extintor de agua: para combustibles sólidos (clase A)",
        "Extintor de CO₂: para equipos eléctricos (clase C)",
        "Extintor de polvo: para múltiples tipos de fuego (clase ABC)"
      ],
      "preguntas": [
        "¿Qué crees que necesita el fuego para existir?",
        "¿Has oído hablar del Triángulo del Fuego?",
        "¿Puedes identificar los tres elementos básicos del fuego?",
        "¿Qué tipos de extintores conoces y para qué se usan?",
        "¿Por qué es importante eliminar al menos uno de los elementos del Triángulo del Fuego?",
        "¿Cómo se relaciona esto con la prevención de incendios?"
      ]
    },
    {
      "momento": "Aplicación",
      "instrucciones_docenteia": "Presentar el caso de la carpintería para aplicar los conocimientos",
      "caso": "En una carpintería donde trabajan 10 personas, hay madera, barnices, equipos eléctricos, y una estufa para calentar el ambiente. Un día, un trabajador está barnizando una pieza cerca de la estufa cuando se derrama barniz sobre la estufa caliente y se inicia un incendio. Usando el Triángulo del Fuego, analicemos este caso: ¿Cuáles son los tres elementos presentes? ¿Qué tipo de extintor sería el más adecuado? ¿Qué medidas preventivas se podrían haber implementado?",
      "preguntas": [
        "En este caso de la carpintería, ¿cuáles son los tres elementos del Triángulo del Fuego?",
        "¿Qué tipo de extintor sería el más adecuado para este incendio y por qué?",
        "¿Qué medidas preventivas se podrían haber implementado para evitar este incidente?",
        "¿Cómo se podría haber roto el Triángulo del Fuego antes de que ocurriera el incendio?",
        "Si tú fueras el responsable de seguridad, ¿qué protocolos establecerías?"
      ]
    },
    {
      "momento": "Discusión",
      "instrucciones_docenteia": "Facilitar la comparación de diferentes enfoques de prevención",
      "preguntas": [
        "¿Qué estrategia prefieres y por qué?",
        "¿Hay situaciones donde una estrategia es mejor que otra?",
        "¿Qué limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "Reflexión",
      "instrucciones_docenteia": "Guiar la reflexión sobre lo aprendido y su aplicación práctica",
      "preguntas": [
        "¿Qué concepto te quedó más claro?",
        "¿Cómo cambiará tu forma de trabajar después de esta sesión?",
        "¿Qué más te gustaría aprender sobre prevención de incendios?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion03.json

===  src\data\sessions\SSO001_sesion02.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion02",
  "nombre": "Procedimientos de Seguridad en el Trabajo",
  "objetivo": "El estudiante aplica procedimientos de seguridad en situaciones específicas del trabajo",
  "momentos": [
    {
      "momento": "Saludo (exposición del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesión sobre procedimientos de seguridad",
      "preguntas": [
        "¿Qué procedimientos de seguridad conoces?",
        "¿Has seguido algún protocolo de seguridad en tu trabajo?",
        "¿Qué esperas aprender sobre procedimientos de seguridad?"
      ]
    },
    {
      "momento": "Conexión",
      "instrucciones_docenteia": "Narrar una situación de trabajo para conectar con experiencias previas",
      "historia": "En una obra de construcción, un trabajador debe realizar trabajos en altura. ¿Qué procedimientos de seguridad debería seguir? ¿Qué equipos de protección necesitaría?",
      "preguntas": [
        "¿Qué elementos de seguridad identificas en esta situación?",
        "¿Qué podría salir mal si no se siguen los procedimientos?",
        "¿Has presenciado alguna situación similar?"
      ]
    },
    {
      "momento": "Adquisición",
      "instrucciones_docenteia": "Explicar los procedimientos de seguridad básicos",
      "contenido_tecnico": [
        "PROCEDIMIENTO: secuencia de pasos para realizar una tarea de forma segura",
        "EQUIPOS DE PROTECCIÓN PERSONAL (EPP): elementos que protegen al trabajador",
        "SEÑALIZACIÓN: indicadores visuales que advierten sobre peligros",
        "PROTOCOLOS DE EMERGENCIA: pasos a seguir en caso de accidente"
      ],
      "preguntas": [
        "¿Qué elementos debe tener un procedimiento de seguridad?",
        "¿Cómo se selecciona el EPP adecuado?",
        "¿Qué tipos de señalización conoces?"
      ]
    },
    {
      "momento": "Aplicación",
      "instrucciones_docenteia": "Presentar un caso práctico para aplicar procedimientos",
      "caso": "En un laboratorio químico, un trabajador debe manipular sustancias peligrosas. ¿Qué procedimientos debería seguir?",
      "preguntas": [
        "¿Qué procedimientos específicos aplicarías?",
        "¿Qué EPP necesitaría el trabajador?",
        "¿Qué medidas de emergencia deberían estar disponibles?"
      ]
    },
    {
      "momento": "Discusión",
      "instrucciones_docenteia": "Facilitar la comparación de diferentes procedimientos",
      "preguntas": [
        "¿Qué procedimiento prefieres y por qué?",
        "¿Hay situaciones donde un procedimiento es mejor que otro?",
        "¿Qué limitaciones tienen los procedimientos?"
      ]
    },
    {
      "momento": "Reflexión",
      "instrucciones_docenteia": "Guiar la reflexión sobre lo aprendido y su aplicación práctica",
      "preguntas": [
        "¿Qué concepto te quedó más claro?",
        "¿Cómo aplicarás estos procedimientos en tu trabajo?",
        "¿Qué más te gustaría aprender sobre seguridad?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion02.json

===  src\data\sessions\SSO001_sesion01.json
```json
{
  "curso": "SSO001",
  "sesion": "sesion01",
  "nombre": "IPERC - Identificación de Peligros, Evaluación de Riesgos y Controles",
  "objetivo": "El estudiante identifica peligros en una situación laboral, evalúa los riesgos asociados y propone controles adecuados para prevenir accidentes",
  "momentos": [
    {
      "momento": "Saludo (exposición del aprendizaje esperado y los puntos clave)",
      "instrucciones_docenteia": "Presentar el objetivo de la sesión IPERC y los puntos clave a desarrollar",
      "preguntas": [
        "¿Qué sabes sobre identificación de peligros en el trabajo?",
        "¿Has identificado algún peligro en tu entorno laboral?",
        "¿Qué esperas aprender sobre evaluación de riesgos?"
      ]
    },
    {
      "momento": "Conexión",
      "instrucciones_docenteia": "Narrar una situación laboral para conectar con experiencias previas",
      "historia": "En una fábrica de producción, un trabajador está operando una máquina sin las protecciones adecuadas. ¿Qué peligros identificas en esta situación? ¿Qué riesgos podrían existir?",
      "preguntas": [
        "¿Qué elementos de riesgo identificas en esta situación?",
        "¿Qué podría salir mal en este escenario?",
        "¿Cómo se relaciona esto con tu experiencia laboral?"
      ]
    },
    {
      "momento": "Adquisición",
      "instrucciones_docenteia": "Explicar los conceptos de IPERC",
      "contenido_tecnico": [
        "IPERC significa: Identificación de Peligros, Evaluación de Riesgos y Controles",
        "PELIGRO: fuente, situación o acto con potencial de causar daño",
        "RIESGO: combinación de la probabilidad de ocurrencia y la severidad del daño",
        "CONTROL: medida implementada para eliminar o reducir el riesgo"
      ],
      "preguntas": [
        "¿Qué diferencia hay entre peligro y riesgo?",
        "¿Cómo se evalúa la probabilidad de un riesgo?",
        "¿Qué tipos de controles conoces?"
      ]
    },
    {
      "momento": "Aplicación",
      "instrucciones_docenteia": "Presentar un caso práctico para aplicar IPERC",
      "caso": "En un taller de mantenimiento, un trabajador debe cambiar una lámpara en altura. ¿Cómo aplicarías el método IPERC en esta situación?",
      "preguntas": [
        "¿Qué peligros identificas en este caso?",
        "¿Cómo evaluarías los riesgos?",
        "¿Qué controles propondrías?"
      ]
    },
    {
      "momento": "Discusión",
      "instrucciones_docenteia": "Facilitar la comparación de diferentes enfoques de control",
      "preguntas": [
        "¿Qué estrategia de control prefieres y por qué?",
        "¿Hay situaciones donde una estrategia es mejor que otra?",
        "¿Qué limitaciones tiene cada enfoque?"
      ]
    },
    {
      "momento": "Reflexión",
      "instrucciones_docenteia": "Guiar la reflexión sobre lo aprendido y su aplicación práctica",
      "preguntas": [
        "¿Qué concepto te quedó más claro?",
        "¿Cómo aplicarás IPERC en tu trabajo?",
        "¿Qué más te gustaría aprender sobre evaluación de riesgos?"
      ]
    }
  ]
} 
```
=== EOF: src\data\sessions\SSO001_sesion01.json

===  src\components\ui\Button.tsx
```tsx
import React from "react";
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants }; 
```
=== EOF: src\components\ui\Button.tsx

===  src\app\api\chat\route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { sendChatMessage, ChatMessage } from '@/lib/openai';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { messages, model = 'gpt-3.5-turbo' } = body;

    // Validar que se proporcionen mensajes
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Se requieren mensajes válidos' },
        { status: 400 }
      );
    }

    // Validar que cada mensaje tenga la estructura correcta
    const validMessages: ChatMessage[] = messages.map((msg: any) => ({
      role: msg.role,
      content: msg.content,
    }));

    // Enviar mensaje a OpenAI
    const response = await sendChatMessage(validMessages, model);

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error en API chat:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
} 
```
=== EOF: src\app\api\chat\route.ts

